<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PaddleOCR - PaddleServing部署</title>
      <link href="/2021/07/29/machinelearn/PaddleOCR-PaddleServing%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/07/29/machinelearn/PaddleOCR-PaddleServing%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="PaddleOCR"><a href="#PaddleOCR" class="headerlink" title="PaddleOCR"></a>PaddleOCR</h3><p>PaddleOCR提供2种服务部署方式：</p><ul><li>基于PaddleHub Serving的部署：代码路径为”./deploy/hubserving”，按照本教程使用；<ul><li>deploy: <a href="https://github.com/PaddlePaddle/PaddleOCR/tree/release/2.1/deploy/hubserving" target="_blank" rel="noopener">https://github.com/PaddlePaddle/PaddleOCR/tree/release/2.1/deploy/hubserving</a></li></ul></li><li>(简单，用于多客户端) 基于PaddleServing的部署：代码路径为”./deploy/pdserving”，使用方法参考文档。<ul><li><a href="https://github.com/PaddlePaddle/PaddleOCR/blob/release/2.1/deploy/pdserving/README_CN.md" target="_blank" rel="noopener">https://github.com/PaddlePaddle/PaddleOCR/blob/release/2.1/deploy/pdserving/README_CN.md</a></li></ul></li></ul><h3 id="PaddleOCR-环境"><a href="#PaddleOCR-环境" class="headerlink" title="PaddleOCR 环境"></a>PaddleOCR 环境</h3><p><a href="https://github.com/PaddlePaddle/PaddleOCR/blob/release/2.1/doc/doc_ch/installation.md" target="_blank" rel="noopener">https://github.com/PaddlePaddle/PaddleOCR/blob/release/2.1/doc/doc_ch/installation.md</a></p><h4 id="python3-7"><a href="#python3-7" class="headerlink" title="python3.7"></a>python3.7</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz</span><br><span class="line">tar -zxvf Python-3.7.0.tgz &amp;&amp; cd Python-3.7.0</span><br><span class="line">yum -y <span class="keyword">install</span> gcc</span><br><span class="line">yum -y <span class="keyword">install</span> gcc-c++</span><br><span class="line">yum -y <span class="keyword">install</span> make</span><br><span class="line">yum -y <span class="keyword">install</span> zlib*</span><br><span class="line">yum <span class="keyword">install</span> libffi-devel -y</span><br><span class="line">yum <span class="keyword">install</span> openssl-devel openssl -y</span><br><span class="line">./configure <span class="comment">--prefix=/usr/local/python3</span></span><br><span class="line">make -j8&amp;&amp; make <span class="keyword">install</span></span><br><span class="line"></span><br><span class="line">yum groupinstall <span class="string">'Development Tools'</span> -y</span><br><span class="line">yum <span class="keyword">install</span> zlib-devel bzip2-devel openssl-devel ncurese-devel -y</span><br><span class="line"></span><br><span class="line">mv /usr/<span class="keyword">bin</span>/python /usr/<span class="keyword">bin</span>/python.bak</span><br><span class="line"><span class="keyword">ln</span> -s /usr/<span class="keyword">local</span>/python3/<span class="keyword">bin</span>/python3<span class="number">.7</span> /usr/<span class="keyword">bin</span>/python3</span><br><span class="line"><span class="keyword">ln</span> -s /usr/<span class="keyword">local</span>/python3/<span class="keyword">bin</span>/pip3 /usr/<span class="keyword">bin</span>/pip3</span><br><span class="line"><span class="keyword">ln</span> -s /usr/<span class="keyword">local</span>/python3/<span class="keyword">bin</span>/pip /usr/<span class="keyword">bin</span>/pip</span><br></pre></td></tr></table></figure><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">wget </span><span class="string">https:</span>//<span class="string">bootstrap.</span><span class="string">pypa.</span><span class="string">io/</span><span class="string">pip/</span>3.5/<span class="built_in">get-pip.py</span></span><br><span class="line"><span class="built_in">python3</span> <span class="built_in">get-pip.py</span></span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">#</span> 更新 <span class="comment">#!/usr/bin/python.bak</span></span><br><span class="line"><span class="string">vim </span>/<span class="string">usr/</span><span class="string">bin/</span><span class="string">yum </span></span><br><span class="line"><span class="string">vim </span>/<span class="string">usr/</span><span class="string">libexec/</span><span class="string">urlgrabber-ext-</span><span class="string">down</span></span><br><span class="line"><span class="string">yum </span>-y <span class="string">upgrade</span></span><br><span class="line"><span class="string">yum </span>-y <span class="string">update</span></span><br></pre></td></tr></table></figure><h4 id="Paddle"><a href="#Paddle" class="headerlink" title="Paddle"></a>Paddle</h4><p>useradd paddleopr<br>passwd paddleopr</p><p>pip的安装都用paddleopr用户。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade pip</span><br><span class="line"></span><br><span class="line"># 如果您的机器安装的是CUDA9或CUDA10，请运行以下命令安装</span><br><span class="line"><span class="keyword">python3</span> -<span class="keyword">m</span> pip install paddlepaddle-gpu==<span class="number">2.0</span>.<span class="number">0</span> -i http<span class="variable">s:</span>//mirror.baidu.<span class="keyword">com</span>/pypi/simple</span><br><span class="line"># 如果您的机器是CPU，请运行以下命令安装</span><br><span class="line"><span class="keyword">python3</span> -<span class="keyword">m</span> pip install paddlepaddle==<span class="number">2.0</span>.<span class="number">0</span> -i http<span class="variable">s:</span>//mirror.baidu.<span class="keyword">com</span>/pypi/simple</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git clone http<span class="variable">s:</span>//gitee.<span class="keyword">com</span>/paddlepaddle/PaddleOCR</span><br><span class="line"><span class="keyword">cd</span> PaddleOCR</span><br><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure><h3 id="PaddleServing-部署"><a href="#PaddleServing-部署" class="headerlink" title="PaddleServing 部署"></a>PaddleServing 部署</h3><h4 id="安装serving，用于启动服务"><a href="#安装serving，用于启动服务" class="headerlink" title="安装serving，用于启动服务"></a>安装serving，用于启动服务</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> paddle-serving-<span class="keyword">server</span>==<span class="number">0.6</span><span class="number">.1</span> <span class="comment"># for CPU</span></span><br><span class="line">pip3 <span class="keyword">install</span> paddle-serving-<span class="keyword">server</span>-gpu==<span class="number">0.6</span><span class="number">.1</span> <span class="comment"># for GPU</span></span><br><span class="line"><span class="comment"># 其他GPU环境需要确认环境再选择执行如下命令</span></span><br><span class="line">pip3 <span class="keyword">install</span> paddle-serving-<span class="keyword">server</span>-gpu==<span class="number">0.6</span><span class="number">.1</span>.post101 <span class="comment"># GPU with CUDA10.1 + TensorRT6</span></span><br><span class="line">pip3 <span class="keyword">install</span> paddle-serving-<span class="keyword">server</span>-gpu==<span class="number">0.6</span><span class="number">.1</span>.post11 <span class="comment"># GPU with CUDA11 + TensorRT7</span></span><br></pre></td></tr></table></figure><h4 id="安装client，用于向服务发送请求"><a href="#安装client，用于向服务发送请求" class="headerlink" title="安装client，用于向服务发送请求"></a>安装client，用于向服务发送请求</h4><p>在下载链接中找到对应python版本的client安装包，这里推荐python3.7版本：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="keyword">https</span>://paddle-serving.bj.bcebos.com/test-dev/whl/paddle_serving_client<span class="number">-0.0</span><span class="number">.0</span>-cp37-<span class="literal">none</span>-<span class="keyword">any</span>.whl</span><br><span class="line">pip3 install paddle_serving_client<span class="number">-0.0</span><span class="number">.0</span>-cp37-<span class="literal">none</span>-<span class="keyword">any</span>.whl</span><br></pre></td></tr></table></figure><h4 id="安装serving-app"><a href="#安装serving-app" class="headerlink" title="安装serving-app"></a>安装serving-app</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install paddle-serving-app==<span class="number">0.6</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><h4 id="模型转换"><a href="#模型转换" class="headerlink" title="模型转换"></a>模型转换</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载并解压 OCR 文本检测模型</span></span><br><span class="line">wget https:<span class="string">//paddleocr.bj.bcebos.com/dygraph_v2.0/ch/ch_ppocr_mobile_v2.0_det_infer.tar</span> &amp;&amp; tar xf ch_ppocr_mobile_v2.0_det_infer.tar</span><br><span class="line"><span class="comment"># 下载并解压 OCR 文本识别模型</span></span><br><span class="line">wget https:<span class="string">//paddleocr.bj.bcebos.com/dygraph_v2.0/ch/ch_ppocr_mobile_v2.0_rec_infer.tar</span> &amp;&amp; tar xf ch_ppocr_mobile_v2.0_rec_infer.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换检测模型</span></span><br><span class="line">python3 -m paddle_serving_client.convert <span class="params">--dirname</span> <span class="string">./ch_ppocr_mobile_v2.0_det_infer/</span> \</span><br><span class="line">                                         <span class="params">--model_filename</span> inference.pdmodel          \</span><br><span class="line">                                         <span class="params">--params_filename</span> inference.pdiparams       \</span><br><span class="line">                                         <span class="params">--serving_server</span> <span class="string">./ppocr_det_mobile_2.0_serving/</span> \</span><br><span class="line">                                         <span class="params">--serving_client</span> <span class="string">./ppocr_det_mobile_2.0_client/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换识别模型</span></span><br><span class="line">python3 -m paddle_serving_client.convert <span class="params">--dirname</span> <span class="string">./ch_ppocr_mobile_v2.0_rec_infer/</span> \</span><br><span class="line">                                         <span class="params">--model_filename</span> inference.pdmodel          \</span><br><span class="line">                                         <span class="params">--params_filename</span> inference.pdiparams       \</span><br><span class="line">                                         <span class="params">--serving_server</span> <span class="string">./ppocr_rec_mobile_2.0_serving/</span>  \</span><br><span class="line">                                         <span class="params">--serving_client</span> <span class="string">./ppocr_rec_mobile_2.0_client/</span></span><br></pre></td></tr></table></figure><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/bin/<span class="keyword">sh</span>: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)</span><br><span class="line"><span class="keyword">Error</span>: Can not import avx core <span class="keyword">while</span> this <span class="keyword">file</span> exists: /home/paddleopr/.<span class="keyword">local</span>/lib/python3.7/site-packages/paddle/fluid/core_avx.<span class="keyword">so</span></span><br><span class="line">...</span><br><span class="line">ImportError: /lib64/libstdc++.<span class="keyword">so</span>.6: <span class="keyword">version</span> `CXXABI_1.3.8' not found (required <span class="keyword">by</span> /home/paddleopr/.<span class="keyword">local</span>/lib/python3.7/site-packages/paddle/fluid/core_avx.<span class="keyword">so</span>)</span><br><span class="line"></span><br><span class="line"># root，查看是否安装CXXABI_1.3.8</span><br><span class="line">strings /usr/lib64/libstdc++.<span class="keyword">so</span>.6|grep CXXABI</span><br><span class="line">下载https:<span class="comment">//wwa.lanzoui.com/i8lnene</span></span><br><span class="line">解压后放在/usr/lib64</span><br><span class="line"><span class="keyword">rm</span> -rf libstdc++.<span class="keyword">so</span>.6</span><br><span class="line">mv libstdc++.<span class="keyword">so</span>.6.0.26 libstdc++.<span class="keyword">so</span>.6</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line">ImportError: /lib64/libc.<span class="keyword">so</span>.6: <span class="keyword">version</span> `GLIBC_2.18' not found (required <span class="keyword">by</span> /lib64/libstdc++.<span class="keyword">so</span>.6)</span><br><span class="line"></span><br><span class="line">root执行</span><br><span class="line">curl -O http:<span class="comment">//ftp.gnu.org/gnu/glibc/glibc-2.18.tar.gz</span></span><br><span class="line">tar zxf glibc-2.18.tar.gz </span><br><span class="line"><span class="keyword">cd</span> glibc-2.18/</span><br><span class="line"><span class="keyword">mkdir</span> build</span><br><span class="line"><span class="keyword">cd</span> build/</span><br><span class="line">../configure --prefix=/usr</span><br><span class="line">make -j2</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 修改config.yml中模型地址</span><br><span class="line"><span class="keyword">cd</span> PaddleOCR/deploy/pdserver/</span><br><span class="line"><span class="keyword">python3</span> web_service.<span class="keyword">py</span> &amp;&gt;<span class="built_in">log</span>.txt &amp;</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line"><span class="keyword">python3</span> pipeline_http_client.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><h5 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ImportError: libSM.so<span class="number">.6</span>: cannot open <span class="keyword">shared</span> object file: No such file <span class="keyword">or</span> directory</span><br><span class="line"></span><br><span class="line">#查看缺少的共享库</span><br><span class="line">yum whatprovides libSM.so<span class="number">.6</span></span><br><span class="line">yum install libSM<span class="number">-1.2</span><span class="number">.2</span><span class="number">-2.</span>el7.x86_64 --setopt=protected_multilib=<span class="literal">false</span></span><br><span class="line">yum install libXrender<span class="number">-0.9</span><span class="number">.10</span><span class="number">-1.</span>el7.x86_64 --setopt=protected_multilib=<span class="literal">false</span></span><br><span class="line">yum install libXext<span class="number">-1.3</span><span class="number">.3</span><span class="number">-3.</span>el7.x86_64 --setopt=protected_multilib=<span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> PaddleOCR </tag>
            
            <tag> OCR </tag>
            
            <tag> Paddle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - 温故知新</title>
      <link href="/2021/01/26/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0/"/>
      <url>/2021/01/26/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><h4 id="关注的点"><a href="#关注的点" class="headerlink" title="关注的点"></a>关注的点</h4><p>选取提案的规则：</p><p>如果acceptor通过提案[M, ]的prepare请求，则向proposer保证以下承诺：</p><ol><li>acceptor承诺不再通过编号小于等于M的提案的prepare请求</li><li>acceptor承诺不再通过编号小于M的提案的accept请求，也就是不再通过编号小于M的提案</li><li>如果acceptor已经通过某一提案，则承诺在prepare请求的响应中返回已经通过的最大编号的提案内容。如果没有通过任何提案，则在prepare请求的响应中返回空值</li></ol><p>proposer在发起accept请求时，提案值由prepare响应决定。如果prepare响应有返回已通过的提案值，该accept请求则使用prepare响应中的值。如果prepare响应没有已通过的提案值，则有该proposer任意指定。</p><h3 id="ZAB"><a href="#ZAB" class="headerlink" title="ZAB"></a>ZAB</h3><h4 id="消息广播模式"><a href="#消息广播模式" class="headerlink" title="消息广播模式"></a>消息广播模式</h4><p>消息广播模式是一个类似于二阶段提交（2PC）过程，<strong>与2PC不同的是，ZAB移除了第二阶段的中断逻辑。所有的Follower要么接收该Proposal，要么抛弃Leader服务器</strong>。这意味着Leader收到过半的Ack响应后就可以提交该事务了，而不需要等待所有的Follower都返回Ack。</p><ol><li>客户端发起事务请求，由Leader进行处理</li><li>Leader将该请求转换为事务Proposal，同时为Proposal分配一个全局的ID，即zxid</li><li>Leader为每个Follower维护一个FIFO队列，将上一步生成的Proposal放入队列中，进行广播</li><li>Follower收到Proposal后，会首先将其以事务日志的方式写入本地磁盘中，写入成功后向Leader反馈一个响应消息</li><li>Leader收到过半的Ack响应后，自己完成对该Proposal的提交后，向每个Follower的队列中，写入Commit消息进行广播</li><li>Follower接收到Commit消息后，会将上一条事务提交</li></ol><p>zxid，用于提交提案的先后顺序。Leader提交提案是有顺序性的，按照zxid的大小，按顺序提交提案，如果前一个提案未提交，此时是不会提交后一个提案的。</p><h4 id="崩溃恢复模式"><a href="#崩溃恢复模式" class="headerlink" title="崩溃恢复模式"></a>崩溃恢复模式</h4><p>约定：</p><ol><li>ZAB需要确保那些已经在Leader上提交的事务最终被所有服务器都提交。</li><li>ZAB需要确保丢弃那些仅仅只在Leader上被提出的事务。</li></ol><h5 id="Leader选举（ELECTION）"><a href="#Leader选举（ELECTION）" class="headerlink" title="Leader选举（ELECTION）"></a>Leader选举（ELECTION）</h5><p>Leader选举PK的规则包含以下几个方面：</p><ul><li>任期编号（epoch），优先判断epoch，epoch大的节点当选Leader</li><li>事务标示符（zxid），epoch相同，则比较zxid，zxid大的当选Leader</li><li>节点ID，epoch、zxid都一致，则比较节点ID（在myid文件中指定的值）</li></ul><ol><li>leader宕机，各个follower开始leader选举PK</li><li>各个follower都投票给自己，封装一个选票信息，广播给其他的follower。选票信息包含：<ul><li>自己所提议的节点ID</li><li>自己所提议节点所处leader周期</li><li>自己所提议节点拥有最大的zxid</li><li>投票节点标示</li></ul></li><li>其他节点收到选票信息后，根据上述规则开始和自己所提议的节点进行PK。如果选票有更新，当前节点则继续广播自己更新之后的选票信息</li><li>最后各节点的选票池，都有过半的选票支持某一节点，该节点晋升为准leader，完成选举</li><li>各节点分别修改自己的状态，准leader修改为LEADING，其余修改为FOLLOWING</li></ol><h5 id="发现（DISCOVERY）"><a href="#发现（DISCOVERY）" class="headerlink" title="发现（DISCOVERY）"></a>发现（DISCOVERY）</h5><p>该阶段用于确立Leader的领导关系，由Follower会主动联系准Leader。</p><ol><li>Follower将自己最后接受的事务Proposal的epoch值发送给准Leader，记作FOLLOWERINFO。</li><li>准Leader收到来自过半（包含B节点自己）的FOLLOWERINFO消息后，选取最大的epoch值，对其进行加1，作为新的epoch值，并封装成LEADERINFO消息发给这些过半的Follower。</li><li>Follower收到LEADERINFO消息后<ul><li>更新自己的epoch</li><li>将自己的运行状态变更为SYNCHRONIZATION</li><li>返回ACKEPOCH给准Leader。</li></ul></li><li>准Leader收到过半的ACKEPOCH消息后，也将自己的运行状态修改为SYNCHRONIZATION。至此完成发现阶段的工作，集群确立Leader的领导关系。</li></ol><h5 id="数据同步（SYNCHRONIZATION）"><a href="#数据同步（SYNCHRONIZATION）" class="headerlink" title="数据同步（SYNCHRONIZATION）"></a>数据同步（SYNCHRONIZATION）</h5><p>该阶段是实现崩溃恢复的关键步骤，由Leader发送数据给Follower处理。数据内容分三种：DIFF、TRUNC、SNAP。</p><ol><li>Leader根据Follower的最大zxid选择同步方式</li><li>Leader将同步方式和需要同步的数据，一起封装为NEWLEADER消息发给Follower</li><li>Follower在收到NEWLEADER消息后，进行修复不一致数据，并返回给Leader响应Ack消息</li><li>Leader在收到过半Ack消息后，则完成数据同步阶段，将自己运行状态修改为BROADCARST（广播状态），并发送UPTODATE消息给过半的Follower，通知他们完成数据同步，修改运行状态修改为BROADCARST</li></ol><h3 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h3><h4 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h4><h4 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h4>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> paxos </tag>
            
            <tag> Raft </tag>
            
            <tag> ZAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - EPaxos</title>
      <link href="/2020/12/21/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20EPaxos/"/>
      <url>/2020/12/21/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20EPaxos/</url>
      
        <content type="html"><![CDATA[<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>epaxos作为paxos族中的一员，并不是单独存在的。所以我在文中开篇给出总结，罗列与basic-paxos、mutli-paxos之间的区别。带着目的学习，可能相对容易理解一些。</p><p>回顾paxos的局限性，总结来说存在三个问题：</p><ol><li>basic-paxos，多个proposal提出时，容易形成活锁，影响整个算法的活性。</li><li>mutli-paxos，通过只允许leader提出proposal，解决活锁问题，同时影响了吞吐量（性能局限于leader）、可扩展性（必须要leader发起提案）、可用性（leader宕机服务不可用）。</li><li>paxos，各提案乱序提交，不能明确各提案之间的依赖关系。</li><li>raft，通过实现对日志项进行编号，解决日志项之间依赖关系，但是又不支持乱序提交。</li><li>paxos、raft，client跨地域请求leader，延迟增大。</li></ol><p>paxos存在的活锁、提案依赖关系的问题。从某个角度来说：mutli-paxos、raft采用“曲线救国”的方案对问题进行规避，通过引入leader和事先对日志项编号来避免，或多或少都降低了可用性和吞吐量。而epaxos则是直面冲突，并给出了自己的解决冲突的方案。</p><h3 id="epaxos简介"><a href="#epaxos简介" class="headerlink" title="epaxos简介"></a>epaxos简介</h3><h4 id="epaxos特性"><a href="#epaxos特性" class="headerlink" title="epaxos特性"></a>epaxos特性</h4><p>在epaxos开篇介绍时，都会提到一个词“leaderless”，这确实是epaxos最值得骄傲的特性了。leaderless描述的是：没有leader，各节点对等，任何节点都可处理事务请求（写请求）。</p><p>在“leaderless”特性下，epaxos的优势很明显：</p><ol><li>epaxos省略了leader选举的开销，同时没有leader瓶颈限制的问题。</li><li>各节点都能处理事务请求（写请求），拥有更高的性能。</li><li>在跨地域场景下，不需要额外的同步（学习）的阶段。</li><li>客户端可选择最近的副本提供服务，具有更小的延迟。</li></ol><h4 id="epaxos的答卷"><a href="#epaxos的答卷" class="headerlink" title="epaxos的答卷"></a>epaxos的答卷</h4><p>面对paxos遗留的两个问题：活锁、提案依赖关系。epaxos又是如何解决的呢？</p><p>epxos将协议拆分为两部分，一部分是commit协议，一部分是恢复阶段。前者是处理写请求，在各副本中选择（提交）command并确定command附加的属性值（当前command依赖其他command的顺序）。后者是集群中某个副本异常时，其他副本尝试恢复其数据。</p><p>在commit协议中，又具体分为三个阶段：</p><ul><li>阶段一：Establish ordering constraints，建立约束关系</li><li>阶段二：Paxos-Accept，达成一致</li><li>阶段三：commit阶段，一般异步提交，通常被大家一笔带过</li></ul><p>commit协议中提出日志冲突的概念，阶段一也就是为了解决日志冲突而存在的。当多个command（写请求）对同一个值进行修改时，epaxos则认为发生冲突，需要先建立command之间的约束关系（command之间顺序）。</p><p>对于是否冲突，commit协议给出不同达成一致的方案：fast-path, slow-path，二者分别对应没有冲突和有冲突的写请求。fast-path是指在没有冲突的写请求中，执行阶段一即可进行提交。slow-path是指在发生冲突的写请求中，需要执行两个阶段才能进行提交。</p><p><img src="/images/theory/distributed/epaxos_1.png" alt="fast-path, slow-path"></p><p>这张经典的图，还是得看，清晰的描述了fast-path, slow-path二者的不同之处。R1, R2,…R5是五个副本。C1, C2, C3, C4是command（即更新操作），R1和R5分别记为C1和C2的command-leader。为了清晰起见，我们省略了异步提交消息。</p><p>左图中C1对obj_A修改，C2对obj_B修改，即两者不会发生冲突，因此两者都可以在fast-path上提交。</p><ol><li>R1收到update obj_A请求，将其发给多数派副本</li><li>各副本在收该请求后，由于没有其他请求发生冲突，则返回成功R1</li><li>异步提交</li><li>R5同上</li></ol><p>右图中C3和C4同时对obj_A修改，相互干扰，因此一个C3将在slow-path上执行。</p><ol><li>R1和R5分别收到update obj_A请求，将其分别封装为C3和C4发送其他多数派副本</li><li>R3为多数派相交的副本，C4比C3先到到达R3</li><li>R3在处理C4时，没有请求与之冲突，则提供通过fast-path提交</li><li>R3在收到C3时，由于C4和C3发生冲突，则返回C3→C4，表示C3获得了对C4的依赖</li><li>R1收到R3的响应，则将依赖关系整理后，发起accept给多数派</li><li>多数派没有继续发生冲突，则返回成功</li><li>异步提交</li></ol><h4 id="quorum特殊要求"><a href="#quorum特殊要求" class="headerlink" title="quorum特殊要求"></a>quorum特殊要求</h4><p>需要注意，与paxos不同的是：paxos只需要多数派的副本正常响应后，便能正常提交。而对epaxos则略有差异：</p><ul><li>论文中指出在fast-path中，quorum数量为：$F+\lfloor(F+1)/2\rfloor$，其中F表示最大容忍的出错副本数量。即：command-leader需要收到$F+\lfloor(F+1)/2\rfloor$个副本（包含command-leader）的正常响应。在上面案例中，5副本的集群，最大容忍出错副本数量为2，则需要与2+[(2+1)/2] = 3.5，向下取整，即3个副本的正常响应。</li><li>在slow-path中，quorum数量为：F+1，其中F表示最大容忍的出错副本数量。在上面案例中，5副本的集群，最大容忍出错副本数量为2，则需要收到2+1=3个副本的正常响应。</li></ul><p>为了解释这个特殊要求，我们看下面的案列，存在7个副本，大于等于4则为多数派，3个容错数量。R1收到修改x=1，R2收到修改x=2，二者分别发起epaxos。<br><img src="/images/theory/distributed/epaxos_2.png" alt="quorum特殊要求"><br>R4, R5在fast-path先收到x=1再收到x=2。R6, R7在fast-path先收到x=2再收到x=1。如果R3是先收到x=1，那么R1、R3、R4、R5构成多数派，确定提交顺序为先提交x=1再提交x=2。如果R3是先收到x=2，那么R2、R3、R6、R7构成多数派，确定提交顺序为先提交x=2再提交x=1。<br>那么如果此时R1, R2, R3宕机，那么剩下的副本将不知道是先提交x=1还是先提交x=2。所以在epxos中fast-path需要quorum数量为$F+\lfloor(F+1)/2\rfloor$，即：$3+\lfloor(3+1)/2\rfloor=5$。</p><h3 id="commit协议"><a href="#commit协议" class="headerlink" title="commit协议"></a>commit协议</h3><p>正如上文提到，epaxos分为两部分，commit协议是指：</p><p>当副本L收到来自客户端写请求时，将其封装为command γ（念：伽玛），并称为γ的command-leader，command-leader开始γ的提交过程。进入第一阶段，command-leader定义γ的初始属性deps, seq。</p><ul><li>deps：定义所有包含与γ冲突的command（不一定是已提交的command）的列表，也称为γ依赖于这些command。</li><li>seq：用于execute算法过程中，打破循环依赖的序列号。取值为所有冲突command的最大的seq。</li></ul><p>command-leader将γ和γ的初始属性deps, seq<strong>至少</strong>发送给fast-path所要求的quorum数量（$F+\lfloor(F+1)/2\rfloor$），论文中称之为PreAccept-Message。各副本收到PreAccept-Message后，再<strong>根据自己本地的cmds-log更新γ的deps, seq值</strong>，并在自己的cmds-log中新增一条用来记录γ。将更新的γ返回给command-leader。</p><p>如果command-leader收到足够多的响应，并且所有响应中的γ的属性都相同，即构成fast-path，便发送Commit-Message进行异步提交。<br>如果command-leader没有收到足够多的响应，或者所有响应中的γ的属性存在不一致，即构成slow-path，command-leader需要基于所有响应更新γ的值（合并所有的deps作为新的deps，取最大的seq作为新的seq）。进入第二阶段，将新的γ<strong>至少</strong>发送给$\lfloor N/2 \rfloor$个副本，这个过程类似经典的paxos，在本轮结束之后，如果收到大多数$\lfloor N/2 \rfloor$响应（包含command-leader）即可给客户端返回成功，并发送Commit-Message进行异步提交。</p><h4 id="commit伪代码"><a href="#commit伪代码" class="headerlink" title="commit伪代码"></a>commit伪代码</h4><p><img src="/images/theory/distributed/epaxos_3.png" alt="commit伪代码"><br>论文中提供了伪代码，我们简单来看看，副本L收到来自客户端的请求γ，成为γ的commandleader</p><ol><li>自增L的instance id $i_L$ ← $i_L$ + 1。</li><li>$seq_γ$表示γ的seq，取值为：副本L已记录的command中最大的seq的值+1，与{0}取并集，是在没有command情况下，取0+1作为seq的值。</li><li>$deps_γ$表示γ的deps，取值为：副本L中与γ冲突的command集合。</li><li>副本L将 $ (γ,seq_γ,deps_γ,pre-accepted) $ 记录到自己 $cmds_L$ ，pre-accepted表示γ的状态。</li><li>发送$ PreAccept(γ,seq_γ,deps_γ,L.i_L) $给所有副本，$L.i_L$即第一步自增的instance id。</li></ol><p>副本R收到PreAccept请求后<br>6. 更新γ的seq值，取值为：副本R中已记录的command中最大的$seq+1$后与原来seq值，取最大。<br>7. 更新γ的deps值，取值为：取副本R中与γ冲突集合和原本deps的并集。<br>8. 副本R将$ (γ,seq_γ,deps_γ,pre-accepted) $记录到自己$cmds_R$，pre-accepted表示γ的状态。<br>9. 回复PreAcceptOK给副本L。</p><p>副本L收到最少$\lfloor N/2 \rfloor$个PreAcceptOK的响应后。（这里的$\lfloor N/2 \rfloor$感觉有问题）<br>10. 如果所有副本响应中$seq_γ$, $deps_γ$都相同<br>11. 副本L执行commit阶段，跳转至21步<br>12. 如果存在不相同的 $seq_γ$, $deps_γ$<br>13. 更新$deps_γ$，取值为：整合所有响应中的deps<br>14. 更新$seq_γ$，取值为：所有响应中最大seq<br>15. 副本L执行paxos-accept阶段</p><p>副本L开始paxos-accept阶段<br>16. 副本L将$(γ,seq_γ,deps_γ,accepted)$记录到自己$cmds_L$，accepted表示γ的状态。<br>17. 发送$Accept(γ,seq_γ,deps_γ,L.i)$给至少$\lfloor N/2 \rfloor$个副本</p><p>副本R收到Accept请求后<br>18. 副本R将$(γ,seq_γ,deps_γ,accepted)$记录到自己$cmds_R$，accepted表示γ的状态。<br>19. 回复AcceptOK给副本L。</p><p>副本L收到至少$\lfloor N/2 \rfloor$个AcceptOK响应后<br>20. 开始commit阶段，跳转至21步</p><p>副本L开始commit阶段<br>21. 副本L将$(γ,seq_γ,deps_γ,commited)$记录到自己$cmds_L$，commited表示γ的状态。<br>22. 回复客户端已提交的响应<br>23. 发送$Commit(γ,seq_γ,deps_γ,L.i)$给其他的副本</p><p>副本R收到commit请求<br>24. 副本R将$(γ,seq_γ,deps_γ,commited)$记录到自己$cmds_R$，commited表示γ的状态。</p><h3 id="Explicit-Prepare"><a href="#Explicit-Prepare" class="headerlink" title="Explicit Prepare"></a>Explicit Prepare</h3><p>这一部分，论文描述的篇幅相对较少，因此也没有被大家重视，epaxos称之为Explicit Prepare，用于恢复异常副本所处理的command。这一部分在论文中也用于执行command。如要要在一个副本上执行command γ，需要经过以下几个步骤：</p><ol><li>等待副本提交，或者显示调用Explicit Prepare</li><li>构建γ所依赖的command的依赖图，对所有依赖command都进行Explicit Prepare</li><li>找到紧密连接的组件（command），对它们进行拓扑排序</li><li>以逆拓扑顺序，对于每个强烈连接的组件（command），执行:<ol><li>按顺序将强连接组件中的所有命令排序；</li><li>以递增的编号顺序执行每个未执行的命令，将其标记为已执行</li></ol></li></ol><h4 id="Explicit-Prepare伪代码"><a href="#Explicit-Prepare伪代码" class="headerlink" title="Explicit Prepare伪代码"></a>Explicit Prepare伪代码</h4><p>在看伪代码之前，需要先描述一个概念。在经典的paxos中，每个proposal都有一个ballot，用于标示proposal唯一性，也用于表示proposal的先后顺序，epaxos当然也需要。为了保证ballot唯一性，所以ballot需要包含副本ID。同时新的周期要优先于旧的周期，所有还需要epoch值。最后ballot的格式为：epoch.b.R。</p><p><img src="/images/theory/distributed/epaxos_4.png" alt="Explicit Prepare"></p><p>副本Q怀疑L失效，尝试去恢复L.i这个instance。<br>25. 自增ballot，取值为epoch.(b+1).Q。（epoch.b.Q为副本Q最大的投票编号）<br>26. 发送$Prepare(epoch.(b+1).Q,L.i)$ 给所有副本，并等待$\lfloor N/2 \rfloor+1$个回复。<br>27. 假设所有回应中最大ballot的是$ballot_max$，定义R是所有回应中ballot等于$ballot_max$的响应的集合。<br>28,29. 如果R包含$(γ,seq_γ,deps_γ,commited)$，执行commit阶段<br>30,31. 如果R包含$(γ,seq_γ,deps_γ,acceprted)$，执行paxos-accept阶段<br>32,33. 如果R包含至少$\lfloor N/2 \rfloor$一致的回复$(γ,seq_γ,deps_γ,pre-accepted)$，且这些回复都不是来自L，执行paxos-accept阶段<br>34,35. 如果R至少包含一个$(γ,seq_γ,deps_γ,pre-accepted)$，执行第一阶段<br>36,37. 如果R没有关于这个instance id的任何信息，那么推出退出恢复阶段，副本Q对L.i实例尝试去commit no-op</p><p>副本R收到来自副本Q的Prepare(epoch.b.Q,L.i)请求<br>38,39. R已接收来自L.i的最大的ballot为epoch.x.Y，如果epoch.b.Q大于epoch.x.Y，回复$PrepareOK(cmds_R,epoch.x.Y,L.i)$<br>40,41.否则回复NACK</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ol><li>论文中强调的Executing和Commiting是两个不同的action，但是几乎没有提交关于Execution Algorithm的内容。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> paxos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - Gossip</title>
      <link href="/2020/11/24/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Gossip/"/>
      <url>/2020/11/24/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Gossip/</url>
      
        <content type="html"><![CDATA[<p>前面我们讲过CAP定理、Paxos、Raft，那么试想几个场景：</p><ul><li>我们要实现一个完全的AP系统。即集群中只有一个节点存活，也能向外提供服务。在此基础上，我们如何保证数据最终一致性？</li><li>在一个庞大的集群中，对某个数据修改后，如何同步到其他节点？</li><li>在一个去中心化的集群中，各节点都是对等节点。如何同步数据，使保证各节点数据达到一致？</li></ul><p>答案就是gossip协议，gossip是一种去中心化的分布式协议，用于实现节点之间的信息交换，大名鼎鼎的bitcoin也使用了gossip来传播交易和区块信息。在分布式系统中，也用它来实现最终一致性，比如cassandra、redis。</p><h3 id="六度分隔理论"><a href="#六度分隔理论" class="headerlink" title="六度分隔理论"></a>六度分隔理论</h3><p>循源，需从六度分隔理论开始。六度分隔理论，简单地说：“你和任何一个陌生人之间所间隔的人不会超五个。”也就是说，最多通过六个人你就能够认识任何一个陌生人。（小声嘀咕）你老婆最多拖6个人的关系就能认识到你的任何一个P（朋）友。</p><p>数学解释如下：<br>若每个人平均认识260人，其六度就是260^6=308,915,776,000,000。消除一些节点重复，那也几乎覆盖了整个地球人口若干多多倍。</p><p>基于六度分隔理论，任何信息的传播其实非常迅速，而且网络交互次数不会很多。Facebook研究了已注册的15.9亿使用者资料，发现“网络直径”为是4.57，即每个人与其他人间隔为4.57人。</p><h3 id="gossip原理"><a href="#gossip原理" class="headerlink" title="gossip原理"></a>gossip原理</h3><p>gossip英文原意：流言蜚语。gossip协议就像流言蜚语一样，利用随机的，带有传染性的方式，将数据传遍整个网络。即在一定时间内，完成数据一致性。<br>gossip传播方式分为两种：反熵、谣言传播。有的也认为可分为三种：直接邮寄、反熵、谣言传播。所增加的直接邮寄，是指当数据有修改时，直接把数据发送给其他节点，即写时完成数据一致。而反熵、谣言传播则是通过异步方式修复节点之间数据一致。</p><p>gossip将各节点分为三类感染状态。</p><ul><li>susceptible (S): The node does not know about the update</li><li>infected (I): The node knows the update and is actively spreading it</li><li>removed (R): The node has seen the update, but is not participating in the spread-<br>ing process (in epidemiology, this corresponds to death or immunity)</li></ul><p>gossip原文中，有一些含义相近的词，我们列出来可能更好理解：<br>反熵：Anti Entropy、error correction、SI<br>谣言传播：Rumor-Mongering、update spreading、SIR</p><p>例如下文：<br>In Section 1.2.1 we identified two sub-problems, namely update spreading and error correction.The former is implemented by an SIR gossip protocol, and the latter by an SI protocol.<br>The SIR gossip is called rumor mongering.<br>The SI algorithm for error correction is called anti-entropy. </p><h4 id="Anti-Entropy-反熵"><a href="#Anti-Entropy-反熵" class="headerlink" title="Anti-Entropy(反熵)"></a>Anti-Entropy(反熵)</h4><p>先解释反熵这个词，熵是物理中指体系的混乱程度。反熵在这里的意思，也是指修复集群中混乱程度，即修复数据一致。</p><p>gossip原文中描述：用于纠错的SI算法称为反熵。这里的SI算法，是指节点只有两种状态：susceptible（未被感染）、infected（已感染）。注意每个节点都可以同时扮演这两个角色，当A把数据推给B时，A为infected，B为susceptible。当A向B拉取数据时，A为susceptible，B为infected。</p><p>具体描述反熵的传播过程，则是每个节点周期性地随机选择其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，直到整个网络中节点数据一致。</p><p>实现反熵的方式主要有三种：推、拉、推拉。推则是将自己数据推给对方，更新对方的数据。拉则是拉取对方的数据，更新自己数据。推拉即更新自己和对方的数据。</p><h5 id="伪代码实现"><a href="#伪代码实现" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><p><img src="/images/theory/distributed/gossip_si.png" alt="si gossip"><br>伪代码中围绕两个boolean变量：push、pull，表示同步消息模式。运行过程可分为两个线程理解：</p><ul><li>异步消息同步线程，即消息同步入口，每个∆时间单位执行一次。</li><li>消息处理线程，即接收到消息，进行处理。</li></ul><ol><li>本次数据同步发起者，记为A，A生成随机集合P。</li><li>如果是push模式，并且A处于infected，则A发送数据给集合P。<ul><li>第11行，集合P收到数据，保存数据。同时意味着自己处于infected</li></ul></li><li>如果是pull模式，则A发送<strong>请求更新的指令</strong>给集合P。<ul><li>第15行，集合P收到<strong>请求更新的指令</strong>，如果自己处于infected，则发送第11行所保存的数据给A。</li><li>A接收到数据，即第11行。</li></ul></li></ol><h5 id="生产应用"><a href="#生产应用" class="headerlink" title="生产应用"></a>生产应用</h5><p>算法描述中，虽然描述的是周期性的向其他节点交换数据来消除两者之间的差异。但是反熵在实际生产中的应用和原本的描述会有所出入，主要原因包含两点：</p><ol><li>每次推送和拉取都是全量数据进行比较，性能消耗比较大。</li><li>可能出现极端情况（两个节点互相进行推拉，其他的节点也没有选择它们两进行推拉）导致某些节点数据可能达不到一致。</li><li>随机性的选择节点消除两者的差异，如果要整个集群节点都达到一致，所需时间不确定，也没有明确的标准表明集群中数据达到一致。</li></ol><p>在实际应用场景中，不推荐采用随机的节点进行反熵。而是需要刻意的设计一个闭环，这样能在一个确定的时间范围内完成最终一致性，而不是基于随机的概率。<br><img src="/images/theory/distributed/gossip_1.png" alt="gossip"></p><ol><li>由A发起反熵，A的数据推给B，可以把A中包含的数据B中不包含的数据同步给B</li><li>B的数据推给C，消除C中没有A、B的数据</li><li>C的数据推给A，则可以消除A中没有B、C的数据</li><li>A还需要再推一次给B，这样才能把C中的数据推给B</li></ol><p>至此，完成数据的最终一致性。这里可以做一个优化：如果反熵每次都推送全量数据进行比较，太消耗资源。这里建议记录已完成一致性的数据，后续执行反熵，只推送增量数据。</p><h4 id="Rumor-Mongering-谣言传播"><a href="#Rumor-Mongering-谣言传播" class="headerlink" title="Rumor-Mongering(谣言传播)"></a>Rumor-Mongering(谣言传播)</h4><p>谣言传播，采用一传十，十传百的方式。指各节点周期性的，向随机的一组节点广播更新数据。其他节点收到更新的数据后，继续周期性的，向随机的一组节点广播更新数据，直到所有节点都处理了新数据。为了使谣言传播能够停止（避免广播风暴），gossip增加removed状态，当节点收到的谣言并且该谣言处于removed（之前已经处理过的谣言）时，该节点将不继续传播该谣言。即SIR算法。</p><h5 id="传播示例"><a href="#传播示例" class="headerlink" title="传播示例"></a>传播示例</h5><p>在一个集群中，发生了数据更新，即为infected状态。图片最开始只有一个节点有数据更新，由它周期性的外向外广播谣言，其每次广播数量为2，该参数即为fanout=2。<br><img src="/images/theory/distributed/gossip_2.png" alt="gossip"><br>当其他susceptible，收到数据后，变更自己为infected状态，继续向外广播谣言。直到完成数据最终一致性。<br><img src="/images/theory/distributed/gossip_3.png" alt="gossip"></p><p>谣言传播属于指数级的传播，我们得到：传播所需周期与fanout（记为f）之间的关系式。当节点数量为N时，有：$log_f{N}$。</p><p>当集群中存在10000个节点时，每次传播感染5个。有：$log_5{10000}$ = 5.72。得出最理想的情况，5.72次传播即可感染10000个节点。该公式为最理想情况，实际传播过程中，可能会出现某一个节点被感染多次。</p><h5 id="伪代码实现-1"><a href="#伪代码实现-1" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><p>在gossip论文中，提供的伪代码实现中，主要增加了不继续传播的条件。<br><img src="/images/theory/distributed/gossip_sir.png" alt="sir gossip"></p><ol><li>本次数据同步发起者，记为A，A生成随机集合P。</li><li>如果是push模式，并且A处于infected，则A发送更新数据给集合P。<ul><li>集合P收到更新数据，第16行，判断是否已处理该数据，则返回feedback给A。</li><li>如果处理，则保存该更新数据。同时意味着自己处于infected</li></ul></li><li>如果是pull模式，则发送<strong>请求更新的指令</strong>给集合P。<ul><li>第23行，集合P收到<strong>请求更新的指令</strong>，如果自己处于infected，则发送第19行所保存的更新数据给A。</li><li>A接收到更新数据，即第15行。</li></ul></li><li>A收到feedback消息，通过概率切换到removed</li></ol><h5 id="生产应用-1"><a href="#生产应用-1" class="headerlink" title="生产应用"></a>生产应用</h5><p>谣言传播，可以快速的向网络中广播，非常具有传染性，适合节点数量多、集群庞大的网络中更新数据。由于集群中都是对等节点，它比较适合动态变化的分布式系统。</p><p>但是为了方便谣言传播，发送的数据包不能太大，主要用于新数据增量更新。</p><h3 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h3><p>gossip的优势很明显，具体总结，可有以下几点：</p><ol><li>简单有趣</li><li>可扩展、容错：由于各节点之间对等性，允许节点之间任意的增加和减少。</li><li>天然的去中心化</li><li>传播速度快，适用于非常庞大的集群</li></ol><p>劣势：</p><ol><li>达成最终一致性的时间不确定性</li><li>消息延迟，只能实现最终一致性，传播过程中，数据不一致</li><li>广播rpc消息量大，对网络压力</li><li>拜占庭将军问题，不允许存在恶意节点</li></ol><h3 id="做几个小题目吧"><a href="#做几个小题目吧" class="headerlink" title="做几个小题目吧"></a>做几个小题目吧</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">文章开始的三个小题目，你有答案了吗？</span><br><span class="line">1. 保证各节点对等，可单独提供服务。宕机恢复后的节点使用反熵拉取新数据。</span><br><span class="line">2. 庞大的集群中，由一个leader节点去广播肯定不行，会把leader整挂的。可以采用谣言传播。</span><br><span class="line">3. 两种传播模式配合使用。新节点上线，通过反熵拉取数据更新。数据更新，通过谣言传播广播数据。</span><br><span class="line">--------------------------------------</span><br><span class="line">每次反熵都需要传输所有数据才能对比，有什么方案优化？</span><br><span class="line"></span><br><span class="line">1. 数据记录只做增量，每次对比只传输增量数据进行对比</span><br><span class="line">2. 采用hash，先传输hash是否一致，再决定要不要传输数据对比</span><br><span class="line">----------------------------------------</span><br><span class="line">谣言传播，谣言传播何时停止？</span><br><span class="line"></span><br><span class="line">论文中提供一个概率来停止广播谣言。我们可以通过设置某个节点被通知到某个阈值时停止广播谣言。</span><br><span class="line">这个阈值设置多少，需要根据集群大小具体调研，阈值设置小了，有可能一些节点接收不到谣言，阈值设置大了，会造成网络性能下降。</span><br><span class="line">------------------------------------------</span><br><span class="line">谣言传播，谣言冲突怎么解决？</span><br><span class="line"></span><br><span class="line">具体场景，可以具体表现。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> gossip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - CAP、BASE、NWR</title>
      <link href="/2020/11/07/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20CAP%E3%80%81BASE%E3%80%81NWR/"/>
      <url>/2020/11/07/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20CAP%E3%80%81BASE%E3%80%81NWR/</url>
      
        <content type="html"><![CDATA[<p>这篇文章<strong>着重点不在于科普</strong>，毕竟关于CAP、BASE的理论的文章，网上很多。所以本文科普篇幅尽量小（只包含概念描述）。主要从几个侧面的问题来描述CAP，进而描述ACID、BASE理念。然后加入一点点调料，如何动态的切换一致性强度。</p><p>本文通过以下几个问题，从侧面描述。文中个人观点较多，看官理性对待。</p><ul><li>为什么CAP三者不可兼得？</li><li>为什么总把ACID与CP、BASE与AP放在一起，它们有什么关联？</li><li>eureka属于AP系统吗？它明明没有放弃一致性啊？</li><li>不考虑一致性的系统，有什么存在的意义呢？</li></ul><h3 id="CAP定理科普"><a href="#CAP定理科普" class="headerlink" title="CAP定理科普"></a>CAP定理科普</h3><p>CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。这三个要素最多只能同时实现两点，不可能三者兼顾。</p><ul><li>一致性（C）：这里是指强一致性。在分布式系统中的所有数据备份，在同一时刻是否同样的值。并不是指整个系统能提供最新的一致的数据。</li><li>可用性（A）：这里是指100%可用性。客户端无论访问到哪个没有宕机的节点上，都能在<strong>有限的时间</strong>内<strong>返回结果</strong>，并不是指整个系统处于可用状态。</li><li>分区容错性（P）：网络中允许丢失一个节点发给另一个节点的任意多的消息，即对网络分区的容忍。在发生网络分区时，能继续保持可用性或者一致性。<br>一个系统要求在运行过程中不能发生网络分区，那么这个系统就不具备分区容错性。</li></ul><p>CAP定理中的可用性和一致性与用户感知的可用性和一致性不是一个概念。我们追求的应该是用户感知的可用性，CAP中可用性和一致性给我们只是起到指导性的作用。</p><p>2017 年，Google 公司的第一代 Spanner 系统已经诞生。Brewer 写了一篇文章讲述了 Google 公司的 Spanner 系统，并且近一步阐述了按照 CAP 定理 Spanner 是一个什么样特性的系统。在文中，Brewer 指出 Spanner 系统说是”实际上的 CA”（effectively CA）系统。从架构上来讲，Spanner 是一个 CP 系统，也就是说当出现网络分区时，Spanner 选择的是保证数据的一致性，放弃可用性的。但实际上，Spanner 是具有非常高可用性效果的一个系统，从架构上 Spanner 没有达到 CAP 定理要求的那种完全可用性，但是也达到非常高的可用性，由于采用多副本的设计，个别副本出现网络分区，并不影响用户能感知到的可用性。按 CAP 定理的定义，当这些个别副本出现网络分区时，这些节点是不可用的，也就是系统没有达到完全可用性。但是此时的用户请求是可以被其他副本服务的，此时服务是可用的，也就是说用户仍然感知到 Spanner 是可用的。所以说用户感知的可用性和 CAP 定理中的可用性不是一个概念。我们追求的应该是用户感知的可用性。</p><h3 id="BASE定理科普"><a href="#BASE定理科普" class="headerlink" title="BASE定理科普"></a>BASE定理科普</h3><p>BASE是对一致性和可用性权衡所得的结果。其核心思想是：在某些场景中，无需做到强一致性，以保证系统的可用性，同时每个应用可以采用适当的方式使系统数据达到最终一致性。</p><p>BASE分别是指：Basically Available, Soft State, Eventual Consistency</p><ul><li>基本可用（Basically Available）：分布式系统在出现故障的时候，允许损失部分可用性，但不等于系统不可用。例如：响应时间的损失，功能上降级。</li><li>软状态（Soft State）：允许系统中的数据存在中间状态，并认为该状态不会影响系统整体可用性。即允许节点之间数据同步存在延时</li><li>最终一致性（Eventually Consistent）：本质是指系统需要使数据最终达到一致性，而不需要实时使数据达到一致性</li></ul><h3 id="ACID科普"><a href="#ACID科普" class="headerlink" title="ACID科普"></a>ACID科普</h3><p>对于ACID中一致性描述，可能理解都不一样，需要先统一下概念。</p><p>ACID中的C（一致性）的定义是：如果事务执行前数据库处于一致状态，那么当事务结束的时候，数据库也会处于一致性状态。这个一致性状态包含两层意思：</p><ul><li>第一层意思是指，数据库内部的完整性，包含实体完整性、域完整性、参照完整性、用户自定义完整性。使用外键、检查约束等，来保证事务执行中不会产生违背数据完整性的数据。例如：使用唯一约束的列不会出现两个一样的值。<br>A transaction must preserve database consistency - if a transaction is run atomically in isolation starting from a consistent database, the database must again be consistent at the end of the transaction.</li><li>第二层意思是对开发者的要求，数据库中的每一行和每个值必须与其所描述的现实保持一致。例如：银行转账，不能只一方扣钱或者一方加钱，我们的代码应该是，一方加钱一方扣钱。<br>Ensuring consistency for an individual transaction is the responsibility of the application programmer who codes the transaction.</li></ul><h3 id="为什么CAP三者不可兼得？"><a href="#为什么CAP三者不可兼得？" class="headerlink" title="为什么CAP三者不可兼得？"></a>为什么CAP三者不可兼得？</h3><p>在分布式系统中，各个组建必然部署在不同的节点上，因此必然出现子网络，同时网络本身又是不可靠的，一定存在延迟和数据丢失，即网络分区是必然存在的。所以P（分区容错性）是分布式系统必须要面对和解决的问题（你无法要求在永远不发生网络分区的环境下运行分布式系统）。</p><p>因此CAP三者不可兼得，变成如何在C（一致性）、A（可用性）二者进行抉择，可以举个例子来说明：在分布式环境中，为了确保系统可用性，通常会采用将数据复制到多个备份节点，而复制的过程需要通过网络交互。当发生网络分区时，你将面临两个选择：</p><ol><li>如果坚持保持各节点之间的数据一致性（选择C），你需要等待网络分区恢复后，将数据复制完成，才可以向外部提供服务。期间发生网络分区将不能对外提供服务，因为它保证不了数据一致性。</li><li>如果选择可用性（选择A），发生网络分区的节点，依然需要向外提供服务。但是由于网络分区，它同步不了最新的数据，所以它返回数据，可能不是最新的（与其他节点不一致的）数据。</li></ol><p>这里需要<strong>强调一句</strong>，CAP三者不可兼得，仅仅是指在发生网络分区情况下，我们才需要在A和C之间进行抉择，选择保证数据一致还是服务可用。而集群正常运行时，A和C是都可以保证的。</p><ul><li>CP架构在当发生网络分区时，为了保证返回给客户端数据准确性，为了不破坏一致性，可能会因为无法响应最新数据，而拒绝响应。在网络分区恢复后，完成数据同步，才可处理客户端请求。</li><li>AP架构在发生网络分区时，发生分区的节点不需要等待数据完成同步，便可处理客户端请求，将尽可能的给用户返回相对新的数据。在网络分区恢复后，完成数据同步。</li></ul><h3 id="ACID与CP、BASE与AP，它们的关联关系？"><a href="#ACID与CP、BASE与AP，它们的关联关系？" class="headerlink" title="ACID与CP、BASE与AP，它们的关联关系？"></a>ACID与CP、BASE与AP，它们的关联关系？</h3><p>根据上一小节C、A二者不可兼得的原因，我们可以总结AP和CP架构的特性。可以发现<strong>CP、AP两者其实是对ACID、BASE的延伸</strong>。是在发生网络分区情况下ACID、BASE的表现。</p><ul><li>CP和ACID都是为了保证数据准确性（两者对准确性定义不同，参考前文科普）。但是两者解决的问题不一样：CP描述的是在发生网络分区时，保证数据准确性。ACID解决的是多个事务并发下，保证数据准确性。</li><li>AP和BASE都是对可用性的研究，BASE要求的只是基本可用，而AP对一致性的要求更低，所以能保证的可用性更高。</li></ul><h4 id="ACID与CP区别"><a href="#ACID与CP区别" class="headerlink" title="ACID与CP区别"></a>ACID与CP区别</h4><p>ACID解决的问题是数据库系统中并发执行多个事务时的问题，是数据库领域的传统问题。那么多个事务并发会存在哪些问题？</p><ul><li>脏读： 事务T1读取了T2更改的x，但是T2在实际存储数据时可能出错回滚了，这时T1读取的实际是无效的数据，这种情况下就是脏读</li><li>不可重复读：是说在T1读取x时，由于中间T2更改了x，所以T1前后两次读取的x值不相同，这就是所谓的不可重复读</li><li>幻读：在T1读取符合某个条件的所有记录时，T2增加了一条符合该条件的记录，这就导致T1执行过程中前后读取的记录可能不一致，即T2之后读取时会多出一条记录。</li></ul><p>为了解决这些问题，事务提出四种隔离级别来规避上述问题。而解决的就是ACID中的C（一致性），所以ACID中的C（一致性）可以理解为不出现脏读、幻读、不可重复读的问题。可以把它称为“内部一致性”，解决的是数据库内部的一致性问题。</p><p>CP中的C（一致性），相对好理解，我把它理解为“外部一致性”。就分布式系统而言的，针对客户端的请求，无论访问那个节点，都能获得最新的相同的值。</p><h4 id="BASE与AP区别"><a href="#BASE与AP区别" class="headerlink" title="BASE与AP区别"></a>BASE与AP区别</h4><p>BASE强调的是基本可用，允许损失部分可用性。这里的损失是指：</p><ul><li>响应时间上的损失：在发生故障时，允许在限定时间之外给用户响应。搜索引擎正常工作0.5秒内给用户返回数据。在部分机房故障后，查询时间增加到1-2秒。</li><li>功能上的损失：在请求高峰时，可以选择一部分请求降级。</li></ul><p>AP则强调是高可用，对数据一致性要求更低。eureka作为AP系统的代表，在发生网络分区时，eureka会移除注册列表中长时间没有心跳的服务，但是当丢失过多客户端时，该节点会进入自我保护，将不会移除过期的服务，并同时接收新服务注册，但不会同步到其他节点。在该种模式下，eureka集群剩下最后一个节点，也可以向外提供服务。</p><h3 id="eureka属于AP系统吗？它明明没有放弃一致性啊？"><a href="#eureka属于AP系统吗？它明明没有放弃一致性啊？" class="headerlink" title="eureka属于AP系统吗？它明明没有放弃一致性啊？"></a>eureka属于AP系统吗？它明明没有放弃一致性啊？</h3><p>描述AP和CP时，通常都会以eureka和zookeeper来具体。eureka是AP的代表作，zookeeper则是CP的代表作。二者之所以这样归类，是因为：</p><ul><li>eureka各节点互相独立、平等的，各节点都提供查询和注册服务（读、写请求）。当发生网络分区，eureka各节点依旧可以接收和注册服务。并且当丢失过多客户端时，节点会进入自我保护（接收新服务注册、不删除过期服务）。在该种模式下，eureka集群剩下最后一个节点，也可以向外提供服务。尽管向外提供的数据可能是过期的数据。</li><li>zookeeper采用的过半原则，由leader处理写请求。当发生网络分区时，leader由于丢失过半的follower，从而处理不了客户端的请求，需要重新选举新leader，期间服务将不可用。糟糕的是，如果集群中没有过半的节点存活，将选举不出新leader，服务将一直处于不可用状态。</li></ul><p>回答eureka没有放弃一致性的问题，还得回顾A、C之间的抉择。这二者需要二选一的情况下，一定是发生了网络分区的情况。eureka集群正常运行时，各节点之间可以正常通讯、保持心跳、复制数据，以此保持数据的一致性。但发生网络分区时，eureka确实选择了可用性，而放弃了一致性。</p><h3 id="NWR"><a href="#NWR" class="headerlink" title="NWR"></a>NWR</h3><p>NWR是一种在分布式存储系统中用于控制一致性级别的一种策略。这个三个字母分别代表着：</p><ul><li>N：分布式系统中，一个有多少个副本数据</li><li>W：处理一次写请求，需要更新多少个副本数据</li><li>R：处理一次读请求，需要读取多少个副本数据</li></ul><p>NWR分别设置不同的值时，将会产生不同的一致性效果。</p><ul><li>W+R&gt;N，整个系统对于客户端的请求能保证强一致性。因为写请求和读请求一定存在一个相交的副本，读取的时候返回该副本的数据即可。</li><li>W+R&lt;=N，整个系统对于客户端的请求则不能保证强一致性。</li></ul><p>基于NWR的性质，我们可以动态的调节系统的一致性效果。还可以根据业务场景动态调整响应速度。以5节点集群为例，在保证强一致性的情况下，需要提高读请求的效率，则可以设置R=2、W=4或者R=1、W=5。当需要提高写请求效率时，则可以设置W=2、R=4或者W=1、R=5。</p><p>W、R的大小，直接影响其对应的处理效率。主要注意，读写请求的效率取决于最慢的副本处理速度。</p><h3 id="建议阅读"><a href="#建议阅读" class="headerlink" title="建议阅读"></a>建议阅读</h3><p>CAP争论及历史：<a href="https://blog.csdn.net/chen77716/article/details/30635543" target="_blank" rel="noopener">https://blog.csdn.net/chen77716/article/details/30635543</a></p><p>CAP，ACID，我们能做什么：<a href="http://hcoona.github.io/Tips/CAP-ACID-what-can-we-do/" target="_blank" rel="noopener">http://hcoona.github.io/Tips/CAP-ACID-what-can-we-do/</a></p><p>理解数据库的事务，ACID，CAP和一致性：<a href="https://www.jianshu.com/p/2c30d1fe5c4e" target="_blank" rel="noopener">https://www.jianshu.com/p/2c30d1fe5c4e</a></p><p>nosql不应该放弃一致性：<a href="https://www.infoq.cn/article/rhzs0KI2G*Y2r9PMdeNv" target="_blank" rel="noopener">https://www.infoq.cn/article/rhzs0KI2G*Y2r9PMdeNv</a></p><h3 id="做几个小题目吧"><a href="#做几个小题目吧" class="headerlink" title="做几个小题目吧"></a>做几个小题目吧</h3><pre><code>paxos算法，可以容忍少数集合节点宕机，我们可以认为paxos提供了比较高的可用性服务，同时又实现了一致性。那么是不是和CAP定理违背了呢？没有违背。CAP定理中可用性是100%可用。当发生网络分区，使paxos集群形成一个多数派集群和一个少数派集群时。当客户端访问多数派节点时，虽然能收到正常的反馈，但是少数派集群的节点则不能。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> CAP </tag>
            
            <tag> BASE </tag>
            
            <tag> NWR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - Raft</title>
      <link href="/2020/10/31/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Raft/"/>
      <url>/2020/10/31/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Raft/</url>
      
        <content type="html"><![CDATA[<p>学习raft之前，给大家推荐一个网站，这个网站动画描述raft运行过程。在看文章时对照该网站，可以帮助更好的理解raft。<br><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p><p>相比于paxos，我们更应掌握raft。raft作为现在分布式系统首选的共识算法。zookeeper、cubby、oceanbase等系统都是在raft诞生之前开发的，所以都是使用了paxos或者对其进行改进。而后来的大多系统都选择了raft，比如consul、etcd等。</p><p>raft相比paxos的优点是:容易理解，容易实现。之所以说容易，是因为raft流程清晰、关键处给出了伪代码描述。相反，可真正用于工程实现的multi-paxos，lamport宗师只提出了个大概。</p><h3 id="Raft术语科普以及总结"><a href="#Raft术语科普以及总结" class="headerlink" title="Raft术语科普以及总结"></a>Raft术语科普以及总结</h3><p>基于前两个篇对paxos和zab的介绍，我们对分布式协议有一定的基础，所以本文先给出总结。</p><h4 id="三种成员身份"><a href="#三种成员身份" class="headerlink" title="三种成员身份"></a>三种成员身份</h4><p>raft提供三种成员身份，<strong>领导者（leader）、跟随者（follower）、候选人（candidate）</strong></p><ul><li>跟随者：相当于paxos中的acceptor，接收和处理leader的消息，当leader故障时，主动推荐自己为候选人</li><li>候选人：向其他节点发送请求投票消息（Request Vote），如果获得大多数选票，则晋升为leader</li><li>领导者：处理写请求，管理日志复制、发送心跳消息。</li></ul><h4 id="两种运行阶段"><a href="#两种运行阶段" class="headerlink" title="两种运行阶段"></a>两种运行阶段</h4><p>raft强化了leader的地位，把整个协议可以清楚的分割成两个部分，并利用日志的连续性做了一些简化：</p><ul><li>leader在时，由leader向follower同步日志。</li><li>leader挂掉了，选一个新leader，leader选举算法。</li></ul><h4 id="两类rpc消息"><a href="#两类rpc消息" class="headerlink" title="两类rpc消息"></a>两类rpc消息</h4><ul><li>请求投票消息（request vote），用于选举leader。</li><li>追加条目消息（append entry），用于心跳消息或日志复制消息。该包含当前最大的日志项。</li></ul><h4 id="raft与multi-paxos的区别"><a href="#raft与multi-paxos的区别" class="headerlink" title="raft与multi-paxos的区别"></a>raft与multi-paxos的区别</h4><ul><li>不是所有节点都能当选leader<br>只有日志最完整的才能当选leader，而multi-paxos则不需要保证这一点，也意味multi-paxos需要额外的流程从其它节点获取已经被提交的日志。</li><li>日志是连续的<br>日志的连续性蕴含了这样一条性质：如果两个不同节点上相同序号的日志，那么这和这之前的日志必然也相同的</li><li>简化的二阶段</li></ul><h3 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h3><p>在节点刚启动状态下，都处于follower状态。同时每个节点会为自己设置一个等待leader心跳消息的随机超时时间。当在超时时间之内没有收到来自leader的心跳信息时，则会推荐自己为candidate。随后增加自己的任期编号，并以candidate的身份发起请求投票消息，推荐自己为leader，当获得大多数选票后，晋升leader，发送心跳消息。</p><h4 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h4><p>例如，存在A、B、C三个节点的raft集群刚启动时，都处于follower状态，其中A超时时间为100ms，B超时时间为200ms，C超时时间为300ms。<br><img src="/images/theory/distributed/raft_1.png" alt="节点信息"></p><p>由于集群中不存在leader，A、B、C三个节点都不会收到来自leader心跳信息。其中，A节点的超时时间最小，则最先修改自己状态为candidate，并增加自己的任期编号为1，发起请求投票消息。<br><img src="/images/theory/distributed/raft_2.png" alt="节点信息"></p><p>节点A的选票会投给自己，而节点B、C收到candidate的请求投票消息。根据投票规则：</p><ol><li>任期编号大的节点拒绝投票给任期编号的小的请求投票消息</li><li>最后一条日志编号大的拒绝投票给最后一条日志编号小的节点</li><li>一个任期编号只投出一张选票</li><li>先来先获得投票</li></ol><p>明显，B、C的任期编号小于A的任期，也不存在最大的日志编号，并且任期编号为1的选票还没有投给任何人，则将任期为1的选票投给节点A，并更新自己的任期编号。<br><img src="/images/theory/distributed/raft_3.png" alt="节点信息"><br>节点A获得包括自己在内的3个选票，赢得大多数选票。其中赢得过半选票也是存在随机超时时间的。如果在超时时间内，则晋升为leader，否则发起新的一轮选举。晋升leader后，则向其他节点发送心跳信息，维护自己的leader角色。<br><img src="/images/theory/distributed/raft_4.png" alt="节点信息"></p><h4 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h4><p>整个选举过程相对来说，比较简单。具体细节还得挑几个点，单独来说：</p><ul><li>随机超时时间<br>在basic-paxos中，通常会描述“活性”一词，是指两个提案同时提出，互相争取选票，导致另一个提案在第二阶段获取不到大多数选票。在muilt-paxos中，leader的选举，而会存在瓜分选票的情况。而raft巧妙的通过随机超时时间，避免了两个candidate同时竞选leader。需要注意，随机超时时间包含两个方面：<ul><li>follower等待leader心跳信息超时的时间间隔。</li><li>candidate在一个随机时间间隔内，没有赢得过半票数，那么选举无效了，需要发起新一轮的选举。</li></ul></li><li>一届任期只投出一张选票，先来先获得投票<br>比如：B节点先后收到A、C任期编号为1的请求投票消息，B节点则将选票投给A节点。至于C节点的请求投票消息，B节点在任期编号为1的已经没有选票可投了。</li><li>任期编号大的节点拒绝投票给任期编号的小的请求投票消息<br>实际上，raft协议在leader选举阶段，由于老leader可能也还存活，也会存在不只一个leader的情形，只是不存在任期编号一样的两个leader。因为选举算法要求leader得到同一个任期编号的多数派的同意，同时赞同的成员会承诺不接受任期编号更小的任何消息。这样可以根据任期编号大小来区分谁是合法的leader。</li><li>最后一条日志编号（uncommited）大的拒绝投票给最后一条日志编号（uncommited）小的节点<br>这一条则是为了保证，只有日志完整度高的节点才能当选leader。这样则可以节省在当选leader后，与各节点比对日志的时间。</li></ul><h3 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h3><p>在raft中，数据都是以日志的形式存在的，客户端每一次的写请求，都会封装成一个日志项（log entry）记录在日志中。所以处理客户端的写请求，就是把日志项（log entry）同步给其他节点并应用到各自状态机的过程。日志同步则可以认为就是处理写请求。</p><p>一条日志项（log entry）又包含：用户数据、索引值、任期编号。</p><ul><li>用户数据，指客户端写请求中的数据，一般是对某个值的修改。</li><li>索引值，日志项的id，一个连续的单调递增的数字</li><li>任期编号，指创建该日志项的leader的任期编号</li></ul><p>在上面总结中，有提到简化的二阶段协议，则是指日志同步阶段。其实在raft之前lamport宗师也有提到如何优化multi-paxos，其中就有优化为一阶段提交。而raft则在日志同步中做出了实践。</p><p>具体实现，在raft中，leader接收到写请求，进入第一阶段。leader将写请求封装为log entry追加到自己的日志中，并发送日志复制消息，将需要同步的log entry复制到集群中其他节点上。如果leader收到大多数节点都成功写入该log entry。那么就将该log entry提交到自己的状态机，同时返回成功给客户端。否则返回错误给客户端。</p><p>而follower则是在接收到leader的心跳信息或者新的日志复制消息后，如果follower发现leader已经提交了某条log entry，而自己还没提交，那么follower就将这条log entry提交到自己的状态机中。</p><h4 id="算法模拟"><a href="#算法模拟" class="headerlink" title="算法模拟"></a>算法模拟</h4><p>存在3节点的集群，A为leader，B、C为follower。当客户端向leader发送set 5的请求，leader收到后，会将其封装成log entry追加到自己的日志中。然后通过日志复制消息时将更改发送给follower。<br><img src="/images/theory/distributed/raft_5.png" alt="算法模拟"></p><p>follower收到消息后，将该log entry追加到自己的日志中，并向leader返回成功响应。当leader收到大多数节点的成功响应后，则在自己的状态机中提交该log entry，并向客户端返回成功。<br><img src="/images/theory/distributed/raft_6.png" alt="算法模拟"></p><p>在下一次追加条目消息（心跳消息、日志复制消息）中，会携带leader最新修改的log entry。follower收到后，则会提交之前尚未提交的log entry。<br><img src="/images/theory/distributed/raft_7.png" alt="算法模拟"></p><p>follower完成提交后，即达成本次共识。</p><h3 id="网络分区、宕机恢复"><a href="#网络分区、宕机恢复" class="headerlink" title="网络分区、宕机恢复"></a>网络分区、宕机恢复</h3><p>当集群中出现网络分区，导致产生了两个小集群时，每个集群都存在自己的leader。或者上一任leader宕机恢复后加入集群时，存在两个leader的情况。raft为此也制定了一些特殊的规定：<strong>根据任期编号大小来区分谁是合法的leader</strong>。例如：当一个candidate或者leader发现自己的任期编号比其他节点小，那么它会立即恢复成follower状态。</p><p>存在一个5节点集群，正常运行时，B节点为leader，其余A、C、D、E为follower<br><img src="/images/theory/distributed/raft_8.png" alt="网络分区"></p><p>当出现网络分区，出现两个由B, A和C, D, E组成的小集群。并且B继续保持leader状态，C为新晋升的leader。<br><img src="/images/theory/distributed/raft_9.png" alt="网络分区"></p><p>当此时，有写请求到B时，由于B不能获得多数票的支持，最终该写请求不会被提交，也不会返回给客户端成功的响应，将一直保持未提交的状态存在日志中。<br><img src="/images/theory/distributed/raft_10.png" alt="网络分区"></p><p>而当网络分区恢复后，B, A节点重新加入集群。当它们收到来自C节点的心跳消息时，发现C的任期编号比自己大，则会切换状态，抛弃掉自己有但C节点没有的log entry，并且同步C节点上的log entry。<br><img src="/images/theory/distributed/raft_11.png" alt="网络分区"></p><h3 id="思考几个题目吧"><a href="#思考几个题目吧" class="headerlink" title="思考几个题目吧"></a>思考几个题目吧</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">leader选举中，B节点的任期编号为1，日志编号为2。A节点任期编号为2，日志编号为1。</span><br><span class="line">B节点收到A节点的请求投票消息，B会投票给A节点吗？</span><br><span class="line"></span><br><span class="line">不会，B节点的编号大于A节点，说明B节点的日志完整度更高，更适合当选leader。</span><br><span class="line">--------------------------------</span><br><span class="line">当一个节点出现网络分区，它即获取不到大多数节点的选票，当不了leader，也接收不到其他leader的心跳，那么任期则会一直增加。</span><br><span class="line">那它网络恢复加入集群后，因为它存在很大编号，其他节点会不会认它为leader。</span><br><span class="line"></span><br><span class="line">不会，它加入集群后，会拒绝新leader的消息（因为它的任期大），则会修改状态为candidate，并发起请求投票。</span><br><span class="line">其他节点收到它的投票信息后，会将自己的任期编号改成它的，然后判断其他投票条件（最大日志编号），将会拒绝投票给它。</span><br><span class="line">它加入集群的唯一的影响就是一下子增加了任期编号的大小。</span><br><span class="line">--------------------------------</span><br><span class="line">假如客户端发送请求set 1，当leader在第一阶段时将该日志项只复制到了一个节点，没有获得大多数选票，则返回给客户端失败。这时leader宕机。新晋升的leader，将怎么处理set 1的日志项？</span><br><span class="line"></span><br><span class="line">raft一切以领导者为准的原则，是否丢弃掉set 1 的日志项，取决于新晋升的leader是否包含该日志项。</span><br><span class="line">1. 如果新晋升的leader包含set 1，则继续提交该日志项</span><br><span class="line">2. 如果新晋升的leader不包含set 1，当初被复制成功的那个节点，将会以领导者的为准，丢弃掉set 1。</span><br><span class="line"></span><br><span class="line">注释：至于新晋升的leader为什么不确认set 1是否被大多数复制成功再决定是否丢弃。</span><br><span class="line">我查过一些资料，这种情况确实会以leader的日志项为准，leader的日志项不会被删除。</span><br><span class="line">--------------------------------</span><br><span class="line">假如客户端发送请求set 1，当leader在第一阶段时将该日志项只复制到了大多数节点，获得了大多数选票，则返回给客户端成功。这时leader宕机。</span><br><span class="line">新选举的leader，将会如何将set 1日志项进行提交呢？</span><br><span class="line"></span><br><span class="line">按照选举规则，不包含set 1日志项的节点是少数集合，包含set 1日志项不会给不包含set 1日志项的节点投票。</span><br><span class="line">最后晋升的一定是包含set 1日志项的节点。一切以领导者为准的原则，则会完成set 1日志项的提交。</span><br><span class="line">--------------------------------</span><br><span class="line">raft一切依赖leader，所以性能瓶颈集中在leader，写性能仅为单机。如何提升？</span><br><span class="line"></span><br><span class="line">可以裂变分区，将原本一个raft集群裂变成多个互不影响的raft集群。</span><br><span class="line">例如：设计一个数据库，可以将元数据同步和用户数据同步使用两个raft集群。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> Raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解jvm03 - 垃圾收集器与内存分配策略</title>
      <link href="/2020/09/22/java/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm03%20-%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
      <url>/2020/09/22/java/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm03%20-%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>本系列博客为《深入理解Java虚拟机 - JVM高级特性与最佳实践》读书笔记。本书大量干货，适合初学jvm的人员，也适合为应付面试人员，比较推荐的一本书。本系列只为记录书中精髓，方便查阅与记忆。如有错误，欢迎指出 O(∩_∩)O </p><p>基于书中第二章总结，程序计数器、java虚拟机栈、本地方法栈随线程的生命周期创建和销毁，自然不用过多的考虑进行垃圾回收。而java堆、方法区则不一样，这一块的分配和回收是动态的，那本章的内容也是基于这两块的内容。</p><h3 id="对象已死吗？"><a href="#对象已死吗？" class="headerlink" title="对象已死吗？"></a>对象已死吗？</h3><p>垃圾回收第一步就是要确定那些对象可回收（已死），那些不可回收（活着）。书中介绍两种算法来确定对象是否存活</p><ul><li>引用计数法</li><li>可达性分析法</li></ul><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>引用计数法，是给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的，则判断为可回收。但是主流jvm都没有使用它，根本原因是它解决不了对象循环引用的问题。</p><h4 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h4><p>可达性分析法，是主流语言（java、c#）的主流实现方案。它是通过定义一系列的“GC Root”对象作为起始点，从这些节点往下搜索，搜索所经过的路劲称为引用链。当一个对象没有任何引用链可到达“GC Root”时，则证明该对象不可用，判断为可回收对象。</p><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ul><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>这一小节，主要再次细分了引用的类型。java将引用的概念扩充成了：强引用（StrongReference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（PhantomReference）4种，这4种引用强度依次逐渐减弱。</p><p>4种引用概念，可以去书中寻找。他们的区别是：<br>强引用，垃圾收集器永远都不会回收。软引用，在抛出内存溢出之前将这类引用进行回收，在判断是否抛内存溢出异常。弱引用，垃圾收集器会正常就会回收这类引用的对象。虚引用，唯一的目的就是在该对象回收时可以收到一个系统通知。</p><h4 id="对象自我拯救（finalize-）"><a href="#对象自我拯救（finalize-）" class="headerlink" title="对象自我拯救（finalize()）"></a>对象自我拯救（finalize()）</h4><p>在可达性分析法中，宣告一个对象真正死亡，至少要经历两次标记：</p><ol><li>该对象没有与GC Root相连接的引用链，进行第一次标记，并放入F-Queue队列中执行finalize()。</li><li>稍后，GC会对F-Queue队列中的对象进行小范围的标记，这次标记是将在finalize()方法中逃脱对象，移出“即将回收”的集合，剩下的对象就会真正被回收。</li></ol><p>注意：<strong>finalize()是一个对象逃脱被回收的最后一次机会</strong>，如果对象不想被回收，可以重写finalize()之后，将自己（this）赋值给某个变量。<strong>finalize()在一个对象生命中，只会执行一次</strong>。<strong>F-Queue队列只会执行重写过的finalize()方法。</strong></p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>方法区（或者HotSpot虚拟机中的永久代）垃圾收集主要回收两部分内容：废弃常量和无用的类。<br>废弃常量：字符串“abc”已经进入了常量池中，但是此时没有任何一个String引用“abc”。如果有必要的话，则会被系统清理出常量池。<br>无用的类：该类所有的实例都已经被回收、加载该类的ClassLoader已经被回收、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。满足上述3个条件，则可以对无用类进行回收，而不是必然会回收。</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记-清除算法，分两个阶段来完成，一是先标记出需要清理的对象，二是将标记的对象统一回收清除。第一个阶段在上一小节已经描述过了。</p><p>标记-清除算法，虽然简单，但是存在两个不足：</p><ul><li>效率问题，标记和清除两个过程的效率都不高</li><li>空间问题，标记清除会产生大量不连续的内存碎片，当遇到需要分配大对象时，会因为无法找到连续的内存而不得不再一次进行垃圾收集。</li></ul><p><img src="/images/java/jvm/understanding_jvm_03_2.png" alt="标记-清除算法"></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>现有的商业虚拟机都采用该种算法来回收新生代。它是将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>这样使得每次都是对整个半区进行回收，内存分配时也不用考虑内存碎片的问题，只需顺序分配即可。这种算法有点就是简单、高效，但是它的代价是内存缩小了一半。</p><p>由于新生代98%的对象都是“朝不保夕”，所以不需要按照1:1的比例来划分，而是划分为一块较大的Eden空间和两块较小的Survivor空间。每次使用Eden和其中一块Survivor空间，回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor上，最后清理掉Eden和刚才使用的Survivor，完成回收动作。</p><p>HotSpot虚拟机默认Eden和Survivor比例是8:1，也就是说新生代中能使用的内存为整个空间的90%（80%+10%），只有10%会用于复制算法所需的开销。但是我们没法保证，每次回收都只有不超过10%的对象存活，这时就需要老年代进行分配担保，让这些对象直接进入老年代。</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>复制算法，在存活对象比例较高时，就需要进行较多的复制操作，效率会很低。更关键的时，如果不想浪费50%的空间，需要额外的空间进行分配担保，以应对回收时，100%的对象都存活的极端情况，所以在老年代不会直接使用复制算法。<br>根据老年代特点，提出标记-整理算法，与标记-清除算法不同的是，第二阶段清除动作，是将所有存活的对象移向一端，然后直接清理掉端边界以外的内存。<br><img src="/images/java/jvm/understanding_jvm_03_3.png" alt="标记-清除算法"></p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>分代收集算法，则是为了将内存划分为几块区域，java划分为新生代、老年代。这样可以根据不同的区域选择不同的收集算法，以提高回收效率。新生代对象存活率低，则使用复制算法效率更高，而老年代对象存活率高，又没有额外的空间给它担保，所以就必须使用“标记-整理算法”或者“标记-清除算法”。</p><h3 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h3><h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><p>在GC分析过程中，如果对象引用一直在变化，则最后分析的结果是不准确的，所以GC进行时需要停止所有java执行线程（Sun 将这件事情叫做“Stop The World”）。号称不会发生停顿的CMS收集器中，枚举根节点也必须要停顿的。而现在很多应用仅仅方法区就有数百兆，所有逐一检查这里面的引用，不太现实。</p><p>在HotSpot中，使用一组称为OopMap的数据结构来存放对象引用在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。</p><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>在OopMap的协助下，HotSpot可以快速枚举根节点，但是OopMap引用的关系变化，不能每次变化都去维护OopMap，这样代价太大，什么时候去维护呢？这就是安全点（Safepoint）的作用，HotSpot只会在这些地方记录OopMap信息，而程序也只能在这些地方才能停顿下来开始GC。</p><p>但是Safepoint也不能过多，因为会增加运行的代价，也不能过少，让GC等待时间太长。一般例如：方法调用、循环跳转、异常跳转等，会产生Safepoint。</p><p>当发生GC时，如何让所有线程都跑到就近的安全点上停顿下来，书中讲述两个方案：</p><ul><li>抢先式中断，首先让所有线程都中断，如果有线程没有停顿在安全点上，就恢复线程，让他跑到安全点上。几乎没有虚拟机采用该方式</li><li>主动式中断，在所有安全点（再增加创建对象分配内存的地方）增加设置标记，当线程执行时，遇到这些标记，就会判断该标记是否需要在当前位置中断自己</li></ul><h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>安全点解决了运行中的线程，但是当线程处于sleep或者blocked状态时，则不能响应jvm的中断请求，这时需要引申安全区域（safe region），安全区域指一段代码片段中，引用关系不会发生变化，可以把safe region透明的看作是safepoint。</p><p>当GC发生时，jvm不用处理进入safe region的线程。只有当线程离开safe region时，需要检查GC是否完成根节点枚举，如果已经完成则继续执行线程即可，否则需要等待直到收到可以安全离开safe region的信号为止。</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="/images/java/jvm/understanding_jvm_03_4.png" alt="垃圾收集器"><br>书中对图中的收集器都做了详细讲解，其中两个收集器之间的连线代表着它们之间可以配合使用。对书中内容先做一个简单总结。</p><ul><li>Serial收集器，单线程完成垃圾收集工作，收集中需要暂停所有工作线程直到它收集完毕。简单高效，多用于Client模式下新生代收集。<br><img src="/images/java/jvm/understanding_jvm_03_5.png" alt="Serial/Serial Old收集器"></li><li>ParNew收集器，为Serial收集器的多线程版本，其余行为包括控制参数与Serial收集器一致，多用于Server模式下新生代收集。<br><img src="/images/java/jvm/understanding_jvm_03_6.png" alt="ParNew/Serial Old收集器收集器"></li><li>Parallel Scavenge收集器，新生代收集器，复制算法，与上述两个不同的是，它还被称为吞吐量优先收集器，可以设置GC最大停顿时间、以及吞吐量大小参数。</li><li>Serial Old收集器，老年代收集器，“标记-整理”算法，单线程，用于Client模式下的虚拟机，或者用于Server模式下搭配Parallel Scavenge收集器使用。<br><img src="/images/java/jvm/understanding_jvm_03_7.png" alt="Serial/Serial Old收集器"></li><li>ParNew Old收集器，老年代收集器，“标记-整理”算法，吞吐量优先收集器。在它出现之前Parallel Scavenge只能和Serial Old搭配使用，并不能使用整体应用获取吞吐量最大化，所以有了它。注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old。<br><img src="/images/java/jvm/understanding_jvm_03_8.png" alt="Serial/Serial Old收集器"></li><li>CMS收集器</li><li>G1收集器</li></ul><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（Concurrent Mark Sweep），以获取最短回收时间为目标的收集器，用于互联网网站的服务端，采用“标记-清除”算法。其收集过程分为4个步骤</p><ul><li>初始标记，仅仅只是枚举GC Root</li><li>并发标记，与用户线程同时执行，标记回收对象</li><li>重新标记，修改并发标记期间因用户线程继续执行而导致标记产生变动的那一部分对象</li><li>并发清除，与用户线程同时执行，回收对象</li></ul><p>初始标记、重新标记，依然需要“Stop the world”，但是耗时相比并发标记、并发清除极短。<br><img src="/images/java/jvm/understanding_jvm_03_9.png" alt="Concurrent Mark Sweep收集器"><br>CMS缺点也很明显：</p><ol><li>对CPU资源敏感，需要独占一个CPU来执行收集线程。</li><li>无法处理浮动垃圾（即并发标记过程中，用户线程产生的垃圾需要等待到下次收集时处理），所有需要给老年代多预留一部分内存来提前进行GC。jdk1.5 CMS在老年代使用68%时则会启动收集工作，jdk1.6 CMS启动阈值为92%，当收集过程中预留内存不够用，虚拟机将启动后备预案：临时启动Serial Old来重新进行老年代的收集。</li><li>CMS采用 “标记-清除”算法，则会产生大量碎片，对大对象分配带来麻烦。CMS收集器提供了一个-XX+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入FullGC时都进行碎片整理）。</li></ol><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一。优点：并行处理，分代收集，“标记整理”算法，可预测的停顿。G1 其思想是将java堆分为多个Region，回收以Region为单位。使用Remenbered Set来保存各个Region之间的对象引用。当程序对Reference类型的数据进行写操作时，会检查Reference引用的对象是否处于不同的Region之中，如果是，便更新Region所属的Remembered Set。</p><p>如果不计算维护Remembered Set，G1收集过程可分为四个阶段</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p><img src="/images/java/jvm/understanding_jvm_03_10.png" alt="G1收集器"></p><h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33.125</span>：[GC[DefNew：<span class="number">3324</span>K-＞<span class="number">152</span>K（<span class="number">3712</span>K），<span class="number">0.0025925</span> secs]<span class="number">3324</span>K-＞<span class="number">152</span>K（<span class="number">11904</span>K），<span class="number">0.0031680</span> secs]</span><br><span class="line"><span class="number">100.667</span>：[Full GC[Tenured：<span class="number">0</span>K-＞<span class="number">210</span>K（<span class="number">10240</span>K），<span class="number">0.0149142</span>secs]<span class="number">4603</span>K-＞<span class="number">210</span>K（<span class="number">19456</span>K），[Perm：<span class="number">2999</span>K-＞<span class="number">2999</span>K（<span class="number">21248</span>K）]，<span class="number">0.0150007</span> secs][Times：user=<span class="number">0.01</span> sys=<span class="number">0.00</span>，real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></table></figure><p>最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</p><p>GC日志开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，而<strong>不是用来区分新生代GC还是老年代GC</strong>的。如果有“Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现“[Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc（）方法所触发的收集，那么在这里将显示“[Full GC（System）”。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC <span class="number">283.736</span>：[ParNew：<span class="number">261599</span>K-＞<span class="number">261599</span>K（<span class="number">261952</span>K），<span class="number">0.0000288</span> secs]</span><br></pre></td></tr></table></figure><p>接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的</p><ul><li>Serial收集器中的新生代名为“DefaultNew Generation”，所以显示的是“[DefNew”。</li><li>ParNew收集器，新生代名称就会变为“[ParNew”，意为“Parallel New Generation”。</li><li>Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”。</li></ul><p>后面方括号内部的“3324K-＞152K（3712K）”含义是“GC前该内存区域已使用容量-＞GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“3324K-＞152K（11904K）”表示“GC前Java堆已使用容量-＞GC后Java堆已使用容量（Java堆总容量）”。</p><p>再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“[Times：user=0.01 sys=0.00，real=0.02 secs]”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以读者看到user或sys时间超过real时间是完全正常的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配 [1] ），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，<strong>分配的规则并不是百分之百固定的</strong>，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p><p>书中对以下几种情况都给出案例，可以去查看</p><ul><li>对象优先分配在Eden</li><li>大对象直接进入老年代</li><li>长期存活对象进入老年代</li><li>动态年龄判断</li><li>空间分配担保</li></ul>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解jvm02 - java内存区域与内存泄露异常</title>
      <link href="/2020/09/05/java/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm02%20-%20java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%BC%82%E5%B8%B8/"/>
      <url>/2020/09/05/java/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm02%20-%20java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>本系列博客为《深入理解Java虚拟机 - JVM高级特性与最佳实践》读书笔记。本书大量干货，适合初学jvm的人员，也适合为应付面试人员，比较推荐的一本书。本系列只为记录书中精髓，方便查阅与记忆。如有错误，欢迎指出 O(∩_∩)O </p><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>在启动java程序时，我们会给jvm分配指定的内存大小。而jvm则对该部分内存划分为若干区域。其中有的区域以来用户线程的启动和结束而建立和销毁，有的区域随jvm进程的启动而存在。<br><img src="/images/java/jvm/understanding_jvm_02_1.png" alt="运行时数据区域"></p><p>线程私有：</p><ul><li>程序计数器</li><li>java虚拟机栈</li><li>本地方法栈</li></ul><p>线程共享：</p><ul><li>java堆</li><li>方法区</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，可以看作当前线程所执行的<strong>字节码的行号指示器</strong>。jvm规范中<strong>唯一一个没有OutOfMemoryError异常的区域</strong>。该区域属于<strong>线程私有</strong>，随线程的启动和结束而建立和销毁。</p><p>字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都一来该计数器来完成。</p><h4 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h4><p>java虚拟机栈（Java Virtual Machine Stacks）描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。该区域属于<strong>线程私有</strong>。</p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>这个区域会抛出两个异常</p><ul><li>线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</li><li>如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><p>Native方法常用于：</p><ul><li>调用一些不是java语言写的代码</li><li>在java语言中直接操作计算机硬件</li></ul><p>异常：StackOverflowError、OutOfMemoryError</p><h4 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h4><p>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有<strong>线程共享</strong>的一块内存区域，在虚拟机启动时创建。注意：线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。</p><p>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。所以它是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。</p><p>Java堆还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</p><p>如果java堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区（Method Area）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。。所以它也是<strong>线程共享</strong>的内存区域。</p><p>方法区还有另一个名字“<strong>永久代</strong>”（Permanent Generation）。这个名字是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，使用“永久代”这个概念来描述方法区的内存回收。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。J9和JRockit只要没有触碰到进程可用内存的上限，就不会出现像HotSpot一样因为方法区发小不够而抛出OutOfMemoryError的异常。</p><p>垃圾收集行为在该区域比较少出现，这也印证了永久代这个名字，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对<strong>常量池的回收和对类型的卸载</strong>。</p><p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError。<br>NIO通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能避免了在Java堆和Native堆中来回复制数据，以提高显著的性能。</p><p>直接内存的分配不会受到Java堆大小的限制，只会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。<strong>如果使用了直接内存，应注意它将会占用了本机总内存，会导致jvm操作的内存扩容时申请不到-Xmx大小的内存，而抛出OutOfMemoryError异常。</strong></p><h3 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><h5 id="类检查"><a href="#类检查" class="headerlink" title="类检查"></a>类检查</h5><p>对象的创建（包含克隆、反序列化）通常new关键字。虚拟机遇到一条new指令时，先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查该符号引用代表的类是否被加载、解析、初始化。</p><h5 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h5><p>在类检查通过后，接下来虚拟机将为新生对象分配内存，分配内存存在两种方式：</p><ul><li>“指针碰撞”（Bump the Pointer）<br>要求堆内存绝对规整，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</li><li>“空闲列表”（Free List）<br>已使用的内存和空闲的内存相互交错，就只能使用空闲列表。它需要维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</li></ul><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。例如：Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p><p>划分可用空间之外，jvm还需要保证内存分配的并发问题，例如：给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p><ul><li>CAS配上失败重试</li><li>本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）<br>每个线程在Java堆中预先分配一小块内存，哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定内存。</li></ul><p>jvm实际上采用CAS配上失败重试的方式进行实现，如需使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>初始化，也分为两步，首先初始化内存为零值（不包括对象头），以保证该字段在Java代码中可以不赋初始值就直接使用（重排序）。<br>第二步，则是对对象进行必要的设置，其中包含这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</p><p>上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。书中有给出HotSpot虚拟机bytecodeInterpreter.cpp中的代码片段，以印证上述内容。</p><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p>对象头存放两部分数据，一部分被称为Mark Word，另一部分则是类型指针。</p><ul><li>Mark Word<br>数据长度为32bit或者64bit别分对应32位和64位的虚拟机。其中保存了哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</li><li>类型指针<br>即对象指向它的类元数据的指针，通过这个指针来确定这个对象是哪个类的实例</li></ul><p>实例数据是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容（包含继承父类）。</p><p>齐填充不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。HotSpot的自动内存管理系统要求对象起始地址必须是8字节的整数倍，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>对象访问是通过栈上的reference数据来操作堆上的具体对象的。目前主流的访问方式有使用句柄和直接指针两种。</p><ul><li>句柄访问，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。优势：reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。</li><li>直接指针访问，reference中存储的直接就是对象地址。优势：节省了一次指针定位的时间开销，速度更快。</li></ul><p>HotSpot而言，它是使用直接指针访问方式进行对象访问的。</p><h3 id="OutOfMemoryError异常"><a href="#OutOfMemoryError异常" class="headerlink" title="OutOfMemoryError异常"></a>OutOfMemoryError异常</h3><h4 id="java堆溢出"><a href="#java堆溢出" class="headerlink" title="java堆溢出"></a>java堆溢出</h4><p>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError：Java heap <span class="literal">space</span></span><br><span class="line">Dumping heap <span class="built_in">to</span> java_pid3404.hprof……</span><br><span class="line">Heap dump <span class="built_in">file</span> created[<span class="number">22045981</span> <span class="keyword">bytes</span> <span class="keyword">in</span> <span class="number">0.663</span> <span class="built_in">secs</span>]</span><br></pre></td></tr></table></figure><p>异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”，则是指java堆异常。</p><p>解决这个区域的异常，先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。内存溢出增加机器配置即可，内存泄露则需要一步步分析定位问题。区分两者的重点是确认内存中的对象是否是必要的。一般的手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析。查看泄露的对象到GC Root的引用链，一般就能比较准确的定位泄露代码的位置。</p><h4 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h4><p>该区域，java规范了两个StackOverflowError、OutOfMemoryError。书中实验只验证了StackOverflowError。通过两种方式：</p><ul><li>使用-Xss参数减少栈内存容量，栈深度相应减少。抛出StackOverflowError异常。</li><li>定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出StackOverflowError。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Exception</span> <span class="selector-tag">in</span> <span class="selector-tag">thread</span>"<span class="selector-tag">main</span>"<span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.StackOverflowError</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.fenixsoft</span><span class="selector-class">.oom</span><span class="selector-class">.VMStackSOF</span><span class="selector-class">.leak</span>（<span class="selector-tag">VMStackSOF</span><span class="selector-class">.java</span>：20）</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.fenixsoft</span><span class="selector-class">.oom</span><span class="selector-class">.VMStackSOF</span><span class="selector-class">.leak</span>（<span class="selector-tag">VMStackSOF</span><span class="selector-class">.java</span>：21）</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.fenixsoft</span><span class="selector-class">.oom</span><span class="selector-class">.VMStackSOF</span><span class="selector-class">.leak</span>（<span class="selector-tag">VMStackSOF</span><span class="selector-class">.java</span>：21）</span><br><span class="line">……后续异常堆栈信息省略</span><br></pre></td></tr></table></figure><p>解决这个区域的异常，StackOverflowError相对还是简单的，因为日志中会打印异常栈。对于OutOfMemoryError，书中指出如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。</p><h4 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h4><p>方法区，存放Class相关信息和运行时常量池，书中从这两个方面分别给出测试案列，使之抛出OutOfMemoryError。</p><ul><li>使用String.intern()，向运行时常量池中存放字符串（仅限jdk1.6，jdk1.7相同字符串只会缓存第一次出现的对象）</li><li>使用CGLib创建大量的动态类</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Exception</span> <span class="selector-tag">in</span> <span class="selector-tag">thread</span>"<span class="selector-tag">main</span>"<span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>：<span class="selector-tag">PermGen</span> <span class="selector-tag">space</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.String</span><span class="selector-class">.intern</span>（<span class="selector-tag">Native</span> <span class="selector-tag">Method</span>）</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.fenixsoft</span><span class="selector-class">.oom</span><span class="selector-class">.RuntimeConstantPoolOOM</span><span class="selector-class">.main</span>（<span class="selector-tag">RuntimeConstantPoolOOM</span><span class="selector-class">.java</span>：18）</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">Caused</span> <span class="selector-tag">by</span>：<span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>：<span class="selector-tag">PermGen</span> <span class="selector-tag">space</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.ClassLoader</span><span class="selector-class">.defineClass1</span>（<span class="selector-tag">Native</span> <span class="selector-tag">Method</span>）</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.ClassLoader</span><span class="selector-class">.defineClassCond</span>（<span class="selector-tag">ClassLoader</span><span class="selector-class">.java</span>：632）</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.ClassLoader</span><span class="selector-class">.defineClass</span>（<span class="selector-tag">ClassLoader</span><span class="selector-class">.java</span>：616）</span><br><span class="line">……8 <span class="selector-tag">more</span></span><br></pre></td></tr></table></figure><p>运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是“PermGen space”，说明运行时常量池属于方法区（HotSpot虚拟机中的永久代）的一部分。</p><p>方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p><h4 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h4><p>使用Unsafe实例的allocateMemory()方法进行内存分配，直到抛出异常</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Exception</span> <span class="selector-tag">in</span> <span class="selector-tag">thread</span>"<span class="selector-tag">main</span>"<span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.allocateMemory</span>（<span class="selector-tag">Native</span> <span class="selector-tag">Method</span>）</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.fenixsoft</span><span class="selector-class">.oom</span><span class="selector-class">.DMOOM</span><span class="selector-class">.main</span>（<span class="selector-tag">DMOOM</span><span class="selector-class">.java</span>：20）</span><br></pre></td></tr></table></figure><p>由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。</p><h3 id="jvm参数"><a href="#jvm参数" class="headerlink" title="jvm参数"></a>jvm参数</h3><p>-Xmx       最大堆大小<br>-Xms       初始堆大小<br>-XX：PermSize   永久代大小<br>-XX：MaxPermSize   永久代大小<br>-XX：+/-UseTLAB     使用本地线程分配缓冲<br>-Xss          栈大小<br>-XX: MaxDirectMemorySize      直接内存（默认和-Xmx相同）</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 内存泄露 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - ZAB</title>
      <link href="/2020/08/12/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20ZAB/"/>
      <url>/2020/08/12/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20ZAB/</url>
      
        <content type="html"><![CDATA[<h3 id="ZAB-背景"><a href="#ZAB-背景" class="headerlink" title="ZAB 背景"></a>ZAB 背景</h3><p>学习ZAB，非常有必要聊聊它诞生的背景。因为在paxos的光芒下，还有必要折腾这样类似的算法吗？这个问题是我们初步了解ZAB关键。</p><p>看到这里，我断定大家都使用过zookeeper，并且知道zookeeper的核心就是ZAB协议。如果没有的话，需要先学习下zookeeper。毕竟基础不牢，地动山摇。</p><p>这里多提一句，ZAB的作者说ZAB不是paxos，但是后面我们又把ZAB归纳为paxos。这里我认为啊，这两个说法都对，只是他们描述的时间不一致。在ZAB诞生的时候，它解决了paxos不能保证顺序执行的问题，从某些角度来说ZAB是要paxos优秀的，说它不是paxos也没问题。但是后来随来越来越多分布式算法诞生，例如raft，因为他们都类似paxos执行逻辑，所以将这类算法归纳为paxos的变种。</p><h4 id="为何不使用paxos来实现zookeeper"><a href="#为何不使用paxos来实现zookeeper" class="headerlink" title="为何不使用paxos来实现zookeeper"></a>为何不使用paxos来实现zookeeper</h4><p>回过头来，ZAB诞生的原因，我们先考虑zookeeper能不能直接使用paxos作为分布式一致性算法？答案肯定是否定的，我们举个例子，假设有个客户端需要分别创建目录：/foo, /foo/ofcoder。</p><p>在前文我们学习过了paxos，知道paxos能集群就某个值达成共识，但是却不关心达成共识的值是什么。如果zookeeper直接使用paxos，就会出现在没有创建/foo的时候，创建/foo/ofcoder。显然这就报错了，因为ofcoder的上级目录不存在。为了描述这个问题，我们描述下过程。</p><p>假如有同一个业务请求，因为入参不一样，导致最后要达成共识的值也不一样。例如proposerA，收到请求先后创建/foo, /foo/ofcoder两个节点。proposerB收到请求先后创建/method，/method/far节点。<br><img src="/images/theory/distributed/zab_1.png" alt="paxos不适合实现zookeeper"></p><ol><li>proposerB先发起paxos的prepare阶段，并获得大多数选票，开始accept阶段。</li><li>在proposerB的accept阶段，只有acceptA接收了提案[1, /method]，其他节点都通过了proposerA的prepare请求。</li><li>根据规定，proposeA的accept的提案应该为[2, /method]，并通过该提案。</li><li>此时proposerB重新开始paxos的两个阶段，得到达成共识的提案是[2, /method]。</li><li>proposerA开始第二个值的paxos过程，即/foo/ofcoder。</li></ol><p>到此为止，可以看到当proposerA开始创建/foo/ofcoder时，则会发现/foo没有创建而导致失败。因为在第一轮paxos在集群中达成共识的值/method。</p><p>通过上面的过程，我们更加论证了，paxos只适合在集群中使某个值达成共识，而不关心达成共识的值是什么。而在zookeeper中，这显然是不能满足业务需求的。</p><h3 id="ZAB术语科普"><a href="#ZAB术语科普" class="headerlink" title="ZAB术语科普"></a>ZAB术语科普</h3><p>ZAB并不像paxos，是一种通用的分布式一致性算法，ZAB是一种专门为zookeeper设计的崩溃可恢复的原子广播协议。相比于paxos，<strong>ZAB主要解决了事务操作的顺序性</strong>，在ZAB协议中，如果一个事务操作被处理了，那么所有其依赖的事务操作都应该被提前处理了。</p><p>在学习ZAB之前，我们需要先整理几个术语、因为在ZAB的论文中，术语相对比较多，并且概念冗余。例如：</p><ul><li>提案（proposal）：进行协商的基本单元，在一些文档中，也有称之为操作（operation）、指令（command）。</li><li>事务（transaction）：也是指提案，常出现在代码中，并非指具有ACID特性的一组操作。</li><li>已提出的Proposal：指广播的第一阶段所提出的Proposal，未提交到状态机的Proposal。</li><li>已提交的Proposal：指广播的第二阶段已提交到状态机的Proposal。</li></ul><p>为了帮助我们理解，ZAB定义了三个角色、四种节点状态、四种ZAB运行状态、以及两种运行模式。大家别看到我罗列了这么多，就打退堂鼓。从多个角度来归纳，只是为了更好的给大家呈现ZAB内部原理。</p><h4 id="三个角色"><a href="#三个角色" class="headerlink" title="三个角色"></a>三个角色</h4><ul><li><p>领导者（leader）<br>leader是整个ZAB协议的核心，其工作内容在于：接收并处理所有事务请求，也就是写请求。将每个事务请求，封装成提案（proposal）广播给每个跟随者（follower），根据跟随者（follower）返回请求，控制是否需要提交该提案。</p></li><li><p>跟随者（follower）follower的工作，可以分为三部分</p><ul><li>接收leader提出的提案（proposal），参与对提案（proposal）的投票</li><li>接收并处理非事务请求，也就是读请求。如果follower收到客户端的事务请求，则会将其转发给leader进行处理。</li><li>参与leader选举投票</li></ul></li></ul><ul><li>观察者（observer）<br>跟paxos中学习者类似，增加observer，可以在不影响集群写性能的情况下，提升读性能。</li></ul><h4 id="四种节点状态"><a href="#四种节点状态" class="headerlink" title="四种节点状态"></a>四种节点状态</h4><p>这是一个容易忽视的点，ZAB虽然规定了三种角色，但是他是通过定义四种状态来描述当前节点所处的角色的。包含以下状态：</p><ul><li>LOOKING，竞选状态，当前集群不存在Leader。该状态下会发起领导者选举。</li><li>FOLLOWING，随从状态，同步Leader状态，参与投票。</li><li>OBSERVING，观察状态，同步Leader状态，不参与投票。</li><li>LEADING，领导者状态，对应Leader角色。</li></ul><p>这里与角色对应多出来一个状态，是因为ZAB是支持自动Leader选举的，LOOKING是属于选举中的一个过渡状态。</p><h4 id="四种ZAB运行状态"><a href="#四种ZAB运行状态" class="headerlink" title="四种ZAB运行状态"></a>四种ZAB运行状态</h4><p>这里是指ZAB集群的运行状态，因为ZAB除了正常向外部提供服务，还得有故障恢复功能。从整个集群的状态，我们可以了解ZAB的运行过程。</p><ul><li>ELECTION，选举状态，表明节点正在进行Leader选举</li><li>DISCOVERY，成员发现状态，在选举出新Leader后集群所处的状态，用于节点协商沟通Leader的合法性</li><li>SYNCHRONIZATION，数据同步状态，在确认新Leader后，以Leader的数据为基础，修复各个节点的数据一致性</li><li>BROADCARST，广播状态，集群处于正常运行状态，可向外提供服务</li></ul><h4 id="两种运行模式"><a href="#两种运行模式" class="headerlink" title="两种运行模式"></a>两种运行模式</h4><p>从上述ZAB运行状态中，可以归纳为两种运行模式，即消息广播模式、崩溃恢复模式。</p><ul><li>崩溃恢复模式：<br>在整个服务框架启动过程中、或者Leader服务器出现网络中断、崩溃退出等异常情况时，ZAB协议就会进入崩溃恢复模式并选举新的Leader服务器。当新的Leader服务器在集群中有过半的Follower与其完成成数据同步后，ZAB就会退出崩溃恢复模式。</li><li>消息广播模式：<br>当集群中已有过半的Follower与Leader完成数据同步，那么整个集群就会进入消息广播模式。此时整个集群才可以对外提供服务，即数据的查询、修改。</li></ul><p>值得注意是，当一台新的ZAB节点加入集群时，该节点会先进入崩溃恢复模式，找到Leader，并与其进行数据同步，然后一起参与到消息广播流程中。所以崩溃恢复模式还分为两个阶段：发现、同步。具体后文会详细讲解。</p><p>后文讲解思路也是从这两种模式入手，在崩溃恢复模式中，再细分为三个阶段，也就是四种运行状态的前三种（ELECTION、DISCOVERY、SYNCHRONIZATION）。</p><h4 id="zxid"><a href="#zxid" class="headerlink" title="zxid"></a>zxid</h4><p>这里把zxid单独拎出来描述，zxid在ZAB占据很重要的位置。Leader在收到事务请求，将其封装成Proposal时，会为每个Proposal生成对应的zxid。</p><p>在消息广播模式中zxid标志者事务请求的先后顺序，在崩溃恢复模式中zxid是Leader的选举的判断依据，以及在Leader选举后，数据同步中zxid能方便的帮助ZAB抛弃上一个Leader没完成的Proposal。所以在学习下面的内容时，要及时参考zxid的设计逻辑。</p><p>zxid它是一个64位，其中低32位可以看成一个简单的<strong>计数器</strong>，而高32位则代表了Leader周期的<strong>epoch编号</strong>。后文中使用&lt;epoch, counter&gt;标示一个zxid，例如&lt;1, 101&gt;。</p><ul><li>epoch，则标示者当前集群所处的周期（年代），或者说当前Leader的周期（年代）。在每一次Leader变更后，新Leader产生的epoch则会在上一任Leader的epoch上进行加1，作为自己的epoch。</li><li>计数器，则是针对客户端每一个事务请求，Leader在产生新的Proposal事务时，都会对该计数器加1。而Leader变更后，该计数器则会重置为0。</li></ul><p>这样做的好处：</p><ol><li>计数器，可以定义Proposal的先后顺序，保证发送提交事务消息广播顺序。</li><li>epoch+计数器，能有效的避免zxid的冲突，不会出现Leader使用了相同编号的zxid提出了不一样的Proposal。</li><li>能随时获取到最新的Leader周期（epoch），当Leader收到在网络故障后，收到比他大的epoch的Proposal，则证明集群中已有其他Leader，自己则变更为Follower。</li><li>新Leader产生的zxid一定比上一任Leader产生zxid大。当上一任Leader宕机恢复后（以Follower角色）加入集群，如果有尚未提交的事务，则可以对比zxid进行抛弃（回退）那一些Proposal，直到回退到一个确实已经被集群中过半机器Commit的最新Proposal。</li></ol><p>第3, 4点如果现在看不明白，在讲述崩溃恢复模式时，我会回过头来再讲讲的。</p><h3 id="消息广播模式"><a href="#消息广播模式" class="headerlink" title="消息广播模式"></a>消息广播模式</h3><p>总的来说，消息广播模式是一个类似于二阶段提交（2PC）过程，针对客户端事务请求，Leader将其生成对应的Proposal，并发给所有的Follower，收集各自的选票后，最后进行事务提交。<strong>与2PC不同的是，ZAB移除了第二阶段的中断逻辑</strong>。所有的Follower要么接收该Proposal，要么抛弃Leader服务器。这意味着Leader收到过半的Ack响应后就可以提交该事务了，而不需要等待所有的Follower都返回Ack。</p><p>由于ZAB为了严格保证Proposal的因果关系，即事务请求的顺序性，ZAB为每个Proposal生成对应的zxid，并严格按照zxid的顺序，进行消息的广播。具体的，Leader会为了Follower分配一个单独的队列，将消息广播前，先将Proposal按照zxid顺序依次放入这些队列中，并根据FIFO策略进行消息发送。</p><p>Follower在收到事务Proposal之后，都会将其以事务日志的形式写入本地磁盘中，并在写入成功后，返回给Leader一个Ack响应。当Leader服务器收到过半的Follower的Ack响应后，就会广播Commit消息给所有Follower通知其进行事务提交，同时Leader自身也会完成事务的提交。至此整个消息广播模式完成。</p><p><img src="/images/theory/distributed/zab_4.png" alt="消息广播"></p><ol><li>客户端发起事务请求，由Leader进行处理</li><li>Leader将该请求转换为事务Proposal，同时为Proposal分配一个全局的ID，即zxid</li><li>Leader为每个Follower维护一个FIFO队列，将上一步生成的Proposal放入队列中，进行广播</li><li>Follower收到Proposal后，会首先将其以事务日志的方式写入本地磁盘中，写入成功后向Leader反馈一个响应消息</li><li>Leader收到过半的Ack响应后，自己完成对该Proposal的提交后，向每个Follower的队列中，写入Commit消息进行广播</li><li>Follower接收到Commit消息后，会将上一条事务提交</li></ol><h4 id="如何保证事务执行的顺序"><a href="#如何保证事务执行的顺序" class="headerlink" title="如何保证事务执行的顺序"></a>如何保证事务执行的顺序</h4><p>此时，我们得回到zxid的构成那部分，ZAB就是通过zxid中计数器，来保证提交顺序的，具体如下：</p><p>在Leader收到客户端<code>set X、set Y</code>两个请求后，会将其封装成两个Proposal（&lt;1, 101&gt;: X， &lt;1, 102&gt;: Y）进行广播所有的Follower。<br><img src="/images/theory/distributed/zab_5.png" alt="消息广播"></p><p>当Leader收到过半的Ack响应后，则会进行Commit消息的广播。这里需要注意，<strong>Leader提交提案是有顺序性的</strong>，按照zxid的大小，按顺序提交提案，<strong>如果前一个提案未提交，此时是不会提交后一个提案的</strong>。因此X一定在Y之前提交。<br><img src="/images/theory/distributed/zab_6.png" alt="消息广播"></p><p>最后，Leader返回执行成功响应给客户端。完成本次消息广播。</p><h3 id="崩溃恢复模式"><a href="#崩溃恢复模式" class="headerlink" title="崩溃恢复模式"></a>崩溃恢复模式</h3><p>通过上面的了解，我们知道了ZAB其实是一个强领导者模型的协议。消息广播模式，只能在ZAB正常运行中向外部提供服务。这也要求ZAB设计者不得不考虑，当Leader宕机或者失去过半的Follower节点后，如何恢复整个集群。</p><p>为了更好理解崩溃恢复模式原理，通常会把他分为两个阶段或者三个阶段，即（Leader选举、Leader发现）、数据同步。</p><h4 id="基本约定"><a href="#基本约定" class="headerlink" title="基本约定"></a>基本约定</h4><p>在选举新的Leader后，向外部提供服务之前，ZAB还需要保证数据正确性，即上一个Leader崩溃之时，正在处理的事务请求，可能会出现两个数据不一致的隐患。针对这样情况，ZAB保证一下特性：</p><ol><li>ZAB需要确保那些已经在Leader上<strong>提交</strong>的事务最终被所有服务器都提交<br>即：ProposalA在Leader上被提出后，收到过半的Follower的Ack响应，但是在将Commit请求广播给所有Follower机器之前，Leader宕机了。<br><img src="/images/theory/distributed/zab_2.png" alt="ZAB崩溃恢复"><br>在该图中，Leader先后广播了P1, P2, C1, P3, C2。其中Leader在广播C2（P2的Commit请求）之前宕机，ZAB会在崩溃恢复模式中，让所有的服务器都提交C2。</li><li>ZAB需要确保丢弃那些仅仅只在Leader上被<strong>提出</strong>的事务<br>即：该约定是指，ZAB会抛弃那些只在Leader上被提出的事务，还没有任何Follower收到该请求。<br><img src="/images/theory/distributed/zab_3.png" alt="ZAB崩溃恢复"><br>在该场景中，Leader提出P3后宕机，还没有任何Follower收到该请求，则崩溃恢复模式中，整个集群会丢弃P3的事务。</li></ol><h4 id="Leader选举（ELECTION）"><a href="#Leader选举（ELECTION）" class="headerlink" title="Leader选举（ELECTION）"></a>Leader选举（ELECTION）</h4><p>Leader的选举，关乎着整个集群的故障容错和集群可用性，是ZAB非常核心的设计之一。而Leader选举说白了，就是对比集群中各节点的信息，选举出最合适的节点当做Leader。而最合适的节点标准是什么，则是理解Leader选举（FastLeaderElection方式）的关键。</p><p>ZAB采用的各节点广播自己所提议的Leader，收到其他节点提议的Leader后，与自己所提议的Leader进行PK，根据PK的规则重新选择提议的Leader，直到有过半的节点都提议某一节点，即结束Leader选举。</p><p>Leader选举PK的规则包含以下几个方面：</p><ul><li>任期编号（epoch），优先判断epoch，epoch大的节点当选Leader</li><li>事务标示符（zxid），epoch相同，则比较zxid，zxid大的当选Leader</li><li>节点ID，epoch、zxid都一致，则比较节点ID（在myid文件中指定的值）</li></ul><p>因为选举规则包含上述三个方面，则每个节点在广播自己所提议的Leader时，选票中都会包含上面三个值。后文使用&lt;proposeLeader, epoch, zxid, node&gt;，来表示一张选票，表明自己所有提议的Leader。</p><ul><li>proposeLeader，表示自己所提议的Leader的节点ID</li><li>epoch，表示所提议的Leader节点所处的任期编号</li><li>zxid，表示所提议的Leader节点拥有的Proposal最大的事务编号</li><li>node，表示本次提议的节点</li></ul><p>这里需要注意的是，这里的zxid是指ZAB在消息广播模式第一阶段的收到Proposal最大的zxid，即：<strong>节点收到被提出的Proposal最大的zxid，而不是已提交的Proposal最大的zxid</strong>。</p><p>这里需要单独拎出来强调，有的伙计，在看zookeeper源码时，会看到Leader选举时，使用的是dataTree.lastProcessedZxid。而dataTree.lastProcessedZxid表示的是已提交的Proposal最大的zxid。这里没错，在正常运行时dataTree.lastProcessedZxid确实表示的是已提交的Proposal最大的zxid。但是当跟随者检测到异常，退出FOLLOWING状态时，在follower.shutdown()中，会使用lastProcessedZxid表示节点上收到已提出的Proposal的zxid。而后续的Leader选举使用的lastProcessedZxid，即为节点收到被提出的Proposal最大的zxid。</p><h5 id="算法陈述"><a href="#算法陈述" class="headerlink" title="算法陈述"></a>算法陈述</h5><p>集群中存在三个节点A, B, C，各自节点ID依次为1, 2, 3。其中A为Leader，已提交两个Proposal（&lt;1, 101&gt;，&lt;1, 102&gt;），B、C为Follower，B已提交两个Proposal（&lt;1, 101&gt;，&lt;1, 102&gt;），C只提交了&lt;1, 101&gt;<br><img src="/images/theory/distributed/zab_7.png" alt="Leader选举"></p><p>当A节点宕机后，跟随者检测Leader异常，则退出FOLLOWING状态，变更为LOOKING，发起Leader选举。<br><img src="/images/theory/distributed/zab_8.png" alt="Leader选举"></p><p>当Follower开始第一轮提议Leader时，都会推荐自己为Leader，并向所有节点广播自己的提议，即B的选票为&lt;2, 1, 102, B&gt;，C的选票为&lt;3, 1, 101, C&gt;。各自将选票发给其他节点，B的选票发送给B、C，C的选票也发送给B、C。<br><img src="/images/theory/distributed/zab_9.png" alt="Leader选举"></p><p>B, C收到对方的选票后，根据上面描述的规则进行PK，依次比较epoch、zxid、节点ID。B、C首先会收到来自自己的提议的选票，因为收到选票与自己提议的选票相同，只需要接受和保存该选票。</p><ul><li>当B收到来自C的选票&lt;3, 1, 101, C&gt;，由于epoch相同，B的zxid大于C的zxid，则B的选票获胜，不需要变更选票信息，保存即可。</li><li>C收到来自B的选票&lt;2, 1, 102, B&gt;，由于epoch相同，C的zxid小于B的zxid，则C的选票落选。需要保存B的选票&lt;2, 1, 102, B&gt;，并变更自己的选票为&lt;2, 1, 102, C&gt;</li></ul><p><img src="/images/theory/distributed/zab_10.png" alt="Leader选举"></p><p>C节点在变更自己的选票信息后，会重新广播选票&lt;2, 1, 102, C&gt;给其他节点。B, C节点都收到来自C的新选票信息&lt;2, 1, 102, C&gt;，根据规则继续PK，结果肯定是B, C都保存两个选票（&lt;2, 1, 102, B&gt;, &lt;2, 1, 102, C&gt;）<br><img src="/images/theory/distributed/zab_11.png" alt="Leader选举"></p><p>最后，B, C所提议的领导者节点ID为2（即B节点），赢得了过半选票。则B竞选为准Leader，退出LOOKING状态，变更为LEADING，C节点变更状态为FOLLOWING，完成Leader选举。<br><img src="/images/theory/distributed/zab_12.png" alt="Leader选举"></p><h5 id="逻辑时钟"><a href="#逻辑时钟" class="headerlink" title="逻辑时钟"></a>逻辑时钟</h5><p>这里需要补充的是逻辑时钟，逻辑时钟也会影响Leader的选举，单独拎出来是为了描述选举算法时思路更清晰。</p><p>逻辑时钟（logicclock），即选举的轮次，避免接收到旧的选票信息。每进行一轮选举，逻辑时钟变会增加。在选举中，逻辑时钟大的节点不会接收来自逻辑时钟小的节点的选票。</p><p>比如，节点A, B的逻辑时钟分别为1, 2，那么B将拒绝接收来自A的选票信息。即使A的zxid大于B的zxid，B也会拒绝接收该选票。</p><h4 id="发现（DISCOVERY）"><a href="#发现（DISCOVERY）" class="headerlink" title="发现（DISCOVERY）"></a>发现（DISCOVERY）</h4><p>该阶段用于确立Leader的领导关系，继上一阶段，也就是ELECTION完成后，每个节点都有自己所保存的选票池，当选池中有过半的选票都提议同一节点为Leader时，则进入发现（DISCOVERY）状态。</p><p>本节思路：会先按每一小步介绍过程，后面会画出整个过程的周期，所以每一小步会记作一个标记，方便后面描述整个过程。</p><p>继续上一小节的案例。A, B, C三个节点，A宕机了，B为新选举的准Leader。其中B已提交两个Proposal（&lt;1, 101&gt;，&lt;1, 102&gt;），C只提交了&lt;1, 101&gt;。</p><p>在该状态期间，由Follower会主动联系准Leader，并将自己最后接受的事务Proposal的epoch值发送给准Leader，这里记作FOLLOWERINFO。<br><img src="/images/theory/distributed/zab_13.png" alt="发现（DISCOVERY）"></p><p>准Leader收到来自过半（包含B节点自己）的FOLLOWERINFO消息后，会从这个FOLLOWERINFO中选取最大的epoch值，对其进行加1，作为新的epoch值，并封装成LEADERINFO消息发给这些过半的Follower。<br><img src="/images/theory/distributed/zab_14.png" alt="发现（DISCOVERY）"></p><p>当Follower收到LEADERINFO消息后，会先校验LEADERINFO消息正确性。校验自己的epoch是否小于LEADERINFO消息中的epoch，如果小于，就将LEADERINFO消息中的epoch赋值给自己的epoch，并将自己的运行状态变更为SYNCHRONIZATION，最后向准Leader返回Ack响应（ACKEPOCH）。<br><img src="/images/theory/distributed/zab_15.png" alt="发现（DISCOVERY）"></p><p>最后准Leader收到过半的ACKEPOCH消息后，也将自己的运行状态修改为SYNCHRONIZATION。至此完成发现阶段的工作，集群确立Leader的领导关系。</p><h4 id="数据同步（SYNCHRONIZATION）"><a href="#数据同步（SYNCHRONIZATION）" class="headerlink" title="数据同步（SYNCHRONIZATION）"></a>数据同步（SYNCHRONIZATION）</h4><p>进入到数据同步阶段，我们需要先了解三种同步方式（DIFF、TRUNC、SNAP）。Leader会根据每个Follower的最大zxid，采用不同方式处理不一致的数据。</p><p>在ZAB的设计中，Leader为了更高效的将Proposal复制给Follower，会在自己的内存队列中缓存一定数量（默认500）的已提交的Proposal。在内存中的Proposal就有zxid的最大值和最小值，即：maxCommittedZxid和minCommittedZxid。</p><ul><li>DIFF：当Follower最大的zxid小于maxCommittedZxid且大于minCommittedZxid</li><li>TRUNC：当Follower最大的zxid大于maxCommittedZxid时，该方式要求Follower丢弃超出的那部分Proposal</li><li>SNAP：当Follower最大的zxid小于minCommittedZxid时，该方式直接同步快照给Follower</li></ul><p>了解了同步方式，接下来来看看具体怎么交互的吧。该阶段由Leader根据Follower的最大zxid来选择同步方式和需要发送的数据。由于B已提交两个Proposal（&lt;1, 101&gt;，&lt;1, 102&gt;），C只提交了&lt;1, 101&gt;。该情况下Leader会选择DIFF的方式，并且和需要同步的数据，一起封装为NEWLEADER消息发给Follower。</p><p>Follower在收到NEWLEADER消息后，进行修复不一致数据，并返回给Leader响应Ack消息。<br><img src="/images/theory/distributed/zab_16.png" alt="数据同步（SYNCHRONIZATION）"></p><p>Leader在收到过半Ack消息后，则完成数据同步阶段，将自己运行状态修改为BROADCARST（广播状态），并发送UPTODATE消息给过半的Follower，通知他们完成数据同步，修改运行状态修改为BROADCARST。</p><h4 id="整体回顾"><a href="#整体回顾" class="headerlink" title="整体回顾"></a>整体回顾</h4><p><img src="/images/theory/distributed/zab_17.png" alt="整体回顾"></p><h3 id="与paxos区别"><a href="#与paxos区别" class="headerlink" title="与paxos区别"></a>与paxos区别</h3><ol><li>ZAB采用的是主备模式的系统架构，相比于paxos不同的是，paxos可以同时存在多个提议者进行提案，而ZAB同一时间只允许一个领导者进行提案，这样即解决客户端并发处理，又能规定提案的顺序性。</li></ol><h3 id="思考几个题目吧"><a href="#思考几个题目吧" class="headerlink" title="思考几个题目吧"></a>思考几个题目吧</h3><ol><li><p>zookeeper提供的最终一致性，任何节点都能处理读请求，但是读到的可能会是旧数据，如果必须要读到最新数据，怎么办？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zookeeper提供解决方案就是：<span class="keyword">sync</span>命令。</span><br><span class="line">你可以在读操作之前，先执行<span class="keyword">sync</span>命令，这样客户端就能读到最新数据了。</span><br></pre></td></tr></table></figure></li><li><p>A, B, C三个节点，A为Leader，B有2个已提交的Proposal(&lt;1, 101&gt;, &lt;1, 102&gt;)，C有3个未提交Proposal(&lt;1, 101&gt;, &lt;1, 102&gt;, &lt;1, 103&gt;)。当A故障后，B和C谁会当选Leader呢？</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案是C。</span><br><span class="line">因为竞选Leader时，使用的是所有已提出的Proposal最大zxid。</span><br><span class="line">C最大的zxid为<span class="number">103</span>，而B最大的zxid为<span class="number">102</span>。</span><br><span class="line">那么C当选Leader。</span><br></pre></td></tr></table></figure></li><li><p>在选举中，会出现选票被瓜分、选举失败的问题吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不会出现选票被瓜分导致选举失败的情况。</span><br><span class="line">因为每个节点的节点ID都是不同的，而节点ID会参与选票的判断。</span><br><span class="line">在epoch、zxid都一致情况下，还有节点ID可以兜底来保证选票给哪一个节点。</span><br></pre></td></tr></table></figure></li><li><p>有一个Proposal，在广播之前Leader宕机，经过崩溃恢复模式后，该Proposal是否会被提交？</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不一定，取决新当选的<span class="built_in">Leader</span>是否包含该Proposal</span><br><span class="line">如果上一任<span class="built_in">Leader</span>，在广播第一阶段有个Follower收到了。而新当选的<span class="built_in">Leader</span>又是该Follower</span><br><span class="line">则该Proposal会被提交。</span><br></pre></td></tr></table></figure></li><li><p>在崩溃恢复后，Leader首先将自己的状态设置为广播，然后再通知其他节点修改。那么这是有写请求进来，会执行成功吗？</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">会，这就是ZAB设计消息发送队列的原因，在<span class="built_in">Leader</span>为广播状态时即可对外服务。</span><br><span class="line">因为新封装的Proposal请求，一定会在通知其他节点数据同步完成的消息（UPTODATE）之后处理</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> ZAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - Paxos</title>
      <link href="/2020/07/07/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Paxos/"/>
      <url>/2020/07/07/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Paxos/</url>
      
        <content type="html"><![CDATA[<h3 id="paxos-科普"><a href="#paxos-科普" class="headerlink" title="paxos 科普"></a>paxos 科普</h3><p>分布式算法，不得不提paxos。它是目前公认的解决分布式共识问题最有效的算法之一，甚至可以说过去几十年里一切分布式一致性算法都来源于它。<br>那么要学习paxos，我们首先得认识它。一般描述它，都会包含两个词：<strong>分布式容错、分布式共识算法</strong>。那么它们是指什么呢？paxos又解决了什么样的问题呢？</p><ol><li>分布式容错<br>分布式容错，是指在分布式环境下，能够容忍一部分节点宕机，还能向外提供稳定的服务。</li><li>分布式共识算法<br>分布式共识算法，是指在分布式环境下，各个节点能就某个值达成共识，即所有节点都认同某个值。</li></ol><p>理解共识可能要难一点，那么我举个例子。假如有A、B两个客户端，他们都对同一个X进行赋值。A需要设置X=1，B需要设置X=2。那么让A和B都认同值X=1或者X=2的过程，就是达成共识。</p><p>带着这个问题，来聊聊如何达成共识呢?</p><h3 id="初探paxos"><a href="#初探paxos" class="headerlink" title="初探paxos"></a>初探paxos</h3><p>paxos为了帮我们理解，抽象出三个角色和两个阶段</p><ul><li>角色：提案者（proposer）、接受者（acceptor）、学习者（learner）</li><li>阶段：<strong>prepare阶段、accept阶段</strong>、learn阶段</li></ul><h4 id="提案（proposal）"><a href="#提案（proposal）" class="headerlink" title="提案（proposal）"></a>提案（proposal）</h4><p>在描述这些角色之前，我们需要先了解什么提案。在paxos算法中提案是指需要达成共识的某一个值，或者某一个操作。paxos对其封装成一个提案，并为其生成唯一的提案编号。本文中使用[M, V]表示一个提案，其M表示提案编号，V表示需要达成共识的值。</p><h4 id="提案者（proposer）"><a href="#提案者（proposer）" class="headerlink" title="提案者（proposer）"></a>提案者（proposer）</h4><p>proposer的工作在于接收客户端请求，将其封装成提案（proposal）。并将提案（proposal）发给所有的接受者（acceptor）。根据接受者（acceptor）返回情况，控制是否需要提交该提案（proposal）即保存该提案（proposal）。</p><h4 id="接受者（acceptor）"><a href="#接受者（acceptor）" class="headerlink" title="接受者（acceptor）"></a>接受者（acceptor）</h4><p>acceptor的工作在于参与对提案（proposal）的投票，接收和处理paxos的两个阶段的请求。</p><h4 id="学习者（learner）"><a href="#学习者（learner）" class="headerlink" title="学习者（learner）"></a>学习者（learner）</h4><p>learner不参与提案和投票，只被动接收提案结果。他的存在可用于扩展读性能，或者跨区域之间读操作。</p><p>因为他们不投票，所以他们不是paxos集群的重要组成部分。因此，它们可以失败，或者与集群断开连接，而不会损害paxos服务的可用性。对用户的好处是learner相比acceptor来说更能通过不太可靠的网络链接进行连接。实际上，learner可用于与另一个数据中心的paxos服务器通信，并且写入消耗最小的网络流量，因为在没有投票协议的情况下所需的消息数量较少。</p><h4 id="prepare阶段"><a href="#prepare阶段" class="headerlink" title="prepare阶段"></a>prepare阶段</h4><p>prepare阶段，由proposer向acceptor发送prepare请求，acceptor根据约定决定是否需要响应该请求。如果acceptor通过提案[M, ]的prepare请求，则向proposer保证以下承诺</p><ol><li>acceptor承诺不再通过编号<strong>小于等于</strong>M的提案的prepare请求</li><li>acceptor承诺不再通过编号<strong>小于</strong>M的提案的accept请求，也就是不再通过编号小于M的提案</li><li>如果acceptor已经通过某一提案，则承诺在prepare请求的响应中返回<strong>已经通过的最大编号的提案内容</strong>。如果没有通过任何提案，则在prepare请求的响应中返回空值</li></ol><p>其中prepare阶段还得注意，在prepare请求中，proposer只会发提案编号，也就是[M, ]。</p><h4 id="accept阶段"><a href="#accept阶段" class="headerlink" title="accept阶段"></a>accept阶段</h4><p>accept阶段，在proposer在prepare阶段收到大多数响应后，由proposer向acceptor发送accept请求。例如此时进行决策的提案是[M, V]，根据acceptor在prepare阶段对proposer的承诺。</p><ul><li>如果此时acceptor没有通过编号大于M的prepare请求，则会批准提案[M, V]，并返回已通过的编号最大的提案（也就是[M, ]）。</li><li>如果此时acceptor已经通过编号大于M的prepare请求，则会拒绝提案[M, V]，并返回已通过的编号最大的提案（大于M的编号）。</li></ul><p>proposer会统计收到的accept请求的响应，<strong>如果响应中的编号等于自己发出的编号，则认为该acceptor批准过了该提案</strong>。如果存在大多数acceptor批准了该提案，则记作该提案已达成共识，或者记作提案已被批准。如果没有大多数acceptor批准该提案，则重新回到prepare阶段进行协商。</p><p>其中accept阶段也有注意的地方，在prepare请求中，proposer只会发提案[M, ]。而accept请求，proposer会发送提案编号和提案值，也就是[M, V]。<strong>这里要注意的是V的值，如果在prepare请求的响应中，部分acceptor已经批准过的提案值，则V为prepare请求的响应中编号最大的提案值，否则可以由proposer任意指定。</strong></p><h4 id="learn阶段"><a href="#learn阶段" class="headerlink" title="learn阶段"></a>learn阶段</h4><p>learn阶段，在某一个提案通过paxos达成共识之后，由acceptor通知learner学习提案结果。</p><h3 id="算法陈述"><a href="#算法陈述" class="headerlink" title="算法陈述"></a>算法陈述</h3><p>该小节分为两部描述：提案选定、提案获取。</p><ul><li>提案选定，是描述paxos从一个提案的产生到如何达成共识的过程。也就是prepare阶段、accept阶段</li><li>提案获取，是描述learner如何获取保存提案，也就是learn阶段</li></ul><h4 id="提案选定"><a href="#提案选定" class="headerlink" title="提案选定"></a>提案选定</h4><p>先来看一张非常流行的图，它用伪代码描述了paxos的过程。我预先描述下几个变量。</p><ul><li>minProposal：当前acceptor在prepare请求中通过的最大提案编号</li><li>acceptedProposal：当前acceptor在accept请求中通过的最大提案编号</li><li>acceptedValue：当前acceptor在accept请求中通过的最大提案编号的提案值</li></ul><p><img src="/images/theory/distributed/paxos_1.jpg" alt="paxos伪代码描述"></p><ol><li>先为proposal生成一个编号n，这里需要保证编号全局唯一，并且全局递增，具体实现全局编号，这里不予讨论。</li><li>proposer向所有acceptors广播prepare(n)请求</li><li>acceptor比较n和minProposal，如果n&gt;minProposal则执行minProposal=n，并且将 acceptedProposal 和 acceptedValue 返回给proposer。</li><li>proposer接收到过半数回复后，如果发现有acceptedValue返回，将所有回复中acceptedProposal最大的acceptedValue作为本次提案的value，否则可以任意决定本次提案的value。</li><li>到这里可以进入第二阶段，广播accept (n,value) 到所有节点。</li><li>acceptor比较n和minProposal，如果n&gt;=minProposal，则acceptedProposal=minProposal=n，acceptedValue=value，本地持久化后，返回；否则，返回minProposal。</li><li>proposer接收到过半数请求后，如果发现有返回值result（minProposal） &gt; n，表示有更新的提议，跳转到1；否则value达成一致。</li></ol><p>当然，实际运行过程中，没有以上陈述的那么理想。真实情况下，每一个proposer都有可能产生多个提案，但只要每个proposal遵循如上算法运行，就一定能保证执行正确性。文章后续我们会对多提案提出的情况进行模拟，并详细讲解。</p><h4 id="提案获取"><a href="#提案获取" class="headerlink" title="提案获取"></a>提案获取</h4><p>在一个提案达成共识后，如何让learner获取该提案也是一个值得细究的问题。一般有以下几种方案。</p><ul><li>方案一<br>最简单的方法就是一旦acceptor批准了一个提案，就将该提案发给所有的learner。这种做法虽然可以让learner尽快的获得被选中的提案，但是却需要每个acceptor与所有learner逐一进行通信，通信次数为二者乘积，所以效率较低。</li><li>方案二<br>选定一个主learner，如有某一个提案批准后，由acceptor通知主learner，当主learner被通知后，由它通知其他的learner。这个方案虽然多了一个步骤，但是通信次数大大降低，通信次数为learner的数量。该方案同时引出另一个问题：主learner随时可能出现故障。</li><li>方案三<br>在基于方案二的基础上，由单个主learner扩展成一个主learner集合。集合中learner数量越高，可靠性也越好。</li></ul><h3 id="算法模拟"><a href="#算法模拟" class="headerlink" title="算法模拟"></a>算法模拟</h3><p>为了更好的熟悉paxos，我们举例描述paxos中提案选定过程。假设存在3节点的paxos集群，这里需要注意每一个节点可以同时扮演proposer和acceptor。情况如下</p><p>proposerA收到请求将X设置成3，proposerB收到请求将X设置成5。proposerA和proposerB分别为此生成提案，其proposerA的提案编号为1，proposerB提案编号为2。在prepare阶段它们交互结果如下</p><p><img src="/images/theory/distributed/paxos_2.png" alt="paxos prepare请求"></p><ol><li>proposerA和proposerB分别进入prepare阶段，将提案编号发给各个acceptor。</li><li>acceptorA和acceptorB在收到proposerA的prepare请求后，由于没有通过过任何prepare请求，也没有批准过任何的accept请求。则给proposerA返回尚无提案。</li><li>acceptorC由于在收到proposerB的prepare请求之后再收到proposerA的prepare请求，且proposerB的提案编号大于proposerA的提案编号，故不给proposerA返回prepare响应。</li><li>acceptorA和acceptorB在收到proposerB的prepare请求后，由于之前收到proposerA的prepare请求，则比较各自的提案编号，由于proposerB的提案编号大于proposerA的提案编号，但是又没有通过任何的accept请求，则给proposerB返回尚无提案，并向proposerB保证前文所说的三个承诺。</li></ol><p>至此，proposerA获得2个prepare响应，proposerB获得三个prepare<br>响应。即他们都获得了大多数节点的prepare响应，于是各自开始accept阶段提交。</p><p><img src="/images/theory/distributed/paxos_3.png" alt="paxos accept请求"></p><ol><li>proposerA由于收到的prepare响应中没有任何提案值，则自己任意设置提案值，也就是[1, 3]。并向各个acceptor发起accept请求。</li><li>acceptorA、acceptorB、acceptorC收到proposerA的accept请求后，由于在prepare阶段，他们都向proposerB保证了上文所说的三个承诺，则他们不会该accept请求，并将prepare阶段通过最大的提案编号返回给proposerA，也就是[2, ]。</li><li>proposerA收到[2, ]后，发现响应中的提案编号2比自己的提案编号1大，则认为没有accept通过该提案。proposerA需要重新回到prepare阶段进行协商。</li><li>proposerB由于收到的prepare响应中没有任何提案值，则自己任意设置提案值，也就是[2, 5]。并向各个acceptor发起accept请求。</li><li>acceptorA、acceptorB、acceptorC，在此期间没有通过任何的prepare请求也没有通过任何的accept请求，即同意批准该提案，返回[2, ]给proposerB。</li><li>proposerB收到accept响应后，比对提案编号发现有大多数的提案编号是自己的编号，则认为该提案达成共识，完成协商过程。</li></ol><p>以上过程的主要描述了accept对proposer的两个承诺，即如果acceptor通过提案[M, ]的准备请求</p><ul><li>acceptor承诺不再通过编号<strong>小于等于</strong>M的提案的prepare请求</li><li>acceptor承诺不再通过编号<strong>小于</strong>M的提案的accept请求，也就是不再通过编号小于M的提案</li></ul><p>那么还有一个承诺是</p><ul><li>如果acceptor已经通过某一提案，则承诺在prepare请求的响应中返回<strong>已经通过的最大编号的提案内容</strong>。如果没有通过任何提案，则在prepare请求的响应中返回空值</li></ul><p>为了描述该承诺，我们想象出这样一个场景。proposeB完成prepare请求后，发起accept请求，且提案为[3, 6]。在此过程中，proposeA发起prepare请求，提案编号为[4, ]，并且acceptor先收到proposeA发起prepare请求，也就是说acceptor会拒绝proposeB的accept请求。情况如下</p><p><img src="/images/theory/distributed/paxos_4.png" alt="paxos 两个提案提出"></p><ol><li>proposerB发起accept请求，提案为[3, 6]。</li><li>acceptorA收到proposerB的accept请求后，批准了该请求。</li><li>proposerA发起prepare请求，提案为[4, ]。</li><li>acceptorB、acceptorC先收到proposerA的prepare请求。则拒绝proposerB的accept请求。</li><li>acceptorA收到proposerA的prepare请求，由于之前接收了proposerB发起accept请求，则给proposeA返回已批准的提案[3, 6]。</li><li>此时，proposerB重新进入prepare协商，proposerA收到大多数prepare响应，发起accept请求，由于收到acceptorA返回的提案[3, 6]，那么proposer的提案值也只能为6，即[4, 6]。</li><li>accept完成协商。</li></ol><h3 id="multi-paxos算法"><a href="#multi-paxos算法" class="headerlink" title="multi-paxos算法"></a>multi-paxos算法</h3><p>原始的paxos算法（Basic Paxos），只能完成一个值的共识。Lamport宗师提到可以通过执行多次basic-paxos实现一系列值的共识。但是由于多次协商会增加通信以及影响协商的活性（指协商进入死循环）。</p><p>宗师则提出multi-paxos的解决方案，但是由于宗师并没有把multi-paxos讲清楚，只是介绍了大概的思想，缺少算法过程必要细节。所以这给了我们很大的想象空间，因此每个人实现的multi-paxos都有所差异。</p><p>总体来说multi-Paxos基于basic-paxos做了两点改进：</p><ol><li>在所有Proposers中选举一个Leader，由Leader唯一地提交Proposal给Acceptors进行表决。这样没有Proposer竞争，解决了活锁问题。在系统中仅有一个Leader进行Value提交的情况下，Prepare阶段就可以跳过，从而将两阶段变为一阶段，提高效率。</li><li>针对每一个要确定的值，运行一次Paxos算法实例（Instance），形成决议。每一个Paxos实例使用唯一的Instance ID标识。</li></ol><p>首先multi-Paxos是要选举一个leader的，宗师提到：可以通过basic-paxos进行leader的选举。</p><ul><li>选举leader后，只能由leader提出proposal。</li><li>在leader宕机后，服务将临时不可用，等待leader重新选举。</li><li>在系统中仅有一个leader进行proposal提交的情况下，prepare阶段可以跳过。</li></ul><p>multi-paxos通过改变prepare阶段的作用范围至后面leader提交的所有实例，从而使得leader的连续提交只需要执行一次prepare阶段，后续只需要执行accept阶段，将两阶段变为一阶段，提高了效率。为了区分连续提交的多个实例，每个实例使用一个instance ID标识，instance ID由leader本地递增生成即可。</p><p>multi-paxos允许有多个自认为是leader的节点并发提交proposal而不影响其安全性，这样的场景即退化为basic-paxos。</p><h3 id="paxos回顾，思考几个题目吧"><a href="#paxos回顾，思考几个题目吧" class="headerlink" title="paxos回顾，思考几个题目吧"></a>paxos回顾，思考几个题目吧</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">怎么解决两个提案提出后陷入死循环？</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">三个节点的集群A、B、C。</span><br><span class="line">A和B通过提案[4, 6]，C没有通过任何提案。</span><br><span class="line">此时C收到客户端请求，将值设置为5，C生成的编号为5，通过basic-paxos后。</span><br><span class="line"></span><br><span class="line">最后集群中通过的提案应该是多少呢？</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">假如有三个提案者A, B, C，五个接受者SERV1, SERV2, SERV3, SERV4, SERV5</span><br><span class="line">A提案编号为1，值为3</span><br><span class="line">B提案编号为2，值为5</span><br><span class="line">C提案编号为3，值为8</span><br><span class="line"></span><br><span class="line">①A第一阶段发给SERV1, SERV2, SERV3获得回应，赢得半数选票</span><br><span class="line">②B开始第一阶段，获得SERV3, SERV4, SERV5的选票</span><br><span class="line">③A开始第二阶段，发给SERV1值为3的提案后，SERV1允许提交该值，此时A宕机</span><br><span class="line">④B开始第二阶段，发给SERV5值为5的提案后，SERV5允许提交该值，此时B宕机</span><br><span class="line">⑤C开始第一阶段，获得SERV1, SERV2, SERV5的选票，根据规定，它将收到SERV1接受的值为3，SERV5接受的值为5。</span><br><span class="line">那C的第二阶段提案应该是[3, 3]还是[3, 5]呢？</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line">multi-paxos提出leader的角色，提案只能由leader提出，那么当写性能达到leader的瓶颈，怎么解决呢？</span><br><span class="line"></span><br><span class="line">答：应该裂变分区，拆成多个不相干的分区，由多个paxos-group来完成之前一个leader的工作</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/31780743。文中提到paxos推导过程，也可以了解下。" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31780743。文中提到paxos推导过程，也可以了解下。</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> paxos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - 2PC, 3PC</title>
      <link href="/2020/07/05/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%202PC,%203PC/"/>
      <url>/2020/07/05/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%202PC,%203PC/</url>
      
        <content type="html"><![CDATA[<p>在分布式系统中，每一个机器节点虽然都能明确的知道自己在事务操作中的结果是成功或失败，但无法直接获取其他节点的操作结果。因此在分布式环境中，为了保持事务的ACID特性，就需要增加一个“协调者”来管理其他节点（“参与者”）事务的提交和回滚。基于这个思想，衍生出二阶段提交和三阶段提交两种协议。</p><h3 id="2PC-简述"><a href="#2PC-简述" class="headerlink" title="2PC 简述"></a>2PC 简述</h3><p>二阶段提交(Two-Phase Commit)，是一个非常经典的<strong>强一致</strong>、<strong>中心化的原子提交协议</strong>。目前，绝大多数关系型数据库都采用二阶段提交协议来完成分布式事务处理（例如mysql的XA协议）。因此二阶段提交协议也被广泛运用到分布式系统中。</p><p>顾名思义，算法流程就是分为两个阶段提交某一操作，其分为准备阶段、提交阶段。为了更好描述算法过程，为此定义了两种角色：协调者（Coordinator）、参与者（Participant）。</p><h4 id="阶段一：准备阶段"><a href="#阶段一：准备阶段" class="headerlink" title="阶段一：准备阶段"></a>阶段一：准备阶段</h4><p><img src="/images/theory/distributed/2pc_1.png" alt="2pc 准备阶段"><br>准备阶段，又被称为投票阶段（Vote Request），由协调者向参与者发送请求，询问当前事务能否处理成功。参与者则开启本地数据库事务，开始执行数据库操作，但是并不会提交。根据操作结果，返回给协调者“yes/no”，表示事务是否可以提交。</p><ul><li>事务询问<br>协调者向所有参与者发送<strong>事务内容</strong>，询问是否可以执行事务的提交操作，并等待各参与者的响应</li><li>执行事务<br>各参与者执行事务操作，准备好事务资源，记录undo、redo信息</li><li>反馈询问结果<br>如果参与者成功执行了事务操作，那么返回给协调者yes（表示当前事务可以提交），否者返回给协调者no（表示当前事务不能执行）</li></ul><h4 id="阶段二：提交阶段"><a href="#阶段二：提交阶段" class="headerlink" title="阶段二：提交阶段"></a>阶段二：提交阶段</h4><p>在准备阶段，由于参与者可以返回yes/no，则在提交阶段也会出现两种可能，即全局提交事务、全局回滚事务。</p><h5 id="全局提交事务"><a href="#全局提交事务" class="headerlink" title="全局提交事务"></a>全局提交事务</h5><p><img src="/images/theory/distributed/2pc_2.png" alt="2pc 提交阶段"><br>当准备阶段所有参与者都返回yes的响应后，协调者将发起全局提交事务请求。</p><ul><li>发送提交请求<br>由协调者向所有参与者发送global_commit请求，要求提交当前事务</li><li>事务提交<br>当参与者收到global_commit请求后，则执行事务提交操作，并释放整个分布式事务期间占用的事务资源</li><li>反馈提交结果<br>参与在执行完事务提交后，向协调者返回ack消息</li><li>完成事务提交<br>协调者收到所有参与者反馈的ack消息后，给客户端返回结果，完成本次事务</li></ul><h5 id="全局回滚事务"><a href="#全局回滚事务" class="headerlink" title="全局回滚事务"></a>全局回滚事务</h5><p><img src="/images/theory/distributed/2pc_3.png" alt="2pc 提交阶段"><br>当准备阶段有一个参与者都返回no的响应后，实际场景中，协调者还会怎加等待响应时间，如果超时后，则协调者将发起全局回滚事务请求，中断事务。</p><ul><li>发送回滚请求<br>由协调者向所有参与者发送global_rollback请求，要求中断当前事务</li><li>事务回滚<br>当参与者收到global_rollback请求后，会利用准备阶段记录的undo信息来进行回滚，并释放整个分布式事务期间占用的事务资源</li><li>反馈回滚结果<br>参与在执行完事务提交后，向协调者返回ack消息</li><li>中断事务<br>协调者收到所有参与者反馈的ack消息后，给客户端返回结果，完成中断事务</li></ul><h4 id="宕机（故障）恢复"><a href="#宕机（故障）恢复" class="headerlink" title="宕机（故障）恢复"></a>宕机（故障）恢复</h4><p>2PC宕机故障，分为多种情况。部分参与者宕机、协调者宕机、部分参与者和协调者都宕机。</p><ul><li>部分参与者宕机<br>参与者恢复后询问协调者宕机期间处理情况便可完成一致性</li><li>协调者宕机<br>新选一个协调者替换，询问所有参与者最后那条事务执行情况，然后决定进行commit/rollback，或者不处理。</li><li>部分参与者和协调者都宕机<br>新竞选的协调者询问所有参与者最后那条事务执行情况。则又分为几种情况：<ul><li>如果有参与者第一阶段返回no，或者第二阶段执行了rollback。则协调者命令所有参与者执行rollback</li><li>如果所有参与者第一阶段返回yes，第二阶段有参与者执行了commit，则协调者命令所有参与者执行commit</li><li>如果所有参与者第一阶段返回yes，第二阶段没有参与者执行任何操作，此时协调者则不知道宕机的参与者执行了commit/rollback。即不能明确的恢复过来。</li></ul></li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>2PC协议明显的优点就是：原理简单、容易实现。但是它的缺点更加明显：</p><ul><li>同步阻塞<br>每个参与者都需要等待协调者的消息，才能继续下一阶段。当协调者在发送第二阶段的消息之前宕机，那么所有参与者将一直锁定准备阶段的事务资源，事务推进不下去了，造成事务阻塞。只有等到协调者恢复，事务才能继续进行。</li><li>数据不一致<br>在第二阶段，如果出现网络异常导致一部分参与者收到了commit请求，一部分参与者没有收到commit请求，结果会是一部分参与者提交了事务，一部分参与者无法进行事务提交。</li><li>宕机恢复，上一小节描述的部分情况下不能保证一致性</li><li>单点问题/脑裂<br>协调者在2PC中，太过重要，当协调者宕机，整个集群将不可用。脑裂是指因为网络原因，出现多个协调者。</li><li>太过保守<br>任何一个节点故障，都会导致整个事务协调失败，换句话说没有完善的容错机制。</li></ul><h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>上面小节讲解了二阶段提交协议的原理，也指出了它所存在的问题，三阶段提交协议则是为了解决2PC的同步阻塞、数据不一致的问题而诞生。</p><p>在2PC的基础上，3PC将准备阶段一分为二，形成由 <strong>CanCommit、PreCommit、DoCommit</strong>三个阶段组成的事务提交协议。并且在3PC<strong>参与者也增加超时机制</strong>（2PC只有协调者拥有超时机制），避免了参与者长时间无法与协调者节点通讯（协调者宕机）的情况下，无法释放资源的问题。在参与者超时后，会自动进行本地commit/abort从而进行释放资源。</p><p>但是3PC并没有完美解决2PC的问题，例如：</p><ul><li>同步阻塞，3PC只是减少了阻塞范围，这里的阻塞包含两方面：<ul><li>参与者在长时间无法与协调者通讯，无法释放资源阻塞的问题。参与者等待协调者消息超时后，自行commit/abort来释放资源。</li><li>协调者和参与者都宕机情况下的阻塞。新晋升的协调者不知道宕机的参与者执行了什么操作，依然不能释放事务资源，而造成的阻塞问题。</li></ul></li><li>数据不一致，也只解决了一部分情况下的不一致。<br>比如第三阶段，部分参与者没有收到DoCommit消息，根据规定会自行提交，最后达成一致。但是如果第三阶段需要abort，部分参与者没有收到abort消息，根据规定也会自行提交，最后数据不一致。</li><li>宕机恢复，解决了2PC中协调者和参与者在第二阶段宕机不能恢复一致性的问题</li></ul><p>可以看出3PC提出的解决方案，自身本就引入了新的问题，比如自动提交后造成的数据不一致。还有增加了一轮通讯，增加了复杂度和协商效率。所以实际上，很少会有系统实现3PC，多数情况下，通过状态机复制来解决2PC的同步阻塞的问题。</p><h4 id="阶段一：CanCommit"><a href="#阶段一：CanCommit" class="headerlink" title="阶段一：CanCommit"></a>阶段一：CanCommit</h4><p><img src="/images/theory/distributed/3pc_1.png" alt="3pc CanCommit"></p><ul><li>事务询问<br>由协调者向所有参与者发送一个<strong>包含事务内容</strong>的canCommit请求，询问是否可以执行事务提交操作，并等待参与者响应</li><li>反馈询问响应<br>参与者收到canCommit请求后，根据自身逻辑判断是否可以顺利执行事务，那么反馈yes，否则反馈no。说白了就是检查下自身状态的健康性，看有没有能力进行事务操作。</li></ul><h4 id="阶段二：PreCommit"><a href="#阶段二：PreCommit" class="headerlink" title="阶段二：PreCommit"></a>阶段二：PreCommit</h4><p>在阶段一结果中，如果所有参与者都返回yes，则执行事务预提交，协调者发起PreCommit请求。如果有任何一个参与者节点返回的结果是no，或者协调者在等待参与者节点反馈的过程中超时，整个分布式事务就会中断，协调者就会向所有的参与者发送“abort”请求。</p><p><strong>注意：</strong>上面所说的参与者增加超时时间，在该阶段就可以派上用场了。在该阶段开始之前，如果协调者宕机，参与者在等待超时时间后，各自选择中断事务，最终达成一致。但是协调者在发出一部分preCommit请求后宕机，有一部分没有收到preCommit请求，那情况则是：一部分参与者执行了preCommit操作，一部分参与者没有执行preCommit操作，最终导致各节点之间数据不一致。</p><h5 id="执行事务预提交"><a href="#执行事务预提交" class="headerlink" title="执行事务预提交"></a>执行事务预提交</h5><p><img src="/images/theory/distributed/3pc_2.png" alt="3pc PreCommit"></p><ul><li>发送preCommit请求<br>由协调者向所有参与者发送preCommit请求，并等待参与者响应</li><li>事务预提交<br>参与者收到preCommit请求后，会执行事务操作，将undo和redo信息写入事务日志中</li><li>反馈执行响应<br>参与者将执行结果反馈给协调者，同时等待最终指令提交（commit）或终止（abort）</li></ul><h5 id="中断事务"><a href="#中断事务" class="headerlink" title="中断事务"></a>中断事务</h5><p>该阶段中断事务相比阶段三中断事务要简单，只需要由协调者向所有参与者发送abort请求，通知中断事务。期间参与者在等待协调者的preCommit请求超时后也会主动中断本地事务。</p><h4 id="阶段三：DoCommit"><a href="#阶段三：DoCommit" class="headerlink" title="阶段三：DoCommit"></a>阶段三：DoCommit</h4><p>同样，根据上一阶段的结果，该阶段也会存在两种情况。阶段二所有参与者成功反馈，则执行提交事务请求，否则中断事务。</p><p><strong>注意：</strong>参与者增加的超时时间，在该阶段也有所体现。在该阶段，无论是协调者宕机了，还是网络原因导致参与者没有收到该阶段的（提交/中断）请求，参与者都会执行本地事务提交。倘若在该阶段，协调者需要发送的是提交事务请求，参与者自动提交本地事务，最后能达到一致性。倘若在该阶段，协调者需要发送的是中断事务请求，如果参与者没有收到该请求，则参与者也会自动提交本地事务，最终导致各节点之间数据不一致。</p><h5 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h5><p><img src="/images/theory/distributed/3pc_3.png" alt="3pc DoCommit"></p><ul><li>发送提交请求<br>协调者就会从“预提交状态”变为“提交状态”。然后向所有的参与者节点发送”global_commit”请求</li><li>事务提交<br>参与者收到global_commit请求后，将执行本地事务提交操作，并释放整个事务执行期间占用的事务资源</li><li>反馈提交结果<br>参与者向协调者反馈ack提交结果</li><li>完成事务<br>协调者收到所有参与者的ack消息后，完成事务</li></ul><h5 id="中断事务-1"><a href="#中断事务-1" class="headerlink" title="中断事务"></a>中断事务</h5><ul><li>发送中断请求<br>协调者向所有参与者发送abort请求</li><li>事务回滚<br>参与者根据阶段二中记录的undo信息，来执行回滚操作，并释放占用事务资源</li><li>反馈回滚结果<br>参与者向协调者反馈ack回滚结果</li><li>中断事务<br>协调者收到所有参与者的ack消息后，中断事务</li></ul><h4 id="宕机（故障）恢复-1"><a href="#宕机（故障）恢复-1" class="headerlink" title="宕机（故障）恢复"></a>宕机（故障）恢复</h4><p>直接分析2PC中的协调者和参与者都宕机情况下，新晋升的协调者怎么恢复一致性的。</p><p>这种情况下，新晋升的协调者同样会询问所有的参与者事务处理情况。这看上去和2PC一样啊？但是深入分析下就会发现不一样。</p><p>我们假设第三阶段，协调者和参与者宕机了，并且参与者执行了第三阶段的操作，没人知道它执行了什么，也就存在两种可能：</p><ul><li>宕机的参与者没执行第三阶段任何操作或者执行了第三阶段的commit操作。那么协调者在询问所有的参与者事务执行情况时，得到的ACK响应一定是，所有参与者处于第二阶段成功完成的状态或者第三阶段执行了commit操作的状态。据此，协调者如果收到这样的回复，那一定可以断定宕机的参与者执行了commit操作或者没执行第三阶段的操作，那么协调者可以大胆的发送DoCommit消息。</li><li>宕机的参与者执行第三阶段的abort操作。那么协调者在询问所有的参与者事务执行情况时，得到的ACK响应一定是，一定存在一个参与者的第二阶段的响应是no，否则第三阶段不会发起abort操作。据此，协调者如果收到存在一个参与者处于第二阶段的abort状态时，则可以大胆的发送abort操作给所有的参与者。</li></ul><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>相比于2PC，3PC最大的优点就是：</p><ul><li>通过增加超时和自动提交，减少了参与者的阻塞范围。</li><li>通过增加PreCommit阶段，能在协调者和参与者都宕机情况下，新晋升的协调者能够使数据达成一致。（维基百科中描述的则是：当协调者和参与者都宕机后，新晋升的协调者可以自信的完成后续的事务操作。）</li></ul><p>3PC的缺点：</p><ul><li>在某些情况下，因为自动提交/中断本地事务的约定，必然会造成数据的不一致性。</li><li>增加一轮消息，增加了复杂度和协商效率。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> 2PC </tag>
            
            <tag> 3PC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈mysql索引实现-B+ Tree</title>
      <link href="/2019/04/01/theory/%E8%B0%88%E8%B0%88mysql%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0-B+Tree/"/>
      <url>/2019/04/01/theory/%E8%B0%88%E8%B0%88mysql%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0-B+Tree/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;本文记录学习mysql索引时，了解到一系列知识点。先从二叉树，到平衡二叉树，再到多路平衡树(B-Tree)，最后到加强版多路平衡查找树(B+Tree)，也就是Mysql默认使用的索引结构。分别解析各自的优缺点。以及最后为什么Mysql选择B+Tree。最后总结对日常开发的影响。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;树，这种数据结构诞生的原因，想必都说腻了。也就是，当你在一堆数据中要查询某个值的时候，你是不是得去遍历所有数据，找到你要的那一个，对不对。当你数据量很大的时候，遍历的成本是非常高。假如你要从一百万个数值中查找你要的值，你有可能就得比较一百万次。那么这个时候树的结构就诞生了。它按照一定规则存储数据，当你查询的时候，按照一定的规则查找数据。它的时间复杂度比你直接遍历要降低数倍。</p><h4 id="二叉查找树-Binary-Search-Tree"><a href="#二叉查找树-Binary-Search-Tree" class="headerlink" title="二叉查找树(Binary Search Tree)"></a>二叉查找树(Binary Search Tree)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;二叉查找树，它将比当前节点小的值全部放在它的左边，当作左子树。将比当前节点大的值放在它的右边，当作右子树。那么它具有以下特性</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;以下为一个标准的二叉查找树。<br><img src="/images/sql/mysql_tree/binary_search_tree_1.png" alt="binary_search_tree"><br>&nbsp;&nbsp;&nbsp;&nbsp;当你要查询某个节点时，二叉查找树的优势就显示出来了。比如你要查询节点<code>14</code>.那么查询的步骤如下：</p><ol><li>跟根节点10比较，14&gt;10，那么向10的右子树查询</li><li>跟节点16比较，14&lt;16，那么向16的左子树查询</li><li>跟节点13比较，14&gt;13，那么向13的右子树查询</li><li>跟节点14比较，14=14，查得结果</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;你以二叉查找树存储数据，查询节点14时，你只需比较4次，而你要是以链表的形式存储，那么你要比较总共进行10比较才可以查询到。当数据量大的时候，这种优势体现的淋漓尽致。但是二叉查找树也有它的缺点。比如当大部分数据都大于或者小于当前节点时，二叉树就夭折了。如下<br><img src="/images/sql/mysql_tree/binary_search_tree_2.png" alt="binary_search_tree"><br>&nbsp;&nbsp;&nbsp;&nbsp;那么这种情况来看，就跟遍历所有数据没有什么区别了，放在数据中，就跟全表遍历没有任何区别。</p><h4 id="平衡二叉查找树-AVL-Tree"><a href="#平衡二叉查找树-AVL-Tree" class="headerlink" title="平衡二叉查找树(AVL Tree)"></a>平衡二叉查找树(AVL Tree)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;上面小节讲到二叉查找树的诞生和致命的缺点，那么本小节介绍的另一种数据结构就是专门解决二叉查找树的缺点的。<br>&nbsp;&nbsp;&nbsp;&nbsp;平衡二叉查找树，是一种结构平衡的二叉搜索树，即叶节点高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。通常都会讲到AVL树、红黑树。它们在增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。<br><img src="/images/sql/mysql_tree/avl_tree_1.png" alt="AVL Tree"><br>&nbsp;&nbsp;&nbsp;&nbsp;当该平衡二叉查找树，增加节点<code>0007</code>的时候，会进行以下步骤</p><ol><li>从根节点查询，找到7应该插入的位置。也就是当作6的右子树<br><img src="/images/sql/mysql_tree/avl_tree_2.png" alt="AVL Tree"></li><li>根据旋转规则，这里以5为中心，6进行左旋。重新恢复平衡。<br><img src="/images/sql/mysql_tree/avl_tree_3.png" alt="AVL Tree"></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;这个时候，我们可以大大的松一口气，我们解决了二叉树致命的缺点，也减少了检索的时间复杂度，那么为什么mysql不使用这种数据结构呢？因为使用AVL树作为索引的数据结构还存在两个问题</p><ol><li>搜索时磁盘IO次数过多</li><li>节点中存放的数据太少</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;第一个问题，是因为数据库中的数据，包括索引一定是存放在硬盘上的，因为数据库中数据少则几个G，多则几个T，这么大的数据不可能存放在内存中，所以存在硬盘中。那么问题就出来了，比较的操作，不可能在硬盘上进行，只能在内存中计算，那么当你要找到节点<code>0003</code>的时候，是不是最少要进行三次IO读取。当总共7个节点的时候，就需要3次的IO读写。当你的数据达到700W的时候，IO次数就很恐怖，而IO读取的效率是非常低效的。<br>&nbsp;&nbsp;&nbsp;&nbsp;第二问题，怎么理解。先要普及另一个知识点，当你的操作系统去读取数据时候，一定是以页为单位去读取的。它不可能根据你要读多少就读多少。一页的大小是4K，当然你可以一次读取4页就是16K的数据。那么回到正题，你觉得每个节点存放了两个子树的地址、自己本身的值、以及其他列的数据所在的地址。足以填满4K的大小吗？肯定是不行的。那么我辛辛苦苦加载一页的数据到内存中，只得到了几十byte的数据。特别是在mysql中，页大小定义是16K。那么肯定是不合适的。</p><h4 id="多路平衡查找树-Balanced-Tree、B-Tree"><a href="#多路平衡查找树-Balanced-Tree、B-Tree" class="headerlink" title="多路平衡查找树(Balanced Tree、B Tree)"></a>多路平衡查找树(Balanced Tree、B Tree)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;B树是一种绝对平衡的树，它从当前节点，到它所有的叶子节点，深度都是相等的。B树，概括来说是一个一般化的二叉查找树（binary search tree），可以拥有多于2个子节点。与自平衡二叉查找树不同，B树为系统大块数据的读写操作做了优化。B树这种数据结构非常适合用来描述外部存储。<br>&nbsp;&nbsp;&nbsp;&nbsp;先感受以下的多路平衡查找树<br><img src="/images/sql/mysql_tree/balance_tree_1.png" alt="Balanced Tree"><br>&nbsp;&nbsp;&nbsp;&nbsp;多路平衡查找树，怎么理解这个路字。回到上一小节把<code>平衡二叉查找树</code>的<code>叉</code>字换成<code>路</code>字，就可以很明了的理解多路平衡查找树了。<br>&nbsp;&nbsp;&nbsp;&nbsp;多路平衡查找树，它的每个节点都存储多个关键字。它每两个相邻的关键字表示的是一个区间，最末端的两个关键字，表示到无穷的区间。那么可以推测，当前节点的路数=它的关键字+1.<br>&nbsp;&nbsp;&nbsp;&nbsp;在以上多路平衡查找树中，当需要查找id为<code>9</code>对应的数据，它的查询步骤则是</p><ol><li>将根节点加载到内存中并比较，9比8大，则向8的右边查找</li><li>将节点10加载到内存中并比较，9比10小，则向左边查找</li><li>这时找到节点9，找到节点9对应数据区。完成查询。</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;那么关键字的个数怎么确定，在mysql中，有一个参数去设置它的页大小的。假如你就设置的是16K，那么一起计算以下，id为int类型（4byte）+关键字对应的子节点引用（假设4byte）+对应存放的数据区（假设8byte）。那么一个关键字是不是就占用16byte的位置，从理论上来说16K就可以存储1000个关键字，这其中不包括磁盘碎片，乱七八糟的因素。<strong>这里又引发另一个思考，也就是说为什么定义字段长度的时候，应该定义它合适的长度就行了。不要过大。</strong>当你定义过大的长度，也就是以上公式的除数变大，那么树的深度就变高。<br>&nbsp;&nbsp;&nbsp;&nbsp;回看平衡二叉查找树的两个缺点是不是都得到了解决。磁盘IO次数过多，是否因为树的深度变矮使得次数降低。每个节点存储的数据太少，是不是通过多关键字得到了解决，每加载一页数据，我都能到我理想的一个数据。所以数据库级别都使用它来作为索引数据结构，它对磁盘的索引是有天然的优势的。<br>&nbsp;&nbsp;&nbsp;&nbsp;回过头来看，我们有说它是一个绝对平衡的树，那么它是怎么保证的呢？以以下树来举例（路数最多为3），插入节点<code>13</code><br><img src="/images/sql/mysql_tree/balance_tree_2.png" alt="Balanced Tree"></p><ol><li>它会找到13可以插入的位置，也就是12的右边<br><img src="/images/sql/mysql_tree/balance_tree_3.png" alt="Balanced Tree"></li><li>但是此时，它违背了上面说的约定，最后的节点它的路数会有4条，这时他会分裂，将12分裂到父节点。完成插入。<br><img src="/images/sql/mysql_tree/balance_tree_4.png" alt="Balanced Tree"></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;从上面步骤来，当分裂到父节点，使得父节点也不满足的时候，就会再往上分裂，那么在你插入时候就会使索引结构发生巨大的变化，<strong>这也就是为什么有的架构师会对你说，某些经常修改的字段、不常使用的字段不建议使用索引。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;重新思考一下，上面的结构update怎么操作。update是分解成delete+insert操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;多路平衡查找树，我们已经讲清楚了，那么mysql还不使用它，还要自己搞一个B+ Tree呢？</p><h4 id="加强版多路平衡查找树-B-Tree"><a href="#加强版多路平衡查找树-B-Tree" class="headerlink" title="加强版多路平衡查找树(B+ Tree)"></a>加强版多路平衡查找树(B+ Tree)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;B+ Tree属于B Tree的一个变种结构，它拥有以下特征</p><ol><li>节点关键字搜索采用闭合区间，关键字=路数</li><li>非叶子节点，不保存数据相关信息，只保存关键字和子节点的引用</li><li>关键字对应的数据保存在叶子节点中</li><li>叶子节点是顺序排列的，并且相邻节点具有顺序引用的关系。形成一个天然有序的链表</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;感受一下它的结构<br><img src="/images/sql/mysql_tree/balance+_tree_1.png" alt="Balanced+ Tree"><br>&nbsp;&nbsp;&nbsp;&nbsp;当他查询数据1时，执行的步骤是</p><ol><li>加载根节点，匹配到1，此时它不会停留</li><li>继续加载下一节点，匹配到1，也不会停留</li><li>一直到叶子节点，因为它的数据保存在叶子节点</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;那么为什么要这样设计呢？它会带来什么好处呢？</p><ol><li>B+ Tree是B Tree的变种，它拥有B Tree的优势</li><li>B+ Tree的扫库、扫表的能力更强</li><li>B+ Tree的磁盘读写能力更强</li><li>B+ Tree排序能力更强</li><li>B+ Tree查询效率更稳定</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;第一点，就是都能解决磁盘IO次数过多，存储的数据太少。<br>&nbsp;&nbsp;&nbsp;&nbsp;第二点，那B Tree来说，当你要基于索引的全表查询，是不是得遍历整棵树，因为数据区散落在各个节点。而B+ Tree，只需要遍历叶子节点。<br>&nbsp;&nbsp;&nbsp;&nbsp;第三点，怎么理解，之前算B Tree每一个节点能保存多少个关键字的时候。算到每一节点都要保存8byte的数据区。而B+ Tree的节点不用保存数据区，是不是每个节点能保存的关键字也就却多。<br>&nbsp;&nbsp;&nbsp;&nbsp;第四点，是因为叶子节点形成了一个天然的有序链表<br>&nbsp;&nbsp;&nbsp;&nbsp;第五点，每次查询都会查询叶子节点，所以它的搜索时间复杂度是一样的。但是有人说，这样的话，那么B Tree的查询效率应该要比B+ Tree快，因为B Tree在第一个节点搜索到了就直接返回了。查询效率这就要看各位的理解了，上面的说法没错，但是B+ Tree不用保存数据区，IO的次数减少了，也会节省效率。</p><h4 id="mysql的B-Tree-具体落地"><a href="#mysql的B-Tree-具体落地" class="headerlink" title="mysql的B+ Tree 具体落地"></a>mysql的B+ Tree 具体落地</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;登陆mysql服务，查询数据保存位置</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="emphasis">'datadir'</span>;</span><br><span class="line"></span><br><span class="line"><span class="code">+---------------+</span>-----------------------------------------+</span><br><span class="line">| Variable<span class="emphasis">_name | Value                                   |</span></span><br><span class="line"><span class="emphasis">+---------------+-----------------------------------------+</span></span><br><span class="line"><span class="emphasis">| datadir       | D:\Program Files (x86)\MySQL\Data\Data\ |</span></span><br><span class="line"><span class="emphasis">+---------------+-----------------------------------------+</span></span><br><span class="line"><span class="emphasis">1 row in set, 1 warning (0.37 sec)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;在这个目录下，以你的数据名字命名的文件夹。进去看到有以表名字开头文件。</p><ul><li>innodb，以frm或ibd结尾的文件，frm保存表的结构，每一个字段结构等信息。idb保存是数据和索引文件</li><li>myisam，以frm、MYI、MYD，frm保存表的结构，MYI保存索引，MYD保存数据。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;在myisam引擎中，当这个表有多个索引，比如id列和name列都有索引，那么它就是维护了同级别的两颗B+树，每个树的叶子节点的数据区都保存磁盘地址指向MYD中的记录。<br>&nbsp;&nbsp;&nbsp;&nbsp;而在innodb中，由于索引和数据保存在一个文件，所以我们猜测它的数据和索引放在一起。那么多个索引结构的时候，它到底怎么把数据和索引放在一起呢？这是引入一个新概念，<strong>innodb是以主键索引来组织数据的存储。</strong>，如下图所示<br><img src="/images/sql/mysql_tree/mysql_data_1.png" alt="mysq balanced+ Tree"><br>&nbsp;&nbsp;&nbsp;&nbsp;此时我再建一个name字段的索引，这个name字段的叶子节点中保存的是对应的主键的值。也就是说在innodb中，分主索引和辅助索引，主索引组织数据存储，辅助索引引用主索引。也就是我们常说的聚集索引，数据库表行中数据的物理顺序与逻辑（索引）顺序相同。<br>&nbsp;&nbsp;&nbsp;&nbsp;innodb这样设计有什么好处？为什么不直接保存数据的地址？因为保存主键，在主键索引发生结构变化（分裂、合并）时，他的值是不变，但是它的磁盘地址是会变的，如果保存地址的话，那么还得去维护辅助索引的引用地址。</p><h4 id="索引的几大原则"><a href="#索引的几大原则" class="headerlink" title="索引的几大原则"></a>索引的几大原则</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在百度上，或者是一些大佬总结的经验，他们有的是对的，有的是不那么准确的，那么本节我们希望可以在原理上得到验证。</p><h5 id="列的离散型"><a href="#列的离散型" class="headerlink" title="列的离散型"></a>列的离散型</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;离散型计算公式：count(distinct col)/count(col)，就是某一列去重后的数量除以它的总数，就是离散型，这个值越大，离散性越好，选择性就越好。<br>&nbsp;&nbsp;&nbsp;&nbsp;举个例子，用性别这一列作为索引，这一列离散型差，1表示男，2表示女。有以下树结构<br><img src="/images/sql/mysql_tree/mysql_data_2.png" alt="mysq balanced+ Tree"><br>&nbsp;&nbsp;&nbsp;&nbsp;在查询数据1时，和根节点比较，往左查询，到了第二节点的时候，懵逼了，它是不是得把所有得路数都得遍历一次。所以说它选择性差。而且在以前得老师有说过，当列的离散型小于0.15，就会强制全表扫描。</p><h5 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;对索引的关键字做比较时，一定是从左往右进行比较的，且不可跳过。比如果当前节点为’abc’，要比较的字符为’adc’，当匹配到第二个字符时，d大于b，那么走右边。</p><h5 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;联合索引就是由多个列组成的索引，把单列索引理解成特殊的联合索引。相当于说，联合索引的树的每个节点的关键字，是由两个列拼接在一起的。比如果name和phone组成联合索引，那么它存储的关键字就是，<code>jack,13838387438</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;基于最左匹配原则和联合索引原理，我们有得出一个结论，<strong>区别度大的列要放在联合索引前面</strong>，是不是都听过这样一句话，那么现在是不是可以理解了。</p><h5 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果查询的列，通过索引项的信息就可以直接返回，那么该索引称为该查询sql的覆盖索引。<br>&nbsp;&nbsp;&nbsp;&nbsp;为什么会有这个概念，是因为它如果在索引的结构树上就有你要查询的列，那么它就不需要去数据区扫描，大大的减少查询效率。这就是老程序员为什么跟你念，<strong>尽量不要使用<code>select *</code></strong>。</p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ol><li>where条件中，like ‘abc%’、like ‘%9999%’、like ‘%999’ 三种都用不到索引？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一中可以，后面两种用不到，归根结底是最左匹配原则。</span><br><span class="line">但是第一种如果离散性太低，也不会使用索引。</span><br></pre></td></tr></table></figure></li><li>where条件中，not in 和&lt;&gt;无法使用索引，对吗？</li><li>select * from user where concat(name, ‘1’) = ‘far1’<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数的结果无法预料，则不会使用索引</span><br></pre></td></tr></table></figure></li></ol><p><strong>考虑一下下面情况，是否属于正确操作？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 经常查询的sql</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = ?;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = ? <span class="keyword">and</span> phone = ?;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么建以下索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> IDX_NAME_IN_USER <span class="keyword">on</span> <span class="keyword">user</span>(<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> IDX_NAME_PHONE_IN_USER <span class="keyword">on</span> <span class="keyword">user</span>(<span class="keyword">name</span>, phone);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;基于最左匹配原则，第一条索引属于冗余索引，如果用其他的扫描工具也会给你报出警告的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> B-Tree </tag>
            
            <tag> 索引 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义注解3-组合注解</title>
      <link href="/2018/10/20/java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A33-%E7%BB%84%E5%90%88%E6%B3%A8%E8%A7%A3/"/>
      <url>/2018/10/20/java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A33-%E7%BB%84%E5%90%88%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;组合注解用处很多，只是我们有时没注意而已，比如RestController，PostMapping，GetMapping等。他们的意义在于将多个注解组合在一起，写一个注解就够了。</p><h4 id="定义组合注解"><a href="#定义组合注解" class="headerlink" title="定义组合注解"></a>定义组合注解</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;本节目的在于，组合Cacheable注解，将它的cacheNames写成默认的default（想想第一节最后的讨论）。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Cacheable</span>(cacheNames = <span class="string">"default"</span>)</span><br><span class="line">public <span class="variable">@interface</span> Interest &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">String</span> <span class="selector-tag">key</span>();</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">String</span> <span class="selector-tag">unless</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;其实以上代码就完成了注解组合，你在一个方法上夹Interest注解就相当于加了Cacheable注解。</p><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;以上代码虽然完成了组合，但是你会发现你用spel写key或者unless时。没有提示，也没有高光。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Cacheable</span>(cacheNames = <span class="string">"default"</span>)</span><br><span class="line">public <span class="variable">@interface</span> Interest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@AliasFor</span>(annotation = Cacheable.class)</span><br><span class="line">    String key();</span><br><span class="line"></span><br><span class="line">    <span class="variable">@AliasFor</span>(annotation = Cacheable.class)</span><br><span class="line">    String unless();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;那么现在快去试试吧。你还可以装逼的加上注释。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="variable">@see</span> Cacheable<span class="comment">#key</span></span><br><span class="line"> * <span class="variable">@return</span></span><br><span class="line"> *<span class="regexp">/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> API设计 </tag>
            
            <tag> 注解 </tag>
            
            <tag> 组合注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义注解2-动态修改注解的属性值</title>
      <link href="/2018/10/20/java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A32-%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC/"/>
      <url>/2018/10/20/java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A32-%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;经过上一节的，我们可以自己解析spel表达式。那么我现在的想法是，在注解的第一层aop中解析spel，然后将解析后的值设置到属性中，那么在之后的aop中就不用解析了。</p><h4 id="找出注解中值存放位置"><a href="#找出注解中值存放位置" class="headerlink" title="找出注解中值存放位置"></a>找出注解中值存放位置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;继续上一节的代码，在上一节的AOP中添加注解@Order(0)，再新增一个注解，添加@Order(1)。注意order这个注解有坑的，最好先百度完再使用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterestResolveELAspect</span> </span>&#123;</span><br><span class="line"><span class="comment">// resolve spel... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterestHandleAspect</span> </span>&#123;</span><br><span class="line"><span class="meta">@Around(<span class="meta-string">"@annotation(anno)"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object invoked(ProceedingJoinPoint pjp, Interest anno) throws Throwable &#123;</span><br><span class="line">String key = anno.key();</span><br><span class="line">String unless = anno.unless();</span><br><span class="line">logger.info(<span class="string">"call InterestHandleAspect.invoked, resolvedKey:[&#123;&#125;], resolvedUnless:[&#123;&#125;]"</span></span><br><span class="line">                , key, unless);</span><br><span class="line"><span class="keyword">return</span> pjp.proceed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;我们在上一节代码中的String keySpel = anno.key()打下断点。查看当前栈的变量。<br><img src="/images/java/costom-anno-1.png" alt="操作流程图"><br>&nbsp;&nbsp;&nbsp;&nbsp;发现注解的对象是一个Proxy的实例，Proxy的作用就是为java类生一个代理对象，有这个代理对象去调用真实方法，就像这样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="built_in">String</span> func1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> B <span class="keyword">implements</span> A &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> func1() &#123; <span class="comment">//do something ... &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> func2() &#123; <span class="comment">//do something ... &#125;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span> ...args) &#123;</span><br><span class="line">    B bInstance = <span class="keyword">new</span> B();</span><br><span class="line">    </span><br><span class="line">    B bProxy = Proxy.newProxyInstance(</span><br><span class="line">        B.class.getClassLoader(),    <span class="comment">// B 类的类加载器</span></span><br><span class="line">        B.class.getInterfaces(), <span class="comment">// B 类所实现的接口，如果你想拦截B类的某个方法，必须让这个方法在某个接口中声明并让B类实现该接口</span></span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123; <span class="comment">// 调用处理器，任何对 B类所实现的接口方法的调用都会触发此处理器</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">Object</span> invoke (<span class="built_in">Object</span> proxy, <span class="comment">// 这个是代理的实例，method.invoke时不能使用这个，否则会死循环</span></span><br><span class="line">                                  Method method, <span class="comment">// 触发的接口方法</span></span><br><span class="line">                                  <span class="built_in">Object</span>[] args <span class="comment">// 此次调用该方法的参数</span></span><br><span class="line">                                  ) throws Throwable &#123;</span><br><span class="line">                System.out.println(<span class="built_in">String</span>.format(<span class="string">"调用 %s 之前"</span>, method.getName()));</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 这里必须使用B类的某个具体实现类的实例，因为触发时这里的method只是一个接口方法的引用，</span></span><br><span class="line"><span class="comment">                 * 也就是说它是空的，你需要为它指定具有逻辑的上下文(bInstance)。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="built_in">Object</span> obj = method.invoke(bInstance, args); </span><br><span class="line">                System.out.println(<span class="built_in">String</span>.format(<span class="string">"调用 %s 之后"</span>, method.getName()));</span><br><span class="line">                <span class="keyword">return</span> obj; <span class="comment">//返回调用结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;再回想注解实质上是一个接口，它本身没有逻辑，那么它的值存在什么地方呢？那么答案就是Proxy实例中了。<br>&nbsp;&nbsp;&nbsp;&nbsp;这个Proxy实例有一个类型为AnnotationInvocationHandler的变量h，我回到上面创建Proxy对象的代码中，Proxy.newProxyInstance()的第三个参数就是InvocationHandler，而这个变量h就是它的实现类。<br>&nbsp;&nbsp;&nbsp;&nbsp;继续往变量h里看，它有一个字段memberValues，是一个map，而在这个map中，我发现了注解值存放的位置。key为注解的属性名，value就是属性值。</p><h4 id="修改注解值"><a href="#修改注解值" class="headerlink" title="修改注解值"></a>修改注解值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;找到了注解值存放位置，那么修改就简单了</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">0</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InterestResolveELAspect</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Around</span>(<span class="string">"@annotation(anno)"</span>)</span><br><span class="line">    public <span class="built_in">Object</span> invoked(ProceedingJoinPoint pjp, Interest anno) throws Throwable &#123;</span><br><span class="line"><span class="comment">// resolve spel</span></span><br><span class="line">        <span class="built_in">String</span> key = resolve spel;</span><br><span class="line">        Boolean unless = resolve spel;</span><br><span class="line"></span><br><span class="line">InvocationHandler h = Proxy.getInvocationHandler(anno);</span><br><span class="line">        Field hField = h.getClass().getDeclaredField(<span class="string">"memberValues"</span>);</span><br><span class="line">        hField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; memberValues = (<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;) hField.<span class="keyword">get</span>(h);</span><br><span class="line">        memberValues.put(<span class="string">"key"</span>, key);</span><br><span class="line">        memberValues.put(<span class="string">"unless"</span>, unless.toString());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pjp.proceed();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;赶紧测试一下，看看InterestHandleAspect打印的内容是不是你想要的。。。。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> API设计 </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义注解1-实现spel表达式</title>
      <link href="/2018/10/19/java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A31-%E5%AE%9E%E7%8E%B0spel%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/10/19/java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A31-%E5%AE%9E%E7%8E%B0spel%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;开发中多多少少会使用spel，spel是Spring3引入了Spring表达式语言（Spring Expression Language,SpEL），在一些配置中，注解中经常用到，可谓是神器。比如说spring中的@Cacheable注解，其中key、unless等属性都支持Spel。举个例子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="constructor">Cacheable(<span class="params">key</span>=<span class="string">"#user.name + '_' + #user_phone"</span>, <span class="params">unless</span>=<span class="string">"#user.age &gt; 18"</span>)</span></span><br><span class="line">public Product get<span class="constructor">Product(User <span class="params">user</span>)</span>&#123;</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;上面spel表达的意思就是，缓存使用的key由入参属性name和phone组成，当用户的年纪大于18岁时，不进入缓存。<br>&nbsp;&nbsp;&nbsp;&nbsp;但是@Cacheable其中cacheNames这个属性不支持Spel，很痛苦。所以我准备“重复造一次轮子”（解决cacheNames的问题还是有别的方法解决的，所以本文纯属技术交流）</p><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;目的很明确，定义一个支持spel的注解</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> Interest&#123;</span><br><span class="line"><span class="selector-tag">String</span> <span class="selector-tag">key</span>();</span><br><span class="line"><span class="selector-tag">String</span> <span class="selector-tag">unless</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">Interest</span>(key = <span class="string">"#user.name + #user.phone"</span>, unless = <span class="string">"#user.age &gt; 18"</span>)</span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">interest</span>(User user)&#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现Spel"><a href="#实现Spel" class="headerlink" title="实现Spel"></a>实现Spel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yzker.interest.core.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.LocalVariableTableParameterNameDiscoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.EvaluationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.Expression;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.ExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.support.StandardEvaluationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> far.liu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterestResolveELAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(InterestResolveELAspect<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">    LocalVariableTableParameterNameDiscoverer discoverer = <span class="keyword">new</span> LocalVariableTableParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"@annotation(anno)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoked</span><span class="params">(ProceedingJoinPoint pjp, Interest anno)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        Method method = ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line">        String[] params = discoverer.getParameterNames(method);</span><br><span class="line">        EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">0</span>; len &lt; params.length; len++) &#123;</span><br><span class="line">            context.setVariable(params[len], args[len]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String keySpel = anno.key();</span><br><span class="line">        Expression keyExpression = parser.parseExpression(keySpel);</span><br><span class="line">        String key = keyExpression.getValue(context, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String unlessSpel = anno.unless();</span><br><span class="line">        Expression unlessExpression = parser.parseExpression(unlessSpel);</span><br><span class="line">        Boolean unless = unlessExpression.getValue(context, Boolean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"call InterestResolveELAspect.invoked, keySpel:[&#123;&#125;], resolvedKey:[&#123;&#125;], unlessSpel:[&#123;&#125;], resolvedUnless:[&#123;&#125;]"</span></span><br><span class="line">                , keySpel, key, unlessSpel, unless);</span><br><span class="line">        <span class="comment">// todo cache ...</span></span><br><span class="line">        <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上代码是由aop解析spel，缓存处理逻辑未实现，本文重点在解析spel，不在于造轮子，如果不到万不得已不要尝试自己造轮子。<br>&nbsp;&nbsp;&nbsp;&nbsp;说一下关于cacheNames不支持spel。首先得明白cacheNames是干嘛的，在这个注解中，它主要用来配置每一类型的缓存数据过期时间。其实你可以定义一个全局默认的cacheName，所有缓存都使用它，而过期时间你在别的地方修改。不管你是用redis缓存，还是guava缓存，它总的有一个put进缓存的方法，其实你重写它本身的put方法，这里面一般会有过期时间的，你可以在这里根据你的业务场景修改过期时间。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> API设计 </tag>
            
            <tag> SpEL </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式15-模棱两可的分组</title>
      <link href="/2018/10/08/sql/antipatterns/15-%E6%A8%A1%E6%A3%B1%E4%B8%A4%E5%8F%AF%E7%9A%84%E5%88%86%E7%BB%84/"/>
      <url>/2018/10/08/sql/antipatterns/15-%E6%A8%A1%E6%A3%B1%E4%B8%A4%E5%8F%AF%E7%9A%84%E5%88%86%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;假如你的老板想知道哪些项目还处于活跃状态，哪些项目已经停止了。他让你生成一个每个项目最后一个bug提交日期的报表。你查询根据product分组的dete_report的最大值，如下：</p><table><thead><tr><th>product</th><th>latest</th><th>bug_id</th></tr></thead><tbody><tr><td>USQL</td><td>2010-06-01</td><td>1234</td></tr><tr><td>Open RoundFile</td><td>2010-02-16</td><td>3456</td></tr><tr><td>ReConsider</td><td>2010-01-01</td><td>5678</td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;但是你对比全量数据，发现这个结果并不准确。</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>product</th><th>latest</th><th>bug_id</th><th>memo</th></tr></thead><tbody><tr><td>USQL</td><td>2009-12-19</td><td>1234</td><td>这个bug_id…</td></tr><tr><td>USQL</td><td>2010-06-01</td><td>2248</td><td>与这个日期不匹配</td></tr><tr><td>Open RoundFile</td><td>2010-02-16</td><td>3456</td><td>这里又正确</td></tr><tr><td>ReConsider</td><td>2010-01-01</td><td>5678</td><td>这里又正确</td></tr></tbody></table><h4 id="目的：获取每组的最大值"><a href="#目的：获取每组的最大值" class="headerlink" title="目的：获取每组的最大值"></a>目的：获取每组的最大值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;group by 确实很强大，他将复杂的报表生成过程简化到只用一个关键字解决。但是我们要认清group by什么能做，什么不能做。我们分析造成上面的原因。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果我们只需要获取每一个项目和最后一个bug提交的时间。那么可以使用以下语句，他会返回正确的结果。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select product_id, max(date_report) as latest</span><br><span class="line"><span class="keyword">from</span> bug join bug_product using (bug_id)</span><br><span class="line">group by product_id;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;接下来我们对以上语句，进行扩展，让它返回最后一个提交bug的id。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select product_id, max(date_report) as latest, bug_id</span><br><span class="line"><span class="keyword">from</span> bug join bug_product using (bug_id)</span><br><span class="line">group by product_id;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;然而这个查询在不同的数据库中，要么返回一个错误的结果，要么是一个错误的语法。<strong>那么我们本章的目的就是要执行一个不仅返回每组最大值的查询，同时也要返回这个值的其他字段。</strong></p><h4 id="反模式：引用非分组列"><a href="#反模式：引用非分组列" class="headerlink" title="反模式：引用非分组列"></a>反模式：引用非分组列</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;造成这个反模式的根本原因就是程序员对于SQL中分组查询逻辑的普遍误解。</p><h5 id="单值规则"><a href="#单值规则" class="headerlink" title="单值规则"></a>单值规则</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;属于一个组的所有行，他们group by关键字所指的那个字段都是一样的。对于以下查询，<strong>每一组都会返回一条且仅返回一条</strong>，这就是单值规则。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select product_id, max(date_report) as latest</span><br><span class="line"><span class="keyword">from</span> bug join bug_product using (bug_id)</span><br><span class="line">group by product_id;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;跟在select之后的每一列，对于每一组来说都必须返回且仅返回一个值，无论这一组匹配多少行。在这个查询中max()返回每一组最大date_report，它也是遵守单值规则的，所以这个查询返回的结果是正确的。但是你想在这个sql中返回其他的字段，如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select product_id, max(date_report) as latest, bug_id</span><br><span class="line"><span class="keyword">from</span> bug join bug_product using (bug_id)</span><br><span class="line">group by product_id;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，在根据product进行的分组中，每一组将有多个bug_id，也是就是说一个product有多个bug_id，那么它不符合单值规则，数据库就不知道它显示哪一个值是正确的。大多数数据库在这样情况下则会抛出错误，或者给出一个错误的值。</p><h5 id="我想要的查询"><a href="#我想要的查询" class="headerlink" title="我想要的查询"></a>我想要的查询</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;常见的误解就是程序员任务SQL会猜测你需要在报表中显示哪个bug_id，大多数人认为如果查询得到最大值，那么查询返回结果的其他列就会是对应的最大值所在的行的那些值。不幸的是，SQL并没有那么智能，原因如下：</p><ol><li>如果两个bug的date_report值相同并且这两个值就是这一组中的最大值，那么哪个bug_id应该显示到报表中呢？</li><li>如果聚合函数没有匹配到任意一行，那么将显示哪个bug_id，如sum(), count(), avg()。</li><li>如果使用了两个聚合函数，那么SQL该显示哪个bug_id。<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> product_id, <span class="built_in">max</span>(date_report) <span class="keyword">as</span> latest, <span class="built_in">min</span>(date_report) <span class="keyword">as</span> earliest, bug_id</span><br><span class="line"><span class="keyword">from</span> bug <span class="keyword">join</span> bug_product <span class="keyword">using</span> (bug_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> product_id;</span><br></pre></td></tr></table></figure></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;这就是为什么单值规则为何如此重要。所以如果没有单值规则，数据库可靠性会降低，这意味着同样的查询可能是合理的，也可能是不合理的，而唯一的标准竟然是数据的状态！！！</p><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;对于大多数数据库，当你违背了单值原则，会立刻返回一个错误。<br><img src="/images/sql/antipatterns/15/01_error.png" alt="USQL"><br>&nbsp;&nbsp;&nbsp;&nbsp;对于mysql和sqlite，有所不同，mysql在有歧义的列上会返回第一行，而sqlite会返回最后一行，其排序规则是实际的物理存储顺序来决定的。</p><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;如上一小节提到mysql和sqlite不严谨之处，有时我们也可以利用它得到一些便利。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select b.report_by, a.account_name </span><br><span class="line"><span class="keyword">from</span> bug b join account a on b.report_by = a.account_name</span><br><span class="line">group by b.report_by;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上查询虽然违背了单值原则，但是它返回的结果确是正确的，因为report_by 和 account_name 是一对一的关系。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;解决这个反模式的方法就是写不带歧义的SQL，下面将一一说明。</p><h5 id="只查询功能所依赖的列"><a href="#只查询功能所依赖的列" class="headerlink" title="只查询功能所依赖的列"></a>只查询功能所依赖的列</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;最直接的解决办法就是将有歧义的列排除在外。很多时候那些额外的列，我们并不见得用得到。</p><h5 id="使用关联子查询"><a href="#使用关联子查询" class="headerlink" title="使用关联子查询"></a>使用关联子查询</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select </span><span class="keyword">bp1.product_id, </span><span class="keyword">b1.date_report </span>as latest, <span class="keyword">b1.bug_id</span></span><br><span class="line"><span class="keyword">from </span><span class="keyword">bug </span><span class="keyword">b1 </span>join <span class="keyword">bug_product </span><span class="keyword">bp1 </span>using (<span class="keyword">bug_id)</span></span><br><span class="line"><span class="keyword">where </span>not exists(</span><br><span class="line"><span class="keyword">select </span>* from <span class="keyword">bug </span><span class="keyword">b2 </span>join <span class="keyword">bug_product </span><span class="keyword">bp2 </span>using (<span class="keyword">bug_id)</span></span><br><span class="line"><span class="keyword"></span>where <span class="keyword">bp1.product_id </span>on <span class="keyword">bp2.product_id</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">and </span><span class="keyword">b1.date_report </span>&lt; <span class="keyword">b2.date_report</span></span><br><span class="line"><span class="keyword">);</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这个查询简单易懂，但是它的效率是很低的。</p><h5 id="使用衍生表"><a href="#使用衍生表" class="headerlink" title="使用衍生表"></a>使用衍生表</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;使用衍生表比使用关联子查询效率要更高，就是先group by得到一个临时表，然后关联这个临时表</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select m.product_id, m.latest, max(<span class="keyword">b1.bug_id) </span>as latest_bug_id</span><br><span class="line">from <span class="keyword">bug </span><span class="keyword">b1 </span><span class="keyword">join </span><span class="keyword">bug_product </span><span class="keyword">bp1 </span>using(<span class="keyword">bug_id)</span></span><br><span class="line"><span class="keyword">join </span>(</span><br><span class="line">select <span class="keyword">bp2.product_id, </span>max(<span class="keyword">b2.date_report) </span>as latest</span><br><span class="line">from <span class="keyword">bug </span><span class="keyword">b2 </span><span class="keyword">join </span><span class="keyword">bug_product </span><span class="keyword">bp2 </span>using(<span class="keyword">bug_id)</span></span><br><span class="line"><span class="keyword"></span>group <span class="keyword">by </span><span class="keyword">bp2.product_id</span></span><br><span class="line"><span class="keyword">) </span>m on <span class="keyword">bp1.product_id </span>= m.product_id <span class="keyword">and </span><span class="keyword">b1.date_report </span>= m.latest</span><br><span class="line">group <span class="keyword">by </span>m.product_id, m.latest;</span><br></pre></td></tr></table></figure><h5 id="使用join"><a href="#使用join" class="headerlink" title="使用join"></a>使用join</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你可以创建一个外联结查询去匹配那些不存在的记录。如果匹配不存在就会返回NULL，因此，如果查询结果返回了NULL，就知道没有找到相应的记录</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select <span class="keyword">bp1.product_id, </span><span class="keyword">b1.date_report </span>as latest, <span class="keyword">b1.bug_id</span></span><br><span class="line"><span class="keyword">from </span><span class="keyword">bug </span><span class="keyword">b1 </span><span class="keyword">join </span><span class="keyword">bug_product </span><span class="keyword">bp1 </span>on <span class="keyword">b1.bug_id </span>= <span class="keyword">bp1.bug_id</span></span><br><span class="line"><span class="keyword">left </span>outer <span class="keyword">join </span>(</span><br><span class="line"><span class="keyword">bug </span>as <span class="keyword">b2 </span><span class="keyword">join </span><span class="keyword">bug_product </span>as <span class="keyword">bp2 </span>on <span class="keyword">b2.bug_id </span>= <span class="keyword">bp2.bug_id</span></span><br><span class="line"><span class="keyword">) </span>on (</span><br><span class="line"><span class="keyword">bp1.product_id </span>= <span class="keyword">bp2.product_id </span><span class="keyword">and </span><span class="keyword">b1.date_report </span>&lt; <span class="keyword">b2.date_report </span></span><br><span class="line"><span class="keyword">or </span><span class="keyword">b1.date_report </span>= <span class="keyword">b2.data_report </span><span class="keyword">and </span><span class="keyword">b1.bug_id </span>&lt; <span class="keyword">b2.bug_id</span></span><br><span class="line"><span class="keyword">)</span></span><br><span class="line"><span class="keyword">where </span><span class="keyword">b2.bug_id </span>is null;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;你理解这个sql需要花点时间，但是它是一个很重要的工具，它适用于大量数据查询并且可伸缩性比较关键时。</p><h5 id="对额外的列使用聚合函数"><a href="#对额外的列使用聚合函数" class="headerlink" title="对额外的列使用聚合函数"></a>对额外的列使用聚合函数</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你可以使用另一个聚合函数，从而让它遵守单值规则</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> product_id, <span class="built_in">max</span>(date_report) <span class="keyword">as</span> latest,</span><br><span class="line"><span class="built_in">max</span>(bug_id) <span class="keyword">as</span> latest_bug_id</span><br><span class="line"><span class="keyword">from</span> bug <span class="keyword">join</span> bug_product <span class="keyword">using</span>(bug_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> product_id;</span><br></pre></td></tr></table></figure><h5 id="连接同组所有值"><a href="#连接同组所有值" class="headerlink" title="连接同组所有值"></a>连接同组所有值</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;最后还有一个聚合函数可以用来处理bug_id并避免单值规则。mysql和sqlite提出一个叫做group_concat()的函数，它能将这一组中所有值连在一起作为单值返回。默认情况下使用逗号分割。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select product_id, max(date_report), group_concat(bug_id)</span><br><span class="line"><span class="keyword">from</span> bug join bug_product using(bug_id)</span><br><span class="line">group by product_id;</span><br></pre></td></tr></table></figure><table><thead><tr><th>product</th><th>latest</th><th>bug_id</th></tr></thead><tbody><tr><td>USQL</td><td>2010-06-01</td><td>1234,2248</td></tr><tr><td>Open RoundFile</td><td>2010-02-16</td><td>3456,4077,5150</td></tr><tr><td>ReConsider</td><td>2010-01-01</td><td>5678,8063</td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;但是它不会告诉你哪个bug_id对应最新bug，他还有一个缺点，它并非SQL标准函数。其他数据库并不支持这个函数。有些数据库支持自定义函数，如postgreSQL你可以这样写：</td><td></td><td></td></tr><tr><td><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">AGGREGATE</span> GROUP_ARRAY(</span><br><span class="line">BASETYPE = <span class="type">ANYELEMENT</span>,</span><br><span class="line">SFUNC = ARRAY_APPEND,</span><br><span class="line">STYPE = <span class="type">ANYARRAY</span>,</span><br><span class="line">INITCOND = <span class="string">'&#123;&#125;'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> product_id, max(date_report) <span class="keyword">as</span> latest,</span><br><span class="line">ARRAY_TO_STRING(GROUP_ARRAY(BUG_ID), <span class="string">','</span>) <span class="keyword">as</span> bug_id_list</span><br><span class="line"><span class="keyword">from</span> bug <span class="keyword">join</span> bug_product <span class="keyword">using</span>(bug_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> product;</span><br></pre></td></tr></table></figure></td><td></td><td></td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;另一些数据库不支持自定义函数，那么你只能写存储过程遍历一个非分组的查询结果，手动将每个值连在一起。</td><td></td><td></td></tr></tbody></table><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;牢记单值规则，避免模棱两可的查询。</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式14-对未知的恐惧</title>
      <link href="/2018/09/10/sql/antipatterns/14-%E5%AF%B9%E6%9C%AA%E7%9F%A5%E7%9A%84%E6%81%90%E6%83%A7/"/>
      <url>/2018/09/10/sql/antipatterns/14-%E5%AF%B9%E6%9C%AA%E7%9F%A5%E7%9A%84%E6%81%90%E6%83%A7/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;你的account表中有first_name, last_name两个字段，现在有需求要你显示一个完整名字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(first_name, last_name)</span><br><span class="line"> <span class="keyword">as</span> <span class="string">'full_name'</span> <span class="keyword">from</span> <span class="keyword">account</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但是你发现大部分人的名字都不显示了，你查到这些人的first_name都为null，concat出来的结果也为null。</p><h4 id="目的：辨别悬空值"><a href="#目的：辨别悬空值" class="headerlink" title="目的：辨别悬空值"></a>目的：辨别悬空值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;不可避免，数据库中总有些字段是没有值的。SQL支持一个特殊的值，那就是NULL。本章的目的就是要弄清楚如何编写那些包含NULL的查询。</p><h4 id="反模式：将NULL作为普通的值，反之亦然"><a href="#反模式：将NULL作为普通的值，反之亦然" class="headerlink" title="反模式：将NULL作为普通的值，反之亦然"></a>反模式：将NULL作为普通的值，反之亦然</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;开发者都对SQL中的NULL的行为感到茫然无措。SQL将NULL当作一个特殊值，不同于0、false或空字符串。但在Oracle的Sybase中，NULL的意义是长度为0的空字符串。</p><h5 id="在表达式中使用NULL"><a href="#在表达式中使用NULL" class="headerlink" title="在表达式中使用NULL"></a>在表达式中使用NULL</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;在值为NULL的列上进行计算所得的结果也是NULL，NULL和0是不同的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">hour</span> + <span class="number">10</span> <span class="keyword">from</span> bug;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上语句你可能期待，当值为NULL时返回10，但是实际上它返回的NULL<br>&nbsp;&nbsp;&nbsp;&nbsp;NULL和false也是不同的，and、or和not这三个布尔操作如果涉及NULL，其结果也让人感到困惑。</p><h5 id="搜索允许为空的列"><a href="#搜索允许为空的列" class="headerlink" title="搜索允许为空的列"></a>搜索允许为空的列</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果以下查询返回assigned_to为123的行，不包含别的值和NULL：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>你可能觉得以下查询会返回上个查询的补集，也就是所有之前查询没有返回的行：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="function"><span class="keyword">from</span> bug <span class="keyword">where</span> <span class="title">not</span> (<span class="params">assigned_to = <span class="number">123</span></span>)</span></span><br></pre></td></tr></table></figure><p>然而，这个查询都不会返回为NULL的记录。任何和NULL比较都返回“未知”，既不是TRUE，也不是FALSE。如下都得不到你需要的结果</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to &lt;&gt; <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h5 id="在查询参数中使用NULL"><a href="#在查询参数中使用NULL" class="headerlink" title="在查询参数中使用NULL"></a>在查询参数中使用NULL</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select </span>* from <span class="keyword">bug </span>assigned_to = ?</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;你传入一个整型时，会返回你期望的值，但是你不能传入一个NULL。这永远得不到为NULL的行。</p><h5 id="避免上述问题"><a href="#避免上述问题" class="headerlink" title="避免上述问题"></a>避免上述问题</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;为了避免上述问题，很多程序员会定义一个固定的值来取代NULL值。但是这样又会造成以下问题。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table bug(</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">assigned_to <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">hour numeric(9,2) <span class="keyword">not</span> <span class="literal">null</span><span class="built_in"> default </span>-1</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;假如定义hour的悬空值为-1，但是你有没有想过当你SUM，AVG这一列时，会有什么后果。因而你又必须添加一个额外的条件去除这个值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SUM</span>(<span class="keyword">hours</span>) <span class="keyword">from</span> bug <span class="keyword">where</span> <span class="keyword">hours</span> &lt;&gt; <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;接着来看assigned_to，这个外键指向account，当一个bug提交了，还没有人处理，assigned_to应该怎么填写呢？如果你因此去创建一个没有意义的账号，这看起来多么可笑。</p><h4 id="如何识别反模式："><a href="#如何识别反模式：" class="headerlink" title="如何识别反模式："></a>如何识别反模式：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当出现以下情况时，可能是反模式</p><ol><li>我如何将没有值（Null）的列取出来？</li><li>将字符串与Null进行拼接操作，结果返回Null</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;反模式不是使用NULL，反模式是将NULL作为一个普通值处理或者使用一个普通的值来代替NULL。<br>&nbsp;&nbsp;&nbsp;&nbsp;有一种情况可以将NULL视为普通值，那就是导入或者导出数据的时候。</p><h4 id="解决方案：将NULL作为特殊值"><a href="#解决方案：将NULL作为特殊值" class="headerlink" title="解决方案：将NULL作为特殊值"></a>解决方案：将NULL作为特殊值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;你需要理解SQL的三值逻辑。true、false和NULL。</p><h5 id="在标量表达式中使用NULL"><a href="#在标量表达式中使用NULL" class="headerlink" title="在标量表达式中使用NULL"></a>在标量表达式中使用NULL</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;假如Bob的年龄未知，Alice的年龄也未知，我问你，他两谁的年纪大，你肯定回答不知道。那么这就是NULL = NULL的结果是NULL。<br>&nbsp;&nbsp;&nbsp;&nbsp;下表列举一些程序员期望得到某种结果，但是不如人意的情况。<br><img src="/images/sql/antipatterns/14/null_1.png" alt="USQL"></p><h5 id="在布尔表达式中使用NULL"><a href="#在布尔表达式中使用NULL" class="headerlink" title="在布尔表达式中使用NULL"></a>在布尔表达式中使用NULL</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;下表列举一些程序员期望得到某种结果，但是不如人意的情况。<br><img src="/images/sql/antipatterns/14/null_2.png" alt="USQL"></p><h5 id="检索NULL值"><a href="#检索NULL值" class="headerlink" title="检索NULL值"></a>检索NULL值</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你需要使用is null等语句</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;在SQL-99标准中，定义了一个比较断言 is distinct from，它在操作NULL时，会返回true或者false。以下两个查询等价</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">or</span> assigned_to &lt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to <span class="keyword">is</span> <span class="keyword">distinct</span> <span class="keyword">from</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;你也可以将NULL做为参数传入</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to <span class="keyword">is</span> <span class="keyword">distinct</span> <span class="keyword">from</span> ?;</span><br></pre></td></tr></table></figure><h5 id="声明NOT-NULL的列"><a href="#声明NOT-NULL的列" class="headerlink" title="声明NOT NULL的列"></a>声明NOT NULL的列</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果NUll会破坏程序逻辑或NULL本身就是毫无意义的，那么使用NOT NULL吧。比如bug表中的date_report, report_by, status。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果有人建议你使用default值，这并不是通用的，比如report_by应该总是非NULL的，如果要定义默认值，那么定义什么默认值。</p><h5 id="动态默认值"><a href="#动态默认值" class="headerlink" title="动态默认值"></a>动态默认值</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你只是某一请求需要使用默认值，那么你就在查询时使用COALESCE()，或者IFNULL()</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="keyword">IFNULL</span>(first_name, <span class="string">''</span>), <span class="keyword">IFNULL</span>(last_name, <span class="string">''</span>)) <span class="keyword">as</span> <span class="string">'full_name'</span> <span class="keyword">from</span> <span class="keyword">account</span>;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;接受NULL来表示任意类型的悬空值</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式13-乱用索引</title>
      <link href="/2018/09/02/sql/antipatterns/13-%E4%B9%B1%E7%94%A8%E7%B4%A2%E5%BC%95/"/>
      <url>/2018/09/02/sql/antipatterns/13-%E4%B9%B1%E7%94%A8%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h4 id="目的：优化性能"><a href="#目的：优化性能" class="headerlink" title="目的：优化性能"></a>目的：优化性能</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;改善性能最好的技术就是合理使用数据库中的索引。索引也是数据结构，他可以帮助快速定位到相应的行，而不需要野蛮的自上而下全表遍历。</p><h4 id="反模式：无规划的使用索引"><a href="#反模式：无规划的使用索引" class="headerlink" title="反模式：无规划的使用索引"></a>反模式：无规划的使用索引</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;软件开发人员通常猜测的来选择索引，那么就不可避免的犯一些错误</p><ol><li>不使用索引或索引不足</li><li>使用了太多索引或者使用了一些无效的索引</li><li>执行一些让索引无能为力的查询</li></ol><h5 id="无索引"><a href="#无索引" class="headerlink" title="无索引"></a>无索引</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;通常我们知道数据库为了保持同步索引会增加额外的开销。每一次insert，update，数据库不得不更新索引的数据结构来保证数据一致。<br>&nbsp;&nbsp;&nbsp;&nbsp;我们已经习惯额外的开销都是浪费的。但却忽略了一个事实，索引能够带给你的好处远远大于它的开销。除了在你select的时候能够快速定位数据。在你update，delete时，索引也能帮你快速找到你要更新的数据。如下SQL，bug_id的索引能有效的提升效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> bug <span class="keyword">set</span> <span class="keyword">status</span> = <span class="string">'FIXED'</span> <span class="keyword">where</span> bug_id = <span class="number">1234</span></span><br></pre></td></tr></table></figure><h5 id="索引太多"><a href="#索引太多" class="headerlink" title="索引太多"></a>索引太多</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你只有在使用索引查询时才能收益。对于那些你不使用的索引，你没有任何好处。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line">bug_id <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">date_report <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">summary varcahr(<span class="number">80</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">hour</span> <span class="built_in">numeric</span>(<span class="number">9</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">index</span>(bug_id),</span><br><span class="line"><span class="keyword">index</span>(summary),</span><br><span class="line"><span class="keyword">index</span>(<span class="keyword">hour</span>),</span><br><span class="line"><span class="keyword">index</span>(bug_id, date_report, <span class="keyword">status</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这个例子中，有几个无用的索引：</p><ul><li>bug_id：为主键，数据库会自动为主键创建索引，因此再定义一个索引就是冗余的操作，这个索引没有任何好处。</li><li>summary：对于长字符串，比如varchar(80)这种类型的索引要比更为紧凑数据类型的索引大很多。而且你好像不可能使用summary进行全匹配查找。</li><li>hour：你不太可能按照特定的值去搜索的列</li><li>bug_id, date_report, status：使用组合查询是一个很好的选择，但大多数人创建的组合索引通常都是冗余索引或很少使用。同样的，组合索引的列的顺序也是很重要的：<strong>你需要在查询条件，联合条件或者排序规则上使用定义索引时的从左到右的顺序。</strong></li></ul><h5 id="索引也无能为力"><a href="#索引也无能为力" class="headerlink" title="索引也无能为力"></a>索引也无能为力</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;接下来常犯的错误就是进行一个无法使用索引的查询。<br>&nbsp;&nbsp;&nbsp;&nbsp;比如电话簿是按照先姓后名的方式对联系人排序的，就像一个按照last_name,first_name顺序创建的联合索引一样，这种索引不能帮你按照名来进行快速查找。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> telephone_book <span class="keyword">on</span> <span class="keyword">account</span>(last_name, first_name);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;那么以下查询无法使用索引</p><ul><li>select * from telephone_book order by first_name, last_name;<br>这个查询就是上面说的，如果你创建了一种先last_name再first_name顺序的索引，那么它是不会帮你先按照first_name进行排序的。</li><li>select * from bug where MONTH(date_report) = 4;<br>即使你为date_report创建了索引，因为在索引中是按照完整的日期来进行排序的，所以你想单独使用它的月份查询是不行的。</li><li>select * from telephone_book where last_name = ‘Charles’ or first_name = ‘Charles’;<br>你定义的是联合索引，那么索引是根据两列进行排序的，所以你无法按照其中某一项来使用索引查询。</li><li>select * from bug where description lisk ‘%crash%’<br>即使你为description定义了索引，由于这个查询断言的匹配字串可能出现在该字段的任何部分，因此索引结构也帮不上忙。</li></ul><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当出现以下情况时，可能是反模式</p><ol><li>这是我的查询语句，怎样使它更快？</li><li>我在每个字段上都定义了索引，为什么它没有变的更？</li><li>我听说索引会使数据库变慢，所以我不使用它。</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你需要设计一个普通的数据库，不了解那些查询时需要重点优化的，你就不能确定哪些索引是最好的。你需要大胆的猜测，你可能创建一些无用的索引，但是你必须去尝试。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>分离率</strong>是衡量索引的一个指标，它是一张表中，所有不重复的数量和总记录条数之比：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">status</span>) / <span class="keyword">count</span>(<span class="keyword">status</span>) <span class="keyword">from</span> bug;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>分离率越低，索引效率就越低</strong>，你需要时刻关注，并抛弃哪些低效的索引。</p><h4 id="解决方案：MENTOR你的索引"><a href="#解决方案：MENTOR你的索引" class="headerlink" title="解决方案：MENTOR你的索引"></a>解决方案：MENTOR你的索引</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;MENTOR：测量(Measure)，解释(Explain)，挑选(Nominate)，测试(Test)，优化(Optimize)，重建(Rebuild)</p><h5 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;大多数据库都提供一些方法来记录执行SQL查询的时效，那么就可以定位到哪些SQL最耗时，并优化。</p><ul><li>Oracle 和 SQL Server都有SQL跟踪功能和工具来生成分析相应报表，SQLServer 称之为 SQL Server Profiler，Oracle称之为TKProf。</li><li>MySQL 和 PostgreSQL 会记录耗时超过一个特定值的查询请求。MySQL称之为慢查询日志，其配置文件中long_query_time项默认为10秒。PostgreSQL有一个类似的配置叫做log_min_duration_statement。</li><li>postgreSQL还有一个配套的工具叫做pgFouine，它能帮助你对查询日志进行分析，并且定位出哪些需要格外注意的查询请求</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;你在做以上操作进行优化时，记得禁止所有缓存，他会影响数值。分析完后记得关闭profiler，或降低profiler运行的频率。</p><h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;找到了最耗时的SQL，接下来就是要找出它之所以慢的原因。每个数据都使用一种优化工具为每次查询选择合适索引。你可以让数据库生成一份它所作做分析的报表。<br>&nbsp;&nbsp;&nbsp;&nbsp;每种数据库的语法不尽相同。</p><table><thead><tr><th>数据库</th><th>QEP报表方案</th></tr></thead><tbody><tr><td>IBM DB2</td><td>EXPLAIN, db2expln命令, Visual Explain</td></tr><tr><td>SQL Server</td><td>SET SHOWPLAN_XML, Display Execution plan</td></tr><tr><td>MySQL</td><td>EXPLAIN</td></tr><tr><td>Oracle</td><td>EXPLAIN PLAN</td></tr><tr><td>PostgreSQL</td><td>EXPLAIN</td></tr><tr><td>SQLite</td><td>EXPLAIN</td></tr></tbody></table><p>&nbsp;&nbsp;&nbsp;&nbsp;看一个简单QEP报表(MySQL)。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> bug.* <span class="keyword">from</span> bug</span><br><span class="line"><span class="keyword">join</span> (bug_product <span class="keyword">join</span> product <span class="keyword">using</span>(product_id)) <span class="keyword">using</span>(bug_id)</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">summary</span> <span class="keyword">like</span> <span class="string">'%crash%'</span></span><br><span class="line"><span class="keyword">and</span> product_name = <span class="string">'Open RoundFile'</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> date_report <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/sql/antipatterns/13/explain_result.png" alt="QEP报表结果"><br>&nbsp;&nbsp;&nbsp;&nbsp;结果中的key这一列表明这个查询使用的索引。<br>&nbsp;&nbsp;&nbsp;&nbsp;like表达式，强制bug表中进行全表遍历。<br>&nbsp;&nbsp;&nbsp;&nbsp;product.product_name列上没有索引，我们可以建立索引增加效率。</p><h5 id="挑选"><a href="#挑选" class="headerlink" title="挑选"></a>挑选</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;有了报表，你应该挑选出哪些被你漏掉的但能起到比较好效果的索引。数据库都有提供一些工具，你可以详细了解一下，如:</p><ul><li>IBM DB2 Design Advisor</li><li>SQL Server Database Engine Tuning Advisor</li><li>MySQL Enterprise Query Advisor</li><li>Oracle Automatic SQL Tuning Advisor</li></ul><h6 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;这是一个额外的话题，但是他能极大提升效率。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果一个索引包含我们所需要的所有列，那么就不需要再从表中获取数据了。<br>&nbsp;&nbsp;&nbsp;&nbsp;想象一下，如果电话簿中的条目只包含一个页码，在你找到一个名字后，你不得不翻到对应的页码才能获取所需要的号码。如果将这两步整和成一步是不是会更合理，由于电话簿是排序的，所以找到一个名字很快的，然后在一个条目中可以包含一个字段存储电话号码，甚至地址。<br>&nbsp;&nbsp;&nbsp;&nbsp;这就是索引覆盖的作用，你可以定义一个索引包含额外的列，即使这些列对于这个索引来说并不是必须包含的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> bug_convering <span class="keyword">on</span> bug (<span class="keyword">status</span>, bug_id, date_report, report_by, summary)</span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">status</span>, bug_id, date_report, report_by, summary <span class="keyword">from</span> bug <span class="keyword">where</span> <span class="keyword">status</span> = <span class="string">'OPEN'</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你定义的索引是1，那么查询语句2就不用去表中查询了，直接在索引的数据结构中就能获取结果，因为查询语句2所查询的所有的列都包含在索引中。</p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;这一步很重要，在创建完索引后，并不是万事大吉，你需要跟踪那些查询，需要确认你的改动确实提升了性能，然后才能确定工作完成。</p><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;索引是小型的、频繁使用的数据结构，因此很适合常驻内存，毕竟内存操作比磁盘IO要快很多倍。<br>&nbsp;&nbsp;&nbsp;&nbsp;数据库服务允许你配置缓存所需要的系统内存大小，大多数默认配置都是最小的。所以你需要调整这个值。<br>&nbsp;&nbsp;&nbsp;&nbsp;使用索引预加载方法可能要比通过数据库活动本身将最频繁使用的数据与索引放入缓存更有效一点。比如MySQL中，使用LOAD INDEX INTO CACHE 语句。</p><h5 id="重建"><a href="#重建" class="headerlink" title="重建"></a>重建</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;索引在平衡的时候效率是最高的，当你更新或删除时，索引就会不平衡，就如文件系统中随着时间推移产生很多磁盘碎片一样。所以你想最大限度的使用索引，就必须定期对索引进行维护。<br>&nbsp;&nbsp;&nbsp;&nbsp;每个数据库维护索引的语句都有区别</p><table><thead><tr><th>数据库</th><th>索引维护命令</th></tr></thead><tbody><tr><td>DB2</td><td>REBUILD INDEX</td></tr><tr><td>SQL Server</td><td>ALTER INDEX … REORGANIZE, ALTER INDEX … REBUILD, or DBCC DBREINDEX</td></tr><tr><td>MySQL</td><td>ANALYZE TABLE or OPTIMIZE TABLE</td></tr><tr><td>Oracle</td><td>ALTER INDEX … REBUILD</td></tr><tr><td>PostgreSQL</td><td>VACUUM or ANALYZE</td></tr></tbody></table><p>&nbsp;&nbsp;&nbsp;&nbsp;那么多久重建一次索引？这个需要你自己定夺。至于花上一小时时间来重构一个使用很少的索引，获得1%的性能提升，这个也没有必要。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>了解你的数据，了解你的查询请求，然后MENTOR你的索引。</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式12-幽灵文件</title>
      <link href="/2018/08/30/sql/antipatterns/12-%E5%B9%BD%E7%81%B5%E6%96%87%E4%BB%B6/"/>
      <url>/2018/08/30/sql/antipatterns/12-%E5%B9%BD%E7%81%B5%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;在一次灾难中，你的服务器硬件机架整个倾倒，导致大量硬盘损坏，庆幸的是IT部分灾备做的比较好，你们有一份和上次备份一样的完整副本。但是在冒烟测试中你们发现所有的图片都不能加载，这是才想起来所有的文件都存在/var目录下。</p><h4 id="目的：存储图片或其他媒体大文件"><a href="#目的：存储图片或其他媒体大文件" class="headerlink" title="目的：存储图片或其他媒体大文件"></a>目的：存储图片或其他媒体大文件</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;本章的目标就是要存储这些图片并且将其和数据库实体管理起来，当查询这些实体时，我们需要确保同时能获取与其关联的图片。</p><h4 id="反模式：假设你必须使用文件系统"><a href="#反模式：假设你必须使用文件系统" class="headerlink" title="反模式：假设你必须使用文件系统"></a>反模式：假设你必须使用文件系统</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;理论上来说，图片是一个字段，在account表中可能有一个portrait_image列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">account</span>(</span><br><span class="line"><span class="comment">-- some columns</span></span><br><span class="line">portrait_image <span class="built_in">BLOB</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你需要一条记录对应多个文件，比如bug表对应多个截图，你可以建立从属表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> screenshot(</span><br><span class="line">image_id <span class="built_in">serial</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">screenshot_image <span class="built_in">blob</span>,</span><br><span class="line">caption <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">primary <span class="keyword">key</span> (image_id, bug_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(bug_id) <span class="keyword">references</span> bug(bug_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这些都不难理解，最纠结的在于，应该使用将二进制格式存储在blob类型中，还是将文件保存在文件系统中，然后用一个varchar类型来保存路径。这两种方式都有其存在的道理，一般程序员会选择第二种，接下来的几节就是要指明这样设计面临的风险。</p><h5 id="文件不支持delete"><a href="#文件不支持delete" class="headerlink" title="文件不支持delete"></a>文件不支持delete</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;第一个问题就是垃圾回收，如果文件在数据库之外，你想删除包含这个路劲的记录，没有什么办法能自动的删除文件，除非你新写一个脚本程序来监视其“无人领养”的图片。</p><h5 id="文件不支持事务隔离"><a href="#文件不支持事务隔离" class="headerlink" title="文件不支持事务隔离"></a>文件不支持事务隔离</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;通常，当更新或删除数据，在commit之前，所有的更改对其他客户端不可见。然而数据库之外的操作并非如此，当你删除一个文件，对于其他的客户端来说就立刻无法访问该图片，同时你修改文件，其他客户端也可以立即看到，而不是看到在事务提交之前的文件状态。</p><h5 id="文件不支持回滚操作"><a href="#文件不支持回滚操作" class="headerlink" title="文件不支持回滚操作"></a>文件不支持回滚操作</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;出错情况下，或者程序逻辑要求取消变更时，事务回滚再正常不过了。但是当你执行一句delete语句来删除一条记录并同时移除对应的截屏文件，然后你回滚了这个操作，被删除的数据回来了，但是文件没了。</p><h5 id="文件不支持数据库备份工具"><a href="#文件不支持数据库备份工具" class="headerlink" title="文件不支持数据库备份工具"></a>文件不支持数据库备份工具</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;多数数据库都提供了备份工具，如，mysql提供了mysqldump，Oracle提供了rman，postgreSQL提供了pg_dump等。这些工具都不知道如何将路劲引用的那些文件包含在备份操作中。所以你需要记住执行两步来备份：使用数据库备份工具，然后使用文件系统备份工具手机外部文件。即使如此，你也不能保证外部文件和数据库备份是否一致</p><h5 id="文件不支持SQL的访问权限设置"><a href="#文件不支持SQL的访问权限设置" class="headerlink" title="文件不支持SQL的访问权限设置"></a>文件不支持SQL的访问权限设置</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;外部文件会绕开grant 和 revoke SQL语句设定的访问权限，SQL权限管理着对表和列的访问，但他们不能应用到外部文件。</p><h5 id="文件不是sql数据类型"><a href="#文件不是sql数据类型" class="headerlink" title="文件不是sql数据类型"></a>文件不是sql数据类型</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;screenshot_image保存的是路径，数据无法保证这个路劲是否正确，当你修改、移动文件时，数据库也不会更新该字段，这些都依赖于你程序的逻辑。</p><h4 id="如何识别反模式："><a href="#如何识别反模式：" class="headerlink" title="如何识别反模式："></a>如何识别反模式：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;典型的使用反模式的项目通常没有考虑以下几个或者全部问题</p><ol><li>数据备份和恢复的过程是怎样的？怎么对一个备份进行验证？你有没有在一个干净的系统或者别的系统上对备份回复的数据进行测试？</li><li>图片文件堆积在那里，还是当他们孤立的时候就从系统中移除？移除他们的过程是怎么样的？这是一个自动的还是手动的过程？</li><li>系统中的哪些用户有权限查看这些图片？进入权限是怎么限制的？当用户请求查看他们无权查看的图片时会发生什么？</li><li>我能撤销对图片的变更吗？如果能，是应用程序来恢复图片之前的状态吗？</li></ol><h4 id="合理使用反模式："><a href="#合理使用反模式：" class="headerlink" title="合理使用反模式："></a>合理使用反模式：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;如下是将图片或者大文件存储在数据库之外的好理由</p><ol><li>这个数据库在没有图片的时候能精艺很多，因为图片相比于简单的数据类型来说大很多；</li><li>当不包含图片时备份数据库会更快并且备份的文件更小。你必须额外的执行一次文件备份，但这些比备份一个大型数据库要更容易管理；</li><li>如果图片是存储在数据库之外的文件系统中，对图片的预览或者编辑就能够使用更简单直接的处理方式。如果这些图片存在文件系统中的好处是重要的，那么可以将大文件存储在数据库之外。</li><li>一些数据库产品提供了特殊的SQL数据类型，Oracle里面的BFile，SQL Server2008里面的FileStream。</li></ol><h4 id="解决方案：在需要的时候使用BLOB类型。"><a href="#解决方案：在需要的时候使用BLOB类型。" class="headerlink" title="解决方案：在需要的时候使用BLOB类型。"></a>解决方案：在需要的时候使用BLOB类型。</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;如果在以上反模式所描述的问题对你的程序有影响，你需要考虑将文件保存到数据库中。如果你将文件保存到数据库中，以上反模式的风险都将迎刃而解。而且几乎所有的数据库产品都支持BLOB类型，支持你存储任何二进制数据。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你考虑到大文件blob存储不了，大多数据库都帮你考虑到了这一点，比如mysql的mediumblob类型最大存储16M，Oracle的longraw或blob最大支持2GB或4GB的长度。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你的数据库一开始是以文件的形式保存的，一些数据库也提供了加载外部文件的函数，如mysql的load_file()</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> screenshot <span class="keyword">set</span> screenshot_image = <span class="keyword">load_file</span>(<span class="string">"image/usql.png) where image_id = 123;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;你还可以将二进制直接从blob中提取并显示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> screenshot_image <span class="keyword">into</span> <span class="keyword">dumpfile</span> <span class="string">'image/usql.png'</span> <span class="keyword">from</span> screenshot <span class="keyword">where</span> image_id = <span class="number">123</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;存储在数据库之外的数据不由数据库管理</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式11-每日新花样(限定列的有效值)</title>
      <link href="/2018/08/22/sql/antipatterns/11-%E6%AF%8F%E6%97%A5%E6%96%B0%E8%8A%B1%E6%A0%B7(%E9%99%90%E5%AE%9A%E5%88%97%E7%9A%84%E6%9C%89%E6%95%88%E5%80%BC)/"/>
      <url>/2018/08/22/sql/antipatterns/11-%E6%AF%8F%E6%97%A5%E6%96%B0%E8%8A%B1%E6%A0%B7(%E9%99%90%E5%AE%9A%E5%88%97%E7%9A%84%E6%9C%89%E6%95%88%E5%80%BC)/</url>
      
        <content type="html"><![CDATA[<h4 id="目标：限定列的有效值"><a href="#目标：限定列的有效值" class="headerlink" title="目标：限定列的有效值"></a>目标：限定列的有效值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;限定列的有效值是非常有用的，比如bug表的status，我们定义check约束，让它只允许保存(“NEW”,”IN PROGRESS”,”FIXED”)，那么它就会拒绝所有不存在以上集合中的无效值。但是定义check约束，我们日后改如何修改限定有效值呢？这就是本章所讲的反模式。</p><h4 id="反模式：在列定义上指定可选值-约束"><a href="#反模式：在列定义上指定可选值-约束" class="headerlink" title="反模式：在列定义上指定可选值(约束)"></a>反模式：在列定义上指定可选值(约束)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;很多数据库设计人员趋向于在定义列的时候指定所有可选的有效值。如下DDL：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- check 约束</span><br><span class="line">create table bug(</span><br><span class="line">-- other columns</span><br><span class="line">status varchar(<span class="number">20</span>) check (status in (<span class="string">'NEW'</span>,<span class="string">'IN PROGRESS'</span>,<span class="string">'FIXED'</span>))</span><br><span class="line">);</span><br><span class="line">-- 或者使用mysql支持的<span class="class"><span class="keyword">enum</span>约束</span></span><br><span class="line">create table bug(</span><br><span class="line">-- other columns</span><br><span class="line">status <span class="class"><span class="keyword">enum</span>('<span class="title">NEW</span>','<span class="title">IN</span> <span class="title">PROGRESS</span>','<span class="title">FIXED</span>')</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="中间的是哪个"><a href="#中间的是哪个" class="headerlink" title="中间的是哪个"></a>中间的是哪个</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;假设你开发用户界面，有一个下拉框显示所有的status。你第一反应可能是查询当前正在被使用的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">status</span> <span class="keyword">from</span> bug;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;然而，如果所有的bug都是新建的，那么你只能得到NEW这个值。还有如果你使用这个查询来填充你的下拉框，这就会变成一个先有鸡还是有蛋的问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;当然你还有另一种方式，就是获取元数据的值，也就是定义约束的值。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column_type </span><br><span class="line"><span class="keyword">from</span> information_schema.<span class="keyword">columns</span></span><br><span class="line"><span class="keyword">where</span> table_schema = <span class="string">'bugtracker'</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">table_name</span> = <span class="string">'bug'</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">column_name</span> = <span class="string">'status'</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但是你还是无法简单的获取到有效值。如果mysql，以上会返回一个类型为longtext，内容为enum(‘NEW’,’IN PROGRESS’,’FIXED’)的结果，其中包含括号、逗号、引号。你必须编写一点额外的程序来解析这个字符串。</p><h5 id="添加新口味"><a href="#添加新口味" class="headerlink" title="添加新口味"></a>添加新口味</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;没有什么语法能后从enum或者check约束中，添加或删除一个值，你只能使用一个新的集合定义到这个列。如添加一个DUPLICATE的值。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table bug modify column status <span class="class"><span class="keyword">enum</span>('<span class="title">NEW</span>','<span class="title">IN</span> <span class="title">PROGRESS</span>','<span class="title">FIXED</span>', '<span class="title">DUPLICATE</span>');</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这个操作会重新构建一张使用的表，在生产环境应该是极少的，开销也是巨大的。修改了元数据，意味着你要花更大的力气来测试稳定性。</p><h5 id="老的口味永不消失"><a href="#老的口味永不消失" class="headerlink" title="老的口味永不消失"></a>老的口味永不消失</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你打算废弃一个状态，比如，将FIXED状态拆分成CODE COMPLETE和VERIFIED两个状态：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table bug modify column status <span class="class"><span class="keyword">enum</span>('<span class="title">NEW</span>','<span class="title">IN</span> <span class="title">PROGRESS</span>','<span class="title">CODE</span> <span class="title">COMPLETE</span>', '<span class="title">VERIFIED</span>');</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但是大多数情况下，这条语句会执行错误，因为表数据中存在FIXED的值。</p><h5 id="可移植性低"><a href="#可移植性低" class="headerlink" title="可移植性低"></a>可移植性低</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;check约束、域和UDT在各数据库的支持形式是不一致的。enum更加是mysql独有的。</p><h4 id="如何识别反模式："><a href="#如何识别反模式：" class="headerlink" title="如何识别反模式："></a>如何识别反模式：</h4><p>当出现以下情况时，可能是反模式</p><ol><li>我们不得不将数据库下线，才能在程序中加入一个新的选项。</li><li>这个Status列可以填入这些候选值中的一个。我们不应该改变这个后选值列表。</li><li>程序代码中关于业务规则的选项列表和数据库中的值又不同步了。</li></ol><h4 id="解决方案：在数据中指定值"><a href="#解决方案：在数据中指定值" class="headerlink" title="解决方案：在数据中指定值"></a>解决方案：在数据中指定值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;也就是创建一张检查表bug_status，其中bug中每一行的值为bug_status中的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_status(</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">varchar</span>(<span class="number">20</span>) primary <span class="keyword">key</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug_status(<span class="keyword">status</span>) <span class="keyword">values</span>(<span class="string">'NEW'</span>),(<span class="string">'IN PROGRESS'</span>),(<span class="string">'FIXED'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line"><span class="comment">-- other columns</span></span><br><span class="line"><span class="keyword">status</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (<span class="keyword">status</span>) <span class="keyword">references</span> bug_status(<span class="keyword">status</span>) <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;该设计能让你有效的更新检查表中的值</p><ol><li>增加一个选项<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug_status(<span class="keyword">status</span>)<span class="keyword">values</span>(<span class="string">'DUPLICATE'</span>);</span><br></pre></td></tr></table></figure></li><li>如果外键使用了on update cascade，重命名一个选项<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> bug_status <span class="keyword">set</span> <span class="keyword">status</span> = <span class="string">'INVALID'</span> <span class="keyword">where</span> <span class="keyword">status</span> = <span class="string">'BOGUS'</span>;</span><br></pre></td></tr></table></figure></li><li>支持废弃的数据<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table bug_status <span class="builtin-name">add</span> column active enum(<span class="string">'INACTIVE'</span>,<span class="string">'ACTIVE'</span>) <span class="keyword">not</span> <span class="literal">null</span><span class="built_in"> default </span><span class="string">'ACTIVE'</span>;</span><br><span class="line">update bug_status <span class="builtin-name">set</span> active = <span class="string">'INACTIVE'</span> where status =<span class="string">'DUPLICATE'</span>;</span><br><span class="line">select * <span class="keyword">from</span> bug_status where active = <span class="string">'ACTIVE'</span>;</span><br></pre></td></tr></table></figure></li></ol><h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><ol><li>在验证固定集合的候选值时使用元数据；</li><li>在验证可变集合的候选值时使用数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式10-取整错误</title>
      <link href="/2018/08/22/sql/antipatterns/10-%E5%8F%96%E6%95%B4%E9%94%99%E8%AF%AF/"/>
      <url>/2018/08/22/sql/antipatterns/10-%E5%8F%96%E6%95%B4%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="目标：使用小数取代整数"><a href="#目标：使用小数取代整数" class="headerlink" title="目标：使用小数取代整数"></a>目标：使用小数取代整数</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;整数是一个很有用的数据类型，但是只能存出整数，但是它不能表示像“2.5”这样的浮点型。如果数据对精度要求很好，你需要使用另一种数据类型来代替整形。当然还要保证运算结果必须正确。</p><h4 id="反模式：使用FLOAT类型"><a href="#反模式：使用FLOAT类型" class="headerlink" title="反模式：使用FLOAT类型"></a>反模式：使用FLOAT类型</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;SQL中的float类型，和其他大多数编程语言的float一样，根据IEEE754标准使用二进制格式编码实数数据。你需要了解一些浮点数的定义规范，才能有效的使用这个数据类型。</p><h5 id="舍入的必要性"><a href="#舍入的必要性" class="headerlink" title="舍入的必要性"></a>舍入的必要性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;很多程序员并不清楚浮点类型的特性：并不是所有十进制中描述的信息都能使用二进制存储。出于一些必要因素，浮点数通常会舍入到一个非常近似的值。<br>&nbsp;&nbsp;&nbsp;&nbsp;举例来说，1/3用一个无限循环的十进制可以表示为0.333<del>~</del>，其真实值无法完整的写出来，因此折中的方法就是限制精度，选择一个尽可能接近原始值的数据，比如0.333。然而，这个数字却不是我们所希望的值。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>/<span class="number">3</span> + <span class="number">1</span>/<span class="number">3</span> + <span class="number">1</span>/<span class="number">3</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0.333</span> + <span class="number">0.333</span> + <span class="number">0.333</span> = <span class="number">0.999</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;即使提高精度，也无法将这三个值加起来等于1.0.这就是使用有限精度的数表示无限小数的必要妥协。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>/<span class="number">3</span> + <span class="number">1</span>/<span class="number">3</span> + <span class="number">1</span>/<span class="number">3</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0.333333</span> + <span class="number">0.333333</span> + <span class="number">0.333333</span> = <span class="number">0.999999</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;IEEE754使用二进制表示浮点数。十进制中的无限小数在二进制中的表达方式是完全不同的。然后一些十进制有限小数，比如0.1，在二进制中确实无限小数。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> * <span class="number">2</span> = <span class="number">0.2</span>     ----<span class="number">-0</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span>     ----<span class="number">-0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span>     ----<span class="number">-0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span>     ----<span class="number">-1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span>     ----<span class="number">-1</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span>     ----<span class="number">-0</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="comment">//你懂的 0.0001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure><h5 id="在SQL中使用FLOAT"><a href="#在SQL中使用FLOAT" class="headerlink" title="在SQL中使用FLOAT"></a>在SQL中使用FLOAT</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;有些数据库能够通过某种方式来弥补数据的不精准性，输出我们期望的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> hourly_rate <span class="keyword">from</span> <span class="keyword">Account</span> <span class="keyword">where</span> account_id=<span class="number">123</span>   ;</span><br><span class="line"><span class="comment">-- Result:59.95</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但float类型的列中实际存储的数据可能并不等于他的值。如果将这个值方法十亿倍，或者将他作为查询条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> hourly_rate * <span class="number">100000000</span> <span class="keyword">from</span> <span class="keyword">Account</span> <span class="keyword">where</span> account_id=<span class="number">123</span>;</span><br><span class="line"><span class="comment">-- Result:59950000762.939</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> hourly_rate = <span class="number">59.95</span>;</span><br><span class="line"><span class="comment">-- Result:empty set; no rows match</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;所以你需要将查询条件修改成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> <span class="keyword">ABS</span>(hourly_rate - <span class="number">59.95</span>) &lt; <span class="number">0.00001</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;另一个使用合计函数计算很多值的时候，影响比较明显，比如使用sum()计算某一列的所有值。举个例子，如果你用<code>1*1.0</code>，无论你执行多少次，结果都是1。但是你用<code>1*0.999</code>，结果就完全不同，执行一千次你的得到的结果约等于0.3677。</p><h4 id="如何识别反模式："><a href="#如何识别反模式：" class="headerlink" title="如何识别反模式："></a>如何识别反模式：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;任何使用Float、Real或者Double Percent类型的设计都有可能是反模式。</p><h4 id="合理使用反模式："><a href="#合理使用反模式：" class="headerlink" title="合理使用反模式："></a>合理使用反模式：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;如果要存储的值取值范围很大，大于integer、numeric的范围，那只能用float了。科学计算类的程序通常使用float。<br>&nbsp;&nbsp;&nbsp;&nbsp;orale使用的float是精准值，而binary_float使用的是IEEE754标准编码。</p><h4 id="解决方案：使用numeric、decimal类型"><a href="#解决方案：使用numeric、decimal类型" class="headerlink" title="解决方案：使用numeric、decimal类型"></a>解决方案：使用numeric、decimal类型</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;使用的numeric或decimal类型来代替float及其类似的数据类型进行固定精度的小数存储。numeric、decimal，他们不会对存储的有理数进行舍入，所以他保存的值和原始的值是一致的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> bug <span class="keyword">add</span> <span class="keyword">column</span> <span class="keyword">hours</span> <span class="built_in">decimal</span>(<span class="number">9</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;其中9代表你可以存储123456789，而1234567890则为非法值。2表示你可以存储1234567.89，而12345678.91、123456.789都为非法值。<br>&nbsp;&nbsp;&nbsp;&nbsp;你依旧不能存储1/3的值，它应该当作非精度的值来处理。</p><h4 id="结论：尽可能不要使用浮点数"><a href="#结论：尽可能不要使用浮点数" class="headerlink" title="结论：尽可能不要使用浮点数"></a>结论：尽可能不要使用浮点数</h4>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 安装 MySQL 服务</title>
      <link href="/2018/08/21/android/Android%20%E5%AE%89%E8%A3%85%20MySQL%20%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/08/21/android/Android%20%E5%AE%89%E8%A3%85%20MySQL%20%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;由于许多原因USQL移除本地MySQL功能，需要者可以参照以下教程来完成。</p><h4 id="介绍：版本为5-1-57编译而来。"><a href="#介绍：版本为5-1-57编译而来。" class="headerlink" title="介绍：版本为5.1.57编译而来。"></a>介绍：版本为5.1.57编译而来。</h4><ul><li>仅支持Myisam数据类型，不支持事务。</li><li>默认编码utf-8，可以支持gb2312。</li><li>默认root密码为123。</li><li>安装手机需要获取root权限。</li></ul><h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><p>地址：<a href="https://www.lanzous.com/i1pc7ni" target="_blank" rel="noopener">https://www.lanzous.com/i1pc7ni</a><br>密码：fr0r</p><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><ol><li>下载好以上压缩包，并解压</li><li>将<code>wj008.net</code>文件夹拷贝到/data目录下，此时路径应该为/data/wj008.net/mysql/**</li><li>把/data/wj008.net/目录下的mysqlstart，mysqlstop 拷贝到/system/bin/目录下</li><li>打开终端（你需要一个可以执行命令的app，如：Ansole），执行以下命令<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#后面为注释，不用执行。</span></span><br><span class="line">su  <span class="comment">#切换到root用户下</span></span><br><span class="line"><span class="keyword">chmod</span> +<span class="keyword">x</span> /<span class="keyword">system</span>/bin/mysqlstart  <span class="comment">#为mysqlstart增加执行权限</span></span><br><span class="line"><span class="keyword">chmod</span> +<span class="keyword">x</span> /<span class="keyword">system</span>/bin/mysqlstop   <span class="comment">#为mysqlstop增加执行权限</span></span><br><span class="line">/<span class="keyword">system</span>/bin/mysqlstart  <span class="comment">#启动mysql</span></span><br></pre></td></tr></table></figure></li><li>关闭mysql.<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/system/</span>bin<span class="regexp">/mysqlstop</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line"><span class="keyword">cd</span> <span class="string">/data/wj008.net/mysql/bin</span></span><br><span class="line"><span class="string">./mysql</span> -u root -p123   <span class="comment">#登录mysql</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;登录成功后，可以尝试创建数据库。如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;该版本默认已经配置了可以远程登录，你可以使用USQL登录，配置如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主机名：localhost</span><br><span class="line">数据库：test</span><br><span class="line">端口：<span class="number">3306</span></span><br><span class="line">用户名：root</span><br><span class="line">密码：<span class="number">123</span></span><br></pre></td></tr></table></figure><h4 id="有报错，留言说明"><a href="#有报错，留言说明" class="headerlink" title="有报错，留言说明"></a>有报错，留言说明</h4>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven打包不能下载插件(maven-clean-plugin)</title>
      <link href="/2018/08/18/java/maven%E6%89%93%E5%8C%85%E4%B8%8D%E8%83%BD%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6(maven-clean-plugin)/"/>
      <url>/2018/08/18/java/maven%E6%89%93%E5%8C%85%E4%B8%8D%E8%83%BD%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6(maven-clean-plugin)/</url>
      
        <content type="html"><![CDATA[<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在一个新环境(新电脑)，第一次执行<code>mvn package</code>，很有可能出先类似问题，具体报错信息如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Downloading</span> <span class="selector-tag">from</span> <span class="selector-tag">central</span>: <span class="selector-tag">https</span>:<span class="comment">//repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-clean-plugin/2.5/maven-clean-plugin-2.5.pom</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> <span class="selector-tag">------------------------------------------------------------------------</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> <span class="selector-tag">BUILD</span> <span class="selector-tag">FAILURE</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> <span class="selector-tag">------------------------------------------------------------------------</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> <span class="selector-tag">Total</span> <span class="selector-tag">time</span>: <span class="selector-tag">4</span><span class="selector-class">.222</span> <span class="selector-tag">s</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> <span class="selector-tag">Finished</span> <span class="selector-tag">at</span>: <span class="selector-tag">2018-08-18T14</span><span class="selector-pseudo">:54</span><span class="selector-pseudo">:25+08</span><span class="selector-pseudo">:00</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> <span class="selector-tag">Final</span> <span class="selector-tag">Memory</span>: <span class="selector-tag">8M</span>/<span class="selector-tag">27M</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> <span class="selector-tag">------------------------------------------------------------------------</span></span><br><span class="line"><span class="selector-attr">[ERROR]</span> <span class="selector-tag">Plugin</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.maven</span><span class="selector-class">.plugins</span><span class="selector-pseudo">:maven-clean-plugin</span><span class="selector-pseudo">:2.5</span> <span class="selector-tag">or</span> <span class="selector-tag">one</span> <span class="selector-tag">of</span> <span class="selector-tag">its</span> <span class="selector-tag">dependencies</span> <span class="selector-tag">could</span> <span class="selector-tag">not</span> <span class="selector-tag">be</span> <span class="selector-tag">resolved</span>: <span class="selector-tag">Failed</span> <span class="selector-tag">to</span> <span class="selector-tag">read</span> <span class="selector-tag">artifact</span> <span class="selector-tag">descriptor</span> <span class="selector-tag">for</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.maven</span><span class="selector-class">.plugins</span><span class="selector-pseudo">:maven-clean-plugin</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.5</span>: <span class="selector-tag">Could</span> <span class="selector-tag">not</span> <span class="selector-tag">transfer</span> <span class="selector-tag">artifact</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.maven</span><span class="selector-class">.plugins</span><span class="selector-pseudo">:maven-clean-plugin</span><span class="selector-pseudo">:pom</span><span class="selector-pseudo">:2.5</span> <span class="selector-tag">from</span>/<span class="selector-tag">to</span> <span class="selector-tag">central</span> (<span class="attribute">https</span>:<span class="comment">//repo.maven.apache.org/maven2): Received fatal alert: protocol_version -&gt; [Help 1]</span></span><br><span class="line">[ERROR] </span><br><span class="line">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</span><br><span class="line">[ERROR] Re-run Maven using the -X switch to enable full debug logging.</span><br><span class="line">[ERROR] </span><br><span class="line">[ERROR] For more information about the errors and possible solutions, please read the following <span class="attribute">articles</span>:</span><br><span class="line">[ERROR] [Help <span class="number">1</span>] <span class="attribute">http</span>:<span class="comment">//cwiki.apache.org/confluence/display/MAVEN/PluginResolutionException</span></span><br></pre></td></tr></table></figure><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;这个问题还有另一种表现方式，在你请求国外的https网站的接口时，有可能会抛出以下异常：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">javax</span><span class="selector-class">.net</span><span class="selector-class">.ssl</span><span class="selector-class">.SSLHandshakeException</span>: <span class="selector-tag">Received</span> <span class="selector-tag">fatal</span> <span class="selector-tag">alert</span>: <span class="selector-tag">handshake_failure</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这都是因为你请求的网站不支持较低版本的协议。而你需要做的就是将请求的协议设置成它所支持的。你可以去下面网站查询你请求的网站支持的协议。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//myssl.com</span></span><br></pre></td></tr></table></figure><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="maven打包是抛出这个异常"><a href="#maven打包是抛出这个异常" class="headerlink" title="maven打包是抛出这个异常"></a>maven打包是抛出这个异常</h5><p>** 开发中遇到 **</p><ol><li>在idea的Maven Projects 选项卡里右键 package，选择Create ‘XXXX’ [package]。</li><li>在弹出的窗口中，选择Runner里的VM Options中增加-Dhttps.protocols=TLSv1.2<br><img src="/images/java/maven-package-1.png" alt="操作流程图"></li><li>然后执行它。以后就不用执行了，可以正常的mvn clean package.<br><img src="/images/java/maven-package-2.png" alt="操作流程图"></li></ol><p>** 部署时遇到 **<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你在部署中遇到这个问题，此时你只能使用命令，没有idea帮你做上面的事情，你修改$MAVEN_HOME/bin/mvn文件，在第一行添加MAVEN_OPTS=”-Dhttps.protocols=TLSv1.2”，打包好记得去掉。</p><h5 id="请求https接口时抛出该异常"><a href="#请求https接口时抛出该异常" class="headerlink" title="请求https接口时抛出该异常"></a>请求https接口时抛出该异常</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;去我的csdn看吧，有时间再搬过来。<a href="https://blog.csdn.net/gege87417376/article/details/77936507" target="_blank" rel="noopener">https://blog.csdn.net/gege87417376/article/details/77936507</a></p>]]></content>
      
      
      <categories>
          
          <category> 踩坑日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> maven </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式09-元数据分裂</title>
      <link href="/2018/08/14/sql/antipatterns/09-%E5%85%83%E6%95%B0%E6%8D%AE%E5%88%86%E8%A3%82/"/>
      <url>/2018/08/14/sql/antipatterns/09-%E5%85%83%E6%95%B0%E6%8D%AE%E5%88%86%E8%A3%82/</url>
      
        <content type="html"><![CDATA[<h4 id="目标：支持可扩展性"><a href="#目标：支持可扩展性" class="headerlink" title="目标：支持可扩展性"></a>目标：支持可扩展性</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;随着数据量增长，数据库的查询性能也会随之下降，哪怕查询结果只是很少的几千行，遍历表中积累的数据也可能使整个查询性能变得极差，即使使用了索引，随着数据量增大，索引的作用也变得非常有限。<br>&nbsp;&nbsp;&nbsp;&nbsp;本章目标就是要优化数据库的结构来提升查询性能以及表的平滑扩展。</p><h4 id="反模式：克隆表与克隆列"><a href="#反模式：克隆表与克隆列" class="headerlink" title="反模式：克隆表与克隆列"></a>反模式：克隆表与克隆列</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;根据经验，我们知道查询一张表的性能和这张表的数据条数有关，越少的记录，查询速度更快。于是我们会想办法将每张表存储的记录尽可能少。这就导致本章反模式的两种表现。</p><ol><li>将一张很长的表拆分成多张较小的表，使用表中某一个特定的数据字段来给这些拆分出来的表命名。（比如按条数拆分表）</li><li>将一个列拆分成多个子列，使用别的列中的不同值给拆分出来的列命名。（比如按年份拆分列）</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;为了减少每张表的记录数，你不得不创建一些有很多列的表，或者创建很多很多表。但在这两个方案中，你会发现数据量的增长，会有越来越多的表或者列，迫使你创建新的schema对象。</p><h5 id="不断产生新表"><a href="#不断产生新表" class="headerlink" title="不断产生新表"></a>不断产生新表</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你按照年份来查分表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_2008(...);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_2009(...);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_2010(...);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;在保存数据时，你要操心，什么时候改插入哪张表。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert <span class="keyword">into</span> bug_2010(<span class="params">...</span>, date_report, <span class="params">...</span>) values(<span class="params">...</span>, <span class="string">'2010-01-01'</span>, <span class="params">...</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;在快进入到2010-01-01时，你的程序还有可能报错，原因是你忘记创建一张叫做bug_2010的表。</p><h5 id="管理数据完整性"><a href="#管理数据完整性" class="headerlink" title="管理数据完整性"></a>管理数据完整性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你统计2010年的bug数量时，发现有一部分数据出现了在bug_2009的表中，导致统计数据不正确。这时你需要在每一张表中都声明一个check约束。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table bug_2009(</span><br><span class="line">...</span><br><span class="line">date_report date<span class="built_in"> check </span>(extract(year from date_report) = 2009)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;某一天，你需要修改bug的日期，在数据库中存储的日期是2010-01-03，但顾客实际是在一周前（2009-12-27），使用传真报告的错误。你必须先修改bug_2010，再插入bug_2009，再删除bug_2010.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> bug_2010 <span class="keyword">set</span> date_report = <span class="string">'2009-12-27'</span> <span class="keyword">where</span> bug_id = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug_2009(..., date_report) <span class="keyword">values</span>(</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug_2010 <span class="keyword">where</span> bug_id = <span class="number">1234</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> bug <span class="keyword">where</span> bug_id = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;使用以上sql，你还可能会遇到，在bug_2010中bug_id已经存在bug_2009中，此时你该怎么选择。</p><h5 id="确保唯一性"><a href="#确保唯一性" class="headerlink" title="确保唯一性"></a>确保唯一性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果同步数据中bug_id重复，难倒你了，你可能会想到创建另外一张表，用来生成bug_id</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_id_generator(</span><br><span class="line">bug_id <span class="built_in">serial</span> primary <span class="keyword">key</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug_id_generator(bug_id) <span class="keyword">value</span>(<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug_2010(bug_id, ....)</span><br><span class="line"><span class="keyword">values</span>(<span class="keyword">last_insert_id</span>(), ....);</span><br></pre></td></tr></table></figure><h5 id="跨表查询"><a href="#跨表查询" class="headerlink" title="跨表查询"></a>跨表查询</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;不可避免，你一定有需求要查询所有的数据。此时你只能选择union 将所有的数据联合起来。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> count(<span class="number">1</span>) from (</span><br><span class="line"><span class="keyword">select</span> * from bug_2008</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">all</span></span></span><br><span class="line"><span class="keyword">select</span> * from bug_2009</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">all</span></span></span><br><span class="line"><span class="keyword">select</span> * from bug_2010</span><br><span class="line">) <span class="keyword">as</span> temp;</span><br></pre></td></tr></table></figure><h5 id="同步元数据"><a href="#同步元数据" class="headerlink" title="同步元数据"></a>同步元数据</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你要添加一列作为每个bug解决的时间，你需要同步之前创建的所有表，不然你在使用union语句会报错，或者你不使用通配符(*)，而是一个一个列出你要查询的列。</p><h5 id="管理引用完整性"><a href="#管理引用完整性" class="headerlink" title="管理引用完整性"></a>管理引用完整性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;使用拆分表，你不能建立一个外键约束，是因为sql是不支持的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">comment</span> (</span><br><span class="line">bug_id <span class="built_in">bigint</span> unsiged <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(bug_id) <span class="keyword">references</span> bug_???(bug_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;同时关联查询也是如此，如果你要统计某一个用户提交的所有bug数</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * from account a </span><br><span class="line">join (</span><br><span class="line"><span class="keyword">select</span> * from bug_2008</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">all</span></span></span><br><span class="line"><span class="keyword">select</span> * from bug_2009</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">all</span></span></span><br><span class="line"><span class="keyword">select</span> * from bug_2010</span><br><span class="line">) t on a.account_id = t.report_id</span><br></pre></td></tr></table></figure><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>当出现以下情况时，可能是反模式</p><ol><li>我们需要每……创建一张表或者列？</li><li>数据库支持的最大数量的表或者列是多少？</li><li>发现程序添加记录失败了：因为王佳伟新的一年添加新表了</li><li>如何查询很多张表？每张表的列都是一样的。<br>【如果你需要查询很多结构一样的表，就应该讲数据全部存储在一个表中，使用一个额外的属性列来分组数据】</li><li>如何将表名称作为一个表里传递？在查询是需要根据辩分动态的生成这些表名称。</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;手动分隔表的一个合理使用场景是“归档数据”—–将历史数据从日常使用的数据库中移除。通常在过期数据的查询变的非常稀少的情况下，才会进行如此的操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你没有同时查询当前数据和历史数据的需求，将老数据从当前活动的表转移到其他地方是很合适的操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;将数据归档到与当前表结构相兼容的新表中，既能支持偶尔做数据分析时的查询，同时能让日常数据查询边的非常高效。</p><h4 id="解决方案：分区并标准化"><a href="#解决方案：分区并标准化" class="headerlink" title="解决方案：分区并标准化"></a>解决方案：分区并标准化</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当一张表的数据量非常巨大时，除了手动拆分这张表，还有比这更好的办法来提升查询性能。这些方法包括了水平分区，垂直分区以及使用关联表。</p><h5 id="水平分区"><a href="#水平分区" class="headerlink" title="水平分区"></a>水平分区</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;水平分区（或者叫分片）：根据数据行来对表进行拆分。同时不用担心那些分隔表所带来的缺陷。仅需要定义一些规则来拆分一张逻辑表，数据库会为你管理余下所有的工作。物理上来说，表的确的被拆分了，但你依旧可以向查询单一表那样执行SQL查询语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mysql 5.1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line">bug_id <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">...</span><br><span class="line">date_report <span class="built_in">date</span></span><br><span class="line">) <span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">hash</span>(<span class="keyword">year</span>(date_report)) </span><br><span class="line"><span class="keyword">partitions</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上分割数据库的方式和这章最开始讲到的方式类似，根据date_report列的年份对数据拆分，但是它不用人工维护。实际存储数据的物理表在本例子中被固定设置为4张，当记录的年份跨度超过4年，某一个分区将用来存储多于一年。年份跨度不断增长，这样的现象也会不断重演。你不必添加新的分区，除非分区里面的数据量变得非常巨大，让你觉得需要重新分区。<br>&nbsp;&nbsp;&nbsp;&nbsp;注意：分区在sql标准中没有定义，每个不用的数据库实现这一功能都是非标准的。</p><h5 id="垂直分区"><a href="#垂直分区" class="headerlink" title="垂直分区"></a>垂直分区</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;鉴于水平分区是根据行来拆分，那么垂直分区就是根据列来拆分，将不经常用到的列或者非常庞大的列拆分出来。<br>&nbsp;&nbsp;&nbsp;&nbsp;BLOB或者TEXT类型的列可能是非常大的，有些数据库默认做了拆分存储，如果你查询不包含BLOB或者TEXT速度是非常快的。<br>&nbsp;&nbsp;&nbsp;&nbsp;我们开发可以创建一张额外的表来保存这些庞大的列，多出一列用来关联之前的表。比如product表，要将安装文件保存到数据库。（例子比较极端）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product_install_image(</span><br><span class="line">product_id bugint unsiged primary <span class="keyword">key</span>,</span><br><span class="line">install_image <span class="built_in">blob</span>,</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> product_id <span class="keyword">references</span> product(product_id);</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;还有值得注意，在mysql的MyISAM引擎中，使用固定长度的列是最高效的，比如说char类型比varchar类型要高效。</p><h5 id="解决元数据分裂"><a href="#解决元数据分裂" class="headerlink" title="解决元数据分裂"></a>解决元数据分裂</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;我们在第8章解决过类似的问题，解决元数据分裂的方案就是创建关联表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product_history(</span><br><span class="line">product_id <span class="built_in">bigint</span>,</span><br><span class="line"><span class="keyword">year</span> <span class="built_in">smallint</span>,</span><br><span class="line">big_fix <span class="built_in">int</span>,</span><br><span class="line">primary <span class="keyword">key</span>(product_id, <span class="keyword">year</span>),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (product_id) <span class="keyword">references</span> product(product_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;使用每一个产品、每一列记录一年的bug修复数量，还不如使用多行、仅用一列记录修复的bug数量。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;别让数据繁衍元数据</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式08-多列属性</title>
      <link href="/2018/08/13/sql/antipatterns/08-%E5%A4%9A%E5%88%97%E5%B1%9E%E6%80%A7/"/>
      <url>/2018/08/13/sql/antipatterns/08-%E5%A4%9A%E5%88%97%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;有时候在我们需求中，一条记录会对应多个<br>相同内容的列，比如电话号码：家庭电话、工作电话、手机号码等。那么就需要分四列来存储，而且后面需求可能还加入出差电话、传真号码这些不可预测的分类。</p><h4 id="目标：存储多列属性"><a href="#目标：存储多列属性" class="headerlink" title="目标：存储多列属性"></a>目标：存储多列属性</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;像第2章一样，解决一个属性看上去只属于一张表，但是同时可能会有多个值。<br>&nbsp;&nbsp;&nbsp;&nbsp;这一章，使用bug数据添加标签来举例。一个bug可以存在多个标签。</p><h4 id="反模式：创建多个列"><a href="#反模式：创建多个列" class="headerlink" title="反模式：创建多个列"></a>反模式：创建多个列</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;第2章，我们解决了一列存储一个列表，这是不合适的。这次反模式采用一列存储一个值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line">bug_id <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">description <span class="built_in">varchar</span>(<span class="number">1000</span>),</span><br><span class="line">tag1 <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">tag2 <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">tag3 <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;当你要根据给定标签(performance)所有bug时，你必须查询所有的三列，因为他可能存在这三列中任意一列。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug</span><br><span class="line"><span class="keyword">where</span> tag1 = <span class="string">'performance'</span> </span><br><span class="line">or tag2 = <span class="string">'performance'</span></span><br><span class="line">or tag3 = <span class="string">'performance'</span></span><br></pre></td></tr></table></figure><p>或者，使用in 的方式来查询</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> <span class="string">'performance'</span> <span class="keyword">in</span> (tag1, tag2, tag3)</span><br></pre></td></tr></table></figure><h5 id="添加及删除值"><a href="#添加及删除值" class="headerlink" title="添加及删除值"></a>添加及删除值</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;在这个设计中添加以及删除也是有问题的，单纯的使用update语句来更新一列是不安全的。举个例子，假如我们事先知道tag2是为null的，于是我们写出以下语句来更新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> bug <span class="keyword">set</span> tag2 = <span class="string">'performance'</span> <span class="keyword">where</span> bug_id = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这条语句是不安全的，假如同时有两个线程执行这个一条语句，结果就是不正确的。或者你可以使用ifnull来避免这个问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> bug <span class="keyword">set</span> tag2 = <span class="keyword">ifnull</span>(<span class="string">'performance'</span>, tag1)</span><br><span class="line"><span class="keyword">where</span> bug_id = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;或者，你可以写出更复杂的语句，但是它是非常耗时的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> bug</span><br><span class="line"><span class="keyword">set</span> tag2 = <span class="keyword">case</span></span><br><span class="line"><span class="keyword">when</span> <span class="string">'performance'</span> <span class="keyword">in</span> (tag1, tag3) <span class="keyword">then</span> tag2</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">coalesce</span>(tag2, <span class="string">'performance'</span>) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">where</span> bug_id = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><h5 id="确保唯一性"><a href="#确保唯一性" class="headerlink" title="确保唯一性"></a>确保唯一性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;在这个设计中，数据库是无法保证在一条记录中不存在相同的值的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug(..., tag1, tag2, tag3) <span class="keyword">values</span>(..., <span class="string">'performance'</span>, <span class="string">'printing'</span>, <span class="string">'performance'</span>);</span><br></pre></td></tr></table></figure><h5 id="处理不断增长的值"><a href="#处理不断增长的值" class="headerlink" title="处理不断增长的值"></a>处理不断增长的值</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;这个设计的另一个弱点就是三列并不够用，当你需要增加新一列时</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> bug <span class="keyword">add</span> <span class="keyword">column</span> tag4 <span class="built_in">varchar</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;如果频繁使用以上语句会存在以下问题：</p><ul><li>重构一张表会锁住整张表，影响客户端访问。</li><li>有些数据库会定义一张符合需求的新表，将现有的数据从旧表中导入新表，在丢弃旧表的方式来实现重构表结构，如果重构的表多，那么转换是相当耗时的。</li><li>新增一列，你需要检查每一条已存在的sql，以保证这些sql能够支持新增的列。</li></ul><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当出现以下情况时，可能是反模式</p><ol><li>应该支持的动态列的数量是多少？</li><li>如何才能在SQL查询中同时查询多列？</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在默写情况下，一个属性可能有固定数量的候选值，并且他们的存储位置和顺序都是固定的。这样的话，可以使用反模式。</p><h4 id="解决方案：创建从属表"><a href="#解决方案：创建从属表" class="headerlink" title="解决方案：创建从属表"></a>解决方案：创建从属表</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;创建另外一张表，保存tag，其中有一列作为外键关联bug表，以上问题迎刃而解。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tag(</span><br><span class="line">bug_id <span class="built_in">bigint</span> unsiged <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">tag <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">primary <span class="keyword">key</span> (bug_id, tag),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (bug_id) <span class="keyword">references</span> bug(bug_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;将具有同样意义的值存储在同一列中。</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API设计-AOP+log4j2(logId)</title>
      <link href="/2018/08/07/java/API%E8%AE%BE%E8%AE%A1-AOP+log4j2(logId)/"/>
      <url>/2018/08/07/java/API%E8%AE%BE%E8%AE%A1-AOP+log4j2(logId)/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;在生产环境下出现bug，都需要靠日志才能定位到问题的关键，而有效的日志往往能让你事半功倍。在生产并发访问情况下，日志纵横交错，那么如何快速找到你要看的日志呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;本章将介绍通过AOP使打印的每一条日志增加一个与业务相关的logId。</p><h4 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="AOP环绕增强controller"><a href="#AOP环绕增强controller" class="headerlink" title="AOP环绕增强controller"></a>AOP环绕增强controller</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;getUnique();没有给出具体实现，大家可以根据自己的业务需求，选择一个合适的值，比如用户id，流水号，都行。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package club.usql.core.aop;</span><br><span class="line"></span><br><span class="line">import club.usql.core.enums.ResponseEnum;</span><br><span class="line">import club.usql.core.facade.domain.vo.ResponseVO;</span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.core.annotation.Order;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line">import org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author far.liu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">@<span class="constructor">Order(0)</span></span><br><span class="line">public <span class="keyword">class</span> ApiLogAspect &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static final Logger logger = <span class="module-access"><span class="module"><span class="identifier">LoggerFactory</span>.</span></span>get<span class="constructor">Logger(ApiLogAspect.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    @<span class="constructor">Around(<span class="string">"execution(public * club.usql..controller.*.*(..))"</span>)</span></span><br><span class="line">    public Object around<span class="constructor">Api(ProceedingJoinPoint <span class="params">pjp</span>)</span> throws Throwable &#123;</span><br><span class="line">        String uri = StringUtils.EMPTY;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object<span class="literal">[]</span> args = pjp.get<span class="constructor">Args()</span>;</span><br><span class="line">            HttpServletRequest request = get<span class="constructor">RequestObj()</span>;</span><br><span class="line">            uri = request.get<span class="constructor">RequestURI()</span>;</span><br><span class="line"></span><br><span class="line">            String unique = get<span class="constructor">Unique(<span class="params">args</span>)</span>;<span class="comment">// not implemented, user_id or seq_no</span></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">ThreadContext</span>.</span></span>put(<span class="string">"unique"</span>, unique);</span><br><span class="line"></span><br><span class="line">            print<span class="constructor">Request(<span class="params">uri</span>, <span class="params">args</span>)</span>;</span><br><span class="line">            Object result = pjp.proceed(args);</span><br><span class="line">            print<span class="constructor">Response(<span class="params">uri</span>, <span class="params">result</span>)</span>;</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">            ResponseVO responseVO = <span class="keyword">new</span> <span class="constructor">ResponseVO(ResponseEnum.UNAUTHORIZED)</span>;</span><br><span class="line">            print<span class="constructor">Response(<span class="params">uri</span>, <span class="params">responseVO</span>)</span>;</span><br><span class="line">            return responseVO;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="comment">// don't forget it</span></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">ThreadContext</span>.</span></span>clear<span class="constructor">All()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest get<span class="constructor">RequestObj()</span> &#123;</span><br><span class="line">        return ((ServletRequestAttributes) <span class="module-access"><span class="module"><span class="identifier">RequestContextHolder</span>.</span></span>get<span class="constructor">RequestAttributes()</span>).get<span class="constructor">Request()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void print<span class="constructor">Request(String <span class="params">uri</span>, Object[] <span class="params">args</span>)</span> &#123;</span><br><span class="line">        logger.info(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">"call uri:%s begin, reqParam:%s"</span>, uri, args.<span class="keyword">to</span><span class="constructor">String()</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void print<span class="constructor">Response(String <span class="params">uri</span>, Object <span class="params">args</span>)</span> &#123;</span><br><span class="line">        logger.info(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">"call uri:%s end, respParam:%s"</span>, uri, args.<span class="keyword">to</span><span class="constructor">String()</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="log4j2-xml"><a href="#log4j2-xml" class="headerlink" title="log4j2.xml"></a>log4j2.xml</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span>&gt;</span>e:/logs<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d %-5p [%t] [unique:%X</span></span></span><span class="template-variable">&#123;unique&#125;</span><span class="xml"><span class="tag"><span class="string">] %C (%F:%L) %m%n"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-06</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">39</span>,<span class="number">456</span> INFO  [thread<span class="number">-495</span>] [unique:<span class="number">101660</span>] club.usql.core.aop.ApiLogAspect(ApiLogAspect.java:<span class="number">56</span>) call uri:/usql/test begin, reqParam:</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-06</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">39</span>,<span class="number">457</span> INFO  [thread<span class="number">-495</span>] [unique:<span class="number">101660</span>] club.usql.core.aop.ApiLogAspect(ApiLogAspect.java:<span class="number">56</span>) call uri:/usql/test end, respParam:</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;以上代码，能让你在本此请求中，所有打印的日志，会显示你设置的unique，你可以通过这个值获取到关于本次请求的日志，不用担心在并发的情况下要根据可能重复的线程号去定位。</p><h4 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h4><h5 id="less-usql-log"><a href="#less-usql-log" class="headerlink" title="less usql.log"></a>less usql.log</h5><ol><li>G -&gt; 跳转到日志结尾</li><li>g -&gt; 跳转到日志开始</li><li>/interest -&gt; 从当前位置往下搜索interest</li><li>?interest -&gt; 从当前位置往上搜索interest</li></ol><h5 id="tailf-usql-log"><a href="#tailf-usql-log" class="headerlink" title="tailf usql.log"></a>tailf usql.log</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;监听日志文件，有更新立即输出</p><h5 id="grep-interest-a5b5-usql-log-gt-gt-test-log"><a href="#grep-interest-a5b5-usql-log-gt-gt-test-log" class="headerlink" title="grep interest -a5b5 usql.log &gt;&gt; test.log"></a>grep interest -a5b5 usql.log &gt;&gt; test.log</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;将usql.log中的interes上下5行，输出到test.log 中，grep不适用与已经压缩的日志文件，可以使用以下命令</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -dc usql.<span class="built_in">log</span>.gz <span class="string">| grep interest</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> AOP </tag>
            
            <tag> log4j </tag>
            
            <tag> API设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式07-多态关联</title>
      <link href="/2018/08/04/sql/antipatterns/07-%E5%A4%9A%E6%80%81%E5%85%B3%E8%81%94/"/>
      <url>/2018/08/04/sql/antipatterns/07-%E5%A4%9A%E6%80%81%E5%85%B3%E8%81%94/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;允许用户对bug记录进行评论，我们很容易设计出一个一对多的关系。但是随着需求变更，可以进行评论的可能是多张表，比如bug和feature_request都可以进行评论，就会有类似以下的关系。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误的语句，仅用于表现关系</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">comment</span>(</span><br><span class="line">comment_id <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">.......</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(issue_id)</span><br><span class="line"><span class="keyword">reference</span> bug(issue_id) <span class="keyword">or</span> <span class="keyword">reference</span> feature_request(issue_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="目的：关联多个父表"><a href="#目的：关联多个父表" class="headerlink" title="目的：关联多个父表"></a>目的：关联多个父表</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;本章目的很明确，就是要处理多个父表关联同一子表的情况。</p><h4 id="反模式：使用多用途外键"><a href="#反模式：使用多用途外键" class="headerlink" title="反模式：使用多用途外键"></a>反模式：使用多用途外键</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;这个解决方案已经正式命名了，那就是多态关联，或者叫杂乱关联。</p><h5 id="定义多态关联"><a href="#定义多态关联" class="headerlink" title="定义多态关联"></a>定义多态关联</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;为了使用多态关联，你需要多添加一列issue_type用来标识issue_id属于bug还是feature_request，如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">comment</span>(</span><br><span class="line">comment_id <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">issue_type <span class="built_in">varchar</span>(<span class="number">20</span>), <span class="comment">-- BUG or FEATURE_REQUEST</span></span><br><span class="line">author <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">....</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(author) <span class="keyword">reference</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;你会发现使用该设计，issue_id外键没有了，因此就没有任何保障数据完整性的手段来确保issue_id是否存在其父表中。同样的也没有一个约束来保证issue_type是否为一个有效值。</p><h5 id="使用多态关联进行查询"><a href="#使用多态关联进行查询" class="headerlink" title="使用多态关联进行查询"></a>使用多态关联进行查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">comment</span> c</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> bug b <span class="keyword">on</span> c.issue_id = b.issue_id <span class="keyword">and</span> c.issue_type = <span class="string">'BUG'</span></span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> feature_request f <span class="keyword">on</span> c.issue_id = f.issue_id <span class="keyword">and</span> c.issue_type = <span class="string">'FEATURE_REQUEST'</span></span><br></pre></td></tr></table></figure><h4 id="如何识别反模式：当出现以下情况时，可能是反模式"><a href="#如何识别反模式：当出现以下情况时，可能是反模式" class="headerlink" title="如何识别反模式：当出现以下情况时，可能是反模式"></a>如何识别反模式：当出现以下情况时，可能是反模式</h4><ol><li>这种标记框架可以让你将标记(或者其他属性)和数据库中的任何其他资源联系起来。就想EAV的设计一样，应该怀疑任何生成有无线扩展性的设计。</li><li>不能在数据库中声明外键。</li><li>有一列，用来说明这条记录的其他列是和什么相关的。任何外键都强制一张表中所有的行引用同一张表。</li></ol><h4 id="合理使用反模式："><a href="#合理使用反模式：" class="headerlink" title="合理使用反模式："></a>合理使用反模式：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;应该尽量避免使用多态关联，应该使用外键约束等来确保引用完整性。<br>&nbsp;&nbsp;&nbsp;&nbsp;因为：多态关联通常过度依赖上层程序设计而不是数据库的元数据。</p><h4 id="解决方案：让关系变得简单"><a href="#解决方案：让关系变得简单" class="headerlink" title="解决方案：让关系变得简单"></a>解决方案：让关系变得简单</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;既要避免使用多态关联的缺点，又要支持你需要的数据模型，最好就是重新设计数据库，接下来就是要帮你解决这个难题。</p><h5 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;当你看清本质时，解决方案异常简单：多态关联是一个反向关联。</p><h5 id="创建交叉表"><a href="#创建交叉表" class="headerlink" title="创建交叉表"></a>创建交叉表</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;comment无法创建外键，是因为多个外键引用comment表，那么我们为每个外键创建一张独立的交叉表。如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_comment(</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">comment_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span> (issue_id, comment_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (issue_id) <span class="keyword">references</span> bug(issue_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (comment_id) <span class="keyword">references</span> <span class="keyword">comment</span>(comment_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> feature_comment(</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">comment_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span> (issue_id, comment_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (issue_id) <span class="keyword">references</span> feature_request(issue_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (comment_id) <span class="keyword">references</span> <span class="keyword">comment</span>(comment_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这个设计模式，元数据可以确保数据完整性。<br>&nbsp;&nbsp;&nbsp;&nbsp;缺点：如果有更多的类型，你需要创建更多这样的交叉表。联结查询需要多关联一张表。</p><h5 id="共用超级表"><a href="#共用超级表" class="headerlink" title="共用超级表"></a>共用超级表</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;创建一个基类表，并让所有的父表都继承该基类表，关系图如下<br><img src="/images/sql/antipatterns/07/01.png" alt="关系示意图"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> issue(</span><br><span class="line">issue_id <span class="built_in">serial</span> primary <span class="keyword">key</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (issue_id) <span class="keyword">references</span> issue(issue_id),</span><br><span class="line">....</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> feature_request(</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (issue_id) <span class="keyword">references</span> issue(issue_id),</span><br><span class="line">....</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">comment</span>(</span><br><span class="line">comment_id <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">author <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">comment_date datetime,</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (issue_id) <span class="keyword">references</span> issue(issue_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (author) <span class="keyword">references</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;给定一个评论，你可以通过一个相对简单的查询就获取对应的bug记录或者feature记录，而不再需要在查询中包含issue表，除非你将一些属性定义在那张表，同样的，由于bug表的主键和他的祖先issue表中的值时一样的，你可以直接对bug和comment表进行关联查询。也可以对两张没有外键约束直接关联的表进行联结查询，只要对应的列的信息是可比较的即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">as</span> c </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> bug <span class="keyword">as</span> b <span class="keyword">using</span>(issue_id)</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> feature <span class="keyword">as</span> f <span class="keyword">using</span>(issue_id)</span><br><span class="line"><span class="keyword">where</span> c.comment_id = <span class="number">1234</span></span><br></pre></td></tr></table></figure><p>对于一个指定bug，你同样可以轻易的查出他的评论</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">join</span> <span class="keyword">comment</span> <span class="keyword">as</span> c <span class="keyword">using</span>(issue_id)</span><br><span class="line"><span class="keyword">where</span> b.issue_id = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>更重要的是如果你是用了像issue这样的祖先表，就可以依赖外键来确保数据完整性。<br>在每一个表与表的关系中，都有一个引用表和一个被引用表。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;看完这章，总感觉有点过度设计，我觉得学习以下作者思考的思路就好了，或者以后也用得上这一章的内容。</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式06-实体-属性-值</title>
      <link href="/2018/07/21/sql/antipatterns/06-%E5%AE%9E%E4%BD%93-%E5%B1%9E%E6%80%A7-%E5%80%BC/"/>
      <url>/2018/07/21/sql/antipatterns/06-%E5%AE%9E%E4%BD%93-%E5%B1%9E%E6%80%A7-%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h4 id="目的：支持可变的属性"><a href="#目的：支持可变的属性" class="headerlink" title="目的：支持可变的属性"></a>目的：支持可变的属性</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;可扩展性是程序员所追求的。通常一张表对应一个实体，但是需求中也可能两个实体他们继承同一个父类实体，他们由相同的属性，也有不同属性。<br>&nbsp;&nbsp;&nbsp;&nbsp;bug和feature_request，有相同的属性，我们抽出一个父类issue。<br><img src="/images/sql/antipatterns/06/01_issue.png" alt="关系示意图"></p><h4 id="反模式：使用泛型属性表-EVA"><a href="#反模式：使用泛型属性表-EVA" class="headerlink" title="反模式：使用泛型属性表(EVA)"></a>反模式：使用泛型属性表(EVA)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;对于程序员来说，需要支持可变的属性时，第一发应就是创建一张表(issue_attributes)，它有三个字段</p><ol><li>实体 ： 指向父表的外键</li><li>属性 ： varchar类型，存储属性名字</li><li>值 ：存储对应属性的值<br><img src="/images/sql/antipatterns/06/02_issue.png" alt="关系示意图"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> issue(</span><br><span class="line">issue_id <span class="built_in">serial</span> primary <span class="keyword">key</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> issue_attribute(</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">attr_name <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">attr_value <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span>(issue_id, attr_name),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(issue_id) <span class="keyword">references</span> issue(issue_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><h5 id="查询某一个属性"><a href="#查询某一个属性" class="headerlink" title="查询某一个属性"></a>查询某一个属性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;假如你要查询bug的描述信息，显得比较啰嗦，还不清晰</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> issue_id, attr_value <span class="keyword">as</span> <span class="string">'description'</span> <span class="keyword">from</span> issue_attribute <span class="keyword">where</span> attr_name = <span class="string">'description'</span></span><br></pre></td></tr></table></figure><h5 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你无法保证attr_value是否是一个有效值</p><h5 id="无法声明属性类型"><a href="#无法声明属性类型" class="headerlink" title="无法声明属性类型"></a>无法声明属性类型</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;无法使用SQL的数据类型，比如对日期、金钱等格式内容都只能保持为字符串类型；</p><h5 id="无法确保引用完整性"><a href="#无法确保引用完整性" class="headerlink" title="无法确保引用完整性"></a>无法确保引用完整性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你不能对attr_value声明外键约束，比如说status，你不能保证status的值一定存在status表中</p><h5 id="无法确定属性名"><a href="#无法确定属性名" class="headerlink" title="无法确定属性名"></a>无法确定属性名</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;假如有两条数据，一条的attr_name是sex，一条attr_name是gender，都是表示性别</p><h5 id="查询结果中有多个属性时，异常困难"><a href="#查询结果中有多个属性时，异常困难" class="headerlink" title="查询结果中有多个属性时，异常困难"></a>查询结果中有多个属性时，异常困难</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> i.issue_id,</span><br><span class="line">i1.attr_value <span class="keyword">as</span> <span class="string">'date_reported'</span>,</span><br><span class="line">i2.attr_value <span class="keyword">as</span> <span class="string">'status'</span></span><br><span class="line"><span class="keyword">from</span> issue i </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> issue_attribute i1 <span class="keyword">on</span> i.issue_id = i1.issue_id <span class="keyword">and</span> attr_name = <span class="string">'date_reported'</span></span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> issue_attribute i2 <span class="keyword">on</span> i.issue_id = i2.issue_id <span class="keyword">and</span> attr_name = <span class="string">'status'</span></span><br></pre></td></tr></table></figure><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>当出现以下情况时，可能是反模式</p><ol><li>数据库不需要修改元数据库（表中的列属性）就可以扩展。还可以在运行时定义新的属性。</li><li>查询是连接数量非常多，且连接的数量可能会达到数据库的限制时，你的数据库的设计可能是有问题的。</li><li>普通的报表查询变的及其复杂甚至不且实际。</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>优点：</p><ol><li>表中的列很少；</li><li>新增属性时，不需要新增列。不会影响现有表的结构；</li><li>存储的字段内容不会为空值。</li></ol><p>缺点：上面列了一大段</p><p>如果真的有非关系数据管理需求，那最好使用nosql数据库</p><h4 id="解决方案：模型化子类型"><a href="#解决方案：模型化子类型" class="headerlink" title="解决方案：模型化子类型"></a>解决方案：模型化子类型</h4><h5 id="单表继承"><a href="#单表继承" class="headerlink" title="单表继承"></a>单表继承</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;所有属性都在一个单表上保存，使用issue_type来标识哪一个子类，子类属性必须支持null。<br>&nbsp;&nbsp;&nbsp;&nbsp;缺点：</p><ol><li>当程序加入新对象时，必须修改数据库来适应这些新对象，而张表的列的数量是有限制的。</li><li>没有任何的元信息来记录哪个属性属于哪个子类型。</li></ol><h5 id="实体表继承"><a href="#实体表继承" class="headerlink" title="实体表继承"></a>实体表继承</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;为每个子类型创建一张独立的表，每个表包含哪些属于基类的共有属性，同时也包含了子类型特殊化的属性。<br>&nbsp;&nbsp;&nbsp;&nbsp;优点：</p><ol><li>你可以像使用普通表那样来使用</li><li>相比于单表继承，新增对象时，你只需要新增表，而不需要修改之前的表结构</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;缺点：</p><ol><li>难将通用属性和子类特有属性区分开来。因此，如果将一个新的属性增加到通用属性中，必须为每个子类表都添加一遍。</li></ol><h5 id="类表继承"><a href="#类表继承" class="headerlink" title="类表继承"></a>类表继承</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;把表当成面向对象里的类，这可能也是最容易想到的吧，创建一张基表存储子类相同的字段，每一个子类创建一张表，添加一列执行基表的外键</p><h5 id="半结构化数据模型"><a href="#半结构化数据模型" class="headerlink" title="半结构化数据模型"></a>半结构化数据模型</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果有很多子类型或者必须经常增加新的属性支持，那么可以用一个BLOB列来存储JSON数据，缺点是，这样的结构中sql无法获取某个指定的属性。你必须或者整个blob字段并通过程序去解释这些属性。<br>&nbsp;&nbsp;&nbsp;&nbsp;当你需要绝对的灵活性时，可以使用这个方案。</p><h5 id="你接手一个EAV项目"><a href="#你接手一个EAV项目" class="headerlink" title="你接手一个EAV项目"></a>你接手一个EAV项目</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你无奈接手一个EAV项目，你需要衡量在数据库中处理数据好还是在程序代码中处理好，比如说查询</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> issue_attribute <span class="keyword">where</span> issue_id = <span class="number">1444</span>;</span><br></pre></td></tr></table></figure><p>查出所有行，在程序代码中遍历，明显要比在数据库中使用无限的联结查询要好。</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActiveMQ解析-客户端（消息发送端）</title>
      <link href="/2018/07/21/middleware/activemq-producter/"/>
      <url>/2018/07/21/middleware/activemq-producter/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;本篇主要粗略介绍程序在启动时，连接mq做了哪些操作，你可能需要先自己阅读一遍源码，再来看本篇文章，或对照源码看本篇文章</p><h3 id="1-抛开spring，创建一个简单生产者"><a href="#1-抛开spring，创建一个简单生产者" class="headerlink" title="1 抛开spring，创建一个简单生产者"></a>1 抛开spring，创建一个简单生产者</h3><h4 id="1-1-安装windows版activemq"><a href="#1-1-安装windows版activemq" class="headerlink" title="1.1 安装windows版activemq"></a>1.1 安装windows版activemq</h4><ol><li>下载地址：<a href="http://activemq.apache.org/download.html" target="_blank" rel="noopener">http://activemq.apache.org/download.html</a></li><li>解压，启动bin\win64\activemq.bat</li><li>访问：<a href="http://localhost:8161/" target="_blank" rel="noopener">http://localhost:8161/</a></li></ol><h4 id="1-2-生产者"><a href="#1-2-生产者" class="headerlink" title="1.2 生产者"></a>1.2 生产者</h4><ol><li><p><strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Producter</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> &#123;</span></span><br><span class="line">    <span class="comment">//ActiveMq 的默认用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> USERNAME = ActiveMQConnection.DEFAULT_USER;</span><br><span class="line">    <span class="comment">//ActiveMq 的默认登录密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;</span><br><span class="line">    <span class="comment">//ActiveMQ 的链接地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> BROKEN_URL = ActiveMQConnection.DEFAULT_BROKER_URL;</span><br><span class="line">    <span class="comment">//链接工厂</span></span><br><span class="line">    ConnectionFactory connectionFactory;</span><br><span class="line">    <span class="comment">//链接对象</span></span><br><span class="line">    Connection connection;</span><br><span class="line">    <span class="comment">//事务管理</span></span><br><span class="line">    Session session;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个链接工厂</span></span><br><span class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKEN_URL);</span><br><span class="line">            <span class="comment">//从工厂中创建一个链接</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//开启链接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//创建一个事务（这里通过参数可以设置事务的级别）</span></span><br><span class="line">            session = connection.createSession(<span class="literal">true</span>, Session.SESSION_TRANSACTED);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">String</span> disname, <span class="keyword">String</span> content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个消息队列</span></span><br><span class="line">            Queue <span class="built_in">queue</span> = session.createQueue(disname);</span><br><span class="line">            <span class="comment">//消息生产者</span></span><br><span class="line">            MessageProducer messageProducer = session.createProducer(<span class="built_in">queue</span>);</span><br><span class="line">            <span class="comment">//创建一条消息</span></span><br><span class="line">            TextMessage msg = session.createTextMessage(content);</span><br><span class="line">            System.out.<span class="built_in">println</span>(content);</span><br><span class="line">            <span class="comment">//发送消息</span></span><br><span class="line">            messageProducer.send(msg);</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            session.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">session.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    Producter producter = <span class="keyword">new</span> Producter();</span><br><span class="line">    producter.init();</span><br><span class="line">    producter.sendMessage(<span class="string">"test"</span>, <span class="string">"interest"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-分析init-方法"><a href="#2-分析init-方法" class="headerlink" title="2 分析init()方法"></a>2 分析init()方法</h3><h4 id="2-1-connectionFactory-new-ActiveMQConnectionFactory-USERNAME-PASSWORD-BROKEN-URL"><a href="#2-1-connectionFactory-new-ActiveMQConnectionFactory-USERNAME-PASSWORD-BROKEN-URL" class="headerlink" title="2.1 connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKEN_URL);"></a>2.1 connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKEN_URL);</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;该语句只是将USERNAME, PASSWORD, BROKEN_URL设置到ActiveMQConnectionFactory的变量里面。</p><h4 id="2-2-connection-connectionFactory-createConnection"><a href="#2-2-connection-connectionFactory-createConnection" class="headerlink" title="2.2 connection = connectionFactory.createConnection();"></a>2.2 connection = connectionFactory.createConnection();</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;createConnection()方法只是单纯调用createActiveMQConnection()方法，createActiveMQConnection的源码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected ActiveMQConnection create<span class="constructor">ActiveMQConnection(String <span class="params">userName</span>, String <span class="params">password</span>)</span> throws JMSException &#123;</span><br><span class="line">    <span class="keyword">if</span> (brokerURL<span class="operator"> == </span>null) &#123;</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">ConfigurationException(<span class="string">"brokerURL not set."</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ActiveMQConnection connection = null;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.2.1 创建Transport</span></span><br><span class="line">        Transport transport = create<span class="constructor">Transport()</span>;</span><br><span class="line">        <span class="comment">// 2.2.2 由transport和状态管理器创建连接</span></span><br><span class="line">        connection = create<span class="constructor">ActiveMQConnection(<span class="params">transport</span>, <span class="params">factoryStats</span>)</span>;</span><br><span class="line"></span><br><span class="line">        connection.set<span class="constructor">UserName(<span class="params">userName</span>)</span>;</span><br><span class="line">        connection.set<span class="constructor">Password(<span class="params">password</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看名字就知道配置connection的参数，它也的确只做了这样事，把new ActiveMQConnectionFactory()时处理好的参数set到connection中</span></span><br><span class="line">        configure<span class="constructor">Connection(<span class="params">connection</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一切准备就绪，就可以启动了</span></span><br><span class="line">        transport.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clientID != null) &#123;</span><br><span class="line">            connection.set<span class="constructor">DefaultClientID(<span class="params">clientID</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return connection;</span><br><span class="line">    &#125; catch (JMSException e) &#123;</span><br><span class="line">        <span class="comment">// Clean up!</span></span><br><span class="line">connection.close<span class="literal">()</span>;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        <span class="comment">// Clean up!</span></span><br><span class="line">        connection.close<span class="literal">()</span>;</span><br><span class="line">        throw <span class="module-access"><span class="module"><span class="identifier">JMSExceptionSupport</span>.</span></span>create(<span class="string">"Could not connect to broker URL: "</span> + brokerURL + <span class="string">". Reason: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-1-创建Transport，createTransport"><a href="#2-2-1-创建Transport，createTransport" class="headerlink" title="2.2.1 创建Transport，createTransport()"></a>2.2.1 创建Transport，createTransport()</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>粗略介绍：</strong>createTransport()，该方法首先从brokerURL中，取出scheme，scheme就是写在brokerUrl中的tcp、auto等关键字，然后根据scheme在一个保存了TransportFactory的ConcurrentMap中查找TransportFactory，没有就新new一个TransportFactory保存到ConcurrentMap中。然后调用TransportFactory.doConnect()，根据brokerUrl中的参数返回一个Transport的对象。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected Transport create<span class="constructor">Transport()</span> throws JMSException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URI connectBrokerUL = brokerURL;</span><br><span class="line">        <span class="comment">//取出scheme</span></span><br><span class="line">        String scheme = brokerURL.get<span class="constructor">Scheme()</span>;</span><br><span class="line">        <span class="keyword">if</span> (scheme<span class="operator"> == </span>null) &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">IOException(<span class="string">"Transport not scheme specified: ["</span> + <span class="params">brokerURL</span> + <span class="string">"]"</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (scheme.equals(<span class="string">"auto"</span>)) &#123;</span><br><span class="line">            connectBrokerUL = <span class="keyword">new</span> <span class="constructor">URI(<span class="params">brokerURL</span>.<span class="params">toString</span>()</span>.replace(<span class="string">"auto"</span>, <span class="string">"tcp"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheme.equals(<span class="string">"auto+ssl"</span>)) &#123;</span><br><span class="line">            connectBrokerUL = <span class="keyword">new</span> <span class="constructor">URI(<span class="params">brokerURL</span>.<span class="params">toString</span>()</span>.replace(<span class="string">"auto+ssl"</span>, <span class="string">"ssl"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheme.equals(<span class="string">"auto+nio"</span>)) &#123;</span><br><span class="line">            connectBrokerUL = <span class="keyword">new</span> <span class="constructor">URI(<span class="params">brokerURL</span>.<span class="params">toString</span>()</span>.replace(<span class="string">"auto+nio"</span>, <span class="string">"nio"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheme.equals(<span class="string">"auto+nio+ssl"</span>)) &#123;</span><br><span class="line">            connectBrokerUL = <span class="keyword">new</span> <span class="constructor">URI(<span class="params">brokerURL</span>.<span class="params">toString</span>()</span>.replace(<span class="string">"auto+nio+ssl"</span>, <span class="string">"nio+ssl"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2.1.1 根据scheme在Map中取出TransportFactory，获得Transport对象</span></span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">TransportFactory</span>.</span></span>connect(connectBrokerUL);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw <span class="module-access"><span class="module"><span class="identifier">JMSExceptionSupport</span>.</span></span>create(<span class="string">"Could not create Transport. Reason: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2.1.1 根据scheme在Map中取出TransportFactory，获得Transport对象</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Transport <span class="title">connect</span><span class="params">(URI location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//2.2.1.1.1 从ConcurrentMap中获取TransportFactory</span></span><br><span class="line">    TransportFactory tf = findTransportFactory(location);</span><br><span class="line">    <span class="comment">//2.2.1.1.2 从TransportFactory返回Transport对象</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> tf.<span class="title">doConnect</span><span class="params">(location)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2.1.1.1 从ConcurrentMap中获取TransportFactory</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static TransportFactory find<span class="constructor">TransportFactory(URI <span class="params">location</span>)</span> throws IOException &#123;</span><br><span class="line">    String scheme = location.get<span class="constructor">Scheme()</span>;</span><br><span class="line">    <span class="keyword">if</span> (scheme<span class="operator"> == </span>null) &#123;</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">IOException(<span class="string">"Transport not scheme specified: ["</span> + <span class="params">location</span> + <span class="string">"]"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TRANSPORT_FACTORYS 保存着 TransportFactory的ConcurrentMap</span></span><br><span class="line">    TransportFactory tf = <span class="module-access"><span class="module"><span class="identifier">TRANSPORT_FACTORYS</span>.</span></span>get(scheme);</span><br><span class="line">    <span class="comment">//没有，则返回一个新对象并保存在map中</span></span><br><span class="line">    <span class="keyword">if</span> (tf<span class="operator"> == </span>null) &#123;</span><br><span class="line">        <span class="comment">// Try to load if from a META-INF property.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tf = (TransportFactory)<span class="module-access"><span class="module"><span class="identifier">TRANSPORT_FACTORY_FINDER</span>.</span></span><span class="keyword">new</span><span class="constructor">Instance(<span class="params">scheme</span>)</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">TRANSPORT_FACTORYS</span>.</span></span>put(scheme, tf);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw <span class="module-access"><span class="module"><span class="identifier">IOExceptionSupport</span>.</span></span>create(<span class="string">"Transport scheme NOT recognized: ["</span> + scheme + <span class="string">"]"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2.1.1.2 从TransportFactory返回Transport对象</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Transport <span class="keyword">do</span><span class="constructor">Connect(URI <span class="params">location</span>)</span> throws Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; options = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="module-access"><span class="module"><span class="identifier">URISupport</span>.</span></span>parse<span class="constructor">Parameters(<span class="params">location</span>)</span>);</span><br><span class="line">        <span class="keyword">if</span>( !options.contains<span class="constructor">Key(<span class="string">"wireFormat.host"</span>)</span> ) &#123;</span><br><span class="line">            options.put(<span class="string">"wireFormat.host"</span>, location.get<span class="constructor">Host()</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        WireFormat wf = create<span class="constructor">WireFormat(<span class="params">options</span>)</span>;</span><br><span class="line">        <span class="comment">//2.2.1.1.2.1 创建Transport对象</span></span><br><span class="line">        Transport transport = create<span class="constructor">Transport(<span class="params">location</span>, <span class="params">wf</span>)</span>;</span><br><span class="line">        Transport rc = configure(transport, wf, options);</span><br><span class="line">        <span class="comment">//remove auto</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">IntrospectionSupport</span>.</span></span>extract<span class="constructor">Properties(<span class="params">options</span>, <span class="string">"auto."</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!options.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">IllegalArgumentException(<span class="string">"Invalid connect parameters: "</span> + <span class="params">options</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return rc;</span><br><span class="line">    &#125; catch (URISyntaxException e) &#123;</span><br><span class="line">        throw <span class="module-access"><span class="module"><span class="identifier">IOExceptionSupport</span>.</span></span>create(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2.1.1.2.1 创建Transport对象</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由子类实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function">Transport <span class="title">createTransport</span><span class="params">(URI location, WireFormat wf)</span> <span class="keyword">throws</span> MalformedURLException, UnknownHostException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"createTransport() method not implemented!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2.1.1.2.2 createTransport()由子类实现，TcpTransportFactory</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected Transport create<span class="constructor">Transport(URI <span class="params">location</span>, WireFormat <span class="params">wf</span>)</span> throws UnknownHostException, IOException &#123;</span><br><span class="line">    URI localLocation = null;</span><br><span class="line">    String path = location.get<span class="constructor">Path()</span>;</span><br><span class="line">    <span class="comment">// see if the path is a local URI location</span></span><br><span class="line">    <span class="keyword">if</span> (path != null<span class="operator"> &amp;&amp; </span>path.length<span class="literal">()</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> localPortIndex = path.index<span class="constructor">Of(':')</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">path</span>.<span class="params">substring</span>(<span class="params">localPortIndex</span> + 1, <span class="params">path</span>.<span class="params">length</span>()</span>));</span><br><span class="line">            String localString = location.get<span class="constructor">Scheme()</span> + <span class="string">":/"</span> + path;</span><br><span class="line">            localLocation = <span class="keyword">new</span> <span class="constructor">URI(<span class="params">localString</span>)</span>;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">LOG</span>.</span></span>warn(<span class="string">"path isn't a valid local location for TcpTransport to use"</span>, e.get<span class="constructor">Message()</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">LOG</span>.</span></span>is<span class="constructor">DebugEnabled()</span>) &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">LOG</span>.</span></span>debug(<span class="string">"Failure detail"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上算是都在校验url</span></span><br><span class="line">    <span class="comment">//这一句new DefaultSocketFactory()对象返回</span></span><br><span class="line">    SocketFactory socketFactory = create<span class="constructor">SocketFactory()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// new一个TcpTransport对象，将wf，socketFactory放入该对象的变量里面</span></span><br><span class="line">    return create<span class="constructor">TcpTransport(<span class="params">wf</span>, <span class="params">socketFactory</span>, <span class="params">location</span>, <span class="params">localLocation</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-2-由transport和状态管理器创建连接"><a href="#2-2-2-由transport和状态管理器创建连接" class="headerlink" title="2.2.2 由transport和状态管理器创建连接"></a>2.2.2 由transport和状态管理器创建连接</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>粗略介绍：</strong>createActiveMQConnection()字面意思就是创建一个activeMQ的连接。这个连接是根据transport，和一个连接状态管理器JMSStats创建的，源码如下。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected ActiveMQConnection create<span class="constructor">ActiveMQConnection(Transport <span class="params">transport</span>, JMSStatsImpl <span class="params">stats</span>)</span> throws Exception &#123;</span><br><span class="line">    <span class="comment">//getConnectionIdGenerator(), getClientIdGenerator()这是一个同步方法，返回IdGenerator对象</span></span><br><span class="line">    <span class="comment">//transport 上面代码生成的Transport对象</span></span><br><span class="line">    <span class="comment">//stats 是一个JMSStatsImpl对象，有提供set方法，修改连接状态</span></span><br><span class="line"><span class="comment">//2.2.2.2 ActiveMQConnection的构造</span></span><br><span class="line">    ActiveMQConnection connection = <span class="keyword">new</span> <span class="constructor">ActiveMQConnection(<span class="params">transport</span>, <span class="params">getClientIdGenerator</span>()</span>,</span><br><span class="line">            get<span class="constructor">ConnectionIdGenerator()</span>, stats);</span><br><span class="line">    return connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>2.2.2.1 JMSStatsImpl *</em></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMSStatsImpl</span> <span class="title">extends</span> <span class="title">StatsImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> List connections;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JMSStatsImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">//CopyOnWriteArrayList，一开是所有线程共享内容，当你需要修改时将内容复制出来再修改，然后把旧的地址指向新地址，这样可以达到并发的读，而不需要加锁</span></span><br><span class="line">        connections = <span class="keyword">new</span> CopyOnWriteArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> JMSConnectionStatsImpl[] getConnections()</span><br><span class="line">    &#123;</span><br><span class="line">        Object connectionArray[] = connections.toArray();</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = connectionArray.length;</span><br><span class="line">        JMSConnectionStatsImpl answer[] = <span class="keyword">new</span> JMSConnectionStatsImpl[<span class="built_in">size</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ActiveMQConnection connection = (ActiveMQConnection)connectionArray[i];</span><br><span class="line">            answer[i] = connection.getConnectionStats();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addConnection</span><span class="params">(ActiveMQConnection connection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        connections.add(connection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeConnection</span><span class="params">(ActiveMQConnection connection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        connections.<span class="built_in">remove</span>(connection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">(IndentPrinter out)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out.printIndent();</span><br><span class="line">        out.<span class="built_in">println</span>(<span class="string">"factory &#123;"</span>);</span><br><span class="line">        out.incrementIndent();</span><br><span class="line">        JMSConnectionStatsImpl <span class="built_in">array</span>[] = getConnections();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            JMSConnectionStatsImpl connectionStat = <span class="built_in">array</span>[i];</span><br><span class="line">            connectionStat.dump(out);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.decrementIndent();</span><br><span class="line">        out.printIndent();</span><br><span class="line">        out.<span class="built_in">println</span>(<span class="string">"&#125;"</span>);</span><br><span class="line">        out.<span class="built_in">flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        super.setEnabled(enabled);</span><br><span class="line">        JMSConnectionStatsImpl stats[] = getConnections();</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = stats.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">            stats[i].setEnabled(enabled);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2.2.2 ActiveMQConnection的构造</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="constructor">ActiveMQConnection(<span class="params">final</span> Transport <span class="params">transport</span>, IdGenerator <span class="params">clientIdGenerator</span>, IdGenerator <span class="params">connectionIdGenerator</span>, JMSStatsImpl <span class="params">factoryStats</span>)</span> throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    this.transport = transport;</span><br><span class="line">    this.clientIdGenerator = clientIdGenerator;</span><br><span class="line">    this.factoryStats = factoryStats;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure a single threaded executor who's core thread can timeout if</span></span><br><span class="line">    <span class="comment">// idle</span></span><br><span class="line">    executor = <span class="keyword">new</span> <span class="constructor">ThreadPoolExecutor(1, 1, 5, TimeUnit.SECONDS, <span class="params">new</span> LinkedBlockingQueue&lt;Runnable&gt;()</span>, <span class="keyword">new</span> <span class="constructor">ThreadFactory()</span> &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Thread <span class="keyword">new</span><span class="constructor">Thread(Runnable <span class="params">r</span>)</span> &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">r</span>, <span class="string">"ActiveMQ Connection Executor: "</span> + <span class="params">transport</span>)</span>;</span><br><span class="line">            <span class="comment">//守护线程，用于关闭，检测心跳等 - see https://issues.apache.org/jira/browse/AMQ-796</span></span><br><span class="line">            <span class="comment">//thread.setDaemon(true);</span></span><br><span class="line">            return thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//连接信息，赋值</span></span><br><span class="line">    <span class="comment">// asyncConnectionThread.allowCoreThreadTimeOut(true);</span></span><br><span class="line">    String uniqueId = connectionIdGenerator.generate<span class="constructor">Id()</span>;</span><br><span class="line">    this.info = <span class="keyword">new</span> <span class="constructor">ConnectionInfo(<span class="params">new</span> ConnectionId(<span class="params">uniqueId</span>)</span>);</span><br><span class="line">    this.info.set<span class="constructor">Manageable(<span class="params">true</span>)</span>;</span><br><span class="line">    this.info.set<span class="constructor">FaultTolerant(<span class="params">transport</span>.<span class="params">isFaultTolerant</span>()</span>);</span><br><span class="line">    this.connectionSessionId = <span class="keyword">new</span> <span class="constructor">SessionId(<span class="params">info</span>.<span class="params">getConnectionId</span>()</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    this.transport.set<span class="constructor">TransportListener(<span class="params">this</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sessions 也是一个 CopyOnWriteArrayList，用于保存session，启动时size = 0</span></span><br><span class="line">    this.stats = <span class="keyword">new</span> <span class="constructor">JMSConnectionStatsImpl(<span class="params">sessions</span>, <span class="params">this</span> <span class="params">instanceof</span> XAConnection)</span>;</span><br><span class="line">    this.factoryStats.add<span class="constructor">Connection(<span class="params">this</span>)</span>;</span><br><span class="line">    this.timeCreated = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span>;</span><br><span class="line">    this.connectionAudit.set<span class="constructor">CheckForDuplicates(<span class="params">transport</span>.<span class="params">isFaultTolerant</span>()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-session-connection-createSession-true-Session-SESSION-TRANSACTED"><a href="#2-3-session-connection-createSession-true-Session-SESSION-TRANSACTED" class="headerlink" title="2.3 session = connection.createSession(true, Session.SESSION_TRANSACTED);"></a>2.3 session = connection.createSession(true, Session.SESSION_TRANSACTED);</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;该方法返回一个seesion，该session用于操作activemq，该方法先做了保护性校验查看连接是否关闭，如果没有，那么将ConnectionInfo发送给broker，没有异常情况下，new 一个 Session对象返回</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">Session <span class="title">createSession</span><span class="params">(<span class="keyword">boolean</span> transacted, <span class="keyword">int</span> acknowledgeMode)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">    checkClosedOrFailed();</span><br><span class="line">    ensureConnectionInfoSent();</span><br><span class="line">    <span class="keyword">if</span> (!transacted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acknowledgeMode == Session.SESSION_TRANSACTED) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JMSException(<span class="string">"acknowledgeMode SESSION_TRANSACTED cannot be used for an non-transacted Session"</span>);</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(acknowledgeMode &lt; Session.SESSION_TRANSACTED || acknowledgeMode &gt; ActiveMQSession.MAX_ACK_CONSTANT)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JMSException(<span class="string">"invalid acknowledgeMode: "</span> + acknowledgeMode + <span class="string">". Valid values are Session.AUTO_ACKNOWLEDGE (1), "</span> +</span><br><span class="line">                    <span class="string">"Session.CLIENT_ACKNOWLEDGE (2), Session.DUPS_OK_ACKNOWLEDGE (3), ActiveMQSession.INDIVIDUAL_ACKNOWLEDGE (4) or for transacted sessions Session.SESSION_TRANSACTED (0)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQSession(<span class="keyword">this</span>, getNextSessionId(), transacted ? Session.SESSION_TRANSACTED : acknowledgeMode, isDispatchAsync(), isAlwaysSessionAsync());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-分析sendMessage-方法"><a href="#3-分析sendMessage-方法" class="headerlink" title="3 分析sendMessage()方法"></a>3 分析sendMessage()方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这个方法基本上就属于业务层了，你需要关心的是Queue，Topic。<br>可参考<a href="http://usql.club/2018/06/17/middleware/activemq-simple/" target="_blank" rel="noopener">点击查看</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据安全02-RSA 加密原理</title>
      <link href="/2018/07/17/theory/RSA%20%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"/>
      <url>/2018/07/17/theory/RSA%20%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="粗略介绍"><a href="#粗略介绍" class="headerlink" title="粗略介绍"></a>粗略介绍</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>RSA属于非对称加密</strong>，它使用一对密钥进行加密，加密和解密分别使用不同密钥，所以也号称地球上最安全的加密算法。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>对称加密</strong>，它的加密解密使用同一密钥，所以相对RSA来说没有那么安全，但是效率却要比RSA高。</p><h4 id="转自"><a href="#转自" class="headerlink" title="转自"></a>转自</h4><p><a href="https://blog.csdn.net/dbs1215/article/details/48953589" target="_blank" rel="noopener">查看</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tomcat爱恨情仇</title>
      <link href="/2018/07/14/centos/tomcat/"/>
      <url>/2018/07/14/centos/tomcat/</url>
      
        <content type="html"><![CDATA[<h4 id="tomcat-与-oom-killer"><a href="#tomcat-与-oom-killer" class="headerlink" title="tomcat 与 oom_killer"></a>tomcat 与 oom_killer</h4><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;在一台centos上，我启动了tomcat，运行之后内存剩余500M，但是第二天tomcat已经被停止了。要知道申请JVM内存是成倍申请，申请到了之后不会回收，也就是说，我的tomcat启动成功后，就拥有固定的内存，而我可以保证它的使用不会超出该内存而去申请下一段内存，但是为什么莫名的停止呢？而且没有留下任何日志，说明是系统kill掉的。</p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;那么我们想办法打出日志，加上以下参数，我们期待在下一次出现问题时能及时打印堆栈信息再挂掉。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改$TOMCAT_HOME/bin/catalina.sh</span></span><br><span class="line"><span class="attr">JAVA_OPTS</span>=<span class="string">"-XX:+HeapDumpOnOutOfMemoryError-XX:HeapDumpPath=/usr/local/tomcat/logs"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;第二天起床照样发现已被kill，查看日志，<strong>/var/log/message</strong> </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">03</span> rcmsit kernel: YDService invoked oom-killer: gfp_mask=<span class="number">0x201da</span>, order=<span class="number">0</span>, oom_score_adj=<span class="number">0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: YDService cpuset=/ mems_allowed=<span class="number">0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: CPU: <span class="number">1</span> PID: <span class="number">9434</span> Comm: YDService Not tainted <span class="number">3.10</span><span class="number">.0</span><span class="number">-514.26</span><span class="number">.2</span>.el7.x86_64 #<span class="number">1</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Hardware name: Bochs Bochs, BIOS Bochs <span class="number">01</span>/<span class="number">01</span>/<span class="number">2011</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: ffff880119648000 <span class="number">00000000210107</span>be ffff88005c037938 ffffffff81687133</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: ffff88005c0379c8 ffffffff816820de ffffffff810eb0dc ffff88005c14b980</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: ffff88005c14b998 <span class="number">0000000000000202</span> ffff880119648000 ffff88005c0379b8</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Call Trace:</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81687133&gt;] dump_stack+<span class="number">0x19</span>/<span class="number">0x1b</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff816820de&gt;] dump_header+<span class="number">0x8e</span>/<span class="number">0x225</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff810eb0dc&gt;] ? ktime_get_ts64+<span class="number">0x4c</span>/<span class="number">0xf0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff8113d22f&gt;] ? delayacct_end+<span class="number">0x8f</span>/<span class="number">0xb0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81184d0e&gt;] oom_kill_process+<span class="number">0x24e</span>/<span class="number">0x3c0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff811847ad&gt;] ? oom_unkillable_task+<span class="number">0xcd</span>/<span class="number">0x120</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81184856&gt;] ? find_lock_task_mm+<span class="number">0x56</span>/<span class="number">0xc0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81093c0e&gt;] ? has_capability_noaudit+<span class="number">0x1e</span>/<span class="number">0x30</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81185546&gt;] out_of_memory+<span class="number">0x4b6</span>/<span class="number">0x4f0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81682be7&gt;] __alloc_pages_slowpath+<span class="number">0x5d7</span>/<span class="number">0x725</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff8118b655&gt;] __alloc_pages_nodemask+<span class="number">0x405</span>/<span class="number">0x420</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff811cf9ca&gt;] alloc_pages_current+<span class="number">0xaa</span>/<span class="number">0x170</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81180be7&gt;] __page_cache_alloc+<span class="number">0x97</span>/<span class="number">0xb0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81183760&gt;] filemap_fault+<span class="number">0x170</span>/<span class="number">0x410</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffffa01b7016&gt;] ext4_filemap_fault+<span class="number">0x36</span>/<span class="number">0x50</span> [ext4]</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff811ac83c&gt;] __do_fault+<span class="number">0x4c</span>/<span class="number">0xc0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff811accd3&gt;] do_read_fault.isra<span class="number">.42</span>+<span class="number">0x43</span>/<span class="number">0x130</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff811b1461&gt;] handle_mm_fault+<span class="number">0x6b1</span>/<span class="number">0x1000</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81692cc4&gt;] __do_page_fault+<span class="number">0x154</span>/<span class="number">0x450</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81692ff5&gt;] do_page_fault+<span class="number">0x35</span>/<span class="number">0x90</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff8168f208&gt;] page_fault+<span class="number">0x28</span>/<span class="number">0x30</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Mem-Info:</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: active_anon:<span class="number">625329</span> inactive_anon:<span class="number">205647</span> isolated_anon:<span class="number">0</span>#<span class="number">012</span> active_file:<span class="number">2142</span> inactive_file:<span class="number">3816</span> isolated_file:<span class="number">0</span>#<span class="number">012</span> unevictable:<span class="number">0</span> dirty:<span class="number">0</span> writeback:<span class="number">0</span> unstable:<span class="number">0</span>#<span class="number">012</span> slab_reclaimable:<span class="number">26535</span> slab_unreclaimable:<span class="number">52499</span>#<span class="number">012</span> mapped:<span class="number">615</span> shmem:<span class="number">12902</span></span><br><span class="line"><span class="number">0</span> pagetables:<span class="number">3722</span> bounce:<span class="number">0</span>#<span class="number">012</span> free:<span class="number">33074</span> free_pcp:<span class="number">192</span> free_cma:<span class="number">0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Node <span class="number">0</span> DMA free:<span class="number">15400</span>kB min:<span class="number">276</span>kB low:<span class="number">344</span>kB high:<span class="number">412</span>kB active_anon:<span class="number">108</span>kB inactive_anon:<span class="number">192</span>kB active_file:<span class="number">0</span>kB inactive_file:<span class="number">0</span>kB unevictable:<span class="number">0</span>kB isolated(anon):<span class="number">0</span>kB isolated(file):<span class="number">0</span>kB present:<span class="number">15992</span>kB managed:<span class="number">15908</span>kB mlocked:<span class="number">0</span>kB dirty:<span class="number">0</span>kB writ</span><br><span class="line">eback:<span class="number">0</span>kB mapped:<span class="number">0</span>kB shmem:<span class="number">44</span>kB slab_reclaimable:<span class="number">68</span>kB slab_unreclaimable:<span class="number">36</span>kB kernel_stack:<span class="number">0</span>kB pagetables:<span class="number">20</span>kB unstable:<span class="number">0</span>kB bounce:<span class="number">0</span>kB free_pcp:<span class="number">0</span>kB local_pcp:<span class="number">0</span>kB free_cma:<span class="number">0</span>kB writeback_tmp:<span class="number">0</span>kB pages_scanned:<span class="number">0</span> all_unreclaimable? yes</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: lowmem_reserve[]: <span class="number">0</span> <span class="number">3327</span> <span class="number">3773</span> <span class="number">3773</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Node <span class="number">0</span> DMA32 free:<span class="number">108368</span>kB min:<span class="number">59340</span>kB low:<span class="number">74172</span>kB high:<span class="number">89008</span>kB active_anon:<span class="number">2321152</span>kB inactive_anon:<span class="number">634816</span>kB active_file:<span class="number">7216</span>kB inactive_file:<span class="number">13476</span>kB unevictable:<span class="number">0</span>kB isolated(anon):<span class="number">0</span>kB isolated(file):<span class="number">0</span>kB present:<span class="number">3653624</span>kB managed:<span class="number">3408868</span>kB</span><br><span class="line"> mlocked:<span class="number">0</span>kB dirty:<span class="number">0</span>kB writeback:<span class="number">0</span>kB mapped:<span class="number">2328</span>kB shmem:<span class="number">500612</span>kB slab_reclaimable:<span class="number">91688</span>kB slab_unreclaimable:<span class="number">184240</span>kB kernel_stack:<span class="number">12304</span>kB pagetables:<span class="number">12780</span>kB unstable:<span class="number">0</span>kB bounce:<span class="number">0</span>kB free_pcp:<span class="number">696</span>kB local_pcp:<span class="number">0</span>kB free_cma:<span class="number">0</span>kB writeback_tmp:<span class="number">0</span>kB pages_scanned:<span class="number">0</span> all_unrecla</span><br><span class="line">imable? no</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: lowmem_reserve[]: <span class="number">0</span> <span class="number">0</span> <span class="number">446</span> <span class="number">446</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Node <span class="number">0</span> Normal free:<span class="number">9892</span>kB min:<span class="number">7964</span>kB low:<span class="number">9952</span>kB high:<span class="number">11944</span>kB active_anon:<span class="number">180056</span>kB inactive_anon:<span class="number">187580</span>kB active_file:<span class="number">1904</span>kB inactive_file:<span class="number">4676</span>kB unevictable:<span class="number">0</span>kB isolated(anon):<span class="number">0</span>kB isolated(file):<span class="number">0</span>kB present:<span class="number">524288</span>kB managed:<span class="number">457256</span>kB mlocke</span><br><span class="line">d:<span class="number">0</span>kB dirty:<span class="number">0</span>kB writeback:<span class="number">0</span>kB mapped:<span class="number">132</span>kB shmem:<span class="number">15424</span>kB slab_reclaimable:<span class="number">14384</span>kB slab_unreclaimable:<span class="number">25720</span>kB kernel_stack:<span class="number">2208</span>kB pagetables:<span class="number">2088</span>kB unstable:<span class="number">0</span>kB bounce:<span class="number">0</span>kB free_pcp:<span class="number">296</span>kB local_pcp:<span class="number">0</span>kB free_cma:<span class="number">0</span>kB writeback_tmp:<span class="number">0</span>kB pages_scanned:<span class="number">96</span> all_unreclaimable? no</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: lowmem_reserve[]: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Node <span class="number">0</span> DMA: <span class="number">17</span>*<span class="number">4</span>kB (UEM) <span class="number">1</span>*<span class="number">8</span>kB (E) <span class="number">2</span>*<span class="number">16</span>kB (UE) <span class="number">2</span>*<span class="number">32</span>kB (EM) <span class="number">2</span>*<span class="number">64</span>kB (UM) <span class="number">2</span>*<span class="number">128</span>kB (UE) <span class="number">2</span>*<span class="number">256</span>kB (UE) <span class="number">2</span>*<span class="number">512</span>kB (EM) <span class="number">3</span>*<span class="number">1024</span>kB (UEM) <span class="number">1</span>*<span class="number">2048</span>kB (E) <span class="number">2</span>*<span class="number">4096</span>kB (M) = <span class="number">15404</span>kB</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Node <span class="number">0</span> DMA32: <span class="number">6745</span>*<span class="number">4</span>kB (UEM) <span class="number">1058</span>*<span class="number">8</span>kB (UEM) <span class="number">922</span>*<span class="number">16</span>kB (UEM) <span class="number">546</span>*<span class="number">32</span>kB (UEM) <span class="number">208</span>*<span class="number">64</span>kB (UEM) <span class="number">83</span>*<span class="number">128</span>kB (UEM) <span class="number">24</span>*<span class="number">256</span>kB (UEM) <span class="number">13</span>*<span class="number">512</span>kB (UEM) <span class="number">4</span>*<span class="number">1024</span>kB (U) <span class="number">0</span>*<span class="number">2048</span>kB <span class="number">0</span>*<span class="number">4096</span>kB = <span class="number">108500</span>kB</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Node <span class="number">0</span> Normal: <span class="number">682</span>*<span class="number">4</span>kB (UEM) <span class="number">180</span>*<span class="number">8</span>kB (UEM) <span class="number">151</span>*<span class="number">16</span>kB (UEM) <span class="number">39</span>*<span class="number">32</span>kB (UEM) <span class="number">18</span>*<span class="number">64</span>kB (UEM) <span class="number">9</span>*<span class="number">128</span>kB (UEM) <span class="number">3</span>*<span class="number">256</span>kB (UEM) <span class="number">2</span>*<span class="number">512</span>kB (EM) <span class="number">0</span>*<span class="number">1024</span>kB <span class="number">0</span>*<span class="number">2048</span>kB <span class="number">0</span>*<span class="number">4096</span>kB = <span class="number">11928</span>kB</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Node <span class="number">0</span> hugepages_total=<span class="number">0</span> hugepages_free=<span class="number">0</span> hugepages_surp=<span class="number">0</span> hugepages_size=<span class="number">2048</span>kB</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: <span class="number">143267</span> total pagecache pages</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: <span class="number">7945</span> pages <span class="keyword">in</span> swap cache</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Swap cache stats: add <span class="number">284622</span>, delete <span class="number">276677</span>, find <span class="number">2373345</span>/<span class="number">2374779</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Free swap  = <span class="number">0</span>kB</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Total swap = <span class="number">1023996</span>kB</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: <span class="number">1048476</span> pages RAM</span><br><span class="line">....</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [ pid ]   uid  tgid total_vm      rss nr_ptes swapents oom_score_adj name</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [  <span class="number">553</span>]     <span class="number">0</span>   <span class="number">553</span>    <span class="number">26364</span>       <span class="number">23</span>      <span class="number">51</span>      <span class="number">223</span>         <span class="number">-1000</span> sshd</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [<span class="number">10530</span>]    <span class="number">27</span> <span class="number">10530</span>   <span class="number">452707</span>    <span class="number">79498</span>     <span class="number">396</span>    <span class="number">91599</span>         <span class="number">-1000</span> mysqld</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [<span class="number">30398</span>]     <span class="number">0</span> <span class="number">30398</span>   <span class="number">582767</span>    <span class="number">20612</span>     <span class="number">109</span>       <span class="number">62</span>             <span class="number">0</span> java</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [  <span class="number">515</span>]     <span class="number">0</span>   <span class="number">515</span>    <span class="number">35253</span>     <span class="number">2031</span>      <span class="number">17</span>        <span class="number">4</span>             <span class="number">0</span> redis-server</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [  <span class="number">520</span>]     <span class="number">0</span>   <span class="number">520</span>    <span class="number">35253</span>     <span class="number">1816</span>      <span class="number">17</span>        <span class="number">1</span>             <span class="number">0</span> redis-server</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [  <span class="number">524</span>]     <span class="number">0</span>   <span class="number">524</span>    <span class="number">35253</span>     <span class="number">1878</span>      <span class="number">17</span>        <span class="number">1</span>             <span class="number">0</span> redis-server</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [ <span class="number">5404</span>]     <span class="number">0</span>  <span class="number">5404</span>   <span class="number">612065</span>    <span class="number">43032</span>     <span class="number">228</span>        <span class="number">0</span>             <span class="number">0</span> java</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [<span class="number">16265</span>]     <span class="number">0</span> <span class="number">16265</span>   <span class="number">520357</span>    <span class="number">65939</span>     <span class="number">261</span>        <span class="number">0</span>         <span class="number">-1000</span> java</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [ <span class="number">3251</span>]     <span class="number">0</span>  <span class="number">3251</span>  <span class="number">1005500</span>   <span class="number">235844</span>     <span class="number">563</span>        <span class="number">0</span>         <span class="number">-1000</span> java</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [ <span class="number">5709</span>]  <span class="number">1000</span>  <span class="number">5709</span>  <span class="number">1007769</span>   <span class="number">134443</span>     <span class="number">358</span>        <span class="number">0</span>             <span class="number">0</span> java</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [ <span class="number">9434</span>]     <span class="number">0</span>  <span class="number">9434</span>   <span class="number">142807</span>      <span class="number">793</span>      <span class="number">38</span>        <span class="number">0</span>             <span class="number">0</span> YDService</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Out of memory: Kill process <span class="number">5709</span> (java) score <span class="number">109</span> <span class="keyword">or</span> sacrifice child</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Killed process <span class="number">5709</span> (java) total-vm:<span class="number">4031076</span>kB, anon-rss:<span class="number">537772</span>kB, file-rss:<span class="number">0</span>kB, shmem-rss:<span class="number">0</span>kB</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;在03:53的时候，看到oom_killer被唤醒。oom_killer会选择占用内存最高的，然后kill 掉 oom_score_adj 值高的进程。<br>&nbsp;&nbsp;&nbsp;&nbsp;日志显示，oom_killer 杀的进程号为5709，而5709是一个java进程，所以也可以断定就被是kill掉的tomcat ，它占用的内存为612065，oom_score_adj为0，所以oom_killer选择kill掉它。</p><h5 id="插播-oom-killer介绍"><a href="#插播-oom-killer介绍" class="headerlink" title="插播 oom_killer介绍"></a>插播 oom_killer介绍</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;Linux下允许程序申请比系统可用内存更多的内存，这个特性叫Overcommit。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Overcommit原理</strong>：优化，申请内存不一定马上使用，可能申请后，如果你在使用的时候有资源释放了，那么就说明 你的申请是有效的<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>容易出现的问题：</strong> 如果使用的时候，还是没有释放出足够的内存，当你用到这个Overcommit给你的内存的时候，系统还没有资源的话，OOM killer就跳出来了。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>oom_killer：策略：</strong>Linux下有3种Overcommit的策略（参考内核文档：vm/overcommit-accounting），可以在/proc/sys/vm/overcommit_memory配置（取0,1和2三个值，默认是0）。</p><ol><li><strong>0：</strong>启发式策略，比较严重的Overcommit将不能得逞，比如你突然申请了128TB的内存。而轻微的overcommit将被允许。另外，root能Overcommit的值比普通用户要稍微多些。</li><li><strong>1：</strong>永远允许overcommit，这种策略适合那些不能承受内存分配失败的应用，比如某些支付模块应用。</li><li><strong>2：</strong>永远禁止overcommit，在这个情况下，系统所能分配的内存不会超过swap+RAM*系数（/proc/sys/vm/overcmmit_ratio，默认50%，你可以调整），如果这么多资源已经用光，那么后面任何尝试申请内存的行为都会返回错误，这通常意味着此时没法运行任何新程序</li></ol><h5 id="继续分析"><a href="#继续分析" class="headerlink" title="继续分析"></a>继续分析</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>关闭进程选择策略：</strong>没用的且耗内存多的程序被枪，作为用户，我们可以通过<strong>设置一些值来影响OOM killer做出决策</strong>。Linux下每个进程都有个OOM权重，在/proc/pid/oom_adj里面，取值是-17到+15，<strong>取值越高，越容易被干掉</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;最终OOM killer是通过/proc/pid/oom_score这个值来决定哪个进程被干掉的。这个值是系统综合进程的内存消耗量、CPU时间(utime + stime)、存活时间(uptime - start time)和oom_adj计算出的，消耗内存越多分越高，存活时间越长分越低。总之，总的策略是：损失最少的工作，释放最大的内存同时不伤及无辜的用了很大内存的进程，并且杀掉的进程数尽量少。<br>具体参考：<a href="http://blog.csdn.net/fjssharpsword/article/details/9341563" target="_blank" rel="noopener">http://blog.csdn.net/fjssharpsword/article/details/9341563</a></p><h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><ol><li>加内存，享受价格成倍增长的乐趣</li><li>修改/proc/pid/oom_adj，取值-17~15，默认0，越小越不容易选中</li><li>根据项目情况修改堆栈配置。（下文tomcat 调优）</li><li>修改代码，比如说大批量处理，不应该一开始把数据全加载到内存中。</li><li><strong>多说一句：</strong>我发现每天固定有个时间点，内存会莫名升高，估计是腾讯云在跑批，所以内存不要用得太紧，多留一点。</li></ol><h4 id="tomcat启动慢"><a href="#tomcat启动慢" class="headerlink" title="tomcat启动慢"></a>tomcat启动慢</h4><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;Tomcat 7/8使用org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom类产生安全随机类SecureRandom的实例作为会话ID，这个操作巨慢。</p><h5 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h5><ol><li>在Tomcat环境中解决，可以通过配置JRE使用非阻塞的Entropy Source。在catalina.sh中加入这么一行：<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.security.egd=<span class="keyword">file</span>:<span class="regexp">/dev/</span>.<span class="regexp">/urandom</span></span><br></pre></td></tr></table></figure></li><li>在JVM环境中解决，打开$JAVA_PATH/jre/lib/security/java.security这个文件<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">securerandom.<span class="keyword">source</span>=<span class="keyword">file</span>:<span class="regexp">/dev/u</span>random</span><br><span class="line">替换成</span><br><span class="line">securerandom.<span class="keyword">source</span>=<span class="keyword">file</span>:<span class="regexp">/dev/</span>.<span class="regexp">/urandom</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="dev-urandom-和-dev-random"><a href="#dev-urandom-和-dev-random" class="headerlink" title="/dev/urandom 和 /dev/random"></a>/dev/urandom 和 /dev/random</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;/dev/random和/dev/urandom是Linux系统中提供的随机伪设备，这两个设备的任务，是提供永不为空的随机字节数据流。很多解密程序与安全应用程序（如SSH Keys,SSL Keys等）需要它们提供的随机数据流。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>这两个设备的差异在于：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;/dev/random的random pool依赖于系统中断，因此在系统的中断数不足时，/dev/random设备会一直封锁，尝试读取的进程就会进入等待状态，直到系统的中断数充分够用.<br>&nbsp;&nbsp;&nbsp;&nbsp;/dev/random设备可以保证数据的随机性。<br>&nbsp;&nbsp;&nbsp;&nbsp;/dev/urandom不依赖系统的中断，也就不会造成进程忙等待，但是数据的随机性也不高。</p><h4 id="tomcat-调优"><a href="#tomcat-调优" class="headerlink" title="tomcat 调优"></a>tomcat 调优</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">JAVA_OPTS="-Xms512m</span> -Xmx2048m -XX:<span class="attr">PermSize=256M</span> -XX:<span class="attr">MaxPermSize=512m</span> -Ddubbo.shutdown.<span class="attr">hook=true</span> -XX:+HeapDumpOnOutOfMemoryError -XX:<span class="attr">HeapDumpPath=/home/administrator/software/server/tomcat-rcm/dump/oom.hprof"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上为2核4G的配置，<strong>只做参考，根据自己项目修改</strong>，在catalina.sh加上。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Xmx：</strong>用来设置你的应用程序能够使用的最大内存数,如果程序要花很大内存的话，那就需要修改增加此数的值。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Xms：</strong>用它来设置程序初始化的时候内存栈的大小，增加这个值的话你的程序的启动性能会得到提高。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>XX:PermSize：</strong>表示非堆区初始内存分配大小，其缩写为permanent size（持久化内存）<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>XX:MaxPermSize：</strong>表示对非堆区分配的内存的最大上限<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>XX:+HeapDumpOnOutOfMemoryError：</strong>JVM会在遇到OutOfMemoryError时拍摄一个“堆转储快照”，并将其保存在一个文件中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;JAVA_OPTS这个变量会在tomcat启动时应用，但是也会在执行shutdown.sh时应用。当你关闭tomcat时如果告诉你内存不够，不要惊慌，这只是在执行shutdown.sh会启动另一个程序，而这时申请不到像启动时那么大的内存，就会报错，你可以忽略该异常，执行kill来关闭tomcat。</p><h4 id="tomcat访问项目时不需要加项目名称"><a href="#tomcat访问项目时不需要加项目名称" class="headerlink" title="tomcat访问项目时不需要加项目名称"></a>tomcat访问项目时不需要加项目名称</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;修改conf目录下的server.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"localhost"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">xmlNamespaceAware</span>=<span class="string">"false"</span> <span class="attr">xmlValidation</span>=<span class="string">"false"</span>&gt;</span>  </span><br><span class="line">     <span class="comment">&lt;!-- path留空代表访问域名后面不需要带项目的名称 --&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">""</span> <span class="attr">docBase</span>=<span class="string">"F:\temp"</span> <span class="attr">reloadable</span>=<span class="string">"false"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式05-无视约束</title>
      <link href="/2018/07/08/sql/antipatterns/05-%E6%97%A0%E8%A7%86%E7%BA%A6%E6%9D%9F/"/>
      <url>/2018/07/08/sql/antipatterns/05-%E6%97%A0%E8%A7%86%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="目的：简化数据库架构"><a href="#目的：简化数据库架构" class="headerlink" title="目的：简化数据库架构"></a>目的：简化数据库架构</h4><p>&nbsp;&nbsp;&nbsp;&nbsp; 一些开发人员为了简化数据库架构，不推荐使用引用完整性约束，原因有一下几点：</p><ol><li>数据更新有可能和约束冲突;</li><li>当前的数据库设计如此灵活，以至于不支持引用完整性约束;</li><li>数据库为外键建立的索引会影响性能;</li><li>当前使用的数据库不支持外键。比如MySQL的MyISAM存储引擎，或者比SQLite3.6.19早的版本;</li><li>定义外键的语法并不简单，还需要查阅;</li></ol><h4 id="反模式：无视约束"><a href="#反模式：无视约束" class="headerlink" title="反模式：无视约束"></a>反模式：无视约束</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;不使用外键约束能使数据库设计更加简单、灵活，或者执行更加高效，但是不得不在其他方面付出相应的代价–增加额外的代码来手动维护引用完整性</p><h5 id="假设无暇代码"><a href="#假设无暇代码" class="headerlink" title="假设无暇代码"></a>假设无暇代码</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;要避免在没有外键约束的情况下产生引用的不完整状态，需要再任何改变生效前执行额外的Select查询，以此来确保这些改变不会导致引用错误。比如插入一条bug</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询account_id是否存在</span></span><br><span class="line"><span class="keyword">select</span> account_id <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> account_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 才能执行插入</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug(reported_by) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h5 id="检查错误"><a href="#检查错误" class="headerlink" title="检查错误"></a>检查错误</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;开发人员使用额外的脚本来查询是否有错误的数据。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b.bug_id, b.status <span class="keyword">from</span> bug b</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> bug_status s <span class="keyword">on</span> b.status = s.status</span><br><span class="line"><span class="keyword">where</span> s.status <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;试想一下，每天手动执行成百上千个这样对整表联结查询的sql是多么恐怖的事情。</p><h5 id="修改代码、数据"><a href="#修改代码、数据" class="headerlink" title="修改代码、数据"></a>修改代码、数据</h5><ol><li>你可以在开发时写几个简单查询来保证引用完整性，但是当修改代码，如何能保证会同时修改所有的地方。</li><li>可能有的用户直接了当的修改或删除了被引用的数据，会导致其他表引用发生未知错误。</li><li>当你Update更新一条被其他记录依赖的记录时，在没有更新父记录前，你不能更新子记录，也不能在更新父记录前更新子记录。你需要同步执行两边的更新，但是使用2个独立的更新语句是不现实的。</li></ol><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>当出现以下情况时，可能是反模式</p><ol><li>我要怎么写这个查询来检查一个值是否没有被同时存在2张表中？（通常这样的需求是为了查找那些孤立的行数据）</li><li>有没有一种简单的方法来判断在一张表中的数据是否也在第二张表中存在？（这么做是用来确认父记录切实存在。外键会自动完成这些，并且外键会使用这父表的索引尽可能的高效完成）</li><li>有人说不要用外键，外键影响数据库效率。</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;如果数据库产品(mysql的MyISAM存储引擎，SQLite 3.6.19 之前的版本)不支持外键约束功能，则不得不使用别的方法来保持引用完整性，比如使用监控脚本。<br>&nbsp;&nbsp;&nbsp;&nbsp;同样也存在一些极度灵活的数据库设计，外键无法用来表示其对应的关系。</p><h4 id="解决方案：声名约束"><a href="#解决方案：声名约束" class="headerlink" title="解决方案：声名约束"></a>解决方案：声名约束</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;声明外键约束，无疑可以保证数据完整性，但是更新，删除时会变的困难，下面会给你解答这个难题</p><h5 id="支持同步修改"><a href="#支持同步修改" class="headerlink" title="支持同步修改"></a>支持同步修改</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;外键有另一个在应用程序中无法模拟的特性：级联更新。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bus(</span><br><span class="line">reported_by <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">'NEW'</span>,</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(reported_by) <span class="keyword">references</span> <span class="keyword">account</span>(account_id)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span>,</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> restrict, <span class="comment">-- 无法删除bug中被引用的账号</span></span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(<span class="keyword">status</span>) <span class="keyword">references</span> bug_stastus(<span class="keyword">status</span>)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span>,</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">set</span> <span class="keyword">default</span> <span class="comment">-- 删除status会设置成默认值</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这个方案允许你更新或删除父记录，数据库会帮你处理子记录，不会出现上面先更新父记录还是先更新子记录的问题</p><h5 id="系统开销过度？"><a href="#系统开销过度？" class="headerlink" title="系统开销过度？"></a>系统开销过度？</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;外键约束需要那么多一点的系统开销，但是相比其他的选择，外键确实高效一点</p><ol><li>不需要在更新或删除记录前执行Select检查；</li><li>在同步修改时不需要再锁住整张表；</li><li>不再需要执行定期监控脚本来修正不可避免的孤立数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式04-需要ID</title>
      <link href="/2018/07/07/sql/antipatterns/04-%E9%9C%80%E8%A6%81ID/"/>
      <url>/2018/07/07/sql/antipatterns/04-%E9%9C%80%E8%A6%81ID/</url>
      
        <content type="html"><![CDATA[<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;这章目的就是要确认哪些使用了主键，却混淆了主键的本质而造成的一种反模式。</p><h4 id="反模式（每个数据库表都需要一个伪主键）"><a href="#反模式（每个数据库表都需要一个伪主键）" class="headerlink" title="反模式（每个数据库表都需要一个伪主键）"></a>反模式（每个数据库表都需要一个伪主键）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在表中，加入一个对于表的域模型无实际意义的列，叫做ID，用它来定位表中的某一条记录。</p><h5 id="冗余键值"><a href="#冗余键值" class="headerlink" title="冗余键值"></a>冗余键值</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">bug_id <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">unique</span>,</span><br><span class="line">description <span class="built_in">varchar</span>(<span class="number">1000</span>),</span><br><span class="line">...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上设计中，bug_id也用来定位到表中某一条数据，它和id有这相同的作用。</p><h5 id="允许重复项"><a href="#允许重复项" class="headerlink" title="允许重复项"></a>允许重复项</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_product(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">product_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(bug_id) <span class="keyword">references</span> bug(bug_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(product_id) <span class="keyword">references</span> bug(product_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;上面设置使用id做为主键，但是它并不能约束bug_id,product_id的组合存在重复，那么你必须再添加unique约束，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_product(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">product_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">unique</span> <span class="keyword">key</span>(bug_id, product_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(bug_id) <span class="keyword">references</span> bug(bug_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(product_id) <span class="keyword">references</span> bug(product_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但是，当你在bug_id, product_id这两列上应用唯一约束，此时id这一列就会变成多余的。</p><h5 id="意义不明的关键字"><a href="#意义不明的关键字" class="headerlink" title="意义不明的关键字"></a>意义不明的关键字</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;单词code有很多意思，其一用于简化或加密消息，其二还有写代码的意思。而ID这个词，如此普通，完全无法表达更深层次的意思，特别是你在做两张表联结查询的时候</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b.id, a.id </span><br><span class="line"><span class="keyword">from</span> bug b </span><br><span class="line"><span class="keyword">join</span> <span class="keyword">account</span> a <span class="keyword">on</span> b.assigned_to = a.id</span><br><span class="line"><span class="keyword">where</span> b.status = <span class="string">'OPEN'</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;列名ID并不会是查询变得清晰，而使用bug_id或者account_id，事请就会变更加简单。</p><h5 id="使用USING关键字"><a href="#使用USING关键字" class="headerlink" title="使用USING关键字"></a>使用USING关键字</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你可能很熟悉联结查询</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">as</span> b <span class="keyword">join</span> bus_product <span class="keyword">as</span> bp <span class="keyword">on</span> b.bug_id=bp.bug_id;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;SQL其实还支持另一种更见简洁的联结查询</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">join</span> bus_product <span class="keyword">USING</span>(bug_id);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;然而，如果所有的表都是ID作为伪主键，那么只能使用ON做联结查询</p><h5 id="使用组合键之难"><a href="#使用组合键之难" class="headerlink" title="使用组合键之难"></a>使用组合键之难</h5><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>当出现以下情况时，可能是反模式</p><ol><li>我觉得这张表不需要主键；</li><li>我怎么能在多对多的表中存储重复的项；</li><li>我学过《数据库设计理论》，里面说我应该把数据移动到一张查询表中，然后通过ID查找。但是我不想这么做，因为每次我想要获得真是的数据，都不得不做一次连接查询。（这在数据库设计中是一个常见的误区，称为“正规化”，然而实际中对于伪主键并没有什么需要做的）</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;使用伪主键，或者通过自动增长的整形的机制本身没有什么错误，但不是每张表都需要一个伪主键，更没有必要将每个伪主键都定义为ID。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;主键是约束而非数据类型，你可以定义任意多的列为主键，只要其数据类型支持索引。你还可以将一个列定义为自增长的整形而不设定其为主键，这两者完全没有关系，<strong>别被既有的惯例限制住设计。</strong></p><h5 id="直接了当的描述设计"><a href="#直接了当的描述设计" class="headerlink" title="直接了当的描述设计"></a>直接了当的描述设计</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;为主键设置一个更有意义的名称，比如，bug表的主键应该叫bug_id。<br>&nbsp;&nbsp;&nbsp;&nbsp;外键应该尽可能和所引用的列使用相同的名称，这通常意味这：一个主键的名称在整个数据库中的设计是唯一的。任意两张表都不应该使用相同的名称来定义主键，除非其中之一引用了另一个作为主键，但是有时也需要和其所引用的主键区分开，从而使他们之间引用关系表现的更加清晰。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line">  ....</span><br><span class="line">  reported_by <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  <span class="keyword">foreign</span> <span class="keyword">key</span>(reported_by) <span class="keyword">references</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="拥抱自然键和组合键"><a href="#拥抱自然键和组合键" class="headerlink" title="拥抱自然键和组合键"></a>拥抱自然键和组合键</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你的表中包含一列能确认唯一、非空以及能够用来定位一条记录，就别仅仅因为传统而觉得有必要加上一个伪主键</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;以下都是我个人想法，看完本章我觉得我还是会继续使用id作为主键，另外就算有一列可能作为唯一标识，我也还是会加上id。<br>&nbsp;&nbsp;&nbsp;&nbsp;举个栗子，假如现在有一张表，存在一列可以唯一的标识一条记录，我因此没有加上id列，产品上线之后，业务方变更需求说，当初那个可以唯一标识一条记录的列变成可以重复的了，那么你该怎么办，此时再加上id列，还来得及吗？</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据安全02-Base64 算法原理</title>
      <link href="/2018/06/30/theory/BASE64%20%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"/>
      <url>/2018/06/30/theory/BASE64%20%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol><li>表示二进制数据，可用于传输二进制数据，如文件、缩略图等</li><li>对数据起一定加密效果</li></ol><h4 id="转换原理"><a href="#转换原理" class="headerlink" title="转换原理"></a>转换原理</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Base64算法，是用64个可打印字符表示二进制所有数据方法。Base64字符成包含A—Z，a—z，0—9，+，/ ，他们编码对应表如下。<br><img src="/images/encrypt/base64_1.png" alt="编码表"><br>&nbsp;&nbsp;&nbsp;&nbsp;一个Base64字符编码转换成二进制都是8个bit位，而前两位都00，有效数字只有6个bit位，也就是说<strong>只需要6个bit位就能表示1个Base64字符</strong>，而正常的字符是使用8个bit位表示， 8和6的最小公倍数是24，所以4个Base64字符可以表示3个标准的ascii字符。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;按照以上原理，我们将要加密的明文对应的ascii值转换成二进制并拼接在一起，将其分为<strong>每6个bit为一份，每4份为一组</strong>。不够6个bit位的用0补充，不够4份的用=补充。根据base64编码表将每一份转成对应的Base64字符，得到的也就是密文。</p><h4 id="转换过程"><a href="#转换过程" class="headerlink" title="转换过程"></a>转换过程</h4><ol><li>得到明文每一个字符对应的ascii码</li><li>将ascii码转换成二进制，并拼接在一起</li><li>将拼接在一起的二进制，分为6个bit位为一份，4份为一组</li><li>将每一份根据base64编码表转换成base64字符</li><li>最后不够6个bit位的用0补充，不够一组的用=补充为4份</li></ol><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><h5 id="不需要补充0或-（明文：Man）"><a href="#不需要补充0或-（明文：Man）" class="headerlink" title="不需要补充0或=（明文：Man）"></a>不需要补充0或=（明文：Man）</h5><ol><li><strong>将明文每一个字符对应的ascii码</strong><br>M 对应ascii码 ：77<br>a 对应ascii码 ：97<br>n 对应ascii码 ：110</li><li><strong>将ascii码转换成二进制，并拼接在一起</strong><br>77 二进制 ： 01001101<br>97 二进制 ： 01100001<br>110 二进制 ： 01101110<br>拼接 : 010011010110000101101110</li><li><strong>分为6个bit位为一份，4份为一组</strong><br>010011<br>010110<br>000101<br>101110</li><li><strong>每一份根据base64编码表转换成base64字符</strong><br>010011 十进制 : 19 : base64字符 : T<br>010110 十进制 : 22 : base64字符 : W<br>000101 十进制 : 5 : base64字符 : F<br>101110 十进制 : 46 : base64字符 : u</li><li><strong>详解图</strong><br><img src="/images/encrypt/base64_2.png" alt="详解图"></li></ol><h5 id="需要补充0或-（明文：BC）"><a href="#需要补充0或-（明文：BC）" class="headerlink" title="需要补充0或=（明文：BC）"></a>需要补充0或=（明文：BC）</h5><ol><li><strong>将明文每一个字符对应的ascii码</strong><br>B 对应ascii码 ：66<br>C 对应ascii码 ：67</li><li><strong>将ascii码转换成二进制，并拼接在一起</strong><br>66 二进制 ： 01000010<br>67 二进制 ： 01000011<br>拼接 : 0100001001000011</li><li><strong>分为6个bit位为一份，4份为一组，补充0和=</strong><br>010000<br>100100<br>0011<strong>00</strong></li></ol><p><strong>xxxxxx</strong><br>4. <strong>每一份根据base64编码表转换成base64字符</strong><br>010000 十进制 : 16 : base64字符 : Q<br>100100 十进制 : 36 : base64字符 : k<br>0011<strong>00</strong> 十进制 : 12 : base64字符 : M<br><strong>xxxxxx</strong> : base64字符 : =<br>5. <strong>详解图</strong><br><img src="/images/encrypt/base64_3.png" alt="详解图"></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;java中早已提供以上算法的jar包，不用自己去实现以上算法，个人倾向使用apache提供的</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.<span class="built_in">binary</span>.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> ENCODING_UTF8 = <span class="string">"UTF-8"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二进制数据编码为BASE64字符串,根据isChunked是否输出换行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> encodeBase64(<span class="built_in">byte</span>[] bytes, <span class="built_in">boolean</span> isChunked) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">String</span>(Base64.encodeBase64(bytes, isChunked), ENCODING_UTF8);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BASE64解码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] decodeBase64(<span class="keyword">String</span> encodedStr) &#123;</span><br><span class="line">    <span class="built_in">byte</span>[] result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = Base64.decodeBase64(encodedStr);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;ASCII码总共128个，用来表示英文字母、数字以及英文标点符号。而简体中文、繁体中文、日文以及韩文等都是用多字节来存储的，通常称之为多字节字符。因为Base编码的输入是字符串的编码，<strong>不同编码的字符串的Base64结果是不同的</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;个人觉得用base64传输缩略图，非常合适，客户端收到base64字符后，就可以显示图片，而不用依赖网络了。这样至少可以保证缩略图一定能显示出来。但是通过以上算法，可以发现<strong>base64后的字符串大小是原来的4/3</strong>.</p>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
            <tag> Base64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据安全01-HTTPS 加密原理</title>
      <link href="/2018/06/29/theory/HTTPS%20%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"/>
      <url>/2018/06/29/theory/HTTPS%20%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;前后端分离的开发模式中，一般由后端提供给接口给前端调用。如果接口中包含用户身份证、银行卡等敏感信息，我们必须要考虑数据安全性，因为网络传输，本身就没有安全保障。所以容不得马虎。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;众所周知，Https比Http要安全，因为传输中Https会对数据进行加密，那么到底如何加密的呢？而Https比Http要慢，也是因为要进行加密过程</p><h4 id="Https-加密简介"><a href="#Https-加密简介" class="headerlink" title="Https 加密简介"></a>Https 加密简介</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;该过程使用RSA加密算法，和AES加密算法.</p><ol><li><strong>AES(对称加密)</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;加密、解密过程中使用同一个密钥，效率快</li><li><strong>RSA(非对称加密)</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;加密、解密分别使用不同的密钥，此密钥是成对的，分为公钥和私钥。公钥允许泄露，私钥只能一方拥有，所以<strong>一般用公钥对数据加密，私钥对数据解密。</strong></li><li><strong>Https加密详情</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;使用RSA的公钥对AES的密钥加密，传输给另一端，另一端使用私钥解密密文得到AES密钥，有了AES密钥了，就可以进行加密操作了。</li></ol><h4 id="Https-加密过程"><a href="#Https-加密过程" class="headerlink" title="Https 加密过程"></a>Https 加密过程</h4><ol><li>客户端启动，发送请求到服务端，服务端用RSA算法生成一对公钥和私钥，我们简称为pubkey1,prikey1，将公钥pubkey1返回给客户端。</li><li>客户端拿到服务端返回的公钥pubkey1后，自己用RSA算法生成一对公钥和私钥，我们简称为pubkey2,prikey2，并将公钥pubkey2通过公钥pubkey1加密，加密之后传输给服务端。</li><li>此时服务端收到客户端传输的密文，用私钥prikey1进行解密，因为数据是用公钥pubkey1加密的，通过解密就可以得到客户端生成的公钥pubkey2。</li><li>然后自己在生成对称加密，也就是我们的AES的密钥，生成了这个key之后我们就用公钥pubkey2进行加密，返回给客户端。</li><li>客户端收到密文后，使用pubkey2对应的私钥prikey2，对密文解密得到AES的密钥。</li><li>最后就用加密key进行数据传输的加密，至此整个流程结束。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
            <tag> 加密 </tag>
            
            <tag> RSA </tag>
            
            <tag> AES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP两种代理JDK和CGLIB</title>
      <link href="/2018/06/25/java/AOP%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86JDK%E5%92%8CCGLIB/"/>
      <url>/2018/06/25/java/AOP%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86JDK%E5%92%8CCGLIB/</url>
      
        <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/u013126379/article/details/52121096" target="_blank" rel="noopener">https://blog.csdn.net/u013126379/article/details/52121096</a></p><h4 id="一、原理区别："><a href="#一、原理区别：" class="headerlink" title="一、原理区别："></a>一、原理区别：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p><p>1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP<br>2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP<br>3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</p><p>如何强制使用CGLIB实现AOP？<br> （1）添加CGLIB库，SPRING_HOME/cglib/*.jar<br> （2）在spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class=”true”/&gt;</p><p>JDK动态代理和CGLIB字节码生成的区别？<br> （1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类<br> （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法<br>   因为是继承，所以该类或方法最好不要声明成final </p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
            <tag> CGLIB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式03-单纯的树</title>
      <link href="/2018/06/23/sql/antipatterns/03-%E5%8D%95%E7%BA%AF%E7%9A%84%E6%A0%91/"/>
      <url>/2018/06/23/sql/antipatterns/03-%E5%8D%95%E7%BA%AF%E7%9A%84%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;设想你正在开发一个新闻网站，读者可以对文章评论，甚至相互回复，这样一来这个树就会<strong>延伸出很多分支</strong>，其<strong>深度也会大大增加</strong>，你选择一个简单的方案来实现需求：每条评论引用它所回复的评论。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> comments(</span><br><span class="line">comment_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">parent_id <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span>,</span><br><span class="line"><span class="keyword">comment</span> <span class="built_in">text</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (parent_id) <span class="keyword">REFERENCES</span> comments(comment_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这样一来，程序逻辑变得清晰明了，<strong>但是它并不能完成一棵树最基本的功能，就是遍历一整棵树</strong></p><h4 id="目的（分成存储与查询）"><a href="#目的（分成存储与查询）" class="headerlink" title="目的（分成存储与查询）"></a>目的（分成存储与查询）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;递归关系的数据很常见，数据会像树或以层级方式组织，比如：</p><ul><li><strong>组织机构图</strong>：职员与经理关系，每个职员有一个经理，同时经理也是一个职员</li><li><strong>线程化讨论</strong>：像引言中介绍的评论链。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;本篇对树结构定义：</p><ul><li>最上层的节点叫做<strong>根（root）节点</strong>，它没有父节点</li><li>最底层的没有子节点的节点叫做<strong>叶（leaf）</strong></li><li>中间的节点简单地称为<strong>非叶节点（nonleaf）</strong></li></ul><h4 id="反模式（总是依赖父节点，邻接表）"><a href="#反模式（总是依赖父节点，邻接表）" class="headerlink" title="反模式（总是依赖父节点，邻接表）"></a>反模式（总是依赖父节点，邻接表）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;最简单的方式就是添加parent_id，引用同一张表的其他条目，这样的设计也叫做<strong>邻接表</strong>，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">comment</span>(</span><br><span class="line">comment_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">parent_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span>,</span><br><span class="line">bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">author <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">comment_date datetime <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">comment</span> <span class="built_in">text</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (parent_id) <span class="keyword">REFERENCES</span> <span class="keyword">comment</span>(comment_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (author) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>以下展示一个树结构</strong><br><img src="/images/sql/antipatterns/03/comment_1.png" alt="评论示意图"></p><h5 id="1-使用邻接表查询树"><a href="#1-使用邻接表查询树" class="headerlink" title="1.使用邻接表查询树"></a>1.使用邻接表查询树</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;在引言中提到，邻接表不能完成一棵树最基本的查询：虽然你可以使用关联查询出某一个节点的子节点，如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select </span><span class="built_in">c1</span>.*, <span class="built_in">c2</span>.* from comment <span class="built_in">c1</span></span><br><span class="line"><span class="symbol">left</span> join comment <span class="built_in">c2</span> on <span class="built_in">c2</span>.parent_id = <span class="built_in">c1</span>.comment_id</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但是，这个查询只能获取两层，如果要继续查询某个节点的孙子，就的再关联一层。但是树的深度是无止境的。<br>&nbsp;&nbsp;&nbsp;&nbsp;另外还有一种办法，查询出所有的评论，然后再Java中重新构造这个树，但是大量的数据赋值，这是非常低效的。</p><h5 id="2-使用邻接表维护树"><a href="#2-使用邻接表维护树" class="headerlink" title="2.使用邻接表维护树"></a>2.使用邻接表维护树</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>插入修改节点：</strong>使用邻接表，是非常简单</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">comment</span>(parent_id, bug_id, author, <span class="keyword">comment</span>)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">7</span>, <span class="number">1234</span>, <span class="string">'Kukla'</span>, <span class="string">'Thanks!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">comment</span> <span class="keyword">SET</span> parent_id = <span class="number">4</span> <span class="keyword">WHERE</span> comment_id = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>删除节点：</strong>但是删除节点会变得复杂，你必须从该节点下最低级子节点开始删除，以保证外键完整性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> comment_id <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> parent_id = <span class="number">4</span> <span class="comment">-- return 5 and 6</span></span><br><span class="line"><span class="keyword">select</span> comment_id <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> parent_id = <span class="number">5</span> <span class="comment">-- return none</span></span><br><span class="line"><span class="keyword">select</span> comment_id <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> parent_id = <span class="number">6</span> <span class="comment">-- return 7</span></span><br><span class="line"><span class="keyword">select</span> comment_id <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> parent_id = <span class="number">7</span> <span class="comment">-- return none</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> comment_id <span class="keyword">in</span> (<span class="number">7</span>);</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> comment_id <span class="keyword">in</span> (<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> comment_id = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这里虽然可以使用带 <strong>ON DELETE CASCADE</strong> 来修改外键，来使它自动完成以上操作。但是，如果需求是删除一个非叶子节点，并提升它的子节点，或将它子节点移动到另一个节点，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查出自己的父节点</span></span><br><span class="line"><span class="keyword">select</span> parent_id <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> comment_id = <span class="number">6</span>; <span class="comment">-- return 4</span></span><br><span class="line"><span class="comment">-- 修改自己所有的子节点的父节点为要删除节点的父节点</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">comment</span> <span class="keyword">set</span> parent_id = <span class="number">4</span> <span class="keyword">where</span> parent_id = <span class="number">6</span>;</span><br><span class="line"><span class="comment">-- 删除自己</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> comment_id = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp; 当你说过以下话，你可能正在使用“反模式”</p><ol><li>我们的数结构要支持多少层</li><li>我们总是很害怕接触那些管理树结构的代码</li><li>我需要一个脚本来定期的清理树中的孤立节点数据</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><ol><li>邻接表设计的优势在与能快速地获取一个给定节点的直接父子节点，也很容易插入新节点、维护节点、删除节点。如果树的<strong>分层结构不是很深，可以使用这种模式</strong>。</li><li>某些数据库提供了<strong>递归查询</strong>，可是使用WITH关键字来查询，<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL Server 2005, Oracle 11g, IBM DB2, PostgreSQL 8.4</span></span><br><span class="line"><span class="keyword">with</span> CommentTree(comment_id, parent_id, bug_id, author, comment_date, <span class="keyword">comment</span>)</span><br><span class="line"><span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> * <span class="number">0</span> <span class="keyword">as</span> <span class="keyword">depth</span> <span class="keyword">from</span> <span class="keyword">comment</span></span><br><span class="line"><span class="keyword">where</span> parent_id <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> c.*, ct.depth+<span class="number">1</span> <span class="keyword">as</span> <span class="keyword">depth</span> <span class="keyword">from</span> CommentTree ct </span><br><span class="line"><span class="keyword">join</span> <span class="keyword">comment</span> c <span class="keyword">on</span> ct.comment_id = c.parent_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> CommentTree <span class="keyword">where</span> bug_id = <span class="number">1234</span>;</span><br><span class="line"><span class="comment">-- Oracle 9i 和 10g 递归查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">comment</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> comment_id = <span class="number">9876</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">prior</span> parent_id = comment_id</span><br></pre></td></tr></table></figure></li></ol><h4 id="解决办法-使用其他树模型"><a href="#解决办法-使用其他树模型" class="headerlink" title="解决办法:使用其他树模型"></a>解决办法:使用其他树模型</h4><h5 id="1-路径枚举："><a href="#1-路径枚举：" class="headerlink" title="1.路径枚举："></a>1.路径枚举：</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;用一个path字段保存当前节点的最顶层的祖先到自己的序列(路径)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">comment</span>(</span><br><span class="line">comment_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line"><span class="keyword">path</span> <span class="built_in">varchar</span>(<span class="number">1000</span>),</span><br><span class="line">bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">author <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">comment_date datetime <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">comment</span> <span class="built_in">text</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (author) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="/images/sql/antipatterns/03/comment_2.png" alt="评论示意图"></p><h6 id="查询评论-7（路径是1-4-6-7），的祖先"><a href="#查询评论-7（路径是1-4-6-7），的祖先" class="headerlink" title="查询评论#7（路径是1/4/6/7），的祖先"></a>查询评论#7（路径是1/4/6/7），的祖先</h6><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from comment where '<span class="number">1</span>/<span class="number">4</span>/<span class="number">6</span>/<span class="number">7</span>' like path || '%';</span><br><span class="line">-- 它会匹配到 <span class="number">1</span>/<span class="number">4</span>/<span class="number">6</span>/%，<span class="number">1</span>/<span class="number">4</span>/%，<span class="number">1</span>/%的节点，而他们就是#<span class="number">7</span>祖先</span><br></pre></td></tr></table></figure><h6 id="查询评论-4（路径是1-4），的子孙"><a href="#查询评论-4（路径是1-4），的子孙" class="headerlink" title="查询评论#4（路径是1/4），的子孙"></a>查询评论#4（路径是1/4），的子孙</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> <span class="keyword">path</span> <span class="keyword">like</span> <span class="string">'1/4/'</span> || <span class="string">'%'</span>;</span><br><span class="line"><span class="comment">-- 它会匹配到 1/4/% 的节点，而他们就是#4子孙</span></span><br></pre></td></tr></table></figure><h6 id="查询评论-4，每个用户的评论数"><a href="#查询评论-4，每个用户的评论数" class="headerlink" title="查询评论#4，每个用户的评论数"></a>查询评论#4，每个用户的评论数</h6><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select count(1) <span class="keyword">from</span> comment where path like <span class="string">'1/4'</span> || <span class="string">'%'</span></span><br><span class="line">group by author</span><br></pre></td></tr></table></figure><h6 id="插入也简单"><a href="#插入也简单" class="headerlink" title="插入也简单"></a>插入也简单</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;只需要将父节点的path查出来，再追加自己的id就行了，但是一般id是自增，你需要先insert子节点，再select父节点，再update子节点</p><h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><ol><li>优点：查询方便</li><li>缺点：</li></ol><ul><li>存在“乱穿马路”，不能保证存储的值的有效性。</li><li>修改节点，比较麻烦，所有子节点的path也要修改</li></ul><h5 id="2-嵌套集："><a href="#2-嵌套集：" class="headerlink" title="2.嵌套集："></a>2.嵌套集：</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;存储子孙节点的相关信息，而不是节点的直接祖先。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">comment</span>(</span><br><span class="line">comment_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">nsleft <span class="built_in">integer</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">nsright <span class="built_in">integer</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">author <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">comment_date datetime <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">comment</span> <span class="built_in">text</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (author) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>要求：nsleft的数值小于该节点所有后代的id，nsright的数值大于所有后代的id。</strong><br><img src="/images/sql/antipatterns/03/comment_3.png" alt="评论示意图"></p><h6 id="查询评论-4及其所有后代"><a href="#查询评论-4及其所有后代" class="headerlink" title="查询评论#4及其所有后代"></a>查询评论#4及其所有后代</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c2.* <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">as</span> c1</span><br><span class="line"><span class="keyword">join</span> <span class="keyword">comment</span> <span class="keyword">as</span> c2 <span class="keyword">on</span> c2.nsleft <span class="keyword">between</span> c1.nsleft <span class="keyword">and</span> c1.nsright</span><br><span class="line"><span class="keyword">where</span> c1.comment_id=<span class="number">4</span>;</span><br></pre></td></tr></table></figure><h6 id="查询评论-6的祖先"><a href="#查询评论-6的祖先" class="headerlink" title="查询评论#6的祖先"></a>查询评论#6的祖先</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c2.* <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">as</span> c1</span><br><span class="line"><span class="keyword">join</span> <span class="keyword">comment</span> <span class="keyword">as</span> c2 <span class="keyword">on</span> c1.nsleft <span class="keyword">between</span> c2.nsleft <span class="keyword">and</span> c2.nsright</span><br><span class="line"><span class="keyword">where</span> c1.comment_id=<span class="number">4</span>;</span><br></pre></td></tr></table></figure><h6 id="删除指定节点"><a href="#删除指定节点" class="headerlink" title="删除指定节点"></a>删除指定节点</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;可以直接删除，虽然再示例图中，左右两个值时有序的，而每个节点也是和它相邻的父兄节点进行比较，但是嵌套集设计并不必须保证分层关系。并且在你删除某节点后，该节点所有子节点自动上移</p><h6 id="查询评论-6的直接父亲"><a href="#查询评论-6的直接父亲" class="headerlink" title="查询评论#6的直接父亲"></a>查询评论#6的直接父亲</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> parent.* <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">as</span> c </span><br><span class="line"><span class="keyword">join</span> <span class="keyword">comment</span> <span class="keyword">as</span> <span class="keyword">parent</span> </span><br><span class="line"><span class="keyword">on</span> c.nsleft <span class="keyword">between</span> parent.nsleft <span class="keyword">and</span> parent.nsright</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">comment</span> <span class="keyword">as</span> in_between </span><br><span class="line"><span class="keyword">on</span> c.nsleft <span class="keyword">between</span> in_between.nsleft <span class="keyword">and</span> in_between.nsright</span><br><span class="line"><span class="keyword">and</span> in_between.nsleft <span class="keyword">between</span> parent.nsleft <span class="keyword">and</span> parent.nsright</span><br><span class="line"><span class="keyword">where</span> c.comment_id = <span class="number">6</span></span><br><span class="line"><span class="keyword">and</span> in_between.comment_id <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h6 id="增加，移动节点"><a href="#增加，移动节点" class="headerlink" title="增加，移动节点"></a>增加，移动节点</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;这个对于嵌套集要复杂的多，你需要重新计算插入节点的相邻兄弟的节点、祖先节点和祖先节点的兄弟，来确保它们左右值都比这个新节点的左右值大，如果这个节点不是非叶节点，你还需要计算它的子孙节点。<br>&nbsp;&nbsp;&nbsp;&nbsp;插入一个叶子节点，以下语句将更新每个需要更新的地方</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- make space for NS values 8 and 9</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">comment</span></span><br><span class="line"><span class="keyword">set</span> nsleft = <span class="keyword">case</span> </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">nsleft &gt;= <span class="number">8</span> </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">nsleft + <span class="number">2</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">nsleft </span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line">nsright = nsright + <span class="number">2</span></span><br><span class="line"><span class="keyword">where</span> nsright &gt;= <span class="number">7</span>;</span><br><span class="line"><span class="comment">-- create new child of comment #5 occupying NS values 8 and 9</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">comment</span>(nsleft, nsright, author, <span class="keyword">comment</span>)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">8</span>, <span class="number">9</span>, <span class="string">'Fran'</span>, <span class="string">'Me too!'</span>);</span><br></pre></td></tr></table></figure><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>优点：查询，简单快速。删除时，原来子节点的关系自动上移。<br>缺点：</p><ol><li>查询一个节点的直接上级或下级，很困难。</li><li>增、改，困难。</li></ol><h5 id="3-闭包表："><a href="#3-闭包表：" class="headerlink" title="3.闭包表："></a>3.闭包表：</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;闭包表是解决分级存储一个简单而优雅的解决办法。<br>&nbsp;&nbsp;&nbsp;&nbsp;创建另一张叫做tree_path，他包含两列，每一列都是一个指向comment中的comment_id</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">comment</span>(</span><br><span class="line">comment_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">author <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">comment_date datetime <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">comment</span> <span class="built_in">text</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (author) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tree_path(</span><br><span class="line">ancestor <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">descendant <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span>(ancestor,descendant),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(ancestor) <span class="keyword">references</span> <span class="keyword">comment</span>(comment_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(descendant) <span class="keyword">references</span> <span class="keyword">comment</span>(comment_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;将树中任何一对具有祖先-后代关系的节点对都存储在tree_path的一行中，即使他们不是直接的父子关系，同时还增加一行指向自己。<br><img src="/images/sql/antipatterns/03/comment_4.png" alt="评论示意图"></p><h6 id="查询评论-4的后代"><a href="#查询评论-4的后代" class="headerlink" title="查询评论#4的后代"></a>查询评论#4的后代</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.* <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">join</span> tree_path <span class="keyword">as</span> t <span class="keyword">on</span> c.comment_id = t.descendant</span><br><span class="line"><span class="keyword">where</span> t.ancestor = <span class="number">4</span></span><br></pre></td></tr></table></figure><h6 id="查询评论-6的祖先-1"><a href="#查询评论-6的祖先-1" class="headerlink" title="查询评论#6的祖先"></a>查询评论#6的祖先</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.* <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">join</span> tree_path <span class="keyword">as</span> t <span class="keyword">on</span> c.comment_id = t.ancestor</span><br><span class="line"><span class="keyword">where</span> t.descendant = <span class="number">6</span></span><br></pre></td></tr></table></figure><h6 id="插入-5下的子节点-8"><a href="#插入-5下的子节点-8" class="headerlink" title="插入#5下的子节点#8"></a>插入#5下的子节点#8</h6><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insert into tree_path（ancestor,descendant）</span><br><span class="line"><span class="keyword">select</span> t.ancestor, <span class="number">8</span></span><br><span class="line">from tree_path <span class="keyword">as</span> t</span><br><span class="line">where t.descendant = <span class="number">5</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">all</span></span></span><br><span class="line"><span class="keyword">select</span> <span class="number">8</span>, <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h6 id="删除评论-4"><a href="#删除评论-4" class="headerlink" title="删除评论#4"></a>删除评论#4</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除直接后代</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tree_path <span class="keyword">where</span> descendant = <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 删除所有后代 </span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tree_path </span><br><span class="line"><span class="keyword">where</span> descendant <span class="keyword">in</span> (<span class="keyword">select</span> descendant <span class="keyword">from</span> tree_path <span class="keyword">where</span> ancestor = <span class="number">4</span>);</span><br></pre></td></tr></table></figure><h6 id="移动，-6从现在的位置-4的孩子-移动到-3下"><a href="#移动，-6从现在的位置-4的孩子-移动到-3下" class="headerlink" title="移动，#6从现在的位置(#4的孩子)移动到#3下"></a>移动，#6从现在的位置(#4的孩子)移动到#3下</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除所有子节点跟他祖先的关系</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tree_path </span><br><span class="line"><span class="keyword">where</span> descendant <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> descendant <span class="keyword">from</span> tree_path</span><br><span class="line"><span class="keyword">where</span> ancestor = <span class="number">6</span></span><br><span class="line">) <span class="keyword">and</span> ancestor <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> ancestor <span class="keyword">from</span> tree_path</span><br><span class="line"><span class="keyword">where</span> descendant = <span class="number">6</span></span><br><span class="line"><span class="keyword">and</span> ancestor != descendant</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 建立新节点的关系</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tree_path (ancestor,descendant) </span><br><span class="line"><span class="keyword">select</span> supertree.ancestor,supertree.descendant <span class="keyword">from</span> tree_path <span class="keyword">as</span> supertree</span><br><span class="line"><span class="keyword">cross</span> <span class="keyword">join</span> tree_path <span class="keyword">as</span> subtree</span><br><span class="line"><span class="keyword">where</span> supertree.descendant = <span class="number">3</span> <span class="keyword">and</span> subtree.ancestor = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h4 id="你改使用哪种设计"><a href="#你改使用哪种设计" class="headerlink" title="你改使用哪种设计"></a>你改使用哪种设计</h4><ul><li><p>邻接表<br>&nbsp;&nbsp;&nbsp;&nbsp;简单高效，如果你的数据库支持WITH或者CONNECT BY PRIOR的递归查询，那么邻接表是最高效的</p></li><li><p>路劲枚举<br>&nbsp;&nbsp;&nbsp;&nbsp;直观的看到祖先到后代关系，但无法保证引用完整性</p></li><li><p>嵌套集<br>&nbsp;&nbsp;&nbsp;&nbsp;无法保证引用完整性，太复杂。适用于查询小于非常高场景</p></li><li><p>闭包表<br>&nbsp;&nbsp;&nbsp;&nbsp;以空间换时间，通用的设计</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql批量插入数据量过大报错</title>
      <link href="/2018/06/20/sql/mysql%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E9%87%8F%E8%BF%87%E5%A4%A7%E6%8A%A5%E9%94%99/"/>
      <url>/2018/06/20/sql/mysql%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E9%87%8F%E8%BF%87%E5%A4%A7%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h4 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Packet <span class="keyword">for</span> query is too large (6071393 &gt; 4194304). You can change this value on the<span class="built_in"> server </span>by setting the max_allowed_packet<span class="string">' variable.</span></span><br></pre></td></tr></table></figure><h4 id="报错SQL"><a href="#报错SQL" class="headerlink" title="报错SQL"></a>报错SQL</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert <span class="built_in">int</span>o table_name(col1，col2) </span><br><span class="line">values (<span class="number">1</span>, <span class="number">2</span>),(<span class="number">1</span>, <span class="number">3</span>) ....;</span><br></pre></td></tr></table></figure><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;批量插入数据时，以上SQL肯定是首选，在java中使用for循环插入，效率肯定要低。但是数据量超大时，以上sql会报错，是因为msql默认限制了。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="修改mysql配置"><a href="#修改mysql配置" class="headerlink" title="修改mysql配置"></a>修改mysql配置</h5><ol><li>修改 my.ini, 添加以下配置。67108864则是大小，单位为字节。需要根据自己项目需求修改大小。需要重启mysql服务<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">max_allowed_packet</span> =<span class="number">67108864</span></span><br></pre></td></tr></table></figure></li><li>也可以登录mysql使用以下命令<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> global <span class="comment">max_allowed_packet = 67108864</span>;</span><br></pre></td></tr></table></figure></li><li>查看是否生效<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">VARIABLES</span> <span class="keyword">like</span> <span class="string">'%max_allowed_packet%'</span>;</span><br></pre></td></tr></table></figure></li></ol><h5 id="java中控制插入条数（推荐）"><a href="#java中控制插入条数（推荐）" class="headerlink" title="java中控制插入条数（推荐）"></a>java中控制插入条数（推荐）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;以上方法虽然能解燃眉之急，但是如何保证以后不会超过你设置的值？当达到一定量时，JVM也会内存溢出，数据库压力也扛不住。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; data = dosomething();</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt;&gt; temp = Lists.partition(data, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; item : temp)&#123;</span><br><span class="line">    insert(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上代码为，将要修改数据分隔成多份，每一份的大小为1000(不要写魔法值哦)个。每一份插入一次。</p>]]></content>
      
      
      <categories>
          
          <category> 踩坑日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初说 - ActiveMQ</title>
      <link href="/2018/06/17/middleware/activemq-simple/"/>
      <url>/2018/06/17/middleware/activemq-simple/</url>
      
        <content type="html"><![CDATA[<h4 id="一、AvticeMQ"><a href="#一、AvticeMQ" class="headerlink" title="一、AvticeMQ"></a>一、AvticeMQ</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;ActiveMQ 是Apache出品的开源消息总线。完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现</p><h4 id="二、JMS"><a href="#二、JMS" class="headerlink" title="二、JMS"></a>二、JMS</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p><h4 id="三、JMS支持的两种消息传递模型"><a href="#三、JMS支持的两种消息传递模型" class="headerlink" title="三、JMS支持的两种消息传递模型"></a>三、JMS支持的两种消息传递模型</h4><h5 id="1-Queue（点对点-point-to-point，简称PTP）"><a href="#1-Queue（点对点-point-to-point，简称PTP）" class="headerlink" title="1. Queue（点对点 point-to-point，简称PTP）"></a>1. Queue（点对点 point-to-point，简称PTP）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;通过该消息传递模型，一个应用程序（即消息生产者）可以向另外一个应用程序（即消息消费者）发送消息。消息目的地类型是队列（即由Session接口实现类实例通过调用其createQueue方法并传入队列名称而创建）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;消息首先被传送至消息服务器端特定的队列中，然后从此对列中将消息传送至对此队列进行监听的某个消费者。同一个队列可以关联多个消息生产者和消息消费者，但<strong>一条消息仅能传递给一个消息消费者</strong>。如果多个消息消费者正在监听队列上的消息，JMS消息服务器将根据“先来者优先”的原则确定由哪个消息消费者接收下一条消息。如果没有消息消费者在监听队列，消息将保留在队列中，直至消息消费者连接到队列为止。这种消息传递模型是传统意义上的懒模型或轮询模型。在此模型中，<strong>消息不是自动推动给消息消费者的，而是要由消息消费者从队列中请求获得</strong>。 </p><h5 id="2-Topic（发布-订阅-publish-subscribe，简称pub-sub）"><a href="#2-Topic（发布-订阅-publish-subscribe，简称pub-sub）" class="headerlink" title="2. Topic（发布/订阅 publish/subscribe，简称pub/sub）"></a>2. Topic（发布/订阅 publish/subscribe，简称pub/sub）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;通过该消息传递模型，应用程序能够将一条消息发送给多个消息消费者。消息目的地类型是主题（即Destination接口实现类实例由Session接口实现类实例通过调用其createTopic方法并传入主题名称而创建）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;消息首先由消息生产者发布至消息服务器中特定的主题中，然后由消息服务器将消息传送至所有已订阅此主题的消费者。与PTP消息传递模型不同，<strong>pub/sub消息传递模型允许多个主题订阅者接收同一条消息</strong>。在该模型中，消息会自动广播，<strong>消息消费者无须通过主动请求或轮询主题的方法来获得新的消息</strong>。</p><h5 id="3-Queue-和-Topic-具体区别"><a href="#3-Queue-和-Topic-具体区别" class="headerlink" title="3. Queue 和 Topic 具体区别"></a>3. Queue 和 Topic 具体区别</h5><table><thead><tr><th>Tables</th><th>Topic</th><th>Queue</th></tr></thead><tbody><tr><td>概要</td><td>Publish Subscribe messaging 发布订阅消息</td><td>Point-to-Point 点对点</td></tr><tr><td>有无状态</td><td>topic数据默认不落地，是无状态的。</td><td>Queue数据默认会在mq服务器上以文件形式保存，比如Active MQ一般保存在$AMQ_HOME\data\kr-store\data下面。也可以配置成DB存储。</td></tr><tr><td>完整性保障</td><td>并不保证publisher发布的每条数据，Subscriber都能接受到。</td><td>Queue保证每条数据都能被receiver接收。</td></tr><tr><td>消息是否会丢失</td><td>一般来说publisher发布消息到某一个topic时，只有正在监听该topic地址的sub能够接收到消息；如果没有sub在监听，该topic就丢失了。</td><td>Sender发送消息到目标Queue，receiver可以异步接收这个Queue上的消息。Queue上的消息如果暂时没有receiver来取，也不会丢失。</td></tr><tr><td>消息发布接收策略</td><td>一对多的消息发布接收策略，监听同一个topic地址的多个sub都能收到publisher发送的消息。Sub接收完通知mq服务器</td><td>一对一的消息发布接收策略，一个sender发送的消息，只能有一个receiver接收。receiver接收完后，通知mq服务器已接收，mq服务器对queue里的消息采取删除或其他操作。</td></tr></tbody></table><h4 id="四、AvticeMQ-配置"><a href="#四、AvticeMQ-配置" class="headerlink" title="四、AvticeMQ 配置"></a>四、AvticeMQ 配置</h4><h5 id="failover"><a href="#failover" class="headerlink" title="failover"></a>failover</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">failover:(tcp:<span class="comment">//192.168.1.118:61616?connectionTimeout=3000)</span></span><br><span class="line">?timeout=<span class="number">5000</span></span><br><span class="line">&amp;initialReconnectDelay=<span class="number">1000</span></span><br><span class="line">&amp;maxReconnectDelay=<span class="number">1000</span></span><br><span class="line">&amp;nested.wireFormat.maxInactivityDuration=<span class="number">30000</span></span><br></pre></td></tr></table></figure><p><strong>initialReconnectDelay：</strong>默认为10，单位毫秒，表示第一次尝试重连之前等待的时间。<br><strong>maxReconnectDelay：</strong>默认30000，单位毫秒，表示两次重连之间的最大时间间隔。<br><strong>nested.wireFormat.maxInactivityDuration</strong> 检测死连接时间<br><strong><a href="http://manzhizhen.iteye.com/blog/2105572" target="_blank" rel="noopener">其它相关配置</a></strong></p><h4 id="五、ActiveMQ-使用"><a href="#五、ActiveMQ-使用" class="headerlink" title="五、ActiveMQ 使用"></a>五、ActiveMQ 使用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;一种典型的JMS 程序需要经过下列几个步骤:</p><ol><li>通过 JNDI 查找 ConnectionFactory。</li><li>用 ConnectionFactory 创建一个 Connection。</li><li>用 Connection 创建一个或多个 Session。 </li><li>用 Session 和 Destination 创建所需的 MessageProducer 和 MessageConsumer。 </li><li>启动 Connection。 (下面是对应的截图说明)</li></ol><h5 id="1-连接工厂-ConnectionFactory"><a href="#1-连接工厂-ConnectionFactory" class="headerlink" title="1. 连接工厂 (ConnectionFactory)"></a>1. 连接工厂 (ConnectionFactory)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;连接工厂是客户用来创建连接的对象.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;例如: ActiveMQ 提供的ActiveMQConnectionFactory。注意（要初始化 JMS，则需要使用连接工厂。客户端通过创建ConnectionFactory建立到 ActveMQ的连接，一个连接工厂封装了一组连接配置参数，这组参数在配置ActiveMQ时已经定义，例如brokerURL参数，此参数传入的是ActiveMQ服务地址和端口，支持openwire协议的默认连接为 tcp://localhost:61616，支持 stomp协议的默认连接为tcp://localhost:61613。</p><h6 id="ActiveMQConnectionFactory构造方法："><a href="#ActiveMQConnectionFactory构造方法：" class="headerlink" title="ActiveMQConnectionFactory构造方法："></a>ActiveMQConnectionFactory构造方法：</h6><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">ActiveMQConnectionFactory()</span>;</span><br><span class="line"><span class="constructor">ActiveMQConnectionFactory(String <span class="params">brokerURL</span>)</span>;</span><br><span class="line"><span class="constructor">ActiveMQConnectionFactory(String <span class="params">userName</span>, String <span class="params">password</span>, String <span class="params">b</span> <span class="params">rokerURL</span>)</span> ; </span><br><span class="line"><span class="constructor">ActiveMQConnectionFactory(String <span class="params">userName</span>, String <span class="params">password</span>, URI <span class="params">brok</span> <span class="params">erURL</span>)</span> ; </span><br><span class="line"><span class="constructor">ActiveMQConnectionFactory(URI <span class="params">brokerURL</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中 brokerURL为ActiveMQ服务地址和端口。</p><h6 id="spring封装的："><a href="#spring封装的：" class="headerlink" title="spring封装的："></a>spring封装的：</h6><ul><li><p><strong>SingleConnectionFactory</strong>：对于建立JMS服务器链接的请求会一直返回同一个链接，并且会忽略Connection的close方法调用。(<br>org.springframework.jms.connection.SingleConnectionFactory)</p></li><li><p><strong>CachingConnectionFactory</strong>：继承了SingleConnectionFactory，所以它拥有SingleConnectionFactory的所有功能，同时它还新增了缓存功能，它可以缓存Session、MessageProducer和MessageConsumer。我们使用CachingConnectionFactory来作为示例。(<br>org.springframework.jms.connection.CachingConnectionFactory)</p></li><li><p><strong>PooledConnectionFactory</strong>：线程池(org.apache.activemq.pool.PooledConnectionFactory)</p></li></ul><h5 id="2-连接-Connection"><a href="#2-连接-Connection" class="headerlink" title="2. 连接 (Connection)"></a>2. 连接 (Connection)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;Connection 封装了客户与 JMS 提供者之间的一个虚拟的连接。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当一个Connection被创建时，它的传输默认是关闭的，必须使用start方法开启。一个Connection可以建立一个或多个的Session。当一个程序执行完成后，必须关闭之前创建的Connection，否则 ActiveMQ不能释放资源，关闭一个Connection同样也关闭了 Session，MessageProducer和MessageConsumer。</p><h5 id="3-会话-Seesion"><a href="#3-会话-Seesion" class="headerlink" title="3. 会话(Seesion)"></a>3. 会话(Seesion)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;Session 是生产和消费消息的一个单线程上下文。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;会话用于创建消息生产者（producer）、消息消费者（consumer）和消息（message）等。会话提供了一个事务性的上下文，在这个上下文中，一组发送和接收被组合到了一个原子操作中。</p><h4 id="六、ActiveMQ的多种部署方式"><a href="#六、ActiveMQ的多种部署方式" class="headerlink" title="六、ActiveMQ的多种部署方式"></a>六、ActiveMQ的多种部署方式</h4><p>具体介绍请查看文章后面部分：<a href="http://manzhizhen.iteye.com/blog/2105572" target="_blank" rel="noopener">查看</a></p><h5 id="1-Master-Slave部署方式"><a href="#1-Master-Slave部署方式" class="headerlink" title="1. Master-Slave部署方式"></a>1. Master-Slave部署方式</h5><h6 id="shared-filesystem-Master-Slave部署方式"><a href="#shared-filesystem-Master-Slave部署方式" class="headerlink" title="shared filesystem Master-Slave部署方式"></a>shared filesystem Master-Slave部署方式</h6><h6 id="shared-database-Master-Slave方式"><a href="#shared-database-Master-Slave方式" class="headerlink" title="shared database Master-Slave方式"></a>shared database Master-Slave方式</h6><h6 id="Replicated-LevelDB-Store方式"><a href="#Replicated-LevelDB-Store方式" class="headerlink" title="Replicated LevelDB Store方式"></a>Replicated LevelDB Store方式</h6><h5 id="2-Broker-Cluster部署方式"><a href="#2-Broker-Cluster部署方式" class="headerlink" title="2. Broker-Cluster部署方式"></a>2. Broker-Cluster部署方式</h5><h6 id="static-Broker-Cluster部署"><a href="#static-Broker-Cluster部署" class="headerlink" title="static Broker-Cluster部署"></a>static Broker-Cluster部署</h6><h6 id="Dynamic-Broker-Cluster部署"><a href="#Dynamic-Broker-Cluster部署" class="headerlink" title="Dynamic Broker-Cluster部署"></a>Dynamic Broker-Cluster部署</h6><h5 id="3-Master-Slave与Broker-Cluster相结合的部署方式"><a href="#3-Master-Slave与Broker-Cluster相结合的部署方式" class="headerlink" title="3. Master-Slave与Broker-Cluster相结合的部署方式"></a>3. Master-Slave与Broker-Cluster相结合的部署方式</h5>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式02-乱穿马路</title>
      <link href="/2018/06/12/sql/antipatterns/02-%E4%B9%B1%E7%A9%BF%E9%A9%AC%E8%B7%AF/"/>
      <url>/2018/06/12/sql/antipatterns/02-%E4%B9%B1%E7%A9%BF%E9%A9%AC%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是“乱穿马路”"><a href="#什么是“乱穿马路”" class="headerlink" title="什么是“乱穿马路”"></a>什么是“乱穿马路”</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在数据库设计中，多对多的情况经常成为我们的需求，比如一个产品有多个负责人，一个人可以负责多个产品。<strong>程序员通常使用逗号分隔的列表来避免在多对多的关系中创建交叉表</strong>，书中将这种设计模式叫做<strong>“乱穿马路”</strong></p><h4 id="目的（存储多值属性）"><a href="#目的（存储多值属性）" class="headerlink" title="目的（存储多值属性）"></a>目的（存储多值属性）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;背景：每个产品对应一个联系人，一个联系人可能对应多个产品，因此我们在产品和账号之间是一个多对一的关系。我们设计product表如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">product_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">product_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">account_id <span class="built_in">BIGINT</span> UNSIGEND,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (account_id) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但是随着需求变更，一个产品需要对应多个联系人，此时product表的一行数据必须存储多个联系人</p><h4 id="反模式（格式化数据，用逗号分隔列表）"><a href="#反模式（格式化数据，用逗号分隔列表）" class="headerlink" title="反模式（格式化数据，用逗号分隔列表）"></a>反模式（格式化数据，用逗号分隔列表）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;为了将数据库表结构改动控制到最小，你决定将account_id的类型改成VARCHAR，每个账号id之间用逗号分隔，这样就可以存储多个联系人</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">product_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">product_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">account_id <span class="built_in">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这样看似可行，但是<strong>你要承受以下伴随的问题</strong></p><h5 id="1-查询指定账号的产品"><a href="#1-查询指定账号的产品" class="headerlink" title="1.查询指定账号的产品"></a>1.查询指定账号的产品</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;不能使用SQL语法中的等号操作符，只能使用like 或者正则表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> PRODUCT <span class="keyword">WHERE</span> account_id REGEXP <span class="string">'[[:&lt;:]]12[[:&gt;:]]'</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;模式匹配可能<strong>会返回错误的结果</strong>，而且，此时<strong>索引将不可用</strong>，查询效率不能保证。</p><h5 id="2-查询指定产品的账号"><a href="#2-查询指定产品的账号" class="headerlink" title="2.查询指定产品的账号"></a>2.查询指定产品的账号</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你想使用关联查询account表，也是<strong>极其耗时</strong>的，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> PRODUCT <span class="keyword">AS</span> p </span><br><span class="line"><span class="keyword">JOIN</span> <span class="keyword">ACCOUNT</span> <span class="keyword">AS</span> a </span><br><span class="line"><span class="keyword">ON</span> a.account_id REGEXP <span class="string">'[[:&lt;:]]'</span>+a.account_id+<span class="string">'[[:&gt;:]]'</span></span><br><span class="line"><span class="keyword">WHERE</span> p.product_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上语句必须扫描两种表，创建一个交叉结果集，然后使用正则匹配每一行联合的数据，而它不能使用任何索引</p><h5 id="3-执行聚合查询"><a href="#3-执行聚合查询" class="headerlink" title="3.执行聚合查询"></a>3.执行聚合查询</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;使用COUNT(),SUM(),AVG()等函数时也极其困难，你不得不间接的得出结果，比如实现COUNT()</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_id,<span class="keyword">LENGTH</span>(account_id)-<span class="keyword">LENGTH</span>(<span class="keyword">REPLACE</span>(account_id,<span class="string">','</span>,<span class="string">''</span>))+<span class="number">1</span> <span class="keyword">as</span> contacts_per_product </span><br><span class="line"><span class="keyword">FROM</span> product;</span><br></pre></td></tr></table></figure><p>这类办法看起来很帅（使用它的长度减去替换后’,’的长度，得到’,’的个数。），但是有些<strong>聚合函数根本不能使用这些技巧来完成</strong>，何况这类解决办法需要花费大量时间</p><h5 id="4-更新产品的账号"><a href="#4-更新产品的账号" class="headerlink" title="4.更新产品的账号"></a>4.更新产品的账号</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;更新产品的联系人，使用追加的方式，也不能保证按顺序存储</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE product <span class="builtin-name">SET</span> <span class="attribute">account_id</span>=account_id+','+3</span><br><span class="line">WHERE <span class="attribute">product_id</span>=1;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;删除产品某个联系人，你必须先查出老的列表，然后使用java等语言删除联系人后，才能将更新后的列表存储</p><h5 id="5-选择合适的分隔符"><a href="#5-选择合适的分隔符" class="headerlink" title="5.选择合适的分隔符"></a>5.选择合适的分隔符</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果存储一个字符串列表而不是数字列表，条目中可能会包含分隔符，那么你该如何选择分隔符，你能确保你选择的分隔符永远不会出现在条目中吗？</p><h5 id="6-列表长度限制"><a href="#6-列表长度限制" class="headerlink" title="6.列表长度限制"></a>6.列表长度限制</h5><p>&nbsp;&nbsp;&nbsp;&nbsp; 你能在一个VARCHAR(30)的结构存储多少数据？用mysql举例，如果每个条目长度为6，你只能存储4个条目，你能确定到底多少的长度够用吗？</p><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><h5 id="如果你在开发中说过下面这些话，那么很有可能在使用“乱穿马路”"><a href="#如果你在开发中说过下面这些话，那么很有可能在使用“乱穿马路”" class="headerlink" title="如果你在开发中说过下面这些话，那么很有可能在使用“乱穿马路”"></a>如果你在开发中说过下面这些话，那么很有可能在使用“乱穿马路”</h5><ol><li><strong>列表最多支持存放多少数据？</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;这个问题在选择Varchar列的最大长度时被提及</li><li><strong>你知道怎么使用正则提取数据吗？</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;需要使用正则表达式来提取数据，这可能是一种提示，意味着你应该把这些数据分开存储。</li><li><strong>哪些字符按不会出现在任何一个条目中？</strong></li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><ol><li>如果应用程序接收的源数据是有逗号分隔的格式，而你只需要存储和使用它们并且不对其做任何修改，完全没有必要分开其中的值。</li><li>个人补充：如果这个要存储的列表，你只是保存和单纯的查询出来，不做修改，不需要关联查询的话，我觉得完全可以这样做。你甚至还可以保存一个json数组</li></ol><h4 id="解决办法-创建一张交叉表"><a href="#解决办法-创建一张交叉表" class="headerlink" title="解决办法(创建一张交叉表)"></a>解决办法(创建一张交叉表)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;创建一张交叉表，使用规范性设计数据，能使你的代码更加灵活，以上所说的，不能使用索引，不能使用聚合函数等，都能得到解决</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式01-引子</title>
      <link href="/2018/06/10/sql/antipatterns/01-%E5%BC%95%E5%AD%90/"/>
      <url>/2018/06/10/sql/antipatterns/01-%E5%BC%95%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>像普通书籍一样，本系列博客也有引子，它将笼统介绍本系列博客内容。</p><p>本博客，是因为我读到一本<strong>《SQL反模式》</strong>的书，发现它介绍了日常开发中我经常遇到的问题，受益匪浅，所以决定写下博客，<strong>画出本书的重点，以及尽可能的将书中sql语句翻译成mysql</strong>，一来帮我记忆，二来分享和大家一起学习</p><h4 id="什么是“反模式”"><a href="#什么是“反模式”" class="headerlink" title="什么是“反模式”"></a>什么是“反模式”</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;本书介绍到的“反模式”，定义为：“反模式是一种<strong>试图</strong>解决需求的“不合常规”方法。”<br>&nbsp;&nbsp;&nbsp;&nbsp;注意：是<strong>试图</strong>，指我们在遇到需求时，想到某个“不合常规”的解决办法，引发的系列问题，但不是说这样的解决办法不好，我们要合理使用</p><h4 id="反模式分类"><a href="#反模式分类" class="headerlink" title="反模式分类"></a>反模式分类</h4><ol><li>逻辑数据库设计反模式</li><li>物理数据库设计反模式</li><li>查询反模式</li><li>应用程序开发反模式</li></ol><h4 id="本书每章结构，我也尽量按照这个结构记录"><a href="#本书每章结构，我也尽量按照这个结构记录" class="headerlink" title="本书每章结构，我也尽量按照这个结构记录"></a>本书每章结构，我也尽量按照这个结构记录</h4><ul><li><strong>目的</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;这是你可能要去尝试解决的任务。意图使用反模式提供解决方案，但通常会以引起更多问题而告终。</li><li><strong>反模式</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;这一部分表述了通常使用的解决方案的本质，并且展示了那些没有预知到的后果，正是这些使得这些方案成为反模式。</li><li><strong>如何识别反模式</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;一些固定的方式会有助于你辨识在项目中使用的反模式。你遇到的特殊障碍，或是你自己和别人说的一些话，都能使你提前识别出反模式。</li><li><strong>合理使用反模式</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;规则总有例外。在某些情况下，本来认为是反模式的设计却可能是合理的，或者说至少是所有的方案中最合理的。</li><li><strong>解决办法</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;描述了首选的最佳解决方案，他们不仅能够解决原有的问题，同时也不至于引起由反模式导致的新问题。</li></ul><h4 id="示例数据库"><a href="#示例数据库" class="headerlink" title="示例数据库"></a>示例数据库</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;以下sql跟书中不一致，我修改有些命名规则，如下。<br>&nbsp;&nbsp;&nbsp;&nbsp;我不喜欢表名存在复数，因为这样会让我生成java类也是复数。<br>&nbsp;&nbsp;&nbsp;&nbsp;我不喜欢表名用驼峰的规则，这貌似也不符合sql的规范。<br>&nbsp;&nbsp;&nbsp;&nbsp;这两点出现在书中，感觉有点怪，也可能是我认知错了</p><h5 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">account</span>(</span><br><span class="line">account_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">account_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">first_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">last_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">email <span class="built_in">VARCHAR</span>(<span class="number">1000</span>),</span><br><span class="line">password_hash <span class="built_in">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">protrait_image <span class="built_in">BLOB</span>,</span><br><span class="line">hourly_rate <span class="built_in">NUMERIC</span>(<span class="number">9</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_stastus(</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) PRIMARY <span class="keyword">KEY</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line">bug_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">date_reported <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">summary <span class="built_in">VARCHAR</span>(<span class="number">80</span>),</span><br><span class="line">description <span class="built_in">VARCHAR</span>(<span class="number">1000</span>),</span><br><span class="line">resolution <span class="built_in">VARCHAR</span>(<span class="number">1000</span>),</span><br><span class="line">reported_by <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">assigned_to <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span>,</span><br><span class="line">verified_by <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span>,</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'NEW'</span>,</span><br><span class="line"><span class="keyword">priority</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">hours</span> <span class="built_in">NUMERIC</span>(<span class="number">9</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (reported_by) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (assigned_to) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (verified_by) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="keyword">status</span>) <span class="keyword">REFERENCES</span> bug_stastus(<span class="keyword">status</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> comments(</span><br><span class="line">comment_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">bug_id <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">author <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">comment_date DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">comment</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (author) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> screenshot(</span><br><span class="line">bug_id <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">image_id <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">screenshot_image <span class="built_in">BLOB</span>,</span><br><span class="line">caption <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (bug_id,image_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tag(</span><br><span class="line">bug_id <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">tag <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (bug_id,tag),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">product_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">product_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_product(</span><br><span class="line">bug_id <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">product_id <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (bug_id,product_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (product_id) <span class="keyword">REFERENCES</span> product(product_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="ERD图"><a href="#ERD图" class="headerlink" title="ERD图"></a>ERD图</h5><p><img src="/images/sql/antipatterns/01/database_erd.png" alt="ERD图"></p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【干货】java集成paypal，含android代码，服务端代码</title>
      <link href="/2018/06/09/integrate/paypal/"/>
      <url>/2018/06/09/integrate/paypal/</url>
      
        <content type="html"><![CDATA[<h3 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h3><blockquote><p><strong>1. 前端选择商品，调用paypal支付</strong></p></blockquote><blockquote><p><strong>2. 支付完成，paypal会返回payment信息，将payment的id返回给自己服务端</strong></p></blockquote><blockquote><p><strong>3. 服务端根据paymentId,调paypal，查询支付是否完成</strong></p></blockquote><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li><p>前往<code>https://www.paypal.com/</code>注册商家账号</p></li><li><p>前往<code>https://developer.paypal.com/</code>，使用刚注册的商家账号登录</p></li><li><p>点击右上角名字，选择Dashboard</p></li><li><p>在左边的导航栏中点击 Sandbox 下的 Accounts</p></li><li><p>进入Acccouts界面后，可以看到系统有两个已经生成好的测试账号，但是我们不要用系统给的测试账号，自己创建两个，一个是商家账号，一个是个人账号</p><blockquote><ol><li>点击右上角的“Create Account”，创建测试用户 </li><li>先创建一个“ PERSONAL”类型的用户，国家一定要选“China”，账户余额自己填写（邮箱地址可以随便写，自己好记就行）</li><li>接着创建一个“BUSINESS”类型的用户，国家一定要选“China”，账户余额自己填写 （邮箱地址可以随便写，自己好记就行）</li><li>创建好之后可以点击测试账号下的”Profile“，可以查看信息，如果没加载出来，刷新</li><li>用测试账号登录测试网站查看，注意！这跟paypal官网不同！不是同一个地址，在浏览器输入：<code>https://www.sandbox.paypal.com</code> 在这里登陆测试账户</li></ol></blockquote></li><li><p>创建应用，生成用于测试的clientID 和 密钥 </p><blockquote><ol><li>点击左边导航栏Dashboard下的My Apps &amp; Credentials，创建一个Live账号</li><li>然后再到下边创建App</li><li>点击刚刚创建好的App，注意看到”ClientID“ 和”Secret“(Secret如果没显示，点击下面的show就会看到，点击后show变为hide) </li></ol></blockquote></li></ul><h3 id="start-coding"><a href="#start-coding" class="headerlink" title="start coding"></a>start coding</h3><h4 id="Android"><a href="#Android" class="headerlink" title="Android`"></a>Android`</h4><ul><li><p>添加依赖</p><pre><code>`compile(&apos;com.paypal.sdk:paypal-android-sdk:2.15.1&apos;) { exclude group: &apos;io.card&apos; }//禁止通过信用卡直接支付，如果不禁止可以直接去掉这一句`</code></pre></li><li><p>强制在你的编译版本上执行编译操作（编译不过的时候才建议添加）</p><pre><code>`&lt;uses-sdk    android:minSdkVersion=&quot;这里填写你需要的编译版本&quot;    tools:overrideLibrary=&quot;com.paypal.android.sdk.payments&quot; /&gt;`</code></pre></li><li><p>封装好的工具类</p><pre><code>`    import android.app.Activity;    import android.content.Context;    import android.content.Intent;    import android.util.Log;    import com.globalegrow.app.gearbest.network.HttpCallBack;    import com.globalegrow.app.gearbest.widget.CustomToast;    import com.paypal.android.sdk.payments.PayPalAuthorization;    import com.paypal.android.sdk.payments.PayPalConfiguration;    import com.paypal.android.sdk.payments.PayPalFuturePaymentActivity;    import com.paypal.android.sdk.payments.PayPalItem;    import com.paypal.android.sdk.payments.PayPalPayment;    import com.paypal.android.sdk.payments.PayPalPaymentDetails;    import com.paypal.android.sdk.payments.PayPalProfileSharingActivity;    import com.paypal.android.sdk.payments.PayPalService;    import com.paypal.android.sdk.payments.PaymentActivity;    import com.paypal.android.sdk.payments.PaymentConfirmation;    import org.json.JSONException;    import org.json.JSONObject;    import java.io.IOException;    import java.math.BigDecimal;    /**     * Create by Moosen on 09/11/2016     */    public class PayPalHelper {        private static final String TAG = &quot;PayPalHelper&quot;;        //配置何种支付环境，一般沙盒，正式        private static final String CONFIG_ENVIRONMENT = PayPalConfiguration.ENVIRONMENT_SANDBOX;        // note that these credentials will differ between live &amp; sandbox environments.        //你所注册的APP Id        private static final String CONFIG_CLIENT_ID = &quot;&quot;;        private static final int REQUEST_CODE_PAYMENT = 1;        private static final int REQUEST_CODE_FUTURE_PAYMENT = 2;        private static final int REQUEST_CODE_PROFILE_SHARING = 3;        private static PayPalConfiguration config = new PayPalConfiguration()                .environment(CONFIG_ENVIRONMENT)                .clientId(CONFIG_CLIENT_ID);        //以下配置是授权支付的时候用到的    //            .merchantName(&quot;Example Merchant&quot;)    //            .merchantPrivacyPolicyUri(Uri.parse(&quot;https://www.example.com/privacy&quot;))    //            .merchantUserAgreementUri(Uri.parse(&quot;https://www.example.com/legal&quot;));        private static PayPalHelper payPalHelper;        private PayPalHelper() {        }        public static PayPalHelper getInstance() {            if (payPalHelper == null) {                synchronized (PayPalHelper.class) {                    payPalHelper = new PayPalHelper();                }            }            return payPalHelper;        }        /**         * 启动PayPal服务         *         * @param context         */        public void startPayPalService(Context context) {            Intent intent = new Intent(context, PayPalService.class);            intent.putExtra(PayPalService.EXTRA_PAYPAL_CONFIGURATION, config);            context.startService(intent);        }        /**         * 停止PayPal服务  sdfsdfsdssaaass         *         * @param context         */        public void stopPayPalService(Context context) {            context.stopService(new Intent(context, PayPalService.class));        }        /**         * 开始执行支付操作         *         * @param context         */        public void doPayPalPay(Context context) {            /*             * PAYMENT_INTENT_SALE will cause the payment to complete immediately.             * Change PAYMENT_INTENT_SALE to             *   - PAYMENT_INTENT_AUTHORIZE to only authorize payment and capture funds later.             *   - PAYMENT_INTENT_ORDER to create a payment for authorization and capture             *     later via calls from your server.             *             * Also, to include additional payment details and an item list, see getStuffToBuy() below.             */            PayPalPayment thingToBuy = getStuffToBuy(PayPalPayment.PAYMENT_INTENT_SALE);            /*             * See getStuffToBuy(..) for examples of some available payment options.             */            Intent intent = new Intent(context, PaymentActivity.class);            // send the same configuration for restart resiliency            intent.putExtra(PayPalService.EXTRA_PAYPAL_CONFIGURATION, config);            intent.putExtra(PaymentActivity.EXTRA_PAYMENT, thingToBuy);            ((Activity) context).startActivityForResult(intent, REQUEST_CODE_PAYMENT);        }        /*             * This method shows use of optional payment details and item list.             *             * 直接给PP创建支付的信息，支付对象实体信息             */        private PayPalPayment getStuffToBuy(String paymentIntent) {            //--- include an item list, payment amount details            //具体的产品信息列表            PayPalItem[] items =                    {                            new PayPalItem(&quot;sample item #1&quot;, 2, new BigDecimal(&quot;0.50&quot;), &quot;USD&quot;,                                    &quot;sku-12345678&quot;),                            new PayPalItem(&quot;free sample item #2&quot;, 1, new BigDecimal(&quot;0.00&quot;),                                    &quot;USD&quot;, &quot;sku-zero-price&quot;),                            new PayPalItem(&quot;sample item #3 with a longer name&quot;, 6, new BigDecimal(&quot;0.99&quot;),                                    &quot;USD&quot;, &quot;sku-33333&quot;)                    };            BigDecimal subtotal = PayPalItem.getItemTotal(items);            BigDecimal shipping = new BigDecimal(&quot;0.21&quot;);            BigDecimal tax = new BigDecimal(&quot;0.67&quot;);            PayPalPaymentDetails paymentDetails = new PayPalPaymentDetails(shipping, subtotal, tax);            BigDecimal amount = subtotal.add(shipping).add(tax);            PayPalPayment payment = new PayPalPayment(amount, &quot;USD&quot;, &quot;sample item&quot;, paymentIntent);            payment.items(items).paymentDetails(paymentDetails);            //--- set other optional fields like invoice_number, custom field, and soft_descriptor            payment.custom(&quot;This is text that will be associated with the payment that the app can use.&quot;);            return payment;        }        /**         * 处理支付之后的结果         *         * @param context         * @param requestCode         * @param resultCode         * @param data         */        public void confirmPayResult(final Context context, int requestCode, int resultCode, Intent data, final DoResult doResult) {            if (requestCode == REQUEST_CODE_PAYMENT) {                if (resultCode == Activity.RESULT_OK) {                    PaymentConfirmation confirm =                            data.getParcelableExtra(PaymentActivity.EXTRA_RESULT_CONFIRMATION);                    if (confirm != null) {                        try {                            Log.i(TAG, confirm.toJSONObject().toString(4));                            Log.i(TAG, confirm.getPayment().toJSONObject().toString(4));                            /**                             *  TODO: send &apos;confirm&apos; (and possibly confirm.getPayment() to your server for verification                             * or consent completion.                             * See https://developer.paypal.com/webapps/developer/docs/integration/mobile/verify-mobile-payment/                             * for more details.                             *                             * For sample mobile backend interactions, see                             * https://github.com/paypal/rest-api-sdk-python/tree/master/samples/mobile_backend                             */    //                        displayResultText(&quot;PaymentConfirmation info received from PayPal&quot;);                            // 这里直接跟服务器确认支付结果，支付结果确认后回调处理结果                            JSONObject jsonObject = confirm.toJSONObject();                            if (jsonObject != null) {                                JSONObject response = jsonObject.optJSONObject(&quot;response&quot;);                                if (response != null) {                                    String id = response.optString(&quot;id&quot;);                                    try {                                        CartManager.getInstance().confirmPayPalPayPrice(context, id, new HttpCallBack&lt;String&gt;() {                                            @Override                                            public void onSuccess(String responseString) {                                                if (responseString != null) {                                                    try {                                                        JSONObject jsonObject = new JSONObject(responseString);                                                        if (jsonObject != null) {                                                            int resultcode = jsonObject.optInt(&quot;_resultcode&quot;);                                                            String msg = jsonObject.optString(&quot;_msg&quot;);                                                            if (200 == resultcode) {                                                                doResult.confirmSuccess();                                                                Log.i(TAG, &quot;dddddddd&quot;);                                                            } else {                                                                Log.i(TAG, &quot;ssssssss&quot;);                                                                CustomToast.getInstance(context).showToast(msg);                                                                doResult.confirmNetWorkError();                                                            }                                                            CustomToast.getInstance(context).showToast(msg);                                                        }                                                    } catch (JSONException e) {                                                        e.printStackTrace();                                                        doResult.confirmNetWorkError();                                                    }                                                }                                            }                                            @Override                                            public void onFailure(IOException e) {                                                Log.i(TAG, &quot;aaaaaaaa&quot;);                                                doResult.confirmNetWorkError();                                            }                                        });                                    } catch (Exception e) {                                        e.printStackTrace();                                        doResult.confirmNetWorkError();                                    }                                }                            }                        } catch (JSONException e) {                            Log.e(TAG, &quot;an extremely unlikely failure occurred: &quot;, e);                            doResult.confirmNetWorkError();                        }                    }                } else if (resultCode == Activity.RESULT_CANCELED) {                    Log.i(TAG, &quot;The user canceled.&quot;);                    doResult.customerCanceled();                } else if (resultCode == PaymentActivity.RESULT_EXTRAS_INVALID) {                    doResult.invalidPaymentConfiguration();                    Log.i(                            TAG,                            &quot;An invalid Payment or PayPalConfiguration was submitted. Please see the docs.&quot;);                }            } else if (requestCode == REQUEST_CODE_FUTURE_PAYMENT) {                if (resultCode == Activity.RESULT_OK) {                    PayPalAuthorization auth =                            data.getParcelableExtra(PayPalFuturePaymentActivity.EXTRA_RESULT_AUTHORIZATION);                    if (auth != null) {                        try {                            doResult.confirmFuturePayment();                            Log.i(&quot;FuturePaymentExample&quot;, auth.toJSONObject().toString(4));                            String authorization_code = auth.getAuthorizationCode();                            Log.i(&quot;FuturePaymentExample&quot;, authorization_code);    //                        sendAuthorizationToServer(auth);    //                        displayResultText(&quot;Future Payment code received from PayPal&quot;);                        } catch (JSONException e) {                            doResult.confirmNetWorkError();                            Log.e(&quot;FuturePaymentExample&quot;, &quot;an extremely unlikely failure occurred: &quot;, e);                        }                    }                } else if (resultCode == Activity.RESULT_CANCELED) {                    Log.i(&quot;FuturePaymentExample&quot;, &quot;The user canceled.&quot;);                    doResult.customerCanceled();                } else if (resultCode == PayPalFuturePaymentActivity.RESULT_EXTRAS_INVALID) {                    doResult.invalidPaymentConfiguration();                    Log.i(                            &quot;FuturePaymentExample&quot;,                            &quot;Probably the attempt to previously start the PayPalService had an invalid PayPalConfiguration. Please see the docs.&quot;);                }            } else if (requestCode == REQUEST_CODE_PROFILE_SHARING) {                if (resultCode == Activity.RESULT_OK) {                    PayPalAuthorization auth =                            data.getParcelableExtra(PayPalProfileSharingActivity.EXTRA_RESULT_AUTHORIZATION);                    if (auth != null) {                        try {                            Log.i(&quot;ProfileSharingExample&quot;, auth.toJSONObject().toString(4));                            String authorization_code = auth.getAuthorizationCode();                            Log.i(&quot;ProfileSharingExample&quot;, authorization_code);    //                        sendAuthorizationToServer(auth);    //                        displayResultText(&quot;Profile Sharing code received from PayPal&quot;);                        } catch (JSONException e) {                            Log.e(&quot;ProfileSharingExample&quot;, &quot;an extremely unlikely failure occurred: &quot;, e);                        }                    }                } else if (resultCode == Activity.RESULT_CANCELED) {                    Log.i(&quot;ProfileSharingExample&quot;, &quot;The user canceled.&quot;);                } else if (resultCode == PayPalFuturePaymentActivity.RESULT_EXTRAS_INVALID) {                    Log.i(                            &quot;ProfileSharingExample&quot;,                            &quot;Probably the attempt to previously start the PayPalService had an invalid PayPalConfiguration. Please see the docs.&quot;);                }            }        }        /**         * c处理完结果之后回调         */        public interface DoResult {            //与服务确认支付成功            void confirmSuccess();            //网络异常或者json返回有问题            void confirmNetWorkError();            //用户取消支付            void customerCanceled();            //授权支付            void confirmFuturePayment();            //订单支付验证无效            void invalidPaymentConfiguration();        }    }`</code></pre></li><li><p>在你需要调起支付的页面配置支付环境（或者在基类配置相应的支付环境）</p><pre><code>`    //配置何种支付环境，一般沙盒，正式        private static final String CONFIG_ENVIRONMENT = PayPalConfiguration.ENVIRONMENT_SANDBOX;        // note that these credentials will differ between live &amp; sandbox environments.        //你所注册的APP Id    private static final String CONFIG_CLIENT_ID = &quot;你所注册的CLient Id&quot;;       private static final int REQUEST_CODE_PAYMENT = 1;        private static final int REQUEST_CODE_FUTURE_PAYMENT = 2;        private static final int REQUEST_CODE_PROFILE_SHARING = 3;        private static PayPalConfiguration config = new PayPalConfiguration()            .environment(CONFIG_ENVIRONMENT)                .clientId(CONFIG_CLIENT_ID);        //以下配置是授权支付的时候用到的    //.merchantName(&quot;Example Merchant&quot;)    // .merchantPrivacyPolicyUri(Uri.parse(&quot;https://www.example.com/privacy&quot;))    //.merchantUserAgreementUri(Uri.parse(&quot;https://www.example.com/legal&quot;));`</code></pre></li><li><p>在类的onCreate方法里面调起支付服务</p><pre><code>`    Intent intent = new Intent(this, PayPalService.class);    intent.putExtra(PayPalService.EXTRA_PAYPAL_CONFIGURATION, config);    startService(intent);`</code></pre></li><li><p>创建支付实体，在需要调起支付的地方调起支付</p><pre><code>`    public void onBuyPressed(View pressed) {    //创建支付对象，用于传过去给PayPal服务器进行收款    PayPalPayment thingToBuy = getThingToBuy(PayPalPayment.PAYMENT_INTENT_SALE);    Intent intent = new Intent(SampleActivity.this, PaymentActivity.class);    intent.putExtra(PayPalService.EXTRA_PAYPAL_CONFIGURATION, config);    intent.putExtra(PaymentActivity.EXTRA_PAYMENT, thingToBuy);    //这里直接调起PayPal的sdk进行付款操作    startActivityForResult(intent, REQUEST_CODE_PAYMENT);    }    //这里只传一个总价格或者单个产品的信息收款情况    private PayPalPayment getThingToBuy(String paymentIntent) {    return new PayPalPayment(new BigDecimal(&quot;0.01&quot;), &quot;USD&quot;, &quot;sample item&quot;,    paymentIntent);    }    //这里是购买一系列产品创建购买对象    private PayPalPayment getStuffToBuy(String paymentIntent) {    PayPalItem[] items =    {    new PayPalItem(&quot;sample item #1&quot;, 2, new BigDecimal(&quot;87.50&quot;), &quot;USD&quot;,    &quot;sku-12345678&quot;),    new PayPalItem(&quot;free sample item #2&quot;, 1, new BigDecimal(&quot;0.00&quot;),    &quot;USD&quot;, &quot;sku-zero-price&quot;),    new PayPalItem(&quot;sample item #3 with a longer name&quot;, 6, new BigDecimal(&quot;37.99&quot;),    &quot;USD&quot;, &quot;sku-33333&quot;)    };    BigDecimal subtotal = PayPalItem.getItemTotal(items);    BigDecimal shipping = new BigDecimal(&quot;7.21&quot;);    BigDecimal tax = new BigDecimal(&quot;4.67&quot;);    PayPalPaymentDetails paymentDetails = new PayPalPaymentDetails(shipping, subtotal, tax);    BigDecimal amount = subtotal.add(shipping).add(tax);    PayPalPayment payment = new PayPalPayment(amount, &quot;USD&quot;, &quot;sample item&quot;, paymentIntent);    payment.items(items).paymentDetails(paymentDetails);    //--- set other optional fields like invoice_number, custom field, and soft_descriptor    payment.custom(&quot;This is text that will be associated with the payment that the app can use.&quot;);    return payment;    }`</code></pre></li><li><p>在类的onActivityResult 里进行回调结果的处理</p><pre><code>`if (resultCode == Activity.RESULT_OK) {    PaymentConfirmation confirm =    data.getParcelableExtra(PaymentActivity.EXTRA_RESULT_CONFIRMATION);    if (confirm != null) {    try {    Log.i(TAG, confirm.toJSONObject().toString(4));    Log.i(TAG, confirm.getPayment().toJSONObject().toString(4));    //这里可以把PayPal带回来的json数据传给服务器以确认你的款项是否收到或者收全    //可以直接把 confirm.toJSONObject() 这个带给服务器，    //得到服务器返回的结果，你就可以跳转成功页面或者做相应的处理了    } catch (JSONException e) {    Log.e(TAG, &quot;an extremely unlikely failure occurred: &quot;, e);    }    }    } else if (resultCode == Activity.RESULT_CANCELED) {    Log.i(TAG, &quot;The user canceled.&quot;);    } else if (resultCode == PaymentActivity.RESULT_EXTRAS_INVALID) {    Log.i(    TAG,    &quot;An invalid Payment or PayPalConfiguration was submitted. Please see the docs.&quot;);    }    }</code></pre><p>  `</p></li><li><p>在类的onDestroy 注销服务</p><pre><code>`stopService(new Intent(this, PayPalService.class));`</code></pre></li></ul><h4 id="服务端，根据前端给的paymentId，判断是否完成付款"><a href="#服务端，根据前端给的paymentId，判断是否完成付款" class="headerlink" title="服务端，根据前端给的paymentId，判断是否完成付款"></a>服务端，根据前端给的paymentId，判断是否完成付款</h4><pre><code>`    package com.net.pay.paypal.service;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import net.sf.json.JSONArray;import net.sf.json.JSONObject;import org.apache.commons.codec.binary.Base64;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.net.crud.dao.RechargeMapper;@Servicepublic class PayPalVerifyPayment {    private static final String TOKEN_URL = &quot;https://api.sandbox.paypal.com/v1/oauth2/token&quot;;    private static final String PAYMENT_DETAIL = &quot;https://api.sandbox.paypal.com/v1/payments/payment/&quot;;    private static final String clientId = &quot;clientId&quot;;    private static final String secret = &quot;secret&quot;;    /**     * 获取token     * 了解更多：https://developer.paypal.com/webapps/developer/docs/integration/mobile/verify-mobile-payment/     * @return     */    private String getAccessToken(){        try{            URL url = new URL(TOKEN_URL);            String authorization = clientId+&quot;:&quot;+secret;            authorization = Base64.encodeBase64String(authorization.getBytes());            HttpURLConnection conn = (HttpURLConnection) url.openConnection();            conn.setRequestMethod(&quot;POST&quot;);// 提交模式            //设置请求头header            conn.setRequestProperty(&quot;Accept&quot;, &quot;application/json&quot;);            conn.setRequestProperty(&quot;Accept-Language&quot;, &quot;en_US&quot;);            conn.setRequestProperty(&quot;Authorization&quot;, &quot;Basic &quot;+authorization);            // conn.setConnectTimeout(10000);//连接超时 单位毫秒            // conn.setReadTimeout(2000);//读取超时 单位毫秒            conn.setDoOutput(true);// 是否输入参数            String params = &quot;grant_type=client_credentials&quot;;            conn.getOutputStream().write(params.getBytes());// 输入参数            InputStreamReader inStream = new InputStreamReader(conn.getInputStream());            BufferedReader reader = new BufferedReader(inStream);            StringBuilder result = new StringBuilder();            String lineTxt = null;            while((lineTxt = reader.readLine()) != null){                result.append(lineTxt);            }            reader.close();            String accessTokey = JSONObject.fromObject(result.toString()).optString(&quot;access_token&quot;);            System.out.println(&quot;getAccessToken:&quot;+accessTokey);            return accessTokey;        }catch(Exception err){            err.printStackTrace();        }        return null;    }    /**     * 获取支付详情     * 了解更多：https://developer.paypal.com/webapps/developer/docs/integration/mobile/verify-mobile-payment/     * @param paymentId 支付ID，来自于用户客户端     * @return     */    public String getPaymentDetails(String paymentId){        try{            URL url = new URL(PAYMENT_DETAIL+paymentId);            HttpURLConnection conn = (HttpURLConnection) url.openConnection();            conn.setRequestMethod(&quot;GET&quot;);// 提交模式            //设置请求头header            conn.setRequestProperty(&quot;Accept&quot;, &quot;application/json&quot;);            conn.setRequestProperty(&quot;Authorization&quot;, &quot;Bearer &quot;+getAccessToken());            // conn.setConnectTimeout(10000);//连接超时 单位毫秒            // conn.setReadTimeout(2000);//读取超时 单位毫秒            InputStreamReader inStream = new InputStreamReader(conn.getInputStream());            BufferedReader reader = new BufferedReader(inStream);            StringBuilder result = new StringBuilder();            String lineTxt = null;            while((lineTxt = reader.readLine()) != null){                result.append(lineTxt);            }            reader.close();            return result.toString();        }catch(Exception err){            err.printStackTrace();        }        return null;    }    /**     * 获取支付详情     * 了解更多：https://developer.paypal.com/webapps/developer/docs/integration/mobile/verify-mobile-payment/     * @param paymentId 支付ID，来自于用户客户端     * @return     */    public boolean verifyPayment(String paymentId) throws Exception {        String str = getPaymentDetails(paymentId);        System.out.println(str);        JSONObject detail = JSONObject.fromObject(str);        //校验订单是否完成        if(&quot;approved&quot;.equals(detail.optString(&quot;state&quot;))){            JSONObject transactions = detail.optJSONArray(&quot;transactions&quot;).optJSONObject(0);            JSONObject amount = transactions.optJSONObject(&quot;amount&quot;);            JSONArray relatedResources = transactions.optJSONArray(&quot;related_resources&quot;);            //从数据库查询支付总金额与Paypal校验支付总金额            double total = 0;            System.out.println(&quot;amount.optDouble(&apos;total&apos;):&quot;+amount.optDouble(&quot;total&quot;));            if( total != amount.optDouble(&quot;total&quot;) ){                return false;            }            //校验交易货币类型            String currency = &quot;USD&quot;;            if( !currency.equals(amount.optString(&quot;currency&quot;)) ){                return false;            }            //校验每个子订单是否完成            for (int i = 0,j = relatedResources.size(); i &lt; j; i++) {                JSONObject sale = relatedResources.optJSONObject(i).optJSONObject(&quot;sale&quot;);                if(sale!=null){                    if( !&quot;completed&quot;.equals(sale.optString(&quot;state&quot;)) ){                        System.out.println(&quot;子订单未完成,订单状态:&quot;+sale.optString(&quot;state&quot;));                    }                }            }            return true;        }        return false;    }    public static void main(String[] args) {        PayPalVerifyPayment payment = new PayPalVerifyPayment();        boolean success = false;        try {            success = payment.verifyPayment(&quot;PAY-9MTXXXXXXXXXXXXXXXXXMI&quot;);        } catch (Exception e) {            e.printStackTrace();        }        System.out.println(success ? &quot;支付完成&quot; : &quot;支付校验失败&quot;);    }}`</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paypal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx负载均衡</title>
      <link href="/2018/06/08/centos/nginx/"/>
      <url>/2018/06/08/centos/nginx/</url>
      
        <content type="html"><![CDATA[<h3 id="nginx用处"><a href="#nginx用处" class="headerlink" title="nginx用处"></a>nginx用处</h3><blockquote><ul><li>直接作为http server(代替tomcat，apache等服务器)；</li><li>另外一个最主要的功能就是作为反向代理服务器实现负载均衡</li></ul></blockquote><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><blockquote><ol><li>nginx部署在windows上，另外两台tomcat,地址为<code>localhost:80</code></li><li>nginx下载地址<code>http://nginx.org/en/download.html</code></li><li>两个tomcat分布部署在虚拟机上，假设他们的ip是<code>192.168.155.1:80</code>和<code>192.168.155.2:80</code>，分别有路劲<code>service1\index.html</code>和<code>service2\index.html</code>，里面的内容只要好鉴别是哪个tomcat下的资源就行了</li><li>先可以启动tomcat，访问相应的地址试试，能不能访问</li></ol></blockquote><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="针对不同请求-负载均衡"><a href="#针对不同请求-负载均衡" class="headerlink" title="针对不同请求 负载均衡"></a>针对不同请求 负载均衡</h4><blockquote><p><strong>下载好nginx之后，修改<code>conf\nginx.conf</code></strong></p></blockquote><pre><code>`    # ~表示根据正则匹配url，以下的效果是，当url包含service1，nginx会将请求给192.168.155.1:80处理    location ~ /service1/ {        proxy_pass    http://192.168.155.1:80;    }            #当url包含service2，nginx会将请求给192.168.155.2:80处理    location ~ /service2/ {        proxy_pass    http://192.168.155.2:80;    }`</code></pre><blockquote><p>启动nginx，这也就实现了最简单的负载均衡</p></blockquote><blockquote><p><strong>例如：</strong>请求<code>http://localhost/service1/index.html</code>，在nginx容器下没有<code>service1/index.html</code>的路劲，nginx就是根据上面的配置，将请求交给<code>http://192.168.155.1:80</code>处理</p></blockquote><h4 id="访问同一请求-负载均衡"><a href="#访问同一请求-负载均衡" class="headerlink" title="访问同一请求 负载均衡"></a>访问同一请求 负载均衡</h4><blockquote><p>即用户访问同一请求时,配置多台tomcat,由nginx随机将请求分给某一个tomcat</p></blockquote><p><strong>在nginx.conf的http模块中添加，服务器集群server cluster</strong></p><pre><code>`    upstream interestCluster {          server 192.168.155.1:80;          server 192.168.155.2:80;    }`</code></pre><p><strong>在server模块中定义，负载均衡</strong></p><pre><code>`    location ~ /service1/ {      proxy_pass http://interestCluster ; #跟上面的集群名字一样      proxy_redirect off;      proxy_set_header Host $host;      proxy_set_header X-Real-IP $remote_addr;      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    }`</code></pre><blockquote><p>以上配置，到达的效果就是，当你访问<code>http://localhost/service1/index.html</code>，在nginx容器下没有<code>service1/index.html</code>的路劲，nginx就是根据上面的配置，将请求交给<code>http://192.168.155.1:80</code>或者时<code>http://192.168.155.2:80</code>处理</p></blockquote><p><strong>以上配置两个tomcat均衡，你可以根据自己服务器硬件配置，来配置权重，继续修改nginx.conf</strong></p><pre><code>`    upstream interestCluster {          server 192.168.155.1:80;          server 192.168.155.2:80 weight=2;    }`</code></pre><blockquote><p>即有三分之二的概率用到192.168.155.2，有三分之一的概率用到192.168.155.1</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>drop, delete, truncate 区别</title>
      <link href="/2018/06/07/sql/drop,delete,truncat/"/>
      <url>/2018/06/07/sql/drop,delete,truncat/</url>
      
        <content type="html"><![CDATA[<h4 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;删除内容和定义，释放空间。<br>&nbsp;&nbsp;&nbsp;&nbsp;将表，数据库，视图等完全删除。删库跑步首选语句。</p><h4 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;删除内容、释放空间但不删除定义，效率高。<br>&nbsp;&nbsp;&nbsp;&nbsp;比如说有一列自增id，当前为5，truncate表之后，id会从1开始。清空表数据首选。</p><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;删除整个表的数据，不删除定义，效率低。<br>&nbsp;&nbsp;&nbsp;&nbsp;系统一行一行地删，效率低，数据量大过程比较痛苦，会保留删除之前id自增的值。</p>]]></content>
      
      
      <categories>
          
          <category> 芝士点心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP失效，事务失效</title>
      <link href="/2018/05/25/java/AOP%E5%A4%B1%E6%95%88%EF%BC%8C%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/"/>
      <url>/2018/05/25/java/AOP%E5%A4%B1%E6%95%88%EF%BC%8C%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h4 id="场景还原（Transaction是由aop实现）"><a href="#场景还原（Transaction是由aop实现）" class="headerlink" title="场景还原（Transaction是由aop实现）"></a>场景还原（Transaction是由aop实现）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transaction</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transaction</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        methodC();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transaction</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AopTest aop;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> test（）&#123;</span><br><span class="line">        aop.methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;请求进来，到Controller.test()，该方法调用AopTest.methodA()。此时只有methodA的事务会生效</p><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>aop实现的方式是生成一个动态的代理对象去调用aop方法。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;因为@Transaction是由aop实现的，aop的方法，会生成一个代理对象去调用，Controller注入的AopTest对象是一个代理对象，在controller调用methodA会按照aop的过程执行，所以methodA的事务会生效。但是在mthodA中调用methodB,是由当前对象直接调用，所有methodB的事务不会生效。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public <span class="keyword">class</span> AopTest&#123;</span><br><span class="line"></span><br><span class="line">    @Transaction</span><br><span class="line">    public void <span class="keyword">method</span><span class="constructor">A()</span>&#123;</span><br><span class="line">        <span class="comment">//通过代理对象去调用sendMessage()方法          </span></span><br><span class="line">        (AopTest)<span class="module-access"><span class="module"><span class="identifier">AopContext</span>.</span></span>current<span class="constructor">Proxy()</span>.<span class="keyword">method</span><span class="constructor">B()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Transaction</span><br><span class="line">    public void <span class="keyword">method</span><span class="constructor">B()</span>&#123;</span><br><span class="line">        (AopTest)<span class="module-access"><span class="module"><span class="identifier">AopContext</span>.</span></span>current<span class="constructor">Proxy()</span>.<span class="keyword">method</span><span class="constructor">C()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Transaction</span><br><span class="line">    public void <span class="keyword">method</span><span class="constructor">C()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 踩坑日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
