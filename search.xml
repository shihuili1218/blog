<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分桶策略管理SpringCache中的缓存</title>
      <link href="/2022/06/03/java/%E5%88%86%E6%A1%B6%E7%AD%96%E7%95%A5%E7%AE%A1%E7%90%86SpringCache%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98/"/>
      <url>/2022/06/03/java/%E5%88%86%E6%A1%B6%E7%AD%96%E7%95%A5%E7%AE%A1%E7%90%86SpringCache%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>我们使用SpringCache框架 + Redis来实现项目中的缓存实现，它能实现自动对数据缓存，也可以自动清理过期的缓存。大多数情况下，它都运行非常好。</p><p>这是因为我们需要缓存的数据，通常都是可序列化的，但是我们迟早会遇到不可序列化的对象。那么我们只能选择SpringCache中的ConcurrentMapCache才能缓存这些不可序列化的对象，但是ConcurrentMapCache呢又不提供自动清理缓存的功能。</p><p>于是我开始自己设计一个本地的、高效的、能自动清理缓存扩展，同样它能支持SpringCache。</p><p>为了高效的清理缓存，我采用分桶策略，这一设计思想来源于ZooKeeper的Session管理。分桶策略也是本文的精彩内容。</p><h3 id="SpringCache的使用"><a href="#SpringCache的使用" class="headerlink" title="SpringCache的使用"></a>SpringCache的使用</h3><h4 id="SpringCache-Redis自动清理缓存"><a href="#SpringCache-Redis自动清理缓存" class="headerlink" title="SpringCache + Redis自动清理缓存"></a>SpringCache + Redis自动清理缓存</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheAutoConfiguration</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisConnectionFactory redisConnectionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"redisCacheManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisCacheManager cacheManager = <span class="keyword">new</span> RedisCacheManager(</span><br><span class="line">                RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory),</span><br><span class="line">                getTtlRedisCacheConfiguration(CacheNameEnum.DEFAULT),</span><br><span class="line">                getCustomizeTtlRedisCacheConfigurationMap());</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, RedisCacheConfiguration&gt; <span class="title">getCustomizeTtlRedisCacheConfigurationMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, RedisCacheConfiguration&gt; redisCacheConfigurationMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (CacheNameEnum cacheNameEnum : CacheNameEnum.values()) &#123;</span><br><span class="line">            redisCacheConfigurationMap.put(cacheNameEnum.name(), getTtlRedisCacheConfiguration(cacheNameEnum));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisCacheConfigurationMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedisCacheConfiguration <span class="title">getTtlRedisCacheConfiguration</span><span class="params">(CacheNameEnum cacheNameEnum)</span> </span>&#123;</span><br><span class="line">        GenericFastJsonRedisSerializer fastJsonRedisSerializer = <span class="keyword">new</span> GenericFastJsonRedisSerializer();</span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">        RedisSerializationContext.SerializationPair&lt;Object&gt; objectSerializationPair = RedisSerializationContext.SerializationPair.fromSerializer(fastJsonRedisSerializer);</span><br><span class="line">        RedisSerializationContext.SerializationPair&lt;String&gt; stringSerializationPair = RedisSerializationContext.SerializationPair.fromSerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        redisCacheConfiguration = redisCacheConfiguration.serializeKeysWith(stringSerializationPair)</span><br><span class="line">                .serializeValuesWith(objectSerializationPair)</span><br><span class="line">                .entryTtl(Duration.ofSeconds(cacheNameEnum.getTtl()));</span><br><span class="line">        <span class="keyword">return</span> redisCacheConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> CacheNameEnum &#123;</span><br><span class="line">        DEFAULT(<span class="number">60</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ttl;</span><br><span class="line"></span><br><span class="line">        CacheNameEnum(<span class="keyword">int</span> ttl) &#123;</span><br><span class="line">            <span class="keyword">this</span>.ttl = ttl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTtl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ttl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么使用的时候，就只需要增加注解就行了<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> @<span class="constructor">Cacheable(<span class="params">cacheManager</span> = <span class="string">"redisCacheManager"</span>, <span class="params">cacheNames</span> = <span class="string">"DEFAULT"</span>, <span class="params">key</span> = <span class="string">"'nft:transafer:' + #mnemonic"</span>)</span></span><br><span class="line">public Transafer recover(String mnemonic) &#123;</span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">Transafer(<span class="params">mnemonic</span>, <span class="params">wenchangChainPropertity</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="SpringCache-Map本地缓存"><a href="#SpringCache-Map本地缓存" class="headerlink" title="SpringCache + Map本地缓存"></a>SpringCache + Map本地缓存</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记得加上@EnableCaching，开启缓存</span></span><br><span class="line">@<span class="constructor">Bean(<span class="string">"localCacheManager"</span>)</span></span><br><span class="line">public CacheManager local<span class="constructor">CacheManager()</span> &#123;</span><br><span class="line">    ConcurrentMapCache publicKeyCache = <span class="keyword">new</span> <span class="constructor">ConcurrentMapCache(<span class="string">"localCache"</span>)</span>;</span><br><span class="line">    Set&lt;Cache&gt; caches = <span class="keyword">new</span> HashSet&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">    caches.add(publicKeyCache);</span><br><span class="line"></span><br><span class="line">    SimpleCacheManager cacheManager = <span class="keyword">new</span> <span class="constructor">SimpleCacheManager()</span>;</span><br><span class="line">    cacheManager.set<span class="constructor">Caches(<span class="params">caches</span>)</span>;</span><br><span class="line">    return cacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么使用的时候，就只需要增加注解就行了<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> @<span class="constructor">Cacheable(<span class="params">cacheManager</span> = <span class="string">"localCacheManager"</span>, <span class="params">cacheNames</span> = <span class="string">"localCache"</span>, <span class="params">key</span> = <span class="string">"'nft:transafer:' + #mnemonic"</span>)</span></span><br><span class="line">public Transafer recover(String mnemonic) &#123;</span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">Transafer(<span class="params">mnemonic</span>, <span class="params">wenchangChainPropertity</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="SpringCache-Map自动清理本地缓存"><a href="#SpringCache-Map自动清理本地缓存" class="headerlink" title="SpringCache + Map自动清理本地缓存"></a>SpringCache + Map自动清理本地缓存</h4><p>为了实现自动清理缓存，我继承了ConcurrentMapCache，采用分桶策略，定时清理。</p><ul><li>expirationInterval，桶的估计范围，如果为1分钟，那么1分钟内创建的缓存都存在一个桶，例如16:11:20和16:11:01，都会存放在16:12:00这个桶中。</li><li>roundToNextInterval，用于根据当前时间计算，下一个桶的时间。</li><li>executorService，用于清理缓存，仅仅在创建桶时，调用其该线程，并不会实时运行，占用CPU资源。</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class LocalExpiryCache extends ConcurrentMapCache &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger <span class="built_in">log</span> = LoggerFactory.getLogger(LocalExpiryCache.class);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 桶的范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> expirationInterval;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">5</span>, NftThreadFactory.create(<span class="string">"cache-cleara"</span>, <span class="keyword">true</span>));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, Set&lt;<span class="keyword">Object</span>&gt;&gt; expiryMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LocalExpiryCache(<span class="keyword">String</span> name, <span class="keyword">long</span> expirationInterval) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.expirationInterval = expirationInterval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> put(<span class="keyword">Object</span> <span class="built_in">key</span>, <span class="keyword">Object</span> value) &#123;</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"=======put======="</span>);</span><br><span class="line">        <span class="keyword">super</span>.put(<span class="built_in">key</span>, value);</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> expires = roundToNextInterval(now);</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"expires: "</span> + DateUtil.formatDate(<span class="keyword">new</span> Date(expires), DateUtil.FORMAT_DATETIME_NORMAL));</span><br><span class="line">        <span class="keyword">if</span> (!expiryMap.containsKey(expires)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!expiryMap.containsKey(expires)) &#123;</span><br><span class="line">                    expiryMap.put(expires, <span class="keyword">new</span> ConcurrentHashSet&lt;&gt;());</span><br><span class="line">                    executorService.schedule((Runnable) <span class="keyword">this</span>::expiry, expires - now + <span class="number">100</span></span><br><span class="line">                            , TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;<span class="keyword">Object</span>&gt; objects = expiryMap.<span class="built_in">get</span>(expires);</span><br><span class="line">        objects.<span class="built_in">add</span>(<span class="built_in">key</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> ValueWrapper putIfAbsent(<span class="keyword">Object</span> <span class="built_in">key</span>, <span class="keyword">Object</span> value) &#123;</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"=======putIfAbsent======="</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.putIfAbsent(<span class="built_in">key</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> roundToNextInterval(<span class="keyword">long</span> time) &#123;</span><br><span class="line">        <span class="keyword">return</span> (time / expirationInterval + <span class="number">1</span>) * expirationInterval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set expiry() &#123;</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        Set&lt;Long&gt; ttls = expiryMap.keySet();</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(ttls)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;Long&gt; iterator = ttls.iterator();</span><br><span class="line">        Set result = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Long expirationTime = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (now &lt; expirationTime) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result.addAll(expiryMap.<span class="built_in">get</span>(expirationTime));</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">Object</span> <span class="built_in">key</span> : result) &#123;</span><br><span class="line">            <span class="keyword">super</span>.evict(<span class="built_in">key</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">log</span>.info(<span class="string">"evict size: "</span> + result.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        LocalExpiryCache localCache = <span class="keyword">new</span> LocalExpiryCache(<span class="string">""</span>, <span class="number">1</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">        localCache.put(<span class="string">"1"</span>, <span class="string">""</span>);</span><br><span class="line">        localCache.put(<span class="string">"2"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">log</span>.info(localCache.getNativeCache().<span class="built_in">size</span>() + <span class="string">""</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">log</span>.info(localCache.getNativeCache().<span class="built_in">size</span>() + <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        localCache.put(<span class="string">"2"</span>, <span class="string">""</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">log</span>.info(localCache.getNativeCache().<span class="built_in">size</span>() + <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时，拥LocalExpiryCache替换掉ConcurrentMapCache即可<br><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="constructor">Bean(<span class="string">"localCacheManager"</span>)</span></span><br><span class="line">public CacheManager local<span class="constructor">CacheManager()</span> &#123;</span><br><span class="line">    LocalExpiryCache publicKeyCache = <span class="keyword">new</span> <span class="constructor">LocalExpiryCache(<span class="string">"localCache"</span>, 1 <span class="operator">*</span> 60 <span class="operator">*</span> 1000)</span>;</span><br><span class="line">    Set&lt;Cache&gt; caches = <span class="keyword">new</span> HashSet&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">    caches.add(publicKeyCache);</span><br><span class="line"></span><br><span class="line">    SimpleCacheManager cacheManager = <span class="keyword">new</span> <span class="constructor">SimpleCacheManager()</span>;</span><br><span class="line">    cacheManager.set<span class="constructor">Caches(<span class="params">caches</span>)</span>;</span><br><span class="line">    return cacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 芝士点心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> SpringCache </tag>
            
            <tag> 分桶策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>释本智大师开示</title>
      <link href="/2022/03/15/other/%E9%87%8A%E6%9C%AC%E6%99%BA%E5%A4%A7%E5%B8%88%E5%BC%80%E7%A4%BA/"/>
      <url>/2022/03/15/other/%E9%87%8A%E6%9C%AC%E6%99%BA%E5%A4%A7%E5%B8%88%E5%BC%80%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="七绝-植树节"><a href="#七绝-植树节" class="headerlink" title="七绝 植树节"></a><center><font face="黑体">七绝 植树节</font></center></h3><center>近平垂范似朝霞，照耀新林绿嫩芽。</br>生态安全民福祉，成荫繁木佑中华。</br></center><h3 id="无题"><a href="#无题" class="headerlink" title="无题"></a><center><font face="黑体">无题</font></center></h3><center>春雷惊蛰物苏醒，细雨和风柳叶青。</br>代表京城商国是，豪情壮志满银屏。</br></center><h3 id="天窗"><a href="#天窗" class="headerlink" title="天窗"></a><center><font face="黑体">天窗</font></center></h3><center>雲淡清风岁月愁，转晴青丝白了头。</br>似水年华随风去，历尽艰辛人已老。</br>读书写字心常乐，别管文化与多少。</br>贫穷生活真自在，樂观情怀智慧花。</br></center><h3 id="敬诵《大乘无量庄严清净平等觉经》"><a href="#敬诵《大乘无量庄严清净平等觉经》" class="headerlink" title="敬诵《大乘无量庄严清净平等觉经》"></a><center><font face="黑体">敬诵《大乘无量庄严清净平等觉经》</font></center></h3><center>人身难得法难闻，无量寿经喜沐熏。</br>恩德布施智深广，佛心通达性芳芬。</br>舍离执着成功德，希摄善知诵圣文。</br>无上菩提幸开示，往生净土驾慈云。</br></center><h3 id="随笔四首"><a href="#随笔四首" class="headerlink" title="随笔四首"></a><center><font face="黑体">随笔四首</font></center></h3><center>一</br>苍山绿树清水流，虾蝉小魚顺溪游。</br>秋风吹来枫叶落，引得蜻蜓长出头。</br>二</br>风吹天涯苦愁长，夜来秋雨化流芳。</br>耄耋不思白头苦，古须悲叹恋贤良。</br>三</br>自古英雄不重来，最喜晨光把熹微。</br>能吃能喝便是福，健康胜过百万财。</br>四</br>旭日东升一点红，远山近岭雾重重。</br>清早甜蜜百鸟叫，夜晚钟声佛号隆。</br></center><h3 id="无题-1"><a href="#无题-1" class="headerlink" title="无题"></a><center><font face="黑体">无题</font></center></h3><center>天真不假异和同，如影随形处处逢。</br>时流当下能荐取，四生十类尽比蒙。</br>大似伶人一场梦，有和尊卑富与穷。</br>世事分明明似镜，切勿自负初发心！</br></center><h3 id="无题-2"><a href="#无题-2" class="headerlink" title="无题"></a><center><font face="黑体">无题</font></center></h3><center>国脉昌隆佛之家，喜鹊峯下月光賒。</br>宗接曹溪开慧眼，山含水月吐烟霞。</br>白雲密密禪房销，清韵声声梵呗加。</br>森林风光無限美，绿叶片片似袈裟。</br></center><h3 id="随笔四首-1"><a href="#随笔四首-1" class="headerlink" title="随笔四首"></a><center><font face="黑体">随笔四首</font></center></h3><center>一</br>师徒相伴桃花嶺，鸟语花香是灵山。</br>雲层波涛涌滚滚，风吹竹叶似剑刀。</br>二</br>早有千户在上供，夜来灯火伴佛眠。</br>放眼洞庭於盘碗，台头可胜天外天。</br>三</br>初次寻溪訪胡源，白云深处鸟和鸣。</br>山幽松掩疑無路，耳听声声佛号音</br>四</br>殿堂清净无尘染，道觉从来绝望思，</br>天地灵明有正气，曹溪一脉密相传。</br></center><h3 id="无题四首"><a href="#无题四首" class="headerlink" title="无题四首"></a><center><font face="黑体">无题四首</font></center></h3><center>一</br>世界潮流浪泊天，桑田滄海豈安然。</br>心内莫種無明草，自有嘉音在眼前。</br>二</br>觉悟世缘復东山，峰显一句不轻談。</br>法筵龙象随高步，狮吼频呻伏野犴。</br>三</br>本来是佛妙难倫，宗师圆融说普门。</br>玉石朗耀非今古，四海清波转法轮。</br>四</br>弘法利生学佛陀，净心当下出娑婆。</br>慧灯照耀三千界，海众皈依唱赞歌。</br></center><h3 id="昨夜探病"><a href="#昨夜探病" class="headerlink" title="昨夜探病"></a><center><font face="黑体">昨夜探病</font></center></h3><center>垂死挣抓實可哀，众生谁能免轮回。</br>贪婪纵欲迷情䋞，恩爱绸林是怪胎。</br>老病無期冯业力，回光返照浄尘埃。</br>心猿意马齐关锁，可免阎王小鬼催。</br></center>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PaddleOCR - PaddleServing部署</title>
      <link href="/2021/07/29/machinelearn/PaddleOCR-PaddleServing%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/07/29/machinelearn/PaddleOCR-PaddleServing%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="PaddleOCR"><a href="#PaddleOCR" class="headerlink" title="PaddleOCR"></a>PaddleOCR</h3><p>PaddleOCR提供2种服务部署方式：</p><ul><li>基于PaddleHub Serving的部署：代码路径为”./deploy/hubserving”，按照本教程使用；<ul><li>deploy: <a href="https://github.com/PaddlePaddle/PaddleOCR/tree/release/2.1/deploy/hubserving" target="_blank" rel="noopener">https://github.com/PaddlePaddle/PaddleOCR/tree/release/2.1/deploy/hubserving</a></li></ul></li><li>(简单，用于多客户端) 基于PaddleServing的部署：代码路径为”./deploy/pdserving”，使用方法参考文档。<ul><li><a href="https://github.com/PaddlePaddle/PaddleOCR/blob/release/2.1/deploy/pdserving/README_CN.md" target="_blank" rel="noopener">https://github.com/PaddlePaddle/PaddleOCR/blob/release/2.1/deploy/pdserving/README_CN.md</a></li></ul></li></ul><h3 id="PaddleOCR-环境"><a href="#PaddleOCR-环境" class="headerlink" title="PaddleOCR 环境"></a>PaddleOCR 环境</h3><p><a href="https://github.com/PaddlePaddle/PaddleOCR/blob/release/2.1/doc/doc_ch/installation.md" target="_blank" rel="noopener">https://github.com/PaddlePaddle/PaddleOCR/blob/release/2.1/doc/doc_ch/installation.md</a></p><h4 id="python3-7"><a href="#python3-7" class="headerlink" title="python3.7"></a>python3.7</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz</span><br><span class="line">tar -zxvf Python-3.7.0.tgz &amp;&amp; cd Python-3.7.0</span><br><span class="line">yum -y <span class="keyword">install</span> gcc</span><br><span class="line">yum -y <span class="keyword">install</span> gcc-c++</span><br><span class="line">yum -y <span class="keyword">install</span> make</span><br><span class="line">yum -y <span class="keyword">install</span> zlib*</span><br><span class="line">yum <span class="keyword">install</span> libffi-devel -y</span><br><span class="line">yum <span class="keyword">install</span> openssl-devel openssl -y</span><br><span class="line">./configure <span class="comment">--prefix=/usr/local/python3</span></span><br><span class="line">make -j8&amp;&amp; make <span class="keyword">install</span></span><br><span class="line"></span><br><span class="line">yum groupinstall <span class="string">'Development Tools'</span> -y</span><br><span class="line">yum <span class="keyword">install</span> zlib-devel bzip2-devel openssl-devel ncurese-devel -y</span><br><span class="line"></span><br><span class="line">mv /usr/<span class="keyword">bin</span>/python /usr/<span class="keyword">bin</span>/python.bak</span><br><span class="line"><span class="keyword">ln</span> -s /usr/<span class="keyword">local</span>/python3/<span class="keyword">bin</span>/python3<span class="number">.7</span> /usr/<span class="keyword">bin</span>/python3</span><br><span class="line"><span class="keyword">ln</span> -s /usr/<span class="keyword">local</span>/python3/<span class="keyword">bin</span>/pip3 /usr/<span class="keyword">bin</span>/pip3</span><br><span class="line"><span class="keyword">ln</span> -s /usr/<span class="keyword">local</span>/python3/<span class="keyword">bin</span>/pip /usr/<span class="keyword">bin</span>/pip</span><br></pre></td></tr></table></figure><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">wget </span><span class="string">https:</span>//<span class="string">bootstrap.</span><span class="string">pypa.</span><span class="string">io/</span><span class="string">pip/</span>3.5/<span class="built_in">get-pip.py</span></span><br><span class="line"><span class="built_in">python3</span> <span class="built_in">get-pip.py</span></span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">#</span> 更新 <span class="comment">#!/usr/bin/python.bak</span></span><br><span class="line"><span class="string">vim </span>/<span class="string">usr/</span><span class="string">bin/</span><span class="string">yum </span></span><br><span class="line"><span class="string">vim </span>/<span class="string">usr/</span><span class="string">libexec/</span><span class="string">urlgrabber-ext-</span><span class="string">down</span></span><br><span class="line"><span class="string">yum </span>-y <span class="string">upgrade</span></span><br><span class="line"><span class="string">yum </span>-y <span class="string">update</span></span><br></pre></td></tr></table></figure><h4 id="Paddle"><a href="#Paddle" class="headerlink" title="Paddle"></a>Paddle</h4><p>useradd paddleopr<br>passwd paddleopr</p><p>pip的安装都用paddleopr用户。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pip3 install --upgrade pip</span><br><span class="line"></span><br><span class="line"># 如果您的机器安装的是CUDA9或CUDA10，请运行以下命令安装</span><br><span class="line"><span class="keyword">python3</span> -<span class="keyword">m</span> pip install paddlepaddle-gpu==<span class="number">2.0</span>.<span class="number">0</span> -i http<span class="variable">s:</span>//mirror.baidu.<span class="keyword">com</span>/pypi/simple</span><br><span class="line"># 如果您的机器是CPU，请运行以下命令安装</span><br><span class="line"><span class="keyword">python3</span> -<span class="keyword">m</span> pip install paddlepaddle==<span class="number">2.0</span>.<span class="number">0</span> -i http<span class="variable">s:</span>//mirror.baidu.<span class="keyword">com</span>/pypi/simple</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git clone http<span class="variable">s:</span>//gitee.<span class="keyword">com</span>/paddlepaddle/PaddleOCR</span><br><span class="line"><span class="keyword">cd</span> PaddleOCR</span><br><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure><h3 id="PaddleServing-部署"><a href="#PaddleServing-部署" class="headerlink" title="PaddleServing 部署"></a>PaddleServing 部署</h3><h4 id="安装serving，用于启动服务"><a href="#安装serving，用于启动服务" class="headerlink" title="安装serving，用于启动服务"></a>安装serving，用于启动服务</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip3 <span class="keyword">install</span> paddle-serving-<span class="keyword">server</span>==<span class="number">0.6</span><span class="number">.1</span> <span class="comment"># for CPU</span></span><br><span class="line">pip3 <span class="keyword">install</span> paddle-serving-<span class="keyword">server</span>-gpu==<span class="number">0.6</span><span class="number">.1</span> <span class="comment"># for GPU</span></span><br><span class="line"><span class="comment"># 其他GPU环境需要确认环境再选择执行如下命令</span></span><br><span class="line">pip3 <span class="keyword">install</span> paddle-serving-<span class="keyword">server</span>-gpu==<span class="number">0.6</span><span class="number">.1</span>.post101 <span class="comment"># GPU with CUDA10.1 + TensorRT6</span></span><br><span class="line">pip3 <span class="keyword">install</span> paddle-serving-<span class="keyword">server</span>-gpu==<span class="number">0.6</span><span class="number">.1</span>.post11 <span class="comment"># GPU with CUDA11 + TensorRT7</span></span><br></pre></td></tr></table></figure><h4 id="安装client，用于向服务发送请求"><a href="#安装client，用于向服务发送请求" class="headerlink" title="安装client，用于向服务发送请求"></a>安装client，用于向服务发送请求</h4><p>在下载链接中找到对应python版本的client安装包，这里推荐python3.7版本：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="keyword">https</span>://paddle-serving.bj.bcebos.com/test-dev/whl/paddle_serving_client<span class="number">-0.0</span><span class="number">.0</span>-cp37-<span class="literal">none</span>-<span class="keyword">any</span>.whl</span><br><span class="line">pip3 install paddle_serving_client<span class="number">-0.0</span><span class="number">.0</span>-cp37-<span class="literal">none</span>-<span class="keyword">any</span>.whl</span><br></pre></td></tr></table></figure><h4 id="安装serving-app"><a href="#安装serving-app" class="headerlink" title="安装serving-app"></a>安装serving-app</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install paddle-serving-app==<span class="number">0.6</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><h4 id="模型转换"><a href="#模型转换" class="headerlink" title="模型转换"></a>模型转换</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载并解压 OCR 文本检测模型</span></span><br><span class="line">wget https:<span class="string">//paddleocr.bj.bcebos.com/dygraph_v2.0/ch/ch_ppocr_mobile_v2.0_det_infer.tar</span> &amp;&amp; tar xf ch_ppocr_mobile_v2.0_det_infer.tar</span><br><span class="line"><span class="comment"># 下载并解压 OCR 文本识别模型</span></span><br><span class="line">wget https:<span class="string">//paddleocr.bj.bcebos.com/dygraph_v2.0/ch/ch_ppocr_mobile_v2.0_rec_infer.tar</span> &amp;&amp; tar xf ch_ppocr_mobile_v2.0_rec_infer.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换检测模型</span></span><br><span class="line">python3 -m paddle_serving_client.convert <span class="params">--dirname</span> <span class="string">./ch_ppocr_mobile_v2.0_det_infer/</span> \</span><br><span class="line">                                         <span class="params">--model_filename</span> inference.pdmodel          \</span><br><span class="line">                                         <span class="params">--params_filename</span> inference.pdiparams       \</span><br><span class="line">                                         <span class="params">--serving_server</span> <span class="string">./ppocr_det_mobile_2.0_serving/</span> \</span><br><span class="line">                                         <span class="params">--serving_client</span> <span class="string">./ppocr_det_mobile_2.0_client/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换识别模型</span></span><br><span class="line">python3 -m paddle_serving_client.convert <span class="params">--dirname</span> <span class="string">./ch_ppocr_mobile_v2.0_rec_infer/</span> \</span><br><span class="line">                                         <span class="params">--model_filename</span> inference.pdmodel          \</span><br><span class="line">                                         <span class="params">--params_filename</span> inference.pdiparams       \</span><br><span class="line">                                         <span class="params">--serving_server</span> <span class="string">./ppocr_rec_mobile_2.0_serving/</span>  \</span><br><span class="line">                                         <span class="params">--serving_client</span> <span class="string">./ppocr_rec_mobile_2.0_client/</span></span><br></pre></td></tr></table></figure><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/bin/<span class="keyword">sh</span>: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)</span><br><span class="line"><span class="keyword">Error</span>: Can not import avx core <span class="keyword">while</span> this <span class="keyword">file</span> exists: /home/paddleopr/.<span class="keyword">local</span>/lib/python3.7/site-packages/paddle/fluid/core_avx.<span class="keyword">so</span></span><br><span class="line">...</span><br><span class="line">ImportError: /lib64/libstdc++.<span class="keyword">so</span>.6: <span class="keyword">version</span> `CXXABI_1.3.8' not found (required <span class="keyword">by</span> /home/paddleopr/.<span class="keyword">local</span>/lib/python3.7/site-packages/paddle/fluid/core_avx.<span class="keyword">so</span>)</span><br><span class="line"></span><br><span class="line"># root，查看是否安装CXXABI_1.3.8</span><br><span class="line">strings /usr/lib64/libstdc++.<span class="keyword">so</span>.6|grep CXXABI</span><br><span class="line">下载https:<span class="comment">//wwa.lanzoui.com/i8lnene</span></span><br><span class="line">解压后放在/usr/lib64</span><br><span class="line"><span class="keyword">rm</span> -rf libstdc++.<span class="keyword">so</span>.6</span><br><span class="line">mv libstdc++.<span class="keyword">so</span>.6.0.26 libstdc++.<span class="keyword">so</span>.6</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line">ImportError: /lib64/libc.<span class="keyword">so</span>.6: <span class="keyword">version</span> `GLIBC_2.18' not found (required <span class="keyword">by</span> /lib64/libstdc++.<span class="keyword">so</span>.6)</span><br><span class="line"></span><br><span class="line">root执行</span><br><span class="line">curl -O http:<span class="comment">//ftp.gnu.org/gnu/glibc/glibc-2.18.tar.gz</span></span><br><span class="line">tar zxf glibc-2.18.tar.gz </span><br><span class="line"><span class="keyword">cd</span> glibc-2.18/</span><br><span class="line"><span class="keyword">mkdir</span> build</span><br><span class="line"><span class="keyword">cd</span> build/</span><br><span class="line">../configure --prefix=/usr</span><br><span class="line">make -j2</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 修改config.yml中模型地址</span><br><span class="line"><span class="keyword">cd</span> PaddleOCR/deploy/pdserver/</span><br><span class="line"><span class="keyword">python3</span> web_service.<span class="keyword">py</span> &amp;&gt;<span class="built_in">log</span>.txt &amp;</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line"><span class="keyword">python3</span> pipeline_http_client.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><h5 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ImportError: libSM.so<span class="number">.6</span>: cannot open <span class="keyword">shared</span> object file: No such file <span class="keyword">or</span> directory</span><br><span class="line"></span><br><span class="line">#查看缺少的共享库</span><br><span class="line">yum whatprovides libSM.so<span class="number">.6</span></span><br><span class="line">yum install libSM<span class="number">-1.2</span><span class="number">.2</span><span class="number">-2.</span>el7.x86_64 --setopt=protected_multilib=<span class="literal">false</span></span><br><span class="line">yum install libXrender<span class="number">-0.9</span><span class="number">.10</span><span class="number">-1.</span>el7.x86_64 --setopt=protected_multilib=<span class="literal">false</span></span><br><span class="line">yum install libXext<span class="number">-1.3</span><span class="number">.3</span><span class="number">-3.</span>el7.x86_64 --setopt=protected_multilib=<span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> PaddleOCR </tag>
            
            <tag> OCR </tag>
            
            <tag> Paddle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务之Seata常见异常</title>
      <link href="/2021/06/23/java/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/"/>
      <url>/2021/06/23/java/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8BSeata%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h3 id="关于log-status-1的记录"><a href="#关于log-status-1的记录" class="headerlink" title="关于log_status=1的记录"></a>关于log_status=1的记录</h3><p>网上都说是防悬挂，具体是指啥又没说清楚。这里先说结论：这个条记录，你可以不用管它。</p><p>防悬挂，因为网络延迟或者第一阶段请求丢包，导致第二阶段的回滚请求，先到RM，RM此时没有处理第一阶段请求，没有记录undo_log，所以插入该记录，作为一个防御性的操作，阻止后到的第一阶段请求继续执行。</p><p>产生的另一个原因是，请检查项目中是否为多数据源。如果是，需要把seata自动代理关了，一般多数据源都是有开发者已经手动代理了。二阶段的时候，下发找datasource，找到的不是你业务操作数据库的datasource，导致没发现undolog，就插了一条status=1。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭自动代理</span></span><br><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">enable-auto-data-source-proxy:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="关于log-status-0的记录"><a href="#关于log-status-0的记录" class="headerlink" title="关于log_status=0的记录"></a>关于log_status=0的记录</h3><p>seata-server宕机后，分支事务的undo_log中将出现log_status=0的记录，重新seata-server后，会自动处理掉这些日志。</p><h3 id="异常：ShouldNeverHappenException"><a href="#异常：ShouldNeverHappenException" class="headerlink" title="异常：ShouldNeverHappenException"></a>异常：ShouldNeverHappenException</h3><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Error </span>preparing statement. Cause: io.seata.common.exception.ShouldNeverHappenException: [xid:172.19.0.204:8091:9483xxxxxxxxx]get tablemeta failed</span><br></pre></td></tr></table></figure><p>解决方案：检查表是否存在。</p><h3 id="异常：SQLJoinTableSource"><a href="#异常：SQLJoinTableSource" class="headerlink" title="异常：SQLJoinTableSource"></a>异常：SQLJoinTableSource</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.ClassCastException</span>: <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.druid</span><span class="selector-class">.sql</span><span class="selector-class">.ast</span><span class="selector-class">.statement</span><span class="selector-class">.SQLJoinTableSource</span> <span class="selector-tag">cannot</span> <span class="selector-tag">be</span> <span class="selector-tag">cast</span> <span class="selector-tag">to</span> <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.druid</span><span class="selector-class">.sql</span><span class="selector-class">.ast</span><span class="selector-class">.statement</span><span class="selector-class">.SQLExprTableSource</span>;</span><br></pre></td></tr></table></figure><p>出现原因：update语句不能join其他表。</p><h3 id="异常：TmTransactionException"><a href="#异常：TmTransactionException" class="headerlink" title="异常：TmTransactionException"></a>异常：TmTransactionException</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Failed</span> <span class="selector-tag">to</span> <span class="selector-tag">begin</span> <span class="selector-tag">transaction</span>. </span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.core</span><span class="selector-class">.exception</span><span class="selector-class">.TmTransactionException</span>: <span class="selector-tag">TransactionException</span><span class="selector-attr">[Fail to store global session]</span></span><br><span class="line">....</span><br><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.UndeclaredThrowableException</span>: <span class="selector-tag">null</span></span><br></pre></td></tr></table></figure><p>查看seata-server是否抛出类似的错误：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">writeSession <span class="keyword">error</span>, <span class="keyword">global</span> session <span class="keyword">size</span> exceeded, <span class="keyword">size</span> : <span class="number">566</span> maxBranchSessionSize : <span class="number">512</span></span><br></pre></td></tr></table></figure><p>解决方案：开启全局事务的方法入参太多。</p><h3 id="异常：TransactionException"><a href="#异常：TransactionException" class="headerlink" title="异常：TransactionException"></a>异常：TransactionException</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransactionException[Could <span class="keyword">not</span> register branch <span class="built_in">int</span>o global session xid = <span class="number">172.32</span><span class="number">.1</span><span class="number">.161</span>:<span class="number">8091</span>:<span class="number">113670</span>****<span class="number">4512</span> status = AsyncComm ]</span><br></pre></td></tr></table></figure><p>产生原因：在 @GlobalTransactional 的外面使用 @Transactional 修饰了，例如：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">aaa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">bbb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GlobalTransactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">bbb</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 踩坑日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> maven </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL生成随机字符串</title>
      <link href="/2021/04/11/sql/SQL%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/04/11/sql/SQL%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="生成随机数字"><a href="#生成随机数字" class="headerlink" title="生成随机数字"></a>生成随机数字</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">CONCAT</span>(<span class="keyword">FLOOR</span>(<span class="keyword">RAND</span>()*<span class="number">500000000000000000</span> + <span class="number">500000000000000000</span>) ,’’)</span><br></pre></td></tr></table></figure><h3 id="生成随机字符"><a href="#生成随机字符" class="headerlink" title="生成随机字符"></a>生成随机字符</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select substring(<span class="name">MD5</span>(<span class="name">RAND</span>()),<span class="number">1</span>,<span class="number">18</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 芝士点心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>祭释慧利感怀</title>
      <link href="/2021/03/15/other/%E7%A5%AD%E9%87%8A%E6%85%A7%E5%88%A9%E6%84%9F%E6%80%80/"/>
      <url>/2021/03/15/other/%E7%A5%AD%E9%87%8A%E6%85%A7%E5%88%A9%E6%84%9F%E6%80%80/</url>
      
        <content type="html"><![CDATA[<h3 id="祭岳母感怀"><a href="#祭岳母感怀" class="headerlink" title="祭岳母感怀"></a><center><font face="黑体">祭岳母感怀</font></center></h3><center><font face="黑体">余礼义</font></center><center>二七悲来暗伤神，嚎啕断肠奠墓门。</br>谆谆教导尤传耳，点点指划唤吾声。</br>憾惭东床无回力，却喜西方有佛恩。</br>但愿九品莲台上，不返凡间半步程。</br></center><h3 id="哭祖母作古"><a href="#哭祖母作古" class="headerlink" title="哭祖母作古"></a><center><font face="黑体">哭祖母作古</font></center></h3><center><font face="黑体">刘源远</font></center><center>旧岁一别两相隔，今日感怀悲痛绝。</br>谆谆教导尤传耳，点点指划唤吾声。</br>只因疬疫误作古，悔恨临终未瞻颜。</br>可庆升座极乐国，三品金莲念佛恩。</br></center>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - 温故知新</title>
      <link href="/2021/01/26/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0/"/>
      <url>/2021/01/26/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><h4 id="关注的点"><a href="#关注的点" class="headerlink" title="关注的点"></a>关注的点</h4><p>选取提案的规则：</p><p>如果acceptor通过提案[M, ]的prepare请求，则向proposer保证以下承诺：</p><ol><li>acceptor承诺不再通过编号小于等于M的提案的prepare请求</li><li>acceptor承诺不再通过编号小于M的提案的accept请求，也就是不再通过编号小于M的提案</li><li>如果acceptor已经通过某一提案，则承诺在prepare请求的响应中返回已经通过的最大编号的提案内容。如果没有通过任何提案，则在prepare请求的响应中返回空值</li></ol><p>proposer在发起accept请求时，提案值由prepare响应决定。如果prepare响应有返回已通过的提案值，该accept请求则使用prepare响应中的值。如果prepare响应没有已通过的提案值，则有该proposer任意指定。</p><h3 id="ZAB"><a href="#ZAB" class="headerlink" title="ZAB"></a>ZAB</h3><h4 id="消息广播模式"><a href="#消息广播模式" class="headerlink" title="消息广播模式"></a>消息广播模式</h4><p>消息广播模式是一个类似于二阶段提交（2PC）过程，<strong>与2PC不同的是，ZAB移除了第二阶段的中断逻辑。所有的Follower要么接收该Proposal，要么抛弃Leader服务器</strong>。这意味着Leader收到过半的Ack响应后就可以提交该事务了，而不需要等待所有的Follower都返回Ack。</p><ol><li>客户端发起事务请求，由Leader进行处理</li><li>Leader将该请求转换为事务Proposal，同时为Proposal分配一个全局的ID，即zxid</li><li>Leader为每个Follower维护一个FIFO队列，将上一步生成的Proposal放入队列中，进行广播</li><li>Follower收到Proposal后，会首先将其以事务日志的方式写入本地磁盘中，写入成功后向Leader反馈一个响应消息</li><li>Leader收到过半的Ack响应后，自己完成对该Proposal的提交后，向每个Follower的队列中，写入Commit消息进行广播</li><li>Follower接收到Commit消息后，会将上一条事务提交</li></ol><p>zxid，用于提交提案的先后顺序。Leader提交提案是有顺序性的，按照zxid的大小，按顺序提交提案，如果前一个提案未提交，此时是不会提交后一个提案的。</p><h4 id="崩溃恢复模式"><a href="#崩溃恢复模式" class="headerlink" title="崩溃恢复模式"></a>崩溃恢复模式</h4><p>约定：</p><ol><li>ZAB需要确保那些已经在Leader上提交的事务最终被所有服务器都提交。</li><li>ZAB需要确保丢弃那些仅仅只在Leader上被提出的事务。</li></ol><h5 id="Leader选举（ELECTION）"><a href="#Leader选举（ELECTION）" class="headerlink" title="Leader选举（ELECTION）"></a>Leader选举（ELECTION）</h5><p>Leader选举PK的规则包含以下几个方面：</p><ul><li>任期编号（epoch），优先判断epoch，epoch大的节点当选Leader</li><li>事务标示符（zxid），epoch相同，则比较zxid，zxid大的当选Leader</li><li>节点ID，epoch、zxid都一致，则比较节点ID（在myid文件中指定的值）</li></ul><ol><li>leader宕机，各个follower开始leader选举PK</li><li>各个follower都投票给自己，封装一个选票信息，广播给其他的follower。选票信息包含：<ul><li>自己所提议的节点ID</li><li>自己所提议节点所处leader周期</li><li>自己所提议节点拥有最大的zxid</li><li>投票节点标示</li></ul></li><li>其他节点收到选票信息后，根据上述规则开始和自己所提议的节点进行PK。如果选票有更新，当前节点则继续广播自己更新之后的选票信息</li><li>最后各节点的选票池，都有过半的选票支持某一节点，该节点晋升为准leader，完成选举</li><li>各节点分别修改自己的状态，准leader修改为LEADING，其余修改为FOLLOWING</li></ol><h5 id="发现（DISCOVERY）"><a href="#发现（DISCOVERY）" class="headerlink" title="发现（DISCOVERY）"></a>发现（DISCOVERY）</h5><p>该阶段用于确立Leader的领导关系，由Follower会主动联系准Leader。</p><ol><li>Follower将自己最后接受的事务Proposal的epoch值发送给准Leader，记作FOLLOWERINFO。</li><li>准Leader收到来自过半（包含B节点自己）的FOLLOWERINFO消息后，选取最大的epoch值，对其进行加1，作为新的epoch值，并封装成LEADERINFO消息发给这些过半的Follower。</li><li>Follower收到LEADERINFO消息后<ul><li>更新自己的epoch</li><li>将自己的运行状态变更为SYNCHRONIZATION</li><li>返回ACKEPOCH给准Leader。</li></ul></li><li>准Leader收到过半的ACKEPOCH消息后，也将自己的运行状态修改为SYNCHRONIZATION。至此完成发现阶段的工作，集群确立Leader的领导关系。</li></ol><h5 id="数据同步（SYNCHRONIZATION）"><a href="#数据同步（SYNCHRONIZATION）" class="headerlink" title="数据同步（SYNCHRONIZATION）"></a>数据同步（SYNCHRONIZATION）</h5><p>该阶段是实现崩溃恢复的关键步骤，由Leader发送数据给Follower处理。数据内容分三种：DIFF、TRUNC、SNAP。</p><ol><li>Leader根据Follower的最大zxid选择同步方式</li><li>Leader将同步方式和需要同步的数据，一起封装为NEWLEADER消息发给Follower</li><li>Follower在收到NEWLEADER消息后，进行修复不一致数据，并返回给Leader响应Ack消息</li><li>Leader在收到过半Ack消息后，则完成数据同步阶段，将自己运行状态修改为BROADCARST（广播状态），并发送UPTODATE消息给过半的Follower，通知他们完成数据同步，修改运行状态修改为BROADCARST</li></ol><h3 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h3><h4 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h4><h4 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h4>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> paxos </tag>
            
            <tag> ZAB </tag>
            
            <tag> Raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos</title>
      <link href="/2021/01/20/centos/Centos/"/>
      <url>/2021/01/20/centos/Centos/</url>
      
        <content type="html"><![CDATA[<h3 id="kill一组进程"><a href="#kill一组进程" class="headerlink" title="kill一组进程"></a>kill一组进程</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ps</span> -ef|<span class="keyword">grep</span> <span class="keyword">python</span>|<span class="keyword">grep</span> -v <span class="keyword">grep</span>|cut -<span class="keyword">c</span> <span class="number">9</span>-<span class="number">16</span>|xargs kill -<span class="number">15</span></span><br></pre></td></tr></table></figure><h3 id="默认编码"><a href="#默认编码" class="headerlink" title="默认编码"></a>默认编码</h3><p>报错：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING! The remote SSH<span class="built_in"> server </span>rejected X11 forwarding request.</span><br><span class="line">Last login: Fri Jul 30 16:31:01 2021 <span class="keyword">from</span> 192.168.1.46</span><br><span class="line">-bash: warning: setlocale: LC_ALL: cannot change locale (en_US.UTF-8)</span><br></pre></td></tr></table></figure><p>解决：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localedef -i en_US -f UTF<span class="number">-8</span> en_US.UTF<span class="number">-8</span></span><br></pre></td></tr></table></figure><h3 id="进程数不够"><a href="#进程数不够" class="headerlink" title="进程数不够"></a>进程数不够</h3><p>非root用户登录报：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash:<span class="built_in"> Resource </span>temporarily unavailable。</span><br></pre></td></tr></table></figure><p>用root修改/etc/security/limits.d/20-nproc.conf，将4096改成65536</p>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - EPaxos</title>
      <link href="/2020/12/21/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20EPaxos/"/>
      <url>/2020/12/21/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20EPaxos/</url>
      
        <content type="html"><![CDATA[<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>epaxos作为paxos族中的一员，并不是单独存在的。所以我在文中开篇给出总结，罗列与basic-paxos、mutli-paxos之间的区别。带着目的学习，可能相对容易理解一些。</p><p>回顾paxos的局限性，总结来说存在三个问题：</p><ol><li>basic-paxos，多个proposal提出时，容易形成活锁，影响整个算法的活性。</li><li>mutli-paxos，通过只允许leader提出proposal，解决活锁问题，同时影响了吞吐量（性能局限于leader）、可扩展性（必须要leader发起提案）、可用性（leader宕机服务不可用）。</li><li>paxos，各提案乱序提交，不能明确各提案之间的依赖关系。</li><li>raft，通过实现对日志项进行编号，解决日志项之间依赖关系，但是又不支持乱序提交。</li><li>paxos、raft，client跨地域请求leader，延迟增大。</li></ol><p>paxos存在的活锁、提案依赖关系的问题。从某个角度来说：mutli-paxos、raft采用“曲线救国”的方案对问题进行规避，通过引入leader和事先对日志项编号来避免，或多或少都降低了可用性和吞吐量。而epaxos则是直面冲突，并给出了自己的解决冲突的方案。</p><h3 id="epaxos简介"><a href="#epaxos简介" class="headerlink" title="epaxos简介"></a>epaxos简介</h3><h4 id="epaxos特性"><a href="#epaxos特性" class="headerlink" title="epaxos特性"></a>epaxos特性</h4><p>在epaxos开篇介绍时，都会提到一个词“leaderless”，这确实是epaxos最值得骄傲的特性了。leaderless描述的是：没有leader，各节点对等，任何节点都可处理事务请求（写请求）。</p><p>在“leaderless”特性下，epaxos的优势很明显：</p><ol><li>epaxos省略了leader选举的开销，同时没有leader瓶颈限制的问题。</li><li>各节点都能处理事务请求（写请求），拥有更高的性能。</li><li>在跨地域场景下，不需要额外的同步（学习）的阶段。</li><li>客户端可选择最近的副本提供服务，具有更小的延迟。</li></ol><h4 id="epaxos的答卷"><a href="#epaxos的答卷" class="headerlink" title="epaxos的答卷"></a>epaxos的答卷</h4><p>面对paxos遗留的两个问题：活锁、提案依赖关系。epaxos又是如何解决的呢？</p><p>epxos将协议拆分为两部分，一部分是commit协议，一部分是恢复阶段。前者是处理写请求，在各副本中选择（提交）command并确定command附加的属性值（当前command依赖其他command的顺序）。后者是集群中某个副本异常时，其他副本尝试恢复其数据。</p><p>在commit协议中，又具体分为三个阶段：</p><ul><li>阶段一：Establish ordering constraints，建立约束关系</li><li>阶段二：Paxos-Accept，达成一致</li><li>阶段三：commit阶段，一般异步提交，通常被大家一笔带过</li></ul><p>commit协议中提出日志冲突的概念，阶段一也就是为了解决日志冲突而存在的。当多个command（写请求）对同一个值进行修改时，epaxos则认为发生冲突，需要先建立command之间的约束关系（command之间顺序）。</p><p>对于是否冲突，commit协议给出不同达成一致的方案：fast-path, slow-path，二者分别对应没有冲突和有冲突的写请求。fast-path是指在没有冲突的写请求中，执行阶段一即可进行提交。slow-path是指在发生冲突的写请求中，需要执行两个阶段才能进行提交。</p><p><img src="/images/theory/distributed/epaxos_1.png" alt="fast-path, slow-path"></p><p>这张经典的图，还是得看，清晰的描述了fast-path, slow-path二者的不同之处。R1, R2,…R5是五个副本。C1, C2, C3, C4是command（即更新操作），R1和R5分别记为C1和C2的command-leader。为了清晰起见，我们省略了异步提交消息。</p><p>左图中C1对obj_A修改，C2对obj_B修改，即两者不会发生冲突，因此两者都可以在fast-path上提交。</p><ol><li>R1收到update obj_A请求，将其发给多数派副本</li><li>各副本在收该请求后，由于没有其他请求发生冲突，则返回成功R1</li><li>异步提交</li><li>R5同上</li></ol><p>右图中C3和C4同时对obj_A修改，相互干扰，因此一个C3将在slow-path上执行。</p><ol><li>R1和R5分别收到update obj_A请求，将其分别封装为C3和C4发送其他多数派副本</li><li>R3为多数派相交的副本，C4比C3先到到达R3</li><li>R3在处理C4时，没有请求与之冲突，则提供通过fast-path提交</li><li>R3在收到C3时，由于C4和C3发生冲突，则返回C3→C4，表示C3获得了对C4的依赖</li><li>R1收到R3的响应，则将依赖关系整理后，发起accept给多数派</li><li>多数派没有继续发生冲突，则返回成功</li><li>异步提交</li></ol><h4 id="quorum特殊要求"><a href="#quorum特殊要求" class="headerlink" title="quorum特殊要求"></a>quorum特殊要求</h4><p>需要注意，与paxos不同的是：paxos只需要多数派的副本正常响应后，便能正常提交。而对epaxos则略有差异：</p><ul><li>论文中指出在fast-path中，quorum数量为：$F+\lfloor(F+1)/2\rfloor$，其中F表示最大容忍的出错副本数量。即：command-leader需要收到$F+\lfloor(F+1)/2\rfloor$个副本（包含command-leader）的正常响应。在上面案例中，5副本的集群，最大容忍出错副本数量为2，则需要与2+[(2+1)/2] = 3.5，向下取整，即3个副本的正常响应。</li><li>在slow-path中，quorum数量为：F+1，其中F表示最大容忍的出错副本数量。在上面案例中，5副本的集群，最大容忍出错副本数量为2，则需要收到2+1=3个副本的正常响应。</li></ul><p>为了解释这个特殊要求，我们看下面的案列，存在7个副本，大于等于4则为多数派，3个容错数量。R1收到修改x=1，R2收到修改x=2，二者分别发起epaxos。<br><img src="/images/theory/distributed/epaxos_2.png" alt="quorum特殊要求"><br>R4, R5在fast-path先收到x=1再收到x=2。R6, R7在fast-path先收到x=2再收到x=1。如果R3是先收到x=1，那么R1、R3、R4、R5构成多数派，确定提交顺序为先提交x=1再提交x=2。如果R3是先收到x=2，那么R2、R3、R6、R7构成多数派，确定提交顺序为先提交x=2再提交x=1。<br>那么如果此时R1, R2, R3宕机，那么剩下的副本将不知道是先提交x=1还是先提交x=2。所以在epxos中fast-path需要quorum数量为$F+\lfloor(F+1)/2\rfloor$，即：$3+\lfloor(3+1)/2\rfloor=5$。</p><h3 id="commit协议"><a href="#commit协议" class="headerlink" title="commit协议"></a>commit协议</h3><p>正如上文提到，epaxos分为两部分，commit协议是指：</p><p>当副本L收到来自客户端写请求时，将其封装为command γ（念：伽玛），并称为γ的command-leader，command-leader开始γ的提交过程。进入第一阶段，command-leader定义γ的初始属性deps, seq。</p><ul><li>deps：定义所有包含与γ冲突的command（不一定是已提交的command）的列表，也称为γ依赖于这些command。</li><li>seq：用于execute算法过程中，打破循环依赖的序列号。取值为所有冲突command的最大的seq。</li></ul><p>command-leader将γ和γ的初始属性deps, seq<strong>至少</strong>发送给fast-path所要求的quorum数量（$F+\lfloor(F+1)/2\rfloor$），论文中称之为PreAccept-Message。各副本收到PreAccept-Message后，再<strong>根据自己本地的cmds-log更新γ的deps, seq值</strong>，并在自己的cmds-log中新增一条用来记录γ。将更新的γ返回给command-leader。</p><p>如果command-leader收到足够多的响应，并且所有响应中的γ的属性都相同，即构成fast-path，便发送Commit-Message进行异步提交。<br>如果command-leader没有收到足够多的响应，或者所有响应中的γ的属性存在不一致，即构成slow-path，command-leader需要基于所有响应更新γ的值（合并所有的deps作为新的deps，取最大的seq作为新的seq）。进入第二阶段，将新的γ<strong>至少</strong>发送给$\lfloor N/2 \rfloor$个副本，这个过程类似经典的paxos，在本轮结束之后，如果收到大多数$\lfloor N/2 \rfloor$响应（包含command-leader）即可给客户端返回成功，并发送Commit-Message进行异步提交。</p><h4 id="commit伪代码"><a href="#commit伪代码" class="headerlink" title="commit伪代码"></a>commit伪代码</h4><p><img src="/images/theory/distributed/epaxos_3.png" alt="commit伪代码"><br>论文中提供了伪代码，我们简单来看看，副本L收到来自客户端的请求γ，成为γ的commandleader</p><ol><li>自增L的instance id $i_L$ ← $i_L$ + 1。</li><li>$seq_γ$表示γ的seq，取值为：副本L已记录的command中最大的seq的值+1，与{0}取并集，是在没有command情况下，取0+1作为seq的值。</li><li>$deps_γ$表示γ的deps，取值为：副本L中与γ冲突的command集合。</li><li>副本L将 $ (γ,seq_γ,deps_γ,pre-accepted) $ 记录到自己 $cmds_L$ ，pre-accepted表示γ的状态。</li><li>发送$ PreAccept(γ,seq_γ,deps_γ,L.i_L) $给所有副本，$L.i_L$即第一步自增的instance id。</li></ol><p>副本R收到PreAccept请求后<br>6. 更新γ的seq值，取值为：副本R中已记录的command中最大的$seq+1$后与原来seq值，取最大。<br>7. 更新γ的deps值，取值为：取副本R中与γ冲突集合和原本deps的并集。<br>8. 副本R将$ (γ,seq_γ,deps_γ,pre-accepted) $记录到自己$cmds_R$，pre-accepted表示γ的状态。<br>9. 回复PreAcceptOK给副本L。</p><p>副本L收到最少$\lfloor N/2 \rfloor$个PreAcceptOK的响应后。（这里的$\lfloor N/2 \rfloor$感觉有问题）<br>10. 如果所有副本响应中$seq_γ$, $deps_γ$都相同<br>11. 副本L执行commit阶段，跳转至21步<br>12. 如果存在不相同的 $seq_γ$, $deps_γ$<br>13. 更新$deps_γ$，取值为：整合所有响应中的deps<br>14. 更新$seq_γ$，取值为：所有响应中最大seq<br>15. 副本L执行paxos-accept阶段</p><p>副本L开始paxos-accept阶段<br>16. 副本L将$(γ,seq_γ,deps_γ,accepted)$记录到自己$cmds_L$，accepted表示γ的状态。<br>17. 发送$Accept(γ,seq_γ,deps_γ,L.i)$给至少$\lfloor N/2 \rfloor$个副本</p><p>副本R收到Accept请求后<br>18. 副本R将$(γ,seq_γ,deps_γ,accepted)$记录到自己$cmds_R$，accepted表示γ的状态。<br>19. 回复AcceptOK给副本L。</p><p>副本L收到至少$\lfloor N/2 \rfloor$个AcceptOK响应后<br>20. 开始commit阶段，跳转至21步</p><p>副本L开始commit阶段<br>21. 副本L将$(γ,seq_γ,deps_γ,commited)$记录到自己$cmds_L$，commited表示γ的状态。<br>22. 回复客户端已提交的响应<br>23. 发送$Commit(γ,seq_γ,deps_γ,L.i)$给其他的副本</p><p>副本R收到commit请求<br>24. 副本R将$(γ,seq_γ,deps_γ,commited)$记录到自己$cmds_R$，commited表示γ的状态。</p><h3 id="Explicit-Prepare"><a href="#Explicit-Prepare" class="headerlink" title="Explicit Prepare"></a>Explicit Prepare</h3><p>这一部分，论文描述的篇幅相对较少，因此也没有被大家重视，epaxos称之为Explicit Prepare，用于恢复异常副本所处理的command。这一部分在论文中也用于执行command。如要要在一个副本上执行command γ，需要经过以下几个步骤：</p><ol><li>等待副本提交，或者显示调用Explicit Prepare</li><li>构建γ所依赖的command的依赖图，对所有依赖command都进行Explicit Prepare</li><li>找到紧密连接的组件（command），对它们进行拓扑排序</li><li>以逆拓扑顺序，对于每个强烈连接的组件（command），执行:<ol><li>按顺序将强连接组件中的所有命令排序；</li><li>以递增的编号顺序执行每个未执行的命令，将其标记为已执行</li></ol></li></ol><h4 id="Explicit-Prepare伪代码"><a href="#Explicit-Prepare伪代码" class="headerlink" title="Explicit Prepare伪代码"></a>Explicit Prepare伪代码</h4><p>在看伪代码之前，需要先描述一个概念。在经典的paxos中，每个proposal都有一个ballot，用于标示proposal唯一性，也用于表示proposal的先后顺序，epaxos当然也需要。为了保证ballot唯一性，所以ballot需要包含副本ID。同时新的周期要优先于旧的周期，所有还需要epoch值。最后ballot的格式为：epoch.b.R。</p><p><img src="/images/theory/distributed/epaxos_4.png" alt="Explicit Prepare"></p><p>副本Q怀疑L失效，尝试去恢复L.i这个instance。<br>25. 自增ballot，取值为epoch.(b+1).Q。（epoch.b.Q为副本Q最大的投票编号）<br>26. 发送$Prepare(epoch.(b+1).Q,L.i)$ 给所有副本，并等待$\lfloor N/2 \rfloor+1$个回复。<br>27. 假设所有回应中最大ballot的是$ballot_max$，定义R是所有回应中ballot等于$ballot_max$的响应的集合。<br>28,29. 如果R包含$(γ,seq_γ,deps_γ,commited)$，执行commit阶段<br>30,31. 如果R包含$(γ,seq_γ,deps_γ,acceprted)$，执行paxos-accept阶段<br>32,33. 如果R包含至少$\lfloor N/2 \rfloor$一致的回复$(γ,seq_γ,deps_γ,pre-accepted)$，且这些回复都不是来自L，执行paxos-accept阶段<br>34,35. 如果R至少包含一个$(γ,seq_γ,deps_γ,pre-accepted)$，执行第一阶段<br>36,37. 如果R没有关于这个instance id的任何信息，那么推出退出恢复阶段，副本Q对L.i实例尝试去commit no-op</p><p>副本R收到来自副本Q的Prepare(epoch.b.Q,L.i)请求<br>38,39. R已接收来自L.i的最大的ballot为epoch.x.Y，如果epoch.b.Q大于epoch.x.Y，回复$PrepareOK(cmds_R,epoch.x.Y,L.i)$<br>40,41.否则回复NACK</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ol><li>论文中强调的Executing和Commiting是两个不同的action，但是几乎没有提交关于Execution Algorithm的内容。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> paxos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇小记，关乎生死</title>
      <link href="/2020/12/14/other/%E4%B8%80%E7%AF%87%E5%B0%8F%E8%AE%B0%EF%BC%8C%E5%85%B3%E4%B9%8E%E7%94%9F%E6%AD%BB/"/>
      <url>/2020/12/14/other/%E4%B8%80%E7%AF%87%E5%B0%8F%E8%AE%B0%EF%BC%8C%E5%85%B3%E4%B9%8E%E7%94%9F%E6%AD%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>教会别人死亡的人，同时也能教会别人生活。<br>  – 《探究哲学既是学习死亡》</p></blockquote><p>二十来岁，是经历生离死别的年纪。死亡，每个人都有这一次，而在我们迎接自己死亡的过程中，如何面对他人死亡，是我最近思考的。</p><p>我的家人正经历病痛的折磨，我常常半夜惊醒，醒来哪种无法言语的情感，弥漫了我的整个身体。我们不愿意相信事实，我们舍不得她，却无力改变，面对疾病，我们仿佛回到更古老的时代。</p><p>所爱之人濒临死亡，我们常常束手无策。不知道如何帮助他们走完人生，应该如何继续帮助他们。比起从前，现在更需要我们改变对于死亡和临终的态度。</p><p>临终关怀需要爱和关怀，也需要一些更深远的东西，他们需要发现死亡和生命的意义。没有这些，我们怎么给他们究竟的安慰呢。</p><p>于是我转而求助于文学，搜索能够把生死解释得清清楚楚的文字，只要和死亡有关的，我都如饥似渴的阅读。从《癌病房》、《向阳而生》、《当呼吸化为空气》到佛教的《西藏生死书》，试图从这些文字中总结死亡的意义，或者让我知道我能做些什么，而不是…</p><p>或许我还太年轻，我最终没有得到想要的答案，我努力让自己坚强，但还是免不了心如刀割，想着他有多么痛苦，一想到在不久的将来，她会疼得直不起腰，我就忍不住心痛。</p><p>他病得这么严重，我们担心在医院往返他会太痛苦，还可能在回家路上就会去世。我们选择留在家里，我们一起消化着最近这些令人痛苦的消息，分担忧伤，珍惜时光。这便是对家人最好的诠释了吧。</p><p>想起人间世2里得骨肿瘤的一个小朋友，说痛的时候就咬牙坚持，嘴里含块糖会感觉好些的，还给病友送去了她的好运糖。好坚强的小朋友。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ControllerAdvice拦截Filter抛出的异常</title>
      <link href="/2020/12/10/java/ControllerAdvice%E6%8B%A6%E6%88%AAFilter%E6%8A%9B%E5%87%BA%E7%9A%84%E5%BC%82%E5%B8%B8/"/>
      <url>/2020/12/10/java/ControllerAdvice%E6%8B%A6%E6%88%AAFilter%E6%8A%9B%E5%87%BA%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h3 id="场景还原"><a href="#场景还原" class="headerlink" title="场景还原"></a>场景还原</h3><p>@ControllerAdvice在spring中用于全局的异常拦截和处理。Filter则过滤请求，多用于请求鉴权。它们之间的关系如下：<br><img src="/images/java/exception_handle_filter_1.png" alt="filter,controller关系"></p><p>因为spring设计原因，Filter和Interceptor中抛出的异常，@ControllerAdvice则捕获不到，自然也就处理不了。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>手动注入HandlerExceptionResolver对象，调用resolveException()，自己处理异常。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Autowired</span></span><br><span class="line"><span class="variable">@Qualifier</span>(<span class="string">"handlerExceptionResolver"</span>)</span><br><span class="line">private HandlerExceptionResolver resolver;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Override</span></span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">    <span class="selector-tag">try</span> &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">    &#125; catch (UnauthorizedException e) &#123;</span><br><span class="line">        <span class="selector-tag">logger</span><span class="selector-class">.info</span>(e.getMessage());</span><br><span class="line">        <span class="selector-tag">resolver</span><span class="selector-class">.resolveException</span>((HttpServletRequest) request, (HttpServletResponse) response, null, e);</span><br><span class="line">    &#125; <span class="selector-tag">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="selector-tag">logger</span><span class="selector-class">.error</span>(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HandlerExceptionResolver.resolveException()调用逻辑如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">HandlerExceptionResolverComposite</span>.</span></span>resolve<span class="constructor">Exception()</span></span><br><span class="line">    for循环</span><br><span class="line">        -&gt; <span class="module-access"><span class="module"><span class="identifier">ExceptionHandlerExceptionResolver</span>.</span></span><span class="keyword">do</span><span class="constructor">ResolveHandlerMethodException()</span>; <span class="comment">// 执行异常处理方法</span></span><br><span class="line">           -&gt; <span class="module-access"><span class="module"><span class="identifier">ExceptionHandlerExceptionResolver</span>.</span></span>get<span class="constructor">ExceptionHandlerMethod()</span>; <span class="comment">//遍历所有的@ControllerAdvice对象，然后根据异常找到异常处理的方法</span></span><br><span class="line">           -&gt; 然后调用异常处理的方法</span><br></pre></td></tr></table></figure><h3 id="resolver-resolveException-失效情况"><a href="#resolver-resolveException-失效情况" class="headerlink" title="resolver.resolveException 失效情况"></a>resolver.resolveException 失效情况</h3><p>这种解决方案，在一些情况下，也不能正常工作。</p><p>存储标注@ControllerAdvice对象是在ExceptionHandlerExceptionResolver.exceptionHandlerAdviceCache中的。该变量初始化逻辑如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExceptionHandlerExceptionResolver.afterPropertiesSet()</span><br><span class="line"><span class="function">    -&gt;</span> initExceptionHandlerAdviceCache()</span><br><span class="line"><span class="function">        -&gt;</span> 从applicationContext中获取标注@ControllerAdvice的对象</span><br><span class="line"><span class="function">        -&gt;</span> put进exceptionHandlerAdviceCache</span><br></pre></td></tr></table></figure><p>也就是说，spring在创建ExceptionHandlerExceptionResolver对象时，会调用afterPropertiesSet()对exceptionHandlerAdviceCache初始化。</p><p>而上述解决方案失效的情况，则是因为exceptionHandlerAdviceCache为空，也就是说没有把标注了@ControllerAdvice的对象放入该字段中。自然也就找不到异常处理的方法。</p><h3 id="寻找原因"><a href="#寻找原因" class="headerlink" title="寻找原因"></a>寻找原因</h3><p>在向exceptionHandlerAdviceCache中put元素后，打印了一条日志Detected @ExceptionHandler methods in xxxxx。但是在日志中搜索“Detected @ExceptionHandler methods in ”发现并没有发现该日志输出，也就是说spring启动时确实没有初始化exceptionHandlerAdviceCache。</p><p>发现这个现象后，自然想到是不是因为WebMvcConfigurationSupport的原因。在我们项目自定义了MessageConverter，是通过集成WebMvcConfigurationSupport实现的。</p><p>为了排除问题，我们注释了继承的WebMvcConfigurationSupport的对象。日志中打印了“Detected @ExceptionHandler methods in ”。然后resolver.resolveException()正常运行。</p><p>问题肯定跟WebMvcConfigurationSupport有关，在WebMvcConfigurationSupport中搜索ExceptionHandler，找到问题的根源：addDefaultHandlerExceptionResolvers()。该方法逻辑如下：</p><ol><li>new 一个ExceptionHandlerExceptionResolver对象</li><li>手动调用afterPropertiesSet()</li><li>将对象保存，用于后续异常处理使用</li></ol><p>该对象是有WebMvcConfigurationSupport手动new出来的，不由spring管理，所以需要手动调用afterPropertiesSet()。而在afterPropertiesSet()中初始化exceptionHandlerAdviceCache的时候，会先从applicationContext中获取标注@ControllerAdvice的对象。但是该对象不由spring管理，applicationContext自然也为null，更加获取不到标注@ControllerAdvice的对象。所以最后exceptionHandlerAdviceCache为空。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用@EnableWebMvc注解。提供三种使用方式：</p><ol><li>直接加该注解，相当于WebMvcConfigurationSupport的配置</li><li>如果要自定义配置，使用@EnableWebMvc + WebMvcConfigurer 实现</li><li>删除@EnableWebMvc注解，使用WebMvcConfigurationSupport or DelegatingWebMvcConfiguration。这两个类都会存在上面说的坑。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 踩坑日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Filter </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - Gossip</title>
      <link href="/2020/11/24/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Gossip/"/>
      <url>/2020/11/24/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Gossip/</url>
      
        <content type="html"><![CDATA[<p>前面我们讲过CAP定理、Paxos、Raft，那么试想几个场景：</p><ul><li>我们要实现一个完全的AP系统。即集群中只有一个节点存活，也能向外提供服务。在此基础上，我们如何保证数据最终一致性？</li><li>在一个庞大的集群中，对某个数据修改后，如何同步到其他节点？</li><li>在一个去中心化的集群中，各节点都是对等节点。如何同步数据，使保证各节点数据达到一致？</li></ul><p>答案就是gossip协议，gossip是一种去中心化的分布式协议，用于实现节点之间的信息交换，大名鼎鼎的bitcoin也使用了gossip来传播交易和区块信息。在分布式系统中，也用它来实现最终一致性，比如cassandra、redis。</p><h3 id="六度分隔理论"><a href="#六度分隔理论" class="headerlink" title="六度分隔理论"></a>六度分隔理论</h3><p>循源，需从六度分隔理论开始。六度分隔理论，简单地说：“你和任何一个陌生人之间所间隔的人不会超五个。”也就是说，最多通过六个人你就能够认识任何一个陌生人。（小声嘀咕）你老婆最多拖6个人的关系就能认识到你的任何一个P（朋）友。</p><p>数学解释如下：<br>若每个人平均认识260人，其六度就是260^6=308,915,776,000,000。消除一些节点重复，那也几乎覆盖了整个地球人口若干多多倍。</p><p>基于六度分隔理论，任何信息的传播其实非常迅速，而且网络交互次数不会很多。Facebook研究了已注册的15.9亿使用者资料，发现“网络直径”为是4.57，即每个人与其他人间隔为4.57人。</p><h3 id="gossip原理"><a href="#gossip原理" class="headerlink" title="gossip原理"></a>gossip原理</h3><p>gossip英文原意：流言蜚语。gossip协议就像流言蜚语一样，利用随机的，带有传染性的方式，将数据传遍整个网络。即在一定时间内，完成数据一致性。<br>gossip传播方式分为两种：反熵、谣言传播。有的也认为可分为三种：直接邮寄、反熵、谣言传播。所增加的直接邮寄，是指当数据有修改时，直接把数据发送给其他节点，即写时完成数据一致。而反熵、谣言传播则是通过异步方式修复节点之间数据一致。</p><p>gossip将各节点分为三类感染状态。</p><ul><li>susceptible (S): The node does not know about the update</li><li>infected (I): The node knows the update and is actively spreading it</li><li>removed (R): The node has seen the update, but is not participating in the spread-<br>ing process (in epidemiology, this corresponds to death or immunity)</li></ul><p>gossip原文中，有一些含义相近的词，我们列出来可能更好理解：<br>反熵：Anti Entropy、error correction、SI<br>谣言传播：Rumor-Mongering、update spreading、SIR</p><p>例如下文：<br>In Section 1.2.1 we identified two sub-problems, namely update spreading and error correction.The former is implemented by an SIR gossip protocol, and the latter by an SI protocol.<br>The SIR gossip is called rumor mongering.<br>The SI algorithm for error correction is called anti-entropy. </p><h4 id="Anti-Entropy-反熵"><a href="#Anti-Entropy-反熵" class="headerlink" title="Anti-Entropy(反熵)"></a>Anti-Entropy(反熵)</h4><p>先解释反熵这个词，熵是物理中指体系的混乱程度。反熵在这里的意思，也是指修复集群中混乱程度，即修复数据一致。</p><p>gossip原文中描述：用于纠错的SI算法称为反熵。这里的SI算法，是指节点只有两种状态：susceptible（未被感染）、infected（已感染）。注意每个节点都可以同时扮演这两个角色，当A把数据推给B时，A为infected，B为susceptible。当A向B拉取数据时，A为susceptible，B为infected。</p><p>具体描述反熵的传播过程，则是每个节点周期性地随机选择其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，直到整个网络中节点数据一致。</p><p>实现反熵的方式主要有三种：推、拉、推拉。推则是将自己数据推给对方，更新对方的数据。拉则是拉取对方的数据，更新自己数据。推拉即更新自己和对方的数据。</p><h5 id="伪代码实现"><a href="#伪代码实现" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><p><img src="/images/theory/distributed/gossip_si.png" alt="si gossip"><br>伪代码中围绕两个boolean变量：push、pull，表示同步消息模式。运行过程可分为两个线程理解：</p><ul><li>异步消息同步线程，即消息同步入口，每个∆时间单位执行一次。</li><li>消息处理线程，即接收到消息，进行处理。</li></ul><ol><li>本次数据同步发起者，记为A，A生成随机集合P。</li><li>如果是push模式，并且A处于infected，则A发送数据给集合P。<ul><li>第11行，集合P收到数据，保存数据。同时意味着自己处于infected</li></ul></li><li>如果是pull模式，则A发送<strong>请求更新的指令</strong>给集合P。<ul><li>第15行，集合P收到<strong>请求更新的指令</strong>，如果自己处于infected，则发送第11行所保存的数据给A。</li><li>A接收到数据，即第11行。</li></ul></li></ol><h5 id="生产应用"><a href="#生产应用" class="headerlink" title="生产应用"></a>生产应用</h5><p>算法描述中，虽然描述的是周期性的向其他节点交换数据来消除两者之间的差异。但是反熵在实际生产中的应用和原本的描述会有所出入，主要原因包含两点：</p><ol><li>每次推送和拉取都是全量数据进行比较，性能消耗比较大。</li><li>可能出现极端情况（两个节点互相进行推拉，其他的节点也没有选择它们两进行推拉）导致某些节点数据可能达不到一致。</li><li>随机性的选择节点消除两者的差异，如果要整个集群节点都达到一致，所需时间不确定，也没有明确的标准表明集群中数据达到一致。</li></ol><p>在实际应用场景中，不推荐采用随机的节点进行反熵。而是需要刻意的设计一个闭环，这样能在一个确定的时间范围内完成最终一致性，而不是基于随机的概率。<br><img src="/images/theory/distributed/gossip_1.png" alt="gossip"></p><ol><li>由A发起反熵，A的数据推给B，可以把A中包含的数据B中不包含的数据同步给B</li><li>B的数据推给C，消除C中没有A、B的数据</li><li>C的数据推给A，则可以消除A中没有B、C的数据</li><li>A还需要再推一次给B，这样才能把C中的数据推给B</li></ol><p>至此，完成数据的最终一致性。这里可以做一个优化：如果反熵每次都推送全量数据进行比较，太消耗资源。这里建议记录已完成一致性的数据，后续执行反熵，只推送增量数据。</p><h4 id="Rumor-Mongering-谣言传播"><a href="#Rumor-Mongering-谣言传播" class="headerlink" title="Rumor-Mongering(谣言传播)"></a>Rumor-Mongering(谣言传播)</h4><p>谣言传播，采用一传十，十传百的方式。指各节点周期性的，向随机的一组节点广播更新数据。其他节点收到更新的数据后，继续周期性的，向随机的一组节点广播更新数据，直到所有节点都处理了新数据。为了使谣言传播能够停止（避免广播风暴），gossip增加removed状态，当节点收到的谣言并且该谣言处于removed（之前已经处理过的谣言）时，该节点将不继续传播该谣言。即SIR算法。</p><h5 id="传播示例"><a href="#传播示例" class="headerlink" title="传播示例"></a>传播示例</h5><p>在一个集群中，发生了数据更新，即为infected状态。图片最开始只有一个节点有数据更新，由它周期性的外向外广播谣言，其每次广播数量为2，该参数即为fanout=2。<br><img src="/images/theory/distributed/gossip_2.png" alt="gossip"><br>当其他susceptible，收到数据后，变更自己为infected状态，继续向外广播谣言。直到完成数据最终一致性。<br><img src="/images/theory/distributed/gossip_3.png" alt="gossip"></p><p>谣言传播属于指数级的传播，我们得到：传播所需周期与fanout（记为f）之间的关系式。当节点数量为N时，有：$log_f{N}$。</p><p>当集群中存在10000个节点时，每次传播感染5个。有：$log_5{10000}$ = 5.72。得出最理想的情况，5.72次传播即可感染10000个节点。该公式为最理想情况，实际传播过程中，可能会出现某一个节点被感染多次。</p><h5 id="伪代码实现-1"><a href="#伪代码实现-1" class="headerlink" title="伪代码实现"></a>伪代码实现</h5><p>在gossip论文中，提供的伪代码实现中，主要增加了不继续传播的条件。<br><img src="/images/theory/distributed/gossip_sir.png" alt="sir gossip"></p><ol><li>本次数据同步发起者，记为A，A生成随机集合P。</li><li>如果是push模式，并且A处于infected，则A发送更新数据给集合P。<ul><li>集合P收到更新数据，第16行，判断是否已处理该数据，则返回feedback给A。</li><li>如果处理，则保存该更新数据。同时意味着自己处于infected</li></ul></li><li>如果是pull模式，则发送<strong>请求更新的指令</strong>给集合P。<ul><li>第23行，集合P收到<strong>请求更新的指令</strong>，如果自己处于infected，则发送第19行所保存的更新数据给A。</li><li>A接收到更新数据，即第15行。</li></ul></li><li>A收到feedback消息，通过概率切换到removed</li></ol><h5 id="生产应用-1"><a href="#生产应用-1" class="headerlink" title="生产应用"></a>生产应用</h5><p>谣言传播，可以快速的向网络中广播，非常具有传染性，适合节点数量多、集群庞大的网络中更新数据。由于集群中都是对等节点，它比较适合动态变化的分布式系统。</p><p>但是为了方便谣言传播，发送的数据包不能太大，主要用于新数据增量更新。</p><h3 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h3><p>gossip的优势很明显，具体总结，可有以下几点：</p><ol><li>简单有趣</li><li>可扩展、容错：由于各节点之间对等性，允许节点之间任意的增加和减少。</li><li>天然的去中心化</li><li>传播速度快，适用于非常庞大的集群</li></ol><p>劣势：</p><ol><li>达成最终一致性的时间不确定性</li><li>消息延迟，只能实现最终一致性，传播过程中，数据不一致</li><li>广播rpc消息量大，对网络压力</li><li>拜占庭将军问题，不允许存在恶意节点</li></ol><h3 id="做几个小题目吧"><a href="#做几个小题目吧" class="headerlink" title="做几个小题目吧"></a>做几个小题目吧</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">文章开始的三个小题目，你有答案了吗？</span><br><span class="line">1. 保证各节点对等，可单独提供服务。宕机恢复后的节点使用反熵拉取新数据。</span><br><span class="line">2. 庞大的集群中，由一个leader节点去广播肯定不行，会把leader整挂的。可以采用谣言传播。</span><br><span class="line">3. 两种传播模式配合使用。新节点上线，通过反熵拉取数据更新。数据更新，通过谣言传播广播数据。</span><br><span class="line">--------------------------------------</span><br><span class="line">每次反熵都需要传输所有数据才能对比，有什么方案优化？</span><br><span class="line"></span><br><span class="line">1. 数据记录只做增量，每次对比只传输增量数据进行对比</span><br><span class="line">2. 采用hash，先传输hash是否一致，再决定要不要传输数据对比</span><br><span class="line">----------------------------------------</span><br><span class="line">谣言传播，谣言传播何时停止？</span><br><span class="line"></span><br><span class="line">论文中提供一个概率来停止广播谣言。我们可以通过设置某个节点被通知到某个阈值时停止广播谣言。</span><br><span class="line">这个阈值设置多少，需要根据集群大小具体调研，阈值设置小了，有可能一些节点接收不到谣言，阈值设置大了，会造成网络性能下降。</span><br><span class="line">------------------------------------------</span><br><span class="line">谣言传播，谣言冲突怎么解决？</span><br><span class="line"></span><br><span class="line">具体场景，可以具体表现。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> gossip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - CAP、BASE、NWR</title>
      <link href="/2020/11/07/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20CAP%E3%80%81BASE%E3%80%81NWR/"/>
      <url>/2020/11/07/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20CAP%E3%80%81BASE%E3%80%81NWR/</url>
      
        <content type="html"><![CDATA[<p>这篇文章<strong>着重点不在于科普</strong>，毕竟关于CAP、BASE的理论的文章，网上很多。所以本文科普篇幅尽量小（只包含概念描述）。主要从几个侧面的问题来描述CAP，进而描述ACID、BASE理念。然后加入一点点调料，如何动态的切换一致性强度。</p><p>本文通过以下几个问题，从侧面描述。文中个人观点较多，看官理性对待。</p><ul><li>为什么CAP三者不可兼得？</li><li>为什么总把ACID与CP、BASE与AP放在一起，它们有什么关联？</li><li>eureka属于AP系统吗？它明明没有放弃一致性啊？</li><li>不考虑一致性的系统，有什么存在的意义呢？</li></ul><h3 id="CAP定理科普"><a href="#CAP定理科普" class="headerlink" title="CAP定理科普"></a>CAP定理科普</h3><p>CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。这三个要素最多只能同时实现两点，不可能三者兼顾。</p><ul><li>一致性（C）：这里是指强一致性。在分布式系统中的所有数据备份，在同一时刻是否同样的值。并不是指整个系统能提供最新的一致的数据。</li><li>可用性（A）：这里是指100%可用性。客户端无论访问到哪个没有宕机的节点上，都能在<strong>有限的时间</strong>内<strong>返回结果</strong>，并不是指整个系统处于可用状态。</li><li>分区容错性（P）：网络中允许丢失一个节点发给另一个节点的任意多的消息，即对网络分区的容忍。在发生网络分区时，能继续保持可用性或者一致性。<br>一个系统要求在运行过程中不能发生网络分区，那么这个系统就不具备分区容错性。</li></ul><p>CAP定理中的可用性和一致性与用户感知的可用性和一致性不是一个概念。我们追求的应该是用户感知的可用性，CAP中可用性和一致性给我们只是起到指导性的作用。</p><p>2017 年，Google 公司的第一代 Spanner 系统已经诞生。Brewer 写了一篇文章讲述了 Google 公司的 Spanner 系统，并且近一步阐述了按照 CAP 定理 Spanner 是一个什么样特性的系统。在文中，Brewer 指出 Spanner 系统说是”实际上的 CA”（effectively CA）系统。从架构上来讲，Spanner 是一个 CP 系统，也就是说当出现网络分区时，Spanner 选择的是保证数据的一致性，放弃可用性的。但实际上，Spanner 是具有非常高可用性效果的一个系统，从架构上 Spanner 没有达到 CAP 定理要求的那种完全可用性，但是也达到非常高的可用性，由于采用多副本的设计，个别副本出现网络分区，并不影响用户能感知到的可用性。按 CAP 定理的定义，当这些个别副本出现网络分区时，这些节点是不可用的，也就是系统没有达到完全可用性。但是此时的用户请求是可以被其他副本服务的，此时服务是可用的，也就是说用户仍然感知到 Spanner 是可用的。所以说用户感知的可用性和 CAP 定理中的可用性不是一个概念。我们追求的应该是用户感知的可用性。</p><h3 id="BASE定理科普"><a href="#BASE定理科普" class="headerlink" title="BASE定理科普"></a>BASE定理科普</h3><p>BASE是对一致性和可用性权衡所得的结果。其核心思想是：在某些场景中，无需做到强一致性，以保证系统的可用性，同时每个应用可以采用适当的方式使系统数据达到最终一致性。</p><p>BASE分别是指：Basically Available, Soft State, Eventual Consistency</p><ul><li>基本可用（Basically Available）：分布式系统在出现故障的时候，允许损失部分可用性，但不等于系统不可用。例如：响应时间的损失，功能上降级。</li><li>软状态（Soft State）：允许系统中的数据存在中间状态，并认为该状态不会影响系统整体可用性。即允许节点之间数据同步存在延时</li><li>最终一致性（Eventually Consistent）：本质是指系统需要使数据最终达到一致性，而不需要实时使数据达到一致性</li></ul><h3 id="ACID科普"><a href="#ACID科普" class="headerlink" title="ACID科普"></a>ACID科普</h3><p>对于ACID中一致性描述，可能理解都不一样，需要先统一下概念。</p><p>ACID中的C（一致性）的定义是：如果事务执行前数据库处于一致状态，那么当事务结束的时候，数据库也会处于一致性状态。这个一致性状态包含两层意思：</p><ul><li>第一层意思是指，数据库内部的完整性，包含实体完整性、域完整性、参照完整性、用户自定义完整性。使用外键、检查约束等，来保证事务执行中不会产生违背数据完整性的数据。例如：使用唯一约束的列不会出现两个一样的值。<br>A transaction must preserve database consistency - if a transaction is run atomically in isolation starting from a consistent database, the database must again be consistent at the end of the transaction.</li><li>第二层意思是对开发者的要求，数据库中的每一行和每个值必须与其所描述的现实保持一致。例如：银行转账，不能只一方扣钱或者一方加钱，我们的代码应该是，一方加钱一方扣钱。<br>Ensuring consistency for an individual transaction is the responsibility of the application programmer who codes the transaction.</li></ul><h3 id="为什么CAP三者不可兼得？"><a href="#为什么CAP三者不可兼得？" class="headerlink" title="为什么CAP三者不可兼得？"></a>为什么CAP三者不可兼得？</h3><p>在分布式系统中，各个组建必然部署在不同的节点上，因此必然出现子网络，同时网络本身又是不可靠的，一定存在延迟和数据丢失，即网络分区是必然存在的。所以P（分区容错性）是分布式系统必须要面对和解决的问题（你无法要求在永远不发生网络分区的环境下运行分布式系统）。</p><p>因此CAP三者不可兼得，变成如何在C（一致性）、A（可用性）二者进行抉择，可以举个例子来说明：在分布式环境中，为了确保系统可用性，通常会采用将数据复制到多个备份节点，而复制的过程需要通过网络交互。当发生网络分区时，你将面临两个选择：</p><ol><li>如果坚持保持各节点之间的数据一致性（选择C），你需要等待网络分区恢复后，将数据复制完成，才可以向外部提供服务。期间发生网络分区将不能对外提供服务，因为它保证不了数据一致性。</li><li>如果选择可用性（选择A），发生网络分区的节点，依然需要向外提供服务。但是由于网络分区，它同步不了最新的数据，所以它返回数据，可能不是最新的（与其他节点不一致的）数据。</li></ol><p>这里需要<strong>强调一句</strong>，CAP三者不可兼得，仅仅是指在发生网络分区情况下，我们才需要在A和C之间进行抉择，选择保证数据一致还是服务可用。而集群正常运行时，A和C是都可以保证的。</p><ul><li>CP架构在当发生网络分区时，为了保证返回给客户端数据准确性，为了不破坏一致性，可能会因为无法响应最新数据，而拒绝响应。在网络分区恢复后，完成数据同步，才可处理客户端请求。</li><li>AP架构在发生网络分区时，发生分区的节点不需要等待数据完成同步，便可处理客户端请求，将尽可能的给用户返回相对新的数据。在网络分区恢复后，完成数据同步。</li></ul><h3 id="ACID与CP、BASE与AP，它们的关联关系？"><a href="#ACID与CP、BASE与AP，它们的关联关系？" class="headerlink" title="ACID与CP、BASE与AP，它们的关联关系？"></a>ACID与CP、BASE与AP，它们的关联关系？</h3><p>根据上一小节C、A二者不可兼得的原因，我们可以总结AP和CP架构的特性。可以发现<strong>CP、AP两者其实是对ACID、BASE的延伸</strong>。是在发生网络分区情况下ACID、BASE的表现。</p><ul><li>CP和ACID都是为了保证数据准确性（两者对准确性定义不同，参考前文科普）。但是两者解决的问题不一样：CP描述的是在发生网络分区时，保证数据准确性。ACID解决的是多个事务并发下，保证数据准确性。</li><li>AP和BASE都是对可用性的研究，BASE要求的只是基本可用，而AP对一致性的要求更低，所以能保证的可用性更高。</li></ul><h4 id="ACID与CP区别"><a href="#ACID与CP区别" class="headerlink" title="ACID与CP区别"></a>ACID与CP区别</h4><p>ACID解决的问题是数据库系统中并发执行多个事务时的问题，是数据库领域的传统问题。那么多个事务并发会存在哪些问题？</p><ul><li>脏读： 事务T1读取了T2更改的x，但是T2在实际存储数据时可能出错回滚了，这时T1读取的实际是无效的数据，这种情况下就是脏读</li><li>不可重复读：是说在T1读取x时，由于中间T2更改了x，所以T1前后两次读取的x值不相同，这就是所谓的不可重复读</li><li>幻读：在T1读取符合某个条件的所有记录时，T2增加了一条符合该条件的记录，这就导致T1执行过程中前后读取的记录可能不一致，即T2之后读取时会多出一条记录。</li></ul><p>为了解决这些问题，事务提出四种隔离级别来规避上述问题。而解决的就是ACID中的C（一致性），所以ACID中的C（一致性）可以理解为不出现脏读、幻读、不可重复读的问题。可以把它称为“内部一致性”，解决的是数据库内部的一致性问题。</p><p>CP中的C（一致性），相对好理解，我把它理解为“外部一致性”。就分布式系统而言的，针对客户端的请求，无论访问那个节点，都能获得最新的相同的值。</p><h4 id="BASE与AP区别"><a href="#BASE与AP区别" class="headerlink" title="BASE与AP区别"></a>BASE与AP区别</h4><p>BASE强调的是基本可用，允许损失部分可用性。这里的损失是指：</p><ul><li>响应时间上的损失：在发生故障时，允许在限定时间之外给用户响应。搜索引擎正常工作0.5秒内给用户返回数据。在部分机房故障后，查询时间增加到1-2秒。</li><li>功能上的损失：在请求高峰时，可以选择一部分请求降级。</li></ul><p>AP则强调是高可用，对数据一致性要求更低。eureka作为AP系统的代表，在发生网络分区时，eureka会移除注册列表中长时间没有心跳的服务，但是当丢失过多客户端时，该节点会进入自我保护，将不会移除过期的服务，并同时接收新服务注册，但不会同步到其他节点。在该种模式下，eureka集群剩下最后一个节点，也可以向外提供服务。</p><h3 id="eureka属于AP系统吗？它明明没有放弃一致性啊？"><a href="#eureka属于AP系统吗？它明明没有放弃一致性啊？" class="headerlink" title="eureka属于AP系统吗？它明明没有放弃一致性啊？"></a>eureka属于AP系统吗？它明明没有放弃一致性啊？</h3><p>描述AP和CP时，通常都会以eureka和zookeeper来具体。eureka是AP的代表作，zookeeper则是CP的代表作。二者之所以这样归类，是因为：</p><ul><li>eureka各节点互相独立、平等的，各节点都提供查询和注册服务（读、写请求）。当发生网络分区，eureka各节点依旧可以接收和注册服务。并且当丢失过多客户端时，节点会进入自我保护（接收新服务注册、不删除过期服务）。在该种模式下，eureka集群剩下最后一个节点，也可以向外提供服务。尽管向外提供的数据可能是过期的数据。</li><li>zookeeper采用的过半原则，由leader处理写请求。当发生网络分区时，leader由于丢失过半的follower，从而处理不了客户端的请求，需要重新选举新leader，期间服务将不可用。糟糕的是，如果集群中没有过半的节点存活，将选举不出新leader，服务将一直处于不可用状态。</li></ul><p>回答eureka没有放弃一致性的问题，还得回顾A、C之间的抉择。这二者需要二选一的情况下，一定是发生了网络分区的情况。eureka集群正常运行时，各节点之间可以正常通讯、保持心跳、复制数据，以此保持数据的一致性。但发生网络分区时，eureka确实选择了可用性，而放弃了一致性。</p><h3 id="NWR"><a href="#NWR" class="headerlink" title="NWR"></a>NWR</h3><p>NWR是一种在分布式存储系统中用于控制一致性级别的一种策略。这个三个字母分别代表着：</p><ul><li>N：分布式系统中，一个有多少个副本数据</li><li>W：处理一次写请求，需要更新多少个副本数据</li><li>R：处理一次读请求，需要读取多少个副本数据</li></ul><p>NWR分别设置不同的值时，将会产生不同的一致性效果。</p><ul><li>W+R&gt;N，整个系统对于客户端的请求能保证强一致性。因为写请求和读请求一定存在一个相交的副本，读取的时候返回该副本的数据即可。</li><li>W+R&lt;=N，整个系统对于客户端的请求则不能保证强一致性。</li></ul><p>基于NWR的性质，我们可以动态的调节系统的一致性效果。还可以根据业务场景动态调整响应速度。以5节点集群为例，在保证强一致性的情况下，需要提高读请求的效率，则可以设置R=2、W=4或者R=1、W=5。当需要提高写请求效率时，则可以设置W=2、R=4或者W=1、R=5。</p><p>W、R的大小，直接影响其对应的处理效率。主要注意，读写请求的效率取决于最慢的副本处理速度。</p><h3 id="建议阅读"><a href="#建议阅读" class="headerlink" title="建议阅读"></a>建议阅读</h3><p>CAP争论及历史：<a href="https://blog.csdn.net/chen77716/article/details/30635543" target="_blank" rel="noopener">https://blog.csdn.net/chen77716/article/details/30635543</a></p><p>CAP，ACID，我们能做什么：<a href="http://hcoona.github.io/Tips/CAP-ACID-what-can-we-do/" target="_blank" rel="noopener">http://hcoona.github.io/Tips/CAP-ACID-what-can-we-do/</a></p><p>理解数据库的事务，ACID，CAP和一致性：<a href="https://www.jianshu.com/p/2c30d1fe5c4e" target="_blank" rel="noopener">https://www.jianshu.com/p/2c30d1fe5c4e</a></p><p>nosql不应该放弃一致性：<a href="https://www.infoq.cn/article/rhzs0KI2G*Y2r9PMdeNv" target="_blank" rel="noopener">https://www.infoq.cn/article/rhzs0KI2G*Y2r9PMdeNv</a></p><h3 id="做几个小题目吧"><a href="#做几个小题目吧" class="headerlink" title="做几个小题目吧"></a>做几个小题目吧</h3><pre><code>paxos算法，可以容忍少数集合节点宕机，我们可以认为paxos提供了比较高的可用性服务，同时又实现了一致性。那么是不是和CAP定理违背了呢？没有违背。CAP定理中可用性是100%可用。当发生网络分区，使paxos集群形成一个多数派集群和一个少数派集群时。当客户端访问多数派节点时，虽然能收到正常的反馈，但是少数派集群的节点则不能。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> CAP </tag>
            
            <tag> BASE </tag>
            
            <tag> NWR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - Raft</title>
      <link href="/2020/10/31/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Raft/"/>
      <url>/2020/10/31/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Raft/</url>
      
        <content type="html"><![CDATA[<p>学习raft之前，给大家推荐一个网站，这个网站动画描述raft运行过程。在看文章时对照该网站，可以帮助更好的理解raft。<br><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p><p>相比于paxos，我们更应掌握raft。raft作为现在分布式系统首选的共识算法。zookeeper、cubby、oceanbase等系统都是在raft诞生之前开发的，所以都是使用了paxos或者对其进行改进。而后来的大多系统都选择了raft，比如consul、etcd等。</p><p>raft相比paxos的优点是:容易理解，容易实现。之所以说容易，是因为raft流程清晰、关键处给出了伪代码描述。相反，可真正用于工程实现的multi-paxos，lamport宗师只提出了个大概。</p><h3 id="Raft术语科普以及总结"><a href="#Raft术语科普以及总结" class="headerlink" title="Raft术语科普以及总结"></a>Raft术语科普以及总结</h3><p>基于前两个篇对paxos和zab的介绍，我们对分布式协议有一定的基础，所以本文先给出总结。</p><h4 id="三种成员身份"><a href="#三种成员身份" class="headerlink" title="三种成员身份"></a>三种成员身份</h4><p>raft提供三种成员身份，<strong>领导者（leader）、跟随者（follower）、候选人（candidate）</strong></p><ul><li>跟随者：相当于paxos中的acceptor，接收和处理leader的消息，当leader故障时，主动推荐自己为候选人</li><li>候选人：向其他节点发送请求投票消息（Request Vote），如果获得大多数选票，则晋升为leader</li><li>领导者：处理写请求，管理日志复制、发送心跳消息。</li></ul><h4 id="两种运行阶段"><a href="#两种运行阶段" class="headerlink" title="两种运行阶段"></a>两种运行阶段</h4><p>raft强化了leader的地位，把整个协议可以清楚的分割成两个部分，并利用日志的连续性做了一些简化：</p><ul><li>leader在时，由leader向follower同步日志。</li><li>leader挂掉了，选一个新leader，leader选举算法。</li></ul><h4 id="两类rpc消息"><a href="#两类rpc消息" class="headerlink" title="两类rpc消息"></a>两类rpc消息</h4><ul><li>请求投票消息（request vote），用于选举leader。</li><li>追加条目消息（append entry），用于心跳消息或日志复制消息。该包含当前最大的日志项。</li></ul><h4 id="raft与multi-paxos的区别"><a href="#raft与multi-paxos的区别" class="headerlink" title="raft与multi-paxos的区别"></a>raft与multi-paxos的区别</h4><ul><li>不是所有节点都能当选leader<br>只有日志最完整的才能当选leader，而multi-paxos则不需要保证这一点，也意味multi-paxos需要额外的流程从其它节点获取已经被提交的日志。</li><li>日志是连续的<br>日志的连续性蕴含了这样一条性质：如果两个不同节点上相同序号的日志，那么这和这之前的日志必然也相同的</li><li>简化的二阶段</li></ul><h3 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h3><p>在节点刚启动状态下，都处于follower状态。同时每个节点会为自己设置一个等待leader心跳消息的随机超时时间。当在超时时间之内没有收到来自leader的心跳信息时，则会推荐自己为candidate。随后增加自己的任期编号，并以candidate的身份发起请求投票消息，推荐自己为leader，当获得大多数选票后，晋升leader，发送心跳消息。</p><h4 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h4><p>例如，存在A、B、C三个节点的raft集群刚启动时，都处于follower状态，其中A超时时间为100ms，B超时时间为200ms，C超时时间为300ms。<br><img src="/images/theory/distributed/raft_1.png" alt="节点信息"></p><p>由于集群中不存在leader，A、B、C三个节点都不会收到来自leader心跳信息。其中，A节点的超时时间最小，则最先修改自己状态为candidate，并增加自己的任期编号为1，发起请求投票消息。<br><img src="/images/theory/distributed/raft_2.png" alt="节点信息"></p><p>节点A的选票会投给自己，而节点B、C收到candidate的请求投票消息。根据投票规则：</p><ol><li>任期编号大的节点拒绝投票给任期编号的小的请求投票消息</li><li>最后一条日志编号大的拒绝投票给最后一条日志编号小的节点</li><li>一个任期编号只投出一张选票</li><li>先来先获得投票</li></ol><p>明显，B、C的任期编号小于A的任期，也不存在最大的日志编号，并且任期编号为1的选票还没有投给任何人，则将任期为1的选票投给节点A，并更新自己的任期编号。<br><img src="/images/theory/distributed/raft_3.png" alt="节点信息"><br>节点A获得包括自己在内的3个选票，赢得大多数选票。其中赢得过半选票也是存在随机超时时间的。如果在超时时间内，则晋升为leader，否则发起新的一轮选举。晋升leader后，则向其他节点发送心跳信息，维护自己的leader角色。<br><img src="/images/theory/distributed/raft_4.png" alt="节点信息"></p><h4 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h4><p>整个选举过程相对来说，比较简单。具体细节还得挑几个点，单独来说：</p><ul><li>随机超时时间<br>在basic-paxos中，通常会描述“活性”一词，是指两个提案同时提出，互相争取选票，导致另一个提案在第二阶段获取不到大多数选票。在muilt-paxos中，leader的选举，而会存在瓜分选票的情况。而raft巧妙的通过随机超时时间，避免了两个candidate同时竞选leader。需要注意，随机超时时间包含两个方面：<ul><li>follower等待leader心跳信息超时的时间间隔。</li><li>candidate在一个随机时间间隔内，没有赢得过半票数，那么选举无效了，需要发起新一轮的选举。</li></ul></li><li>一届任期只投出一张选票，先来先获得投票<br>比如：B节点先后收到A、C任期编号为1的请求投票消息，B节点则将选票投给A节点。至于C节点的请求投票消息，B节点在任期编号为1的已经没有选票可投了。</li><li>任期编号大的节点拒绝投票给任期编号的小的请求投票消息<br>实际上，raft协议在leader选举阶段，由于老leader可能也还存活，也会存在不只一个leader的情形，只是不存在任期编号一样的两个leader。因为选举算法要求leader得到同一个任期编号的多数派的同意，同时赞同的成员会承诺不接受任期编号更小的任何消息。这样可以根据任期编号大小来区分谁是合法的leader。</li><li>最后一条日志编号（uncommited）大的拒绝投票给最后一条日志编号（uncommited）小的节点<br>这一条则是为了保证，只有日志完整度高的节点才能当选leader。这样则可以节省在当选leader后，与各节点比对日志的时间。</li></ul><h3 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h3><p>在raft中，数据都是以日志的形式存在的，客户端每一次的写请求，都会封装成一个日志项（log entry）记录在日志中。所以处理客户端的写请求，就是把日志项（log entry）同步给其他节点并应用到各自状态机的过程。日志同步则可以认为就是处理写请求。</p><p>一条日志项（log entry）又包含：用户数据、索引值、任期编号。</p><ul><li>用户数据，指客户端写请求中的数据，一般是对某个值的修改。</li><li>索引值，日志项的id，一个连续的单调递增的数字</li><li>任期编号，指创建该日志项的leader的任期编号</li></ul><p>在上面总结中，有提到简化的二阶段协议，则是指日志同步阶段。其实在raft之前lamport宗师也有提到如何优化multi-paxos，其中就有优化为一阶段提交。而raft则在日志同步中做出了实践。</p><p>具体实现，在raft中，leader接收到写请求，进入第一阶段。leader将写请求封装为log entry追加到自己的日志中，并发送日志复制消息，将需要同步的log entry复制到集群中其他节点上。如果leader收到大多数节点都成功写入该log entry。那么就将该log entry提交到自己的状态机，同时返回成功给客户端。否则返回错误给客户端。</p><p>而follower则是在接收到leader的心跳信息或者新的日志复制消息后，如果follower发现leader已经提交了某条log entry，而自己还没提交，那么follower就将这条log entry提交到自己的状态机中。</p><h4 id="算法模拟"><a href="#算法模拟" class="headerlink" title="算法模拟"></a>算法模拟</h4><p>存在3节点的集群，A为leader，B、C为follower。当客户端向leader发送set 5的请求，leader收到后，会将其封装成log entry追加到自己的日志中。然后通过日志复制消息时将更改发送给follower。<br><img src="/images/theory/distributed/raft_5.png" alt="算法模拟"></p><p>follower收到消息后，将该log entry追加到自己的日志中，并向leader返回成功响应。当leader收到大多数节点的成功响应后，则在自己的状态机中提交该log entry，并向客户端返回成功。<br><img src="/images/theory/distributed/raft_6.png" alt="算法模拟"></p><p>在下一次追加条目消息（心跳消息、日志复制消息）中，会携带leader最新修改的log entry。follower收到后，则会提交之前尚未提交的log entry。<br><img src="/images/theory/distributed/raft_7.png" alt="算法模拟"></p><p>follower完成提交后，即达成本次共识。</p><h3 id="网络分区、宕机恢复"><a href="#网络分区、宕机恢复" class="headerlink" title="网络分区、宕机恢复"></a>网络分区、宕机恢复</h3><p>当集群中出现网络分区，导致产生了两个小集群时，每个集群都存在自己的leader。或者上一任leader宕机恢复后加入集群时，存在两个leader的情况。raft为此也制定了一些特殊的规定：<strong>根据任期编号大小来区分谁是合法的leader</strong>。例如：当一个candidate或者leader发现自己的任期编号比其他节点小，那么它会立即恢复成follower状态。</p><p>存在一个5节点集群，正常运行时，B节点为leader，其余A、C、D、E为follower<br><img src="/images/theory/distributed/raft_8.png" alt="网络分区"></p><p>当出现网络分区，出现两个由B, A和C, D, E组成的小集群。并且B继续保持leader状态，C为新晋升的leader。<br><img src="/images/theory/distributed/raft_9.png" alt="网络分区"></p><p>当此时，有写请求到B时，由于B不能获得多数票的支持，最终该写请求不会被提交，也不会返回给客户端成功的响应，将一直保持未提交的状态存在日志中。<br><img src="/images/theory/distributed/raft_10.png" alt="网络分区"></p><p>而当网络分区恢复后，B, A节点重新加入集群。当它们收到来自C节点的心跳消息时，发现C的任期编号比自己大，则会切换状态，抛弃掉自己有但C节点没有的log entry，并且同步C节点上的log entry。<br><img src="/images/theory/distributed/raft_11.png" alt="网络分区"></p><h3 id="思考几个题目吧"><a href="#思考几个题目吧" class="headerlink" title="思考几个题目吧"></a>思考几个题目吧</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">leader选举中，B节点的任期编号为1，日志编号为2。A节点任期编号为2，日志编号为1。</span><br><span class="line">B节点收到A节点的请求投票消息，B会投票给A节点吗？</span><br><span class="line"></span><br><span class="line">不会，B节点的编号大于A节点，说明B节点的日志完整度更高，更适合当选leader。</span><br><span class="line">--------------------------------</span><br><span class="line">当一个节点出现网络分区，它即获取不到大多数节点的选票，当不了leader，也接收不到其他leader的心跳，那么任期则会一直增加。</span><br><span class="line">那它网络恢复加入集群后，因为它存在很大编号，其他节点会不会认它为leader。</span><br><span class="line"></span><br><span class="line">不会，它加入集群后，会拒绝新leader的消息（因为它的任期大），则会修改状态为candidate，并发起请求投票。</span><br><span class="line">其他节点收到它的投票信息后，会将自己的任期编号改成它的，然后判断其他投票条件（最大日志编号），将会拒绝投票给它。</span><br><span class="line">它加入集群的唯一的影响就是一下子增加了任期编号的大小。</span><br><span class="line">--------------------------------</span><br><span class="line">假如客户端发送请求set 1，当leader在第一阶段时将该日志项只复制到了一个节点，没有获得大多数选票，则返回给客户端失败。这时leader宕机。新晋升的leader，将怎么处理set 1的日志项？</span><br><span class="line"></span><br><span class="line">raft一切以领导者为准的原则，是否丢弃掉set 1 的日志项，取决于新晋升的leader是否包含该日志项。</span><br><span class="line">1. 如果新晋升的leader包含set 1，则继续提交该日志项</span><br><span class="line">2. 如果新晋升的leader不包含set 1，当初被复制成功的那个节点，将会以领导者的为准，丢弃掉set 1。</span><br><span class="line"></span><br><span class="line">注释：至于新晋升的leader为什么不确认set 1是否被大多数复制成功再决定是否丢弃。</span><br><span class="line">我查过一些资料，这种情况确实会以leader的日志项为准，leader的日志项不会被删除。</span><br><span class="line">--------------------------------</span><br><span class="line">假如客户端发送请求set 1，当leader在第一阶段时将该日志项只复制到了大多数节点，获得了大多数选票，则返回给客户端成功。这时leader宕机。</span><br><span class="line">新选举的leader，将会如何将set 1日志项进行提交呢？</span><br><span class="line"></span><br><span class="line">按照选举规则，不包含set 1日志项的节点是少数集合，包含set 1日志项不会给不包含set 1日志项的节点投票。</span><br><span class="line">最后晋升的一定是包含set 1日志项的节点。一切以领导者为准的原则，则会完成set 1日志项的提交。</span><br><span class="line">--------------------------------</span><br><span class="line">raft一切依赖leader，所以性能瓶颈集中在leader，写性能仅为单机。如何提升？</span><br><span class="line"></span><br><span class="line">可以裂变分区，将原本一个raft集群裂变成多个互不影响的raft集群。</span><br><span class="line">例如：设计一个数据库，可以将元数据同步和用户数据同步使用两个raft集群。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> Raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解jvm03 - 垃圾收集器与内存分配策略</title>
      <link href="/2020/09/22/java/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm03%20-%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
      <url>/2020/09/22/java/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm03%20-%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>本系列博客为《深入理解Java虚拟机 - JVM高级特性与最佳实践》读书笔记。本书大量干货，适合初学jvm的人员，也适合为应付面试人员，比较推荐的一本书。本系列只为记录书中精髓，方便查阅与记忆。如有错误，欢迎指出 O(∩_∩)O </p><p>基于书中第二章总结，程序计数器、java虚拟机栈、本地方法栈随线程的生命周期创建和销毁，自然不用过多的考虑进行垃圾回收。而java堆、方法区则不一样，这一块的分配和回收是动态的，那本章的内容也是基于这两块的内容。</p><h3 id="对象已死吗？"><a href="#对象已死吗？" class="headerlink" title="对象已死吗？"></a>对象已死吗？</h3><p>垃圾回收第一步就是要确定那些对象可回收（已死），那些不可回收（活着）。书中介绍两种算法来确定对象是否存活</p><ul><li>引用计数法</li><li>可达性分析法</li></ul><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>引用计数法，是给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的，则判断为可回收。但是主流jvm都没有使用它，根本原因是它解决不了对象循环引用的问题。</p><h4 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h4><p>可达性分析法，是主流语言（java、c#）的主流实现方案。它是通过定义一系列的“GC Root”对象作为起始点，从这些节点往下搜索，搜索所经过的路劲称为引用链。当一个对象没有任何引用链可到达“GC Root”时，则证明该对象不可用，判断为可回收对象。</p><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ul><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>这一小节，主要再次细分了引用的类型。java将引用的概念扩充成了：强引用（StrongReference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（PhantomReference）4种，这4种引用强度依次逐渐减弱。</p><p>4种引用概念，可以去书中寻找。他们的区别是：<br>强引用，垃圾收集器永远都不会回收。软引用，在抛出内存溢出之前将这类引用进行回收，在判断是否抛内存溢出异常。弱引用，垃圾收集器会正常就会回收这类引用的对象。虚引用，唯一的目的就是在该对象回收时可以收到一个系统通知。</p><h4 id="对象自我拯救（finalize-）"><a href="#对象自我拯救（finalize-）" class="headerlink" title="对象自我拯救（finalize()）"></a>对象自我拯救（finalize()）</h4><p>在可达性分析法中，宣告一个对象真正死亡，至少要经历两次标记：</p><ol><li>该对象没有与GC Root相连接的引用链，进行第一次标记，并放入F-Queue队列中执行finalize()。</li><li>稍后，GC会对F-Queue队列中的对象进行小范围的标记，这次标记是将在finalize()方法中逃脱对象，移出“即将回收”的集合，剩下的对象就会真正被回收。</li></ol><p>注意：<strong>finalize()是一个对象逃脱被回收的最后一次机会</strong>，如果对象不想被回收，可以重写finalize()之后，将自己（this）赋值给某个变量。<strong>finalize()在一个对象生命中，只会执行一次</strong>。<strong>F-Queue队列只会执行重写过的finalize()方法。</strong></p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>方法区（或者HotSpot虚拟机中的永久代）垃圾收集主要回收两部分内容：废弃常量和无用的类。<br>废弃常量：字符串“abc”已经进入了常量池中，但是此时没有任何一个String引用“abc”。如果有必要的话，则会被系统清理出常量池。<br>无用的类：该类所有的实例都已经被回收、加载该类的ClassLoader已经被回收、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。满足上述3个条件，则可以对无用类进行回收，而不是必然会回收。</p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>标记-清除算法，分两个阶段来完成，一是先标记出需要清理的对象，二是将标记的对象统一回收清除。第一个阶段在上一小节已经描述过了。</p><p>标记-清除算法，虽然简单，但是存在两个不足：</p><ul><li>效率问题，标记和清除两个过程的效率都不高</li><li>空间问题，标记清除会产生大量不连续的内存碎片，当遇到需要分配大对象时，会因为无法找到连续的内存而不得不再一次进行垃圾收集。</li></ul><p><img src="/images/java/jvm/understanding_jvm_03_2.png" alt="标记-清除算法"></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>现有的商业虚拟机都采用该种算法来回收新生代。它是将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>这样使得每次都是对整个半区进行回收，内存分配时也不用考虑内存碎片的问题，只需顺序分配即可。这种算法有点就是简单、高效，但是它的代价是内存缩小了一半。</p><p>由于新生代98%的对象都是“朝不保夕”，所以不需要按照1:1的比例来划分，而是划分为一块较大的Eden空间和两块较小的Survivor空间。每次使用Eden和其中一块Survivor空间，回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor上，最后清理掉Eden和刚才使用的Survivor，完成回收动作。</p><p>HotSpot虚拟机默认Eden和Survivor比例是8:1，也就是说新生代中能使用的内存为整个空间的90%（80%+10%），只有10%会用于复制算法所需的开销。但是我们没法保证，每次回收都只有不超过10%的对象存活，这时就需要老年代进行分配担保，让这些对象直接进入老年代。</p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>复制算法，在存活对象比例较高时，就需要进行较多的复制操作，效率会很低。更关键的时，如果不想浪费50%的空间，需要额外的空间进行分配担保，以应对回收时，100%的对象都存活的极端情况，所以在老年代不会直接使用复制算法。<br>根据老年代特点，提出标记-整理算法，与标记-清除算法不同的是，第二阶段清除动作，是将所有存活的对象移向一端，然后直接清理掉端边界以外的内存。<br><img src="/images/java/jvm/understanding_jvm_03_3.png" alt="标记-清除算法"></p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>分代收集算法，则是为了将内存划分为几块区域，java划分为新生代、老年代。这样可以根据不同的区域选择不同的收集算法，以提高回收效率。新生代对象存活率低，则使用复制算法效率更高，而老年代对象存活率高，又没有额外的空间给它担保，所以就必须使用“标记-整理算法”或者“标记-清除算法”。</p><h3 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现"></a>HotSpot算法实现</h3><h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><p>在GC分析过程中，如果对象引用一直在变化，则最后分析的结果是不准确的，所以GC进行时需要停止所有java执行线程（Sun 将这件事情叫做“Stop The World”）。号称不会发生停顿的CMS收集器中，枚举根节点也必须要停顿的。而现在很多应用仅仅方法区就有数百兆，所有逐一检查这里面的引用，不太现实。</p><p>在HotSpot中，使用一组称为OopMap的数据结构来存放对象引用在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。</p><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><p>在OopMap的协助下，HotSpot可以快速枚举根节点，但是OopMap引用的关系变化，不能每次变化都去维护OopMap，这样代价太大，什么时候去维护呢？这就是安全点（Safepoint）的作用，HotSpot只会在这些地方记录OopMap信息，而程序也只能在这些地方才能停顿下来开始GC。</p><p>但是Safepoint也不能过多，因为会增加运行的代价，也不能过少，让GC等待时间太长。一般例如：方法调用、循环跳转、异常跳转等，会产生Safepoint。</p><p>当发生GC时，如何让所有线程都跑到就近的安全点上停顿下来，书中讲述两个方案：</p><ul><li>抢先式中断，首先让所有线程都中断，如果有线程没有停顿在安全点上，就恢复线程，让他跑到安全点上。几乎没有虚拟机采用该方式</li><li>主动式中断，在所有安全点（再增加创建对象分配内存的地方）增加设置标记，当线程执行时，遇到这些标记，就会判断该标记是否需要在当前位置中断自己</li></ul><h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>安全点解决了运行中的线程，但是当线程处于sleep或者blocked状态时，则不能响应jvm的中断请求，这时需要引申安全区域（safe region），安全区域指一段代码片段中，引用关系不会发生变化，可以把safe region透明的看作是safepoint。</p><p>当GC发生时，jvm不用处理进入safe region的线程。只有当线程离开safe region时，需要检查GC是否完成根节点枚举，如果已经完成则继续执行线程即可，否则需要等待直到收到可以安全离开safe region的信号为止。</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="/images/java/jvm/understanding_jvm_03_4.png" alt="垃圾收集器"><br>书中对图中的收集器都做了详细讲解，其中两个收集器之间的连线代表着它们之间可以配合使用。对书中内容先做一个简单总结。</p><ul><li>Serial收集器，单线程完成垃圾收集工作，收集中需要暂停所有工作线程直到它收集完毕。简单高效，多用于Client模式下新生代收集。<br><img src="/images/java/jvm/understanding_jvm_03_5.png" alt="Serial/Serial Old收集器"></li><li>ParNew收集器，为Serial收集器的多线程版本，其余行为包括控制参数与Serial收集器一致，多用于Server模式下新生代收集。<br><img src="/images/java/jvm/understanding_jvm_03_6.png" alt="ParNew/Serial Old收集器收集器"></li><li>Parallel Scavenge收集器，新生代收集器，复制算法，与上述两个不同的是，它还被称为吞吐量优先收集器，可以设置GC最大停顿时间、以及吞吐量大小参数。</li><li>Serial Old收集器，老年代收集器，“标记-整理”算法，单线程，用于Client模式下的虚拟机，或者用于Server模式下搭配Parallel Scavenge收集器使用。<br><img src="/images/java/jvm/understanding_jvm_03_7.png" alt="Serial/Serial Old收集器"></li><li>ParNew Old收集器，老年代收集器，“标记-整理”算法，吞吐量优先收集器。在它出现之前Parallel Scavenge只能和Serial Old搭配使用，并不能使用整体应用获取吞吐量最大化，所以有了它。注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old。<br><img src="/images/java/jvm/understanding_jvm_03_8.png" alt="Serial/Serial Old收集器"></li><li>CMS收集器</li><li>G1收集器</li></ul><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（Concurrent Mark Sweep），以获取最短回收时间为目标的收集器，用于互联网网站的服务端，采用“标记-清除”算法。其收集过程分为4个步骤</p><ul><li>初始标记，仅仅只是枚举GC Root</li><li>并发标记，与用户线程同时执行，标记回收对象</li><li>重新标记，修改并发标记期间因用户线程继续执行而导致标记产生变动的那一部分对象</li><li>并发清除，与用户线程同时执行，回收对象</li></ul><p>初始标记、重新标记，依然需要“Stop the world”，但是耗时相比并发标记、并发清除极短。<br><img src="/images/java/jvm/understanding_jvm_03_9.png" alt="Concurrent Mark Sweep收集器"><br>CMS缺点也很明显：</p><ol><li>对CPU资源敏感，需要独占一个CPU来执行收集线程。</li><li>无法处理浮动垃圾（即并发标记过程中，用户线程产生的垃圾需要等待到下次收集时处理），所有需要给老年代多预留一部分内存来提前进行GC。jdk1.5 CMS在老年代使用68%时则会启动收集工作，jdk1.6 CMS启动阈值为92%，当收集过程中预留内存不够用，虚拟机将启动后备预案：临时启动Serial Old来重新进行老年代的收集。</li><li>CMS采用 “标记-清除”算法，则会产生大量碎片，对大对象分配带来麻烦。CMS收集器提供了一个-XX+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入FullGC时都进行碎片整理）。</li></ol><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一。优点：并行处理，分代收集，“标记整理”算法，可预测的停顿。G1 其思想是将java堆分为多个Region，回收以Region为单位。使用Remenbered Set来保存各个Region之间的对象引用。当程序对Reference类型的数据进行写操作时，会检查Reference引用的对象是否处于不同的Region之中，如果是，便更新Region所属的Remembered Set。</p><p>如果不计算维护Remembered Set，G1收集过程可分为四个阶段</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p><img src="/images/java/jvm/understanding_jvm_03_10.png" alt="G1收集器"></p><h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33.125</span>：[GC[DefNew：<span class="number">3324</span>K-＞<span class="number">152</span>K（<span class="number">3712</span>K），<span class="number">0.0025925</span> secs]<span class="number">3324</span>K-＞<span class="number">152</span>K（<span class="number">11904</span>K），<span class="number">0.0031680</span> secs]</span><br><span class="line"><span class="number">100.667</span>：[Full GC[Tenured：<span class="number">0</span>K-＞<span class="number">210</span>K（<span class="number">10240</span>K），<span class="number">0.0149142</span>secs]<span class="number">4603</span>K-＞<span class="number">210</span>K（<span class="number">19456</span>K），[Perm：<span class="number">2999</span>K-＞<span class="number">2999</span>K（<span class="number">21248</span>K）]，<span class="number">0.0150007</span> secs][Times：user=<span class="number">0.01</span> sys=<span class="number">0.00</span>，real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></table></figure><p>最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</p><p>GC日志开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，而<strong>不是用来区分新生代GC还是老年代GC</strong>的。如果有“Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现“[Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc（）方法所触发的收集，那么在这里将显示“[Full GC（System）”。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC <span class="number">283.736</span>：[ParNew：<span class="number">261599</span>K-＞<span class="number">261599</span>K（<span class="number">261952</span>K），<span class="number">0.0000288</span> secs]</span><br></pre></td></tr></table></figure><p>接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的</p><ul><li>Serial收集器中的新生代名为“DefaultNew Generation”，所以显示的是“[DefNew”。</li><li>ParNew收集器，新生代名称就会变为“[ParNew”，意为“Parallel New Generation”。</li><li>Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”。</li></ul><p>后面方括号内部的“3324K-＞152K（3712K）”含义是“GC前该内存区域已使用容量-＞GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“3324K-＞152K（11904K）”表示“GC前Java堆已使用容量-＞GC后Java堆已使用容量（Java堆总容量）”。</p><p>再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“[Times：user=0.01 sys=0.00，real=0.02 secs]”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以读者看到user或sys时间超过real时间是完全正常的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配 [1] ），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，<strong>分配的规则并不是百分之百固定的</strong>，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p><p>书中对以下几种情况都给出案例，可以去查看</p><ul><li>对象优先分配在Eden</li><li>大对象直接进入老年代</li><li>长期存活对象进入老年代</li><li>动态年龄判断</li><li>空间分配担保</li></ul>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解jvm02 - java内存区域与内存泄露异常</title>
      <link href="/2020/09/05/java/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm02%20-%20java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%BC%82%E5%B8%B8/"/>
      <url>/2020/09/05/java/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm02%20-%20java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>本系列博客为《深入理解Java虚拟机 - JVM高级特性与最佳实践》读书笔记。本书大量干货，适合初学jvm的人员，也适合为应付面试人员，比较推荐的一本书。本系列只为记录书中精髓，方便查阅与记忆。如有错误，欢迎指出 O(∩_∩)O </p><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>在启动java程序时，我们会给jvm分配指定的内存大小。而jvm则对该部分内存划分为若干区域。其中有的区域以来用户线程的启动和结束而建立和销毁，有的区域随jvm进程的启动而存在。<br><img src="/images/java/jvm/understanding_jvm_02_1.png" alt="运行时数据区域"></p><p>线程私有：</p><ul><li>程序计数器</li><li>java虚拟机栈</li><li>本地方法栈</li></ul><p>线程共享：</p><ul><li>java堆</li><li>方法区</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器（Program Counter Register）是一块较小的内存空间，可以看作当前线程所执行的<strong>字节码的行号指示器</strong>。jvm规范中<strong>唯一一个没有OutOfMemoryError异常的区域</strong>。该区域属于<strong>线程私有</strong>，随线程的启动和结束而建立和销毁。</p><p>字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都一来该计数器来完成。</p><h4 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h4><p>java虚拟机栈（Java Virtual Machine Stacks）描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。该区域属于<strong>线程私有</strong>。</p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>这个区域会抛出两个异常</p><ul><li>线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</li><li>如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><p>Native方法常用于：</p><ul><li>调用一些不是java语言写的代码</li><li>在java语言中直接操作计算机硬件</li></ul><p>异常：StackOverflowError、OutOfMemoryError</p><h4 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h4><p>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有<strong>线程共享</strong>的一块内存区域，在虚拟机启动时创建。注意：线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。</p><p>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。所以它是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”。</p><p>Java堆还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</p><p>如果java堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区（Method Area）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。。所以它也是<strong>线程共享</strong>的内存区域。</p><p>方法区还有另一个名字“<strong>永久代</strong>”（Permanent Generation）。这个名字是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，使用“永久代”这个概念来描述方法区的内存回收。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。J9和JRockit只要没有触碰到进程可用内存的上限，就不会出现像HotSpot一样因为方法区发小不够而抛出OutOfMemoryError的异常。</p><p>垃圾收集行为在该区域比较少出现，这也印证了永久代这个名字，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对<strong>常量池的回收和对类型的卸载</strong>。</p><p>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError。<br>NIO通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能避免了在Java堆和Native堆中来回复制数据，以提高显著的性能。</p><p>直接内存的分配不会受到Java堆大小的限制，只会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。<strong>如果使用了直接内存，应注意它将会占用了本机总内存，会导致jvm操作的内存扩容时申请不到-Xmx大小的内存，而抛出OutOfMemoryError异常。</strong></p><h3 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><h5 id="类检查"><a href="#类检查" class="headerlink" title="类检查"></a>类检查</h5><p>对象的创建（包含克隆、反序列化）通常new关键字。虚拟机遇到一条new指令时，先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查该符号引用代表的类是否被加载、解析、初始化。</p><h5 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h5><p>在类检查通过后，接下来虚拟机将为新生对象分配内存，分配内存存在两种方式：</p><ul><li>“指针碰撞”（Bump the Pointer）<br>要求堆内存绝对规整，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</li><li>“空闲列表”（Free List）<br>已使用的内存和空闲的内存相互交错，就只能使用空闲列表。它需要维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</li></ul><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。例如：Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p><p>划分可用空间之外，jvm还需要保证内存分配的并发问题，例如：给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p><ul><li>CAS配上失败重试</li><li>本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）<br>每个线程在Java堆中预先分配一小块内存，哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定内存。</li></ul><p>jvm实际上采用CAS配上失败重试的方式进行实现，如需使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>初始化，也分为两步，首先初始化内存为零值（不包括对象头），以保证该字段在Java代码中可以不赋初始值就直接使用（重排序）。<br>第二步，则是对对象进行必要的设置，其中包含这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</p><p>上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。书中有给出HotSpot虚拟机bytecodeInterpreter.cpp中的代码片段，以印证上述内容。</p><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p>对象头存放两部分数据，一部分被称为Mark Word，另一部分则是类型指针。</p><ul><li>Mark Word<br>数据长度为32bit或者64bit别分对应32位和64位的虚拟机。其中保存了哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</li><li>类型指针<br>即对象指向它的类元数据的指针，通过这个指针来确定这个对象是哪个类的实例</li></ul><p>实例数据是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容（包含继承父类）。</p><p>齐填充不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。HotSpot的自动内存管理系统要求对象起始地址必须是8字节的整数倍，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>对象访问是通过栈上的reference数据来操作堆上的具体对象的。目前主流的访问方式有使用句柄和直接指针两种。</p><ul><li>句柄访问，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。优势：reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。</li><li>直接指针访问，reference中存储的直接就是对象地址。优势：节省了一次指针定位的时间开销，速度更快。</li></ul><p>HotSpot而言，它是使用直接指针访问方式进行对象访问的。</p><h3 id="OutOfMemoryError异常"><a href="#OutOfMemoryError异常" class="headerlink" title="OutOfMemoryError异常"></a>OutOfMemoryError异常</h3><h4 id="java堆溢出"><a href="#java堆溢出" class="headerlink" title="java堆溢出"></a>java堆溢出</h4><p>Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError：Java heap <span class="literal">space</span></span><br><span class="line">Dumping heap <span class="built_in">to</span> java_pid3404.hprof……</span><br><span class="line">Heap dump <span class="built_in">file</span> created[<span class="number">22045981</span> <span class="keyword">bytes</span> <span class="keyword">in</span> <span class="number">0.663</span> <span class="built_in">secs</span>]</span><br></pre></td></tr></table></figure><p>异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”，则是指java堆异常。</p><p>解决这个区域的异常，先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。内存溢出增加机器配置即可，内存泄露则需要一步步分析定位问题。区分两者的重点是确认内存中的对象是否是必要的。一般的手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析。查看泄露的对象到GC Root的引用链，一般就能比较准确的定位泄露代码的位置。</p><h4 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h4><p>该区域，java规范了两个StackOverflowError、OutOfMemoryError。书中实验只验证了StackOverflowError。通过两种方式：</p><ul><li>使用-Xss参数减少栈内存容量，栈深度相应减少。抛出StackOverflowError异常。</li><li>定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出StackOverflowError。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Exception</span> <span class="selector-tag">in</span> <span class="selector-tag">thread</span>"<span class="selector-tag">main</span>"<span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.StackOverflowError</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.fenixsoft</span><span class="selector-class">.oom</span><span class="selector-class">.VMStackSOF</span><span class="selector-class">.leak</span>（<span class="selector-tag">VMStackSOF</span><span class="selector-class">.java</span>：20）</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.fenixsoft</span><span class="selector-class">.oom</span><span class="selector-class">.VMStackSOF</span><span class="selector-class">.leak</span>（<span class="selector-tag">VMStackSOF</span><span class="selector-class">.java</span>：21）</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.fenixsoft</span><span class="selector-class">.oom</span><span class="selector-class">.VMStackSOF</span><span class="selector-class">.leak</span>（<span class="selector-tag">VMStackSOF</span><span class="selector-class">.java</span>：21）</span><br><span class="line">……后续异常堆栈信息省略</span><br></pre></td></tr></table></figure><p>解决这个区域的异常，StackOverflowError相对还是简单的，因为日志中会打印异常栈。对于OutOfMemoryError，书中指出如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。</p><h4 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h4><p>方法区，存放Class相关信息和运行时常量池，书中从这两个方面分别给出测试案列，使之抛出OutOfMemoryError。</p><ul><li>使用String.intern()，向运行时常量池中存放字符串（仅限jdk1.6，jdk1.7相同字符串只会缓存第一次出现的对象）</li><li>使用CGLib创建大量的动态类</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Exception</span> <span class="selector-tag">in</span> <span class="selector-tag">thread</span>"<span class="selector-tag">main</span>"<span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>：<span class="selector-tag">PermGen</span> <span class="selector-tag">space</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.String</span><span class="selector-class">.intern</span>（<span class="selector-tag">Native</span> <span class="selector-tag">Method</span>）</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.fenixsoft</span><span class="selector-class">.oom</span><span class="selector-class">.RuntimeConstantPoolOOM</span><span class="selector-class">.main</span>（<span class="selector-tag">RuntimeConstantPoolOOM</span><span class="selector-class">.java</span>：18）</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">Caused</span> <span class="selector-tag">by</span>：<span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>：<span class="selector-tag">PermGen</span> <span class="selector-tag">space</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.ClassLoader</span><span class="selector-class">.defineClass1</span>（<span class="selector-tag">Native</span> <span class="selector-tag">Method</span>）</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.ClassLoader</span><span class="selector-class">.defineClassCond</span>（<span class="selector-tag">ClassLoader</span><span class="selector-class">.java</span>：632）</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.ClassLoader</span><span class="selector-class">.defineClass</span>（<span class="selector-tag">ClassLoader</span><span class="selector-class">.java</span>：616）</span><br><span class="line">……8 <span class="selector-tag">more</span></span><br></pre></td></tr></table></figure><p>运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是“PermGen space”，说明运行时常量池属于方法区（HotSpot虚拟机中的永久代）的一部分。</p><p>方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p><h4 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h4><p>使用Unsafe实例的allocateMemory()方法进行内存分配，直到抛出异常</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Exception</span> <span class="selector-tag">in</span> <span class="selector-tag">thread</span>"<span class="selector-tag">main</span>"<span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span></span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.allocateMemory</span>（<span class="selector-tag">Native</span> <span class="selector-tag">Method</span>）</span><br><span class="line"><span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.fenixsoft</span><span class="selector-class">.oom</span><span class="selector-class">.DMOOM</span><span class="selector-class">.main</span>（<span class="selector-tag">DMOOM</span><span class="selector-class">.java</span>：20）</span><br></pre></td></tr></table></figure><p>由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。</p><h3 id="jvm参数"><a href="#jvm参数" class="headerlink" title="jvm参数"></a>jvm参数</h3><p>-Xmx       最大堆大小<br>-Xms       初始堆大小<br>-XX：PermSize   永久代大小<br>-XX：MaxPermSize   永久代大小<br>-XX：+/-UseTLAB     使用本地线程分配缓冲<br>-Xss          栈大小<br>-XX: MaxDirectMemorySize      直接内存（默认和-Xmx相同）</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 内存泄露 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - ZAB</title>
      <link href="/2020/08/12/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20ZAB/"/>
      <url>/2020/08/12/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20ZAB/</url>
      
        <content type="html"><![CDATA[<h3 id="ZAB-背景"><a href="#ZAB-背景" class="headerlink" title="ZAB 背景"></a>ZAB 背景</h3><p>学习ZAB，非常有必要聊聊它诞生的背景。因为在paxos的光芒下，还有必要折腾这样类似的算法吗？这个问题是我们初步了解ZAB关键。</p><p>看到这里，我断定大家都使用过zookeeper，并且知道zookeeper的核心就是ZAB协议。如果没有的话，需要先学习下zookeeper。毕竟基础不牢，地动山摇。</p><p>这里多提一句，ZAB的作者说ZAB不是paxos，但是后面我们又把ZAB归纳为paxos。这里我认为啊，这两个说法都对，只是他们描述的时间不一致。在ZAB诞生的时候，它解决了paxos不能保证顺序执行的问题，从某些角度来说ZAB是要paxos优秀的，说它不是paxos也没问题。但是后来随来越来越多分布式算法诞生，例如raft，因为他们都类似paxos执行逻辑，所以将这类算法归纳为paxos的变种。</p><h4 id="为何不使用paxos来实现zookeeper"><a href="#为何不使用paxos来实现zookeeper" class="headerlink" title="为何不使用paxos来实现zookeeper"></a>为何不使用paxos来实现zookeeper</h4><p>回过头来，ZAB诞生的原因，我们先考虑zookeeper能不能直接使用paxos作为分布式一致性算法？答案肯定是否定的，我们举个例子，假设有个客户端需要分别创建目录：/foo, /foo/ofcoder。</p><p>在前文我们学习过了paxos，知道paxos能集群就某个值达成共识，但是却不关心达成共识的值是什么。如果zookeeper直接使用paxos，就会出现在没有创建/foo的时候，创建/foo/ofcoder。显然这就报错了，因为ofcoder的上级目录不存在。为了描述这个问题，我们描述下过程。</p><p>假如有同一个业务请求，因为入参不一样，导致最后要达成共识的值也不一样。例如proposerA，收到请求先后创建/foo, /foo/ofcoder两个节点。proposerB收到请求先后创建/method，/method/far节点。<br><img src="/images/theory/distributed/zab_1.png" alt="paxos不适合实现zookeeper"></p><ol><li>proposerB先发起paxos的prepare阶段，并获得大多数选票，开始accept阶段。</li><li>在proposerB的accept阶段，只有acceptA接收了提案[1, /method]，其他节点都通过了proposerA的prepare请求。</li><li>根据规定，proposeA的accept的提案应该为[2, /method]，并通过该提案。</li><li>此时proposerB重新开始paxos的两个阶段，得到达成共识的提案是[2, /method]。</li><li>proposerA开始第二个值的paxos过程，即/foo/ofcoder。</li></ol><p>到此为止，可以看到当proposerA开始创建/foo/ofcoder时，则会发现/foo没有创建而导致失败。因为在第一轮paxos在集群中达成共识的值/method。</p><p>通过上面的过程，我们更加论证了，paxos只适合在集群中使某个值达成共识，而不关心达成共识的值是什么。而在zookeeper中，这显然是不能满足业务需求的。</p><h3 id="ZAB术语科普"><a href="#ZAB术语科普" class="headerlink" title="ZAB术语科普"></a>ZAB术语科普</h3><p>ZAB并不像paxos，是一种通用的分布式一致性算法，ZAB是一种专门为zookeeper设计的崩溃可恢复的原子广播协议。相比于paxos，<strong>ZAB主要解决了事务操作的顺序性</strong>，在ZAB协议中，如果一个事务操作被处理了，那么所有其依赖的事务操作都应该被提前处理了。</p><p>在学习ZAB之前，我们需要先整理几个术语、因为在ZAB的论文中，术语相对比较多，并且概念冗余。例如：</p><ul><li>提案（proposal）：进行协商的基本单元，在一些文档中，也有称之为操作（operation）、指令（command）。</li><li>事务（transaction）：也是指提案，常出现在代码中，并非指具有ACID特性的一组操作。</li><li>已提出的Proposal：指广播的第一阶段所提出的Proposal，未提交到状态机的Proposal。</li><li>已提交的Proposal：指广播的第二阶段已提交到状态机的Proposal。</li></ul><p>为了帮助我们理解，ZAB定义了三个角色、四种节点状态、四种ZAB运行状态、以及两种运行模式。大家别看到我罗列了这么多，就打退堂鼓。从多个角度来归纳，只是为了更好的给大家呈现ZAB内部原理。</p><h4 id="三个角色"><a href="#三个角色" class="headerlink" title="三个角色"></a>三个角色</h4><ul><li><p>领导者（leader）<br>leader是整个ZAB协议的核心，其工作内容在于：接收并处理所有事务请求，也就是写请求。将每个事务请求，封装成提案（proposal）广播给每个跟随者（follower），根据跟随者（follower）返回请求，控制是否需要提交该提案。</p></li><li><p>跟随者（follower）follower的工作，可以分为三部分</p><ul><li>接收leader提出的提案（proposal），参与对提案（proposal）的投票</li><li>接收并处理非事务请求，也就是读请求。如果follower收到客户端的事务请求，则会将其转发给leader进行处理。</li><li>参与leader选举投票</li></ul></li></ul><ul><li>观察者（observer）<br>跟paxos中学习者类似，增加observer，可以在不影响集群写性能的情况下，提升读性能。</li></ul><h4 id="四种节点状态"><a href="#四种节点状态" class="headerlink" title="四种节点状态"></a>四种节点状态</h4><p>这是一个容易忽视的点，ZAB虽然规定了三种角色，但是他是通过定义四种状态来描述当前节点所处的角色的。包含以下状态：</p><ul><li>LOOKING，竞选状态，当前集群不存在Leader。该状态下会发起领导者选举。</li><li>FOLLOWING，随从状态，同步Leader状态，参与投票。</li><li>OBSERVING，观察状态，同步Leader状态，不参与投票。</li><li>LEADING，领导者状态，对应Leader角色。</li></ul><p>这里与角色对应多出来一个状态，是因为ZAB是支持自动Leader选举的，LOOKING是属于选举中的一个过渡状态。</p><h4 id="四种ZAB运行状态"><a href="#四种ZAB运行状态" class="headerlink" title="四种ZAB运行状态"></a>四种ZAB运行状态</h4><p>这里是指ZAB集群的运行状态，因为ZAB除了正常向外部提供服务，还得有故障恢复功能。从整个集群的状态，我们可以了解ZAB的运行过程。</p><ul><li>ELECTION，选举状态，表明节点正在进行Leader选举</li><li>DISCOVERY，成员发现状态，在选举出新Leader后集群所处的状态，用于节点协商沟通Leader的合法性</li><li>SYNCHRONIZATION，数据同步状态，在确认新Leader后，以Leader的数据为基础，修复各个节点的数据一致性</li><li>BROADCARST，广播状态，集群处于正常运行状态，可向外提供服务</li></ul><h4 id="两种运行模式"><a href="#两种运行模式" class="headerlink" title="两种运行模式"></a>两种运行模式</h4><p>从上述ZAB运行状态中，可以归纳为两种运行模式，即消息广播模式、崩溃恢复模式。</p><ul><li>崩溃恢复模式：<br>在整个服务框架启动过程中、或者Leader服务器出现网络中断、崩溃退出等异常情况时，ZAB协议就会进入崩溃恢复模式并选举新的Leader服务器。当新的Leader服务器在集群中有过半的Follower与其完成成数据同步后，ZAB就会退出崩溃恢复模式。</li><li>消息广播模式：<br>当集群中已有过半的Follower与Leader完成数据同步，那么整个集群就会进入消息广播模式。此时整个集群才可以对外提供服务，即数据的查询、修改。</li></ul><p>值得注意是，当一台新的ZAB节点加入集群时，该节点会先进入崩溃恢复模式，找到Leader，并与其进行数据同步，然后一起参与到消息广播流程中。所以崩溃恢复模式还分为两个阶段：发现、同步。具体后文会详细讲解。</p><p>后文讲解思路也是从这两种模式入手，在崩溃恢复模式中，再细分为三个阶段，也就是四种运行状态的前三种（ELECTION、DISCOVERY、SYNCHRONIZATION）。</p><h4 id="zxid"><a href="#zxid" class="headerlink" title="zxid"></a>zxid</h4><p>这里把zxid单独拎出来描述，zxid在ZAB占据很重要的位置。Leader在收到事务请求，将其封装成Proposal时，会为每个Proposal生成对应的zxid。</p><p>在消息广播模式中zxid标志者事务请求的先后顺序，在崩溃恢复模式中zxid是Leader的选举的判断依据，以及在Leader选举后，数据同步中zxid能方便的帮助ZAB抛弃上一个Leader没完成的Proposal。所以在学习下面的内容时，要及时参考zxid的设计逻辑。</p><p>zxid它是一个64位，其中低32位可以看成一个简单的<strong>计数器</strong>，而高32位则代表了Leader周期的<strong>epoch编号</strong>。后文中使用&lt;epoch, counter&gt;标示一个zxid，例如&lt;1, 101&gt;。</p><ul><li>epoch，则标示者当前集群所处的周期（年代），或者说当前Leader的周期（年代）。在每一次Leader变更后，新Leader产生的epoch则会在上一任Leader的epoch上进行加1，作为自己的epoch。</li><li>计数器，则是针对客户端每一个事务请求，Leader在产生新的Proposal事务时，都会对该计数器加1。而Leader变更后，该计数器则会重置为0。</li></ul><p>这样做的好处：</p><ol><li>计数器，可以定义Proposal的先后顺序，保证发送提交事务消息广播顺序。</li><li>epoch+计数器，能有效的避免zxid的冲突，不会出现Leader使用了相同编号的zxid提出了不一样的Proposal。</li><li>能随时获取到最新的Leader周期（epoch），当Leader收到在网络故障后，收到比他大的epoch的Proposal，则证明集群中已有其他Leader，自己则变更为Follower。</li><li>新Leader产生的zxid一定比上一任Leader产生zxid大。当上一任Leader宕机恢复后（以Follower角色）加入集群，如果有尚未提交的事务，则可以对比zxid进行抛弃（回退）那一些Proposal，直到回退到一个确实已经被集群中过半机器Commit的最新Proposal。</li></ol><p>第3, 4点如果现在看不明白，在讲述崩溃恢复模式时，我会回过头来再讲讲的。</p><h3 id="消息广播模式"><a href="#消息广播模式" class="headerlink" title="消息广播模式"></a>消息广播模式</h3><p>总的来说，消息广播模式是一个类似于二阶段提交（2PC）过程，针对客户端事务请求，Leader将其生成对应的Proposal，并发给所有的Follower，收集各自的选票后，最后进行事务提交。<strong>与2PC不同的是，ZAB移除了第二阶段的中断逻辑</strong>。所有的Follower要么接收该Proposal，要么抛弃Leader服务器。这意味着Leader收到过半的Ack响应后就可以提交该事务了，而不需要等待所有的Follower都返回Ack。</p><p>由于ZAB为了严格保证Proposal的因果关系，即事务请求的顺序性，ZAB为每个Proposal生成对应的zxid，并严格按照zxid的顺序，进行消息的广播。具体的，Leader会为了Follower分配一个单独的队列，将消息广播前，先将Proposal按照zxid顺序依次放入这些队列中，并根据FIFO策略进行消息发送。</p><p>Follower在收到事务Proposal之后，都会将其以事务日志的形式写入本地磁盘中，并在写入成功后，返回给Leader一个Ack响应。当Leader服务器收到过半的Follower的Ack响应后，就会广播Commit消息给所有Follower通知其进行事务提交，同时Leader自身也会完成事务的提交。至此整个消息广播模式完成。</p><p><img src="/images/theory/distributed/zab_4.png" alt="消息广播"></p><ol><li>客户端发起事务请求，由Leader进行处理</li><li>Leader将该请求转换为事务Proposal，同时为Proposal分配一个全局的ID，即zxid</li><li>Leader为每个Follower维护一个FIFO队列，将上一步生成的Proposal放入队列中，进行广播</li><li>Follower收到Proposal后，会首先将其以事务日志的方式写入本地磁盘中，写入成功后向Leader反馈一个响应消息</li><li>Leader收到过半的Ack响应后，自己完成对该Proposal的提交后，向每个Follower的队列中，写入Commit消息进行广播</li><li>Follower接收到Commit消息后，会将上一条事务提交</li></ol><h4 id="如何保证事务执行的顺序"><a href="#如何保证事务执行的顺序" class="headerlink" title="如何保证事务执行的顺序"></a>如何保证事务执行的顺序</h4><p>此时，我们得回到zxid的构成那部分，ZAB就是通过zxid中计数器，来保证提交顺序的，具体如下：</p><p>在Leader收到客户端<code>set X、set Y</code>两个请求后，会将其封装成两个Proposal（&lt;1, 101&gt;: X， &lt;1, 102&gt;: Y）进行广播所有的Follower。<br><img src="/images/theory/distributed/zab_5.png" alt="消息广播"></p><p>当Leader收到过半的Ack响应后，则会进行Commit消息的广播。这里需要注意，<strong>Leader提交提案是有顺序性的</strong>，按照zxid的大小，按顺序提交提案，<strong>如果前一个提案未提交，此时是不会提交后一个提案的</strong>。因此X一定在Y之前提交。<br><img src="/images/theory/distributed/zab_6.png" alt="消息广播"></p><p>最后，Leader返回执行成功响应给客户端。完成本次消息广播。</p><h3 id="崩溃恢复模式"><a href="#崩溃恢复模式" class="headerlink" title="崩溃恢复模式"></a>崩溃恢复模式</h3><p>通过上面的了解，我们知道了ZAB其实是一个强领导者模型的协议。消息广播模式，只能在ZAB正常运行中向外部提供服务。这也要求ZAB设计者不得不考虑，当Leader宕机或者失去过半的Follower节点后，如何恢复整个集群。</p><p>为了更好理解崩溃恢复模式原理，通常会把他分为两个阶段或者三个阶段，即（Leader选举、Leader发现）、数据同步。</p><h4 id="基本约定"><a href="#基本约定" class="headerlink" title="基本约定"></a>基本约定</h4><p>在选举新的Leader后，向外部提供服务之前，ZAB还需要保证数据正确性，即上一个Leader崩溃之时，正在处理的事务请求，可能会出现两个数据不一致的隐患。针对这样情况，ZAB保证一下特性：</p><ol><li>ZAB需要确保那些已经在Leader上<strong>提交</strong>的事务最终被所有服务器都提交<br>即：ProposalA在Leader上被提出后，收到过半的Follower的Ack响应，但是在将Commit请求广播给所有Follower机器之前，Leader宕机了。<br><img src="/images/theory/distributed/zab_2.png" alt="ZAB崩溃恢复"><br>在该图中，Leader先后广播了P1, P2, C1, P3, C2。其中Leader在广播C2（P2的Commit请求）之前宕机，ZAB会在崩溃恢复模式中，让所有的服务器都提交C2。</li><li>ZAB需要确保丢弃那些仅仅只在Leader上被<strong>提出</strong>的事务<br>即：该约定是指，ZAB会抛弃那些只在Leader上被提出的事务，还没有任何Follower收到该请求。<br><img src="/images/theory/distributed/zab_3.png" alt="ZAB崩溃恢复"><br>在该场景中，Leader提出P3后宕机，还没有任何Follower收到该请求，则崩溃恢复模式中，整个集群会丢弃P3的事务。</li></ol><h4 id="Leader选举（ELECTION）"><a href="#Leader选举（ELECTION）" class="headerlink" title="Leader选举（ELECTION）"></a>Leader选举（ELECTION）</h4><p>Leader的选举，关乎着整个集群的故障容错和集群可用性，是ZAB非常核心的设计之一。而Leader选举说白了，就是对比集群中各节点的信息，选举出最合适的节点当做Leader。而最合适的节点标准是什么，则是理解Leader选举（FastLeaderElection方式）的关键。</p><p>ZAB采用的各节点广播自己所提议的Leader，收到其他节点提议的Leader后，与自己所提议的Leader进行PK，根据PK的规则重新选择提议的Leader，直到有过半的节点都提议某一节点，即结束Leader选举。</p><p>Leader选举PK的规则包含以下几个方面：</p><ul><li>任期编号（epoch），优先判断epoch，epoch大的节点当选Leader</li><li>事务标示符（zxid），epoch相同，则比较zxid，zxid大的当选Leader</li><li>节点ID，epoch、zxid都一致，则比较节点ID（在myid文件中指定的值）</li></ul><p>因为选举规则包含上述三个方面，则每个节点在广播自己所提议的Leader时，选票中都会包含上面三个值。后文使用&lt;proposeLeader, epoch, zxid, node&gt;，来表示一张选票，表明自己所有提议的Leader。</p><ul><li>proposeLeader，表示自己所提议的Leader的节点ID</li><li>epoch，表示所提议的Leader节点所处的任期编号</li><li>zxid，表示所提议的Leader节点拥有的Proposal最大的事务编号</li><li>node，表示本次提议的节点</li></ul><p>这里需要注意的是，这里的zxid是指ZAB在消息广播模式第一阶段的收到Proposal最大的zxid，即：<strong>节点收到被提出的Proposal最大的zxid，而不是已提交的Proposal最大的zxid</strong>。</p><p>这里需要单独拎出来强调，有的伙计，在看zookeeper源码时，会看到Leader选举时，使用的是dataTree.lastProcessedZxid。而dataTree.lastProcessedZxid表示的是已提交的Proposal最大的zxid。这里没错，在正常运行时dataTree.lastProcessedZxid确实表示的是已提交的Proposal最大的zxid。但是当跟随者检测到异常，退出FOLLOWING状态时，在follower.shutdown()中，会使用lastProcessedZxid表示节点上收到已提出的Proposal的zxid。而后续的Leader选举使用的lastProcessedZxid，即为节点收到被提出的Proposal最大的zxid。</p><h5 id="算法陈述"><a href="#算法陈述" class="headerlink" title="算法陈述"></a>算法陈述</h5><p>集群中存在三个节点A, B, C，各自节点ID依次为1, 2, 3。其中A为Leader，已提交两个Proposal（&lt;1, 101&gt;，&lt;1, 102&gt;），B、C为Follower，B已提交两个Proposal（&lt;1, 101&gt;，&lt;1, 102&gt;），C只提交了&lt;1, 101&gt;<br><img src="/images/theory/distributed/zab_7.png" alt="Leader选举"></p><p>当A节点宕机后，跟随者检测Leader异常，则退出FOLLOWING状态，变更为LOOKING，发起Leader选举。<br><img src="/images/theory/distributed/zab_8.png" alt="Leader选举"></p><p>当Follower开始第一轮提议Leader时，都会推荐自己为Leader，并向所有节点广播自己的提议，即B的选票为&lt;2, 1, 102, B&gt;，C的选票为&lt;3, 1, 101, C&gt;。各自将选票发给其他节点，B的选票发送给B、C，C的选票也发送给B、C。<br><img src="/images/theory/distributed/zab_9.png" alt="Leader选举"></p><p>B, C收到对方的选票后，根据上面描述的规则进行PK，依次比较epoch、zxid、节点ID。B、C首先会收到来自自己的提议的选票，因为收到选票与自己提议的选票相同，只需要接受和保存该选票。</p><ul><li>当B收到来自C的选票&lt;3, 1, 101, C&gt;，由于epoch相同，B的zxid大于C的zxid，则B的选票获胜，不需要变更选票信息，保存即可。</li><li>C收到来自B的选票&lt;2, 1, 102, B&gt;，由于epoch相同，C的zxid小于B的zxid，则C的选票落选。需要保存B的选票&lt;2, 1, 102, B&gt;，并变更自己的选票为&lt;2, 1, 102, C&gt;</li></ul><p><img src="/images/theory/distributed/zab_10.png" alt="Leader选举"></p><p>C节点在变更自己的选票信息后，会重新广播选票&lt;2, 1, 102, C&gt;给其他节点。B, C节点都收到来自C的新选票信息&lt;2, 1, 102, C&gt;，根据规则继续PK，结果肯定是B, C都保存两个选票（&lt;2, 1, 102, B&gt;, &lt;2, 1, 102, C&gt;）<br><img src="/images/theory/distributed/zab_11.png" alt="Leader选举"></p><p>最后，B, C所提议的领导者节点ID为2（即B节点），赢得了过半选票。则B竞选为准Leader，退出LOOKING状态，变更为LEADING，C节点变更状态为FOLLOWING，完成Leader选举。<br><img src="/images/theory/distributed/zab_12.png" alt="Leader选举"></p><h5 id="逻辑时钟"><a href="#逻辑时钟" class="headerlink" title="逻辑时钟"></a>逻辑时钟</h5><p>这里需要补充的是逻辑时钟，逻辑时钟也会影响Leader的选举，单独拎出来是为了描述选举算法时思路更清晰。</p><p>逻辑时钟（logicclock），即选举的轮次，避免接收到旧的选票信息。每进行一轮选举，逻辑时钟变会增加。在选举中，逻辑时钟大的节点不会接收来自逻辑时钟小的节点的选票。</p><p>比如，节点A, B的逻辑时钟分别为1, 2，那么B将拒绝接收来自A的选票信息。即使A的zxid大于B的zxid，B也会拒绝接收该选票。</p><h4 id="发现（DISCOVERY）"><a href="#发现（DISCOVERY）" class="headerlink" title="发现（DISCOVERY）"></a>发现（DISCOVERY）</h4><p>该阶段用于确立Leader的领导关系，继上一阶段，也就是ELECTION完成后，每个节点都有自己所保存的选票池，当选池中有过半的选票都提议同一节点为Leader时，则进入发现（DISCOVERY）状态。</p><p>本节思路：会先按每一小步介绍过程，后面会画出整个过程的周期，所以每一小步会记作一个标记，方便后面描述整个过程。</p><p>继续上一小节的案例。A, B, C三个节点，A宕机了，B为新选举的准Leader。其中B已提交两个Proposal（&lt;1, 101&gt;，&lt;1, 102&gt;），C只提交了&lt;1, 101&gt;。</p><p>在该状态期间，由Follower会主动联系准Leader，并将自己最后接受的事务Proposal的epoch值发送给准Leader，这里记作FOLLOWERINFO。<br><img src="/images/theory/distributed/zab_13.png" alt="发现（DISCOVERY）"></p><p>准Leader收到来自过半（包含B节点自己）的FOLLOWERINFO消息后，会从这个FOLLOWERINFO中选取最大的epoch值，对其进行加1，作为新的epoch值，并封装成LEADERINFO消息发给这些过半的Follower。<br><img src="/images/theory/distributed/zab_14.png" alt="发现（DISCOVERY）"></p><p>当Follower收到LEADERINFO消息后，会先校验LEADERINFO消息正确性。校验自己的epoch是否小于LEADERINFO消息中的epoch，如果小于，就将LEADERINFO消息中的epoch赋值给自己的epoch，并将自己的运行状态变更为SYNCHRONIZATION，最后向准Leader返回Ack响应（ACKEPOCH）。<br><img src="/images/theory/distributed/zab_15.png" alt="发现（DISCOVERY）"></p><p>最后准Leader收到过半的ACKEPOCH消息后，也将自己的运行状态修改为SYNCHRONIZATION。至此完成发现阶段的工作，集群确立Leader的领导关系。</p><h4 id="数据同步（SYNCHRONIZATION）"><a href="#数据同步（SYNCHRONIZATION）" class="headerlink" title="数据同步（SYNCHRONIZATION）"></a>数据同步（SYNCHRONIZATION）</h4><p>进入到数据同步阶段，我们需要先了解三种同步方式（DIFF、TRUNC、SNAP）。Leader会根据每个Follower的最大zxid，采用不同方式处理不一致的数据。</p><p>在ZAB的设计中，Leader为了更高效的将Proposal复制给Follower，会在自己的内存队列中缓存一定数量（默认500）的已提交的Proposal。在内存中的Proposal就有zxid的最大值和最小值，即：maxCommittedZxid和minCommittedZxid。</p><ul><li>DIFF：当Follower最大的zxid小于maxCommittedZxid且大于minCommittedZxid</li><li>TRUNC：当Follower最大的zxid大于maxCommittedZxid时，该方式要求Follower丢弃超出的那部分Proposal</li><li>SNAP：当Follower最大的zxid小于minCommittedZxid时，该方式直接同步快照给Follower</li></ul><p>了解了同步方式，接下来来看看具体怎么交互的吧。该阶段由Leader根据Follower的最大zxid来选择同步方式和需要发送的数据。由于B已提交两个Proposal（&lt;1, 101&gt;，&lt;1, 102&gt;），C只提交了&lt;1, 101&gt;。该情况下Leader会选择DIFF的方式，并且和需要同步的数据，一起封装为NEWLEADER消息发给Follower。</p><p>Follower在收到NEWLEADER消息后，进行修复不一致数据，并返回给Leader响应Ack消息。<br><img src="/images/theory/distributed/zab_16.png" alt="数据同步（SYNCHRONIZATION）"></p><p>Leader在收到过半Ack消息后，则完成数据同步阶段，将自己运行状态修改为BROADCARST（广播状态），并发送UPTODATE消息给过半的Follower，通知他们完成数据同步，修改运行状态修改为BROADCARST。</p><h4 id="整体回顾"><a href="#整体回顾" class="headerlink" title="整体回顾"></a>整体回顾</h4><p><img src="/images/theory/distributed/zab_17.png" alt="整体回顾"></p><h3 id="与paxos区别"><a href="#与paxos区别" class="headerlink" title="与paxos区别"></a>与paxos区别</h3><ol><li>ZAB采用的是主备模式的系统架构，相比于paxos不同的是，paxos可以同时存在多个提议者进行提案，而ZAB同一时间只允许一个领导者进行提案，这样即解决客户端并发处理，又能规定提案的顺序性。</li></ol><h3 id="思考几个题目吧"><a href="#思考几个题目吧" class="headerlink" title="思考几个题目吧"></a>思考几个题目吧</h3><ol><li><p>zookeeper提供的最终一致性，任何节点都能处理读请求，但是读到的可能会是旧数据，如果必须要读到最新数据，怎么办？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zookeeper提供解决方案就是：<span class="keyword">sync</span>命令。</span><br><span class="line">你可以在读操作之前，先执行<span class="keyword">sync</span>命令，这样客户端就能读到最新数据了。</span><br></pre></td></tr></table></figure></li><li><p>A, B, C三个节点，A为Leader，B有2个已提交的Proposal(&lt;1, 101&gt;, &lt;1, 102&gt;)，C有3个未提交Proposal(&lt;1, 101&gt;, &lt;1, 102&gt;, &lt;1, 103&gt;)。当A故障后，B和C谁会当选Leader呢？</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答案是C。</span><br><span class="line">因为竞选Leader时，使用的是所有已提出的Proposal最大zxid。</span><br><span class="line">C最大的zxid为<span class="number">103</span>，而B最大的zxid为<span class="number">102</span>。</span><br><span class="line">那么C当选Leader。</span><br></pre></td></tr></table></figure></li><li><p>在选举中，会出现选票被瓜分、选举失败的问题吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不会出现选票被瓜分导致选举失败的情况。</span><br><span class="line">因为每个节点的节点ID都是不同的，而节点ID会参与选票的判断。</span><br><span class="line">在epoch、zxid都一致情况下，还有节点ID可以兜底来保证选票给哪一个节点。</span><br></pre></td></tr></table></figure></li><li><p>有一个Proposal，在广播之前Leader宕机，经过崩溃恢复模式后，该Proposal是否会被提交？</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不一定，取决新当选的<span class="built_in">Leader</span>是否包含该Proposal</span><br><span class="line">如果上一任<span class="built_in">Leader</span>，在广播第一阶段有个Follower收到了。而新当选的<span class="built_in">Leader</span>又是该Follower</span><br><span class="line">则该Proposal会被提交。</span><br></pre></td></tr></table></figure></li><li><p>在崩溃恢复后，Leader首先将自己的状态设置为广播，然后再通知其他节点修改。那么这是有写请求进来，会执行成功吗？</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">会，这就是ZAB设计消息发送队列的原因，在<span class="built_in">Leader</span>为广播状态时即可对外服务。</span><br><span class="line">因为新封装的Proposal请求，一定会在通知其他节点数据同步完成的消息（UPTODATE）之后处理</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> ZAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - Paxos</title>
      <link href="/2020/07/07/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Paxos/"/>
      <url>/2020/07/07/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Paxos/</url>
      
        <content type="html"><![CDATA[<h3 id="paxos-科普"><a href="#paxos-科普" class="headerlink" title="paxos 科普"></a>paxos 科普</h3><p>分布式算法，不得不提paxos。它是目前公认的解决分布式共识问题最有效的算法之一，甚至可以说过去几十年里一切分布式一致性算法都来源于它。<br>那么要学习paxos，我们首先得认识它。一般描述它，都会包含两个词：<strong>分布式容错、分布式共识算法</strong>。那么它们是指什么呢？paxos又解决了什么样的问题呢？</p><ol><li>分布式容错<br>分布式容错，是指在分布式环境下，能够容忍一部分节点宕机，还能向外提供稳定的服务。</li><li>分布式共识算法<br>分布式共识算法，是指在分布式环境下，各个节点能就某个值达成共识，即所有节点都认同某个值。</li></ol><p>理解共识可能要难一点，那么我举个例子。假如有A、B两个客户端，他们都对同一个X进行赋值。A需要设置X=1，B需要设置X=2。那么让A和B都认同值X=1或者X=2的过程，就是达成共识。</p><p>带着这个问题，来聊聊如何达成共识呢?</p><h3 id="初探paxos"><a href="#初探paxos" class="headerlink" title="初探paxos"></a>初探paxos</h3><p>paxos为了帮我们理解，抽象出三个角色和两个阶段</p><ul><li>角色：提案者（proposer）、接受者（acceptor）、学习者（learner）</li><li>阶段：<strong>prepare阶段、accept阶段</strong>、learn阶段</li></ul><h4 id="提案（proposal）"><a href="#提案（proposal）" class="headerlink" title="提案（proposal）"></a>提案（proposal）</h4><p>在描述这些角色之前，我们需要先了解什么提案。在paxos算法中提案是指需要达成共识的某一个值，或者某一个操作。paxos对其封装成一个提案，并为其生成唯一的提案编号。本文中使用[M, V]表示一个提案，其M表示提案编号，V表示需要达成共识的值。</p><h4 id="提案者（proposer）"><a href="#提案者（proposer）" class="headerlink" title="提案者（proposer）"></a>提案者（proposer）</h4><p>proposer的工作在于接收客户端请求，将其封装成提案（proposal）。并将提案（proposal）发给所有的接受者（acceptor）。根据接受者（acceptor）返回情况，控制是否需要提交该提案（proposal）即保存该提案（proposal）。</p><h4 id="接受者（acceptor）"><a href="#接受者（acceptor）" class="headerlink" title="接受者（acceptor）"></a>接受者（acceptor）</h4><p>acceptor的工作在于参与对提案（proposal）的投票，接收和处理paxos的两个阶段的请求。</p><h4 id="学习者（learner）"><a href="#学习者（learner）" class="headerlink" title="学习者（learner）"></a>学习者（learner）</h4><p>learner不参与提案和投票，只被动接收提案结果。他的存在可用于扩展读性能，或者跨区域之间读操作。</p><p>因为他们不投票，所以他们不是paxos集群的重要组成部分。因此，它们可以失败，或者与集群断开连接，而不会损害paxos服务的可用性。对用户的好处是learner相比acceptor来说更能通过不太可靠的网络链接进行连接。实际上，learner可用于与另一个数据中心的paxos服务器通信，并且写入消耗最小的网络流量，因为在没有投票协议的情况下所需的消息数量较少。</p><h4 id="prepare阶段"><a href="#prepare阶段" class="headerlink" title="prepare阶段"></a>prepare阶段</h4><p>prepare阶段，由proposer向acceptor发送prepare请求，acceptor根据约定决定是否需要响应该请求。如果acceptor通过提案[M, ]的prepare请求，则向proposer保证以下承诺</p><ol><li>acceptor承诺不再通过编号<strong>小于等于</strong>M的提案的prepare请求</li><li>acceptor承诺不再通过编号<strong>小于</strong>M的提案的accept请求，也就是不再通过编号小于M的提案</li><li>如果acceptor已经通过某一提案，则承诺在prepare请求的响应中返回<strong>已经通过的最大编号的提案内容</strong>。如果没有通过任何提案，则在prepare请求的响应中返回空值</li></ol><p>其中prepare阶段还得注意，在prepare请求中，proposer只会发提案编号，也就是[M, ]。</p><h4 id="accept阶段"><a href="#accept阶段" class="headerlink" title="accept阶段"></a>accept阶段</h4><p>accept阶段，在proposer在prepare阶段收到大多数响应后，由proposer向acceptor发送accept请求。例如此时进行决策的提案是[M, V]，根据acceptor在prepare阶段对proposer的承诺。</p><ul><li>如果此时acceptor没有通过编号大于M的prepare请求，则会批准提案[M, V]，并返回已通过的编号最大的提案（也就是[M, ]）。</li><li>如果此时acceptor已经通过编号大于M的prepare请求，则会拒绝提案[M, V]，并返回已通过的编号最大的提案（大于M的编号）。</li></ul><p>proposer会统计收到的accept请求的响应，<strong>如果响应中的编号等于自己发出的编号，则认为该acceptor批准过了该提案</strong>。如果存在大多数acceptor批准了该提案，则记作该提案已达成共识，或者记作提案已被批准。如果没有大多数acceptor批准该提案，则重新回到prepare阶段进行协商。</p><p>其中accept阶段也有注意的地方，在prepare请求中，proposer只会发提案[M, ]。而accept请求，proposer会发送提案编号和提案值，也就是[M, V]。<strong>这里要注意的是V的值，如果在prepare请求的响应中，部分acceptor已经批准过的提案值，则V为prepare请求的响应中编号最大的提案值，否则可以由proposer任意指定。</strong></p><h4 id="learn阶段"><a href="#learn阶段" class="headerlink" title="learn阶段"></a>learn阶段</h4><p>learn阶段，在某一个提案通过paxos达成共识之后，由acceptor通知learner学习提案结果。</p><h3 id="算法陈述"><a href="#算法陈述" class="headerlink" title="算法陈述"></a>算法陈述</h3><p>该小节分为两部描述：提案选定、提案获取。</p><ul><li>提案选定，是描述paxos从一个提案的产生到如何达成共识的过程。也就是prepare阶段、accept阶段</li><li>提案获取，是描述learner如何获取保存提案，也就是learn阶段</li></ul><h4 id="提案选定"><a href="#提案选定" class="headerlink" title="提案选定"></a>提案选定</h4><p>先来看一张非常流行的图，它用伪代码描述了paxos的过程。我预先描述下几个变量。</p><ul><li>minProposal：当前acceptor在prepare请求中通过的最大提案编号</li><li>acceptedProposal：当前acceptor在accept请求中通过的最大提案编号</li><li>acceptedValue：当前acceptor在accept请求中通过的最大提案编号的提案值</li></ul><p><img src="/images/theory/distributed/paxos_1.jpg" alt="paxos伪代码描述"></p><ol><li>先为proposal生成一个编号n，这里需要保证编号全局唯一，并且全局递增，具体实现全局编号，这里不予讨论。</li><li>proposer向所有acceptors广播prepare(n)请求</li><li>acceptor比较n和minProposal，如果n&gt;minProposal则执行minProposal=n，并且将 acceptedProposal 和 acceptedValue 返回给proposer。</li><li>proposer接收到过半数回复后，如果发现有acceptedValue返回，将所有回复中acceptedProposal最大的acceptedValue作为本次提案的value，否则可以任意决定本次提案的value。</li><li>到这里可以进入第二阶段，广播accept (n,value) 到所有节点。</li><li>acceptor比较n和minProposal，如果n&gt;=minProposal，则acceptedProposal=minProposal=n，acceptedValue=value，本地持久化后，返回；否则，返回minProposal。</li><li>proposer接收到过半数请求后，如果发现有返回值result（minProposal） &gt; n，表示有更新的提议，跳转到1；否则value达成一致。</li></ol><p>当然，实际运行过程中，没有以上陈述的那么理想。真实情况下，每一个proposer都有可能产生多个提案，但只要每个proposal遵循如上算法运行，就一定能保证执行正确性。文章后续我们会对多提案提出的情况进行模拟，并详细讲解。</p><h4 id="提案获取"><a href="#提案获取" class="headerlink" title="提案获取"></a>提案获取</h4><p>在一个提案达成共识后，如何让learner获取该提案也是一个值得细究的问题。一般有以下几种方案。</p><ul><li>方案一<br>最简单的方法就是一旦acceptor批准了一个提案，就将该提案发给所有的learner。这种做法虽然可以让learner尽快的获得被选中的提案，但是却需要每个acceptor与所有learner逐一进行通信，通信次数为二者乘积，所以效率较低。</li><li>方案二<br>选定一个主learner，如有某一个提案批准后，由acceptor通知主learner，当主learner被通知后，由它通知其他的learner。这个方案虽然多了一个步骤，但是通信次数大大降低，通信次数为learner的数量。该方案同时引出另一个问题：主learner随时可能出现故障。</li><li>方案三<br>在基于方案二的基础上，由单个主learner扩展成一个主learner集合。集合中learner数量越高，可靠性也越好。</li></ul><h3 id="算法模拟"><a href="#算法模拟" class="headerlink" title="算法模拟"></a>算法模拟</h3><p>为了更好的熟悉paxos，我们举例描述paxos中提案选定过程。假设存在3节点的paxos集群，这里需要注意每一个节点可以同时扮演proposer和acceptor。情况如下</p><p>proposerA收到请求将X设置成3，proposerB收到请求将X设置成5。proposerA和proposerB分别为此生成提案，其proposerA的提案编号为1，proposerB提案编号为2。在prepare阶段它们交互结果如下</p><p><img src="/images/theory/distributed/paxos_2.png" alt="paxos prepare请求"></p><ol><li>proposerA和proposerB分别进入prepare阶段，将提案编号发给各个acceptor。</li><li>acceptorA和acceptorB在收到proposerA的prepare请求后，由于没有通过过任何prepare请求，也没有批准过任何的accept请求。则给proposerA返回尚无提案。</li><li>acceptorC由于在收到proposerB的prepare请求之后再收到proposerA的prepare请求，且proposerB的提案编号大于proposerA的提案编号，故不给proposerA返回prepare响应。</li><li>acceptorA和acceptorB在收到proposerB的prepare请求后，由于之前收到proposerA的prepare请求，则比较各自的提案编号，由于proposerB的提案编号大于proposerA的提案编号，但是又没有通过任何的accept请求，则给proposerB返回尚无提案，并向proposerB保证前文所说的三个承诺。</li></ol><p>至此，proposerA获得2个prepare响应，proposerB获得三个prepare<br>响应。即他们都获得了大多数节点的prepare响应，于是各自开始accept阶段提交。</p><p><img src="/images/theory/distributed/paxos_3.png" alt="paxos accept请求"></p><ol><li>proposerA由于收到的prepare响应中没有任何提案值，则自己任意设置提案值，也就是[1, 3]。并向各个acceptor发起accept请求。</li><li>acceptorA、acceptorB、acceptorC收到proposerA的accept请求后，由于在prepare阶段，他们都向proposerB保证了上文所说的三个承诺，则他们不会该accept请求，并将prepare阶段通过最大的提案编号返回给proposerA，也就是[2, ]。</li><li>proposerA收到[2, ]后，发现响应中的提案编号2比自己的提案编号1大，则认为没有accept通过该提案。proposerA需要重新回到prepare阶段进行协商。</li><li>proposerB由于收到的prepare响应中没有任何提案值，则自己任意设置提案值，也就是[2, 5]。并向各个acceptor发起accept请求。</li><li>acceptorA、acceptorB、acceptorC，在此期间没有通过任何的prepare请求也没有通过任何的accept请求，即同意批准该提案，返回[2, ]给proposerB。</li><li>proposerB收到accept响应后，比对提案编号发现有大多数的提案编号是自己的编号，则认为该提案达成共识，完成协商过程。</li></ol><p>以上过程的主要描述了accept对proposer的两个承诺，即如果acceptor通过提案[M, ]的准备请求</p><ul><li>acceptor承诺不再通过编号<strong>小于等于</strong>M的提案的prepare请求</li><li>acceptor承诺不再通过编号<strong>小于</strong>M的提案的accept请求，也就是不再通过编号小于M的提案</li></ul><p>那么还有一个承诺是</p><ul><li>如果acceptor已经通过某一提案，则承诺在prepare请求的响应中返回<strong>已经通过的最大编号的提案内容</strong>。如果没有通过任何提案，则在prepare请求的响应中返回空值</li></ul><p>为了描述该承诺，我们想象出这样一个场景。proposeB完成prepare请求后，发起accept请求，且提案为[3, 6]。在此过程中，proposeA发起prepare请求，提案编号为[4, ]，并且acceptor先收到proposeA发起prepare请求，也就是说acceptor会拒绝proposeB的accept请求。情况如下</p><p><img src="/images/theory/distributed/paxos_4.png" alt="paxos 两个提案提出"></p><ol><li>proposerB发起accept请求，提案为[3, 6]。</li><li>acceptorA收到proposerB的accept请求后，批准了该请求。</li><li>proposerA发起prepare请求，提案为[4, ]。</li><li>acceptorB、acceptorC先收到proposerA的prepare请求。则拒绝proposerB的accept请求。</li><li>acceptorA收到proposerA的prepare请求，由于之前接收了proposerB发起accept请求，则给proposeA返回已批准的提案[3, 6]。</li><li>此时，proposerB重新进入prepare协商，proposerA收到大多数prepare响应，发起accept请求，由于收到acceptorA返回的提案[3, 6]，那么proposer的提案值也只能为6，即[4, 6]。</li><li>accept完成协商。</li></ol><h3 id="multi-paxos算法"><a href="#multi-paxos算法" class="headerlink" title="multi-paxos算法"></a>multi-paxos算法</h3><p>原始的paxos算法（Basic Paxos），只能完成一个值的共识。Lamport宗师提到可以通过执行多次basic-paxos实现一系列值的共识。但是由于多次协商会增加通信以及影响协商的活性（指协商进入死循环）。</p><p>宗师则提出multi-paxos的解决方案，但是由于宗师并没有把multi-paxos讲清楚，只是介绍了大概的思想，缺少算法过程必要细节。所以这给了我们很大的想象空间，因此每个人实现的multi-paxos都有所差异。</p><p>总体来说multi-Paxos基于basic-paxos做了两点改进：</p><ol><li>在所有Proposers中选举一个Leader，由Leader唯一地提交Proposal给Acceptors进行表决。这样没有Proposer竞争，解决了活锁问题。在系统中仅有一个Leader进行Value提交的情况下，Prepare阶段就可以跳过，从而将两阶段变为一阶段，提高效率。</li><li>针对每一个要确定的值，运行一次Paxos算法实例（Instance），形成决议。每一个Paxos实例使用唯一的Instance ID标识。</li></ol><p>首先multi-Paxos是要选举一个leader的，宗师提到：可以通过basic-paxos进行leader的选举。</p><ul><li>选举leader后，只能由leader提出proposal。</li><li>在leader宕机后，服务将临时不可用，等待leader重新选举。</li><li>在系统中仅有一个leader进行proposal提交的情况下，prepare阶段可以跳过。</li></ul><p>multi-paxos通过改变prepare阶段的作用范围至后面leader提交的所有实例，从而使得leader的连续提交只需要执行一次prepare阶段，后续只需要执行accept阶段，将两阶段变为一阶段，提高了效率。为了区分连续提交的多个实例，每个实例使用一个instance ID标识，instance ID由leader本地递增生成即可。</p><p>multi-paxos允许有多个自认为是leader的节点并发提交proposal而不影响其安全性，这样的场景即退化为basic-paxos。</p><h3 id="paxos回顾，思考几个题目吧"><a href="#paxos回顾，思考几个题目吧" class="headerlink" title="paxos回顾，思考几个题目吧"></a>paxos回顾，思考几个题目吧</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">怎么解决两个提案提出后陷入死循环？</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">三个节点的集群A、B、C。</span><br><span class="line">A和B通过提案[4, 6]，C没有通过任何提案。</span><br><span class="line">此时C收到客户端请求，将值设置为5，C生成的编号为5，通过basic-paxos后。</span><br><span class="line"></span><br><span class="line">最后集群中通过的提案应该是多少呢？</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">假如有三个提案者A, B, C，五个接受者SERV1, SERV2, SERV3, SERV4, SERV5</span><br><span class="line">A提案编号为1，值为3</span><br><span class="line">B提案编号为2，值为5</span><br><span class="line">C提案编号为3，值为8</span><br><span class="line"></span><br><span class="line">①A第一阶段发给SERV1, SERV2, SERV3获得回应，赢得半数选票</span><br><span class="line">②B开始第一阶段，获得SERV3, SERV4, SERV5的选票</span><br><span class="line">③A开始第二阶段，发给SERV1值为3的提案后，SERV1允许提交该值，此时A宕机</span><br><span class="line">④B开始第二阶段，发给SERV5值为5的提案后，SERV5允许提交该值，此时B宕机</span><br><span class="line">⑤C开始第一阶段，获得SERV1, SERV2, SERV5的选票，根据规定，它将收到SERV1接受的值为3，SERV5接受的值为5。</span><br><span class="line">那C的第二阶段提案应该是[3, 3]还是[3, 5]呢？</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------</span><br><span class="line">multi-paxos提出leader的角色，提案只能由leader提出，那么当写性能达到leader的瓶颈，怎么解决呢？</span><br><span class="line"></span><br><span class="line">答：应该裂变分区，拆成多个不相干的分区，由多个paxos-group来完成之前一个leader的工作</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/31780743。文中提到paxos推导过程，也可以了解下。" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31780743。文中提到paxos推导过程，也可以了解下。</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> paxos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性协议 - 2PC, 3PC</title>
      <link href="/2020/07/05/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%202PC,%203PC/"/>
      <url>/2020/07/05/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%202PC,%203PC/</url>
      
        <content type="html"><![CDATA[<p>在分布式系统中，每一个机器节点虽然都能明确的知道自己在事务操作中的结果是成功或失败，但无法直接获取其他节点的操作结果。因此在分布式环境中，为了保持事务的ACID特性，就需要增加一个“协调者”来管理其他节点（“参与者”）事务的提交和回滚。基于这个思想，衍生出二阶段提交和三阶段提交两种协议。</p><h3 id="2PC-简述"><a href="#2PC-简述" class="headerlink" title="2PC 简述"></a>2PC 简述</h3><p>二阶段提交(Two-Phase Commit)，是一个非常经典的<strong>强一致</strong>、<strong>中心化的原子提交协议</strong>。目前，绝大多数关系型数据库都采用二阶段提交协议来完成分布式事务处理（例如mysql的XA协议）。因此二阶段提交协议也被广泛运用到分布式系统中。</p><p>顾名思义，算法流程就是分为两个阶段提交某一操作，其分为准备阶段、提交阶段。为了更好描述算法过程，为此定义了两种角色：协调者（Coordinator）、参与者（Participant）。</p><h4 id="阶段一：准备阶段"><a href="#阶段一：准备阶段" class="headerlink" title="阶段一：准备阶段"></a>阶段一：准备阶段</h4><p><img src="/images/theory/distributed/2pc_1.png" alt="2pc 准备阶段"><br>准备阶段，又被称为投票阶段（Vote Request），由协调者向参与者发送请求，询问当前事务能否处理成功。参与者则开启本地数据库事务，开始执行数据库操作，但是并不会提交。根据操作结果，返回给协调者“yes/no”，表示事务是否可以提交。</p><ul><li>事务询问<br>协调者向所有参与者发送<strong>事务内容</strong>，询问是否可以执行事务的提交操作，并等待各参与者的响应</li><li>执行事务<br>各参与者执行事务操作，准备好事务资源，记录undo、redo信息</li><li>反馈询问结果<br>如果参与者成功执行了事务操作，那么返回给协调者yes（表示当前事务可以提交），否者返回给协调者no（表示当前事务不能执行）</li></ul><h4 id="阶段二：提交阶段"><a href="#阶段二：提交阶段" class="headerlink" title="阶段二：提交阶段"></a>阶段二：提交阶段</h4><p>在准备阶段，由于参与者可以返回yes/no，则在提交阶段也会出现两种可能，即全局提交事务、全局回滚事务。</p><h5 id="全局提交事务"><a href="#全局提交事务" class="headerlink" title="全局提交事务"></a>全局提交事务</h5><p><img src="/images/theory/distributed/2pc_2.png" alt="2pc 提交阶段"><br>当准备阶段所有参与者都返回yes的响应后，协调者将发起全局提交事务请求。</p><ul><li>发送提交请求<br>由协调者向所有参与者发送global_commit请求，要求提交当前事务</li><li>事务提交<br>当参与者收到global_commit请求后，则执行事务提交操作，并释放整个分布式事务期间占用的事务资源</li><li>反馈提交结果<br>参与在执行完事务提交后，向协调者返回ack消息</li><li>完成事务提交<br>协调者收到所有参与者反馈的ack消息后，给客户端返回结果，完成本次事务</li></ul><h5 id="全局回滚事务"><a href="#全局回滚事务" class="headerlink" title="全局回滚事务"></a>全局回滚事务</h5><p><img src="/images/theory/distributed/2pc_3.png" alt="2pc 提交阶段"><br>当准备阶段有一个参与者都返回no的响应后，实际场景中，协调者还会怎加等待响应时间，如果超时后，则协调者将发起全局回滚事务请求，中断事务。</p><ul><li>发送回滚请求<br>由协调者向所有参与者发送global_rollback请求，要求中断当前事务</li><li>事务回滚<br>当参与者收到global_rollback请求后，会利用准备阶段记录的undo信息来进行回滚，并释放整个分布式事务期间占用的事务资源</li><li>反馈回滚结果<br>参与在执行完事务提交后，向协调者返回ack消息</li><li>中断事务<br>协调者收到所有参与者反馈的ack消息后，给客户端返回结果，完成中断事务</li></ul><h4 id="宕机（故障）恢复"><a href="#宕机（故障）恢复" class="headerlink" title="宕机（故障）恢复"></a>宕机（故障）恢复</h4><p>2PC宕机故障，分为多种情况。部分参与者宕机、协调者宕机、部分参与者和协调者都宕机。</p><ul><li>部分参与者宕机<br>参与者恢复后询问协调者宕机期间处理情况便可完成一致性</li><li>协调者宕机<br>新选一个协调者替换，询问所有参与者最后那条事务执行情况，然后决定进行commit/rollback，或者不处理。</li><li>部分参与者和协调者都宕机<br>新竞选的协调者询问所有参与者最后那条事务执行情况。则又分为几种情况：<ul><li>如果有参与者第一阶段返回no，或者第二阶段执行了rollback。则协调者命令所有参与者执行rollback</li><li>如果所有参与者第一阶段返回yes，第二阶段有参与者执行了commit，则协调者命令所有参与者执行commit</li><li>如果所有参与者第一阶段返回yes，第二阶段没有参与者执行任何操作，此时协调者则不知道宕机的参与者执行了commit/rollback。即不能明确的恢复过来。</li></ul></li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>2PC协议明显的优点就是：原理简单、容易实现。但是它的缺点更加明显：</p><ul><li>同步阻塞<br>每个参与者都需要等待协调者的消息，才能继续下一阶段。当协调者在发送第二阶段的消息之前宕机，那么所有参与者将一直锁定准备阶段的事务资源，事务推进不下去了，造成事务阻塞。只有等到协调者恢复，事务才能继续进行。</li><li>数据不一致<br>在第二阶段，如果出现网络异常导致一部分参与者收到了commit请求，一部分参与者没有收到commit请求，结果会是一部分参与者提交了事务，一部分参与者无法进行事务提交。</li><li>宕机恢复，上一小节描述的部分情况下不能保证一致性</li><li>单点问题/脑裂<br>协调者在2PC中，太过重要，当协调者宕机，整个集群将不可用。脑裂是指因为网络原因，出现多个协调者。</li><li>太过保守<br>任何一个节点故障，都会导致整个事务协调失败，换句话说没有完善的容错机制。</li></ul><h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>上面小节讲解了二阶段提交协议的原理，也指出了它所存在的问题，三阶段提交协议则是为了解决2PC的同步阻塞、数据不一致的问题而诞生。</p><p>在2PC的基础上，3PC将准备阶段一分为二，形成由 <strong>CanCommit、PreCommit、DoCommit</strong>三个阶段组成的事务提交协议。并且在3PC<strong>参与者也增加超时机制</strong>（2PC只有协调者拥有超时机制），避免了参与者长时间无法与协调者节点通讯（协调者宕机）的情况下，无法释放资源的问题。在参与者超时后，会自动进行本地commit/abort从而进行释放资源。</p><p>但是3PC并没有完美解决2PC的问题，例如：</p><ul><li>同步阻塞，3PC只是减少了阻塞范围，这里的阻塞包含两方面：<ul><li>参与者在长时间无法与协调者通讯，无法释放资源阻塞的问题。参与者等待协调者消息超时后，自行commit/abort来释放资源。</li><li>协调者和参与者都宕机情况下的阻塞。新晋升的协调者不知道宕机的参与者执行了什么操作，依然不能释放事务资源，而造成的阻塞问题。</li></ul></li><li>数据不一致，也只解决了一部分情况下的不一致。<br>比如第三阶段，部分参与者没有收到DoCommit消息，根据规定会自行提交，最后达成一致。但是如果第三阶段需要abort，部分参与者没有收到abort消息，根据规定也会自行提交，最后数据不一致。</li><li>宕机恢复，解决了2PC中协调者和参与者在第二阶段宕机不能恢复一致性的问题</li></ul><p>可以看出3PC提出的解决方案，自身本就引入了新的问题，比如自动提交后造成的数据不一致。还有增加了一轮通讯，增加了复杂度和协商效率。所以实际上，很少会有系统实现3PC，多数情况下，通过状态机复制来解决2PC的同步阻塞的问题。</p><h4 id="阶段一：CanCommit"><a href="#阶段一：CanCommit" class="headerlink" title="阶段一：CanCommit"></a>阶段一：CanCommit</h4><p><img src="/images/theory/distributed/3pc_1.png" alt="3pc CanCommit"></p><ul><li>事务询问<br>由协调者向所有参与者发送一个<strong>包含事务内容</strong>的canCommit请求，询问是否可以执行事务提交操作，并等待参与者响应</li><li>反馈询问响应<br>参与者收到canCommit请求后，根据自身逻辑判断是否可以顺利执行事务，那么反馈yes，否则反馈no。说白了就是检查下自身状态的健康性，看有没有能力进行事务操作。</li></ul><h4 id="阶段二：PreCommit"><a href="#阶段二：PreCommit" class="headerlink" title="阶段二：PreCommit"></a>阶段二：PreCommit</h4><p>在阶段一结果中，如果所有参与者都返回yes，则执行事务预提交，协调者发起PreCommit请求。如果有任何一个参与者节点返回的结果是no，或者协调者在等待参与者节点反馈的过程中超时，整个分布式事务就会中断，协调者就会向所有的参与者发送“abort”请求。</p><p><strong>注意：</strong>上面所说的参与者增加超时时间，在该阶段就可以派上用场了。在该阶段开始之前，如果协调者宕机，参与者在等待超时时间后，各自选择中断事务，最终达成一致。但是协调者在发出一部分preCommit请求后宕机，有一部分没有收到preCommit请求，那情况则是：一部分参与者执行了preCommit操作，一部分参与者没有执行preCommit操作，最终导致各节点之间数据不一致。</p><h5 id="执行事务预提交"><a href="#执行事务预提交" class="headerlink" title="执行事务预提交"></a>执行事务预提交</h5><p><img src="/images/theory/distributed/3pc_2.png" alt="3pc PreCommit"></p><ul><li>发送preCommit请求<br>由协调者向所有参与者发送preCommit请求，并等待参与者响应</li><li>事务预提交<br>参与者收到preCommit请求后，会执行事务操作，将undo和redo信息写入事务日志中</li><li>反馈执行响应<br>参与者将执行结果反馈给协调者，同时等待最终指令提交（commit）或终止（abort）</li></ul><h5 id="中断事务"><a href="#中断事务" class="headerlink" title="中断事务"></a>中断事务</h5><p>该阶段中断事务相比阶段三中断事务要简单，只需要由协调者向所有参与者发送abort请求，通知中断事务。期间参与者在等待协调者的preCommit请求超时后也会主动中断本地事务。</p><h4 id="阶段三：DoCommit"><a href="#阶段三：DoCommit" class="headerlink" title="阶段三：DoCommit"></a>阶段三：DoCommit</h4><p>同样，根据上一阶段的结果，该阶段也会存在两种情况。阶段二所有参与者成功反馈，则执行提交事务请求，否则中断事务。</p><p><strong>注意：</strong>参与者增加的超时时间，在该阶段也有所体现。在该阶段，无论是协调者宕机了，还是网络原因导致参与者没有收到该阶段的（提交/中断）请求，参与者都会执行本地事务提交。倘若在该阶段，协调者需要发送的是提交事务请求，参与者自动提交本地事务，最后能达到一致性。倘若在该阶段，协调者需要发送的是中断事务请求，如果参与者没有收到该请求，则参与者也会自动提交本地事务，最终导致各节点之间数据不一致。</p><h5 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h5><p><img src="/images/theory/distributed/3pc_3.png" alt="3pc DoCommit"></p><ul><li>发送提交请求<br>协调者就会从“预提交状态”变为“提交状态”。然后向所有的参与者节点发送”global_commit”请求</li><li>事务提交<br>参与者收到global_commit请求后，将执行本地事务提交操作，并释放整个事务执行期间占用的事务资源</li><li>反馈提交结果<br>参与者向协调者反馈ack提交结果</li><li>完成事务<br>协调者收到所有参与者的ack消息后，完成事务</li></ul><h5 id="中断事务-1"><a href="#中断事务-1" class="headerlink" title="中断事务"></a>中断事务</h5><ul><li>发送中断请求<br>协调者向所有参与者发送abort请求</li><li>事务回滚<br>参与者根据阶段二中记录的undo信息，来执行回滚操作，并释放占用事务资源</li><li>反馈回滚结果<br>参与者向协调者反馈ack回滚结果</li><li>中断事务<br>协调者收到所有参与者的ack消息后，中断事务</li></ul><h4 id="宕机（故障）恢复-1"><a href="#宕机（故障）恢复-1" class="headerlink" title="宕机（故障）恢复"></a>宕机（故障）恢复</h4><p>直接分析2PC中的协调者和参与者都宕机情况下，新晋升的协调者怎么恢复一致性的。</p><p>这种情况下，新晋升的协调者同样会询问所有的参与者事务处理情况。这看上去和2PC一样啊？但是深入分析下就会发现不一样。</p><p>我们假设第三阶段，协调者和参与者宕机了，并且参与者执行了第三阶段的操作，没人知道它执行了什么，也就存在两种可能：</p><ul><li>宕机的参与者没执行第三阶段任何操作或者执行了第三阶段的commit操作。那么协调者在询问所有的参与者事务执行情况时，得到的ACK响应一定是，所有参与者处于第二阶段成功完成的状态或者第三阶段执行了commit操作的状态。据此，协调者如果收到这样的回复，那一定可以断定宕机的参与者执行了commit操作或者没执行第三阶段的操作，那么协调者可以大胆的发送DoCommit消息。</li><li>宕机的参与者执行第三阶段的abort操作。那么协调者在询问所有的参与者事务执行情况时，得到的ACK响应一定是，一定存在一个参与者的第二阶段的响应是no，否则第三阶段不会发起abort操作。据此，协调者如果收到存在一个参与者处于第二阶段的abort状态时，则可以大胆的发送abort操作给所有的参与者。</li></ul><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>相比于2PC，3PC最大的优点就是：</p><ul><li>通过增加超时和自动提交，减少了参与者的阻塞范围。</li><li>通过增加PreCommit阶段，能在协调者和参与者都宕机情况下，新晋升的协调者能够使数据达成一致。（维基百科中描述的则是：当协调者和参与者都宕机后，新晋升的协调者可以自信的完成后续的事务操作。）</li></ul><p>3PC的缺点：</p><ul><li>在某些情况下，因为自动提交/中断本地事务的约定，必然会造成数据的不一致性。</li><li>增加一轮消息，增加了复杂度和协商效率。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> 2PC </tag>
            
            <tag> 3PC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务之实现分布式系统的最终一致性</title>
      <link href="/2020/05/20/java/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8B%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2020/05/20/java/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8B%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>转载自： <a href="https://www.cnblogs.com/wudimanong/p/10558710.html" target="_blank" rel="noopener">https://www.cnblogs.com/wudimanong/p/10558710.html</a></p><h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>在之前的文章中我们介绍了如何基于RocketMQ搭建生产级消息集群，以及2PC、3PC和TCC等与分布式事务相关的基本概念（没有读过的读者详见👇推荐阅读）。在这篇文章中我们将介绍RocketMQ的事务消息相关的内容，并通过一些实践和大家一起来探索下事务消息如何解决分布式系统中的分布式事务问题。</p><h3 id="事务消息原理"><a href="#事务消息原理" class="headerlink" title="事务消息原理"></a>事务消息原理</h3><p>事务消息特性可以看作是<strong>两阶段协议</strong>的消息实现方式，用以确保在以<strong>消息中间件解耦</strong>的分布式系统中<strong>本地事务的执行和消息的发送</strong>，可以<strong>以原子的方式进行</strong>。</p><p>举个例子，以某互联网公司的用户余额充值为例，因为有充返活动（充值100元赠送20元），优惠比较大，用户Joe禁不住诱惑用支付宝向自己的余额账户充值了100元，支付成功后Joe的余额账户有了120元钱。</p><p>而该公司的关于用户余额充值的系统设计是这样的：<br><img src="/images/java/distributed-transaction-1.png" alt="原理"></p><p>在这个设计流程中，该公司通过自建支付系统完成用户Joe的支付宝扣款操作，成功后需要更新支付流水的状态，因为用户的<strong>余额账户系统与支付系统之间通过MQ解耦</strong>了，所以支付系统在完成支付流水状态更新后需要通过发送MQ消息到消息中间件服务，然后用户余额系统作为消费者通过消息消费的方式完成用户余额的增加操作。</p><p>这里有个问题：“<strong>支付系统如何确保这笔余额充值消息一定会成功发送到MQ，并且用户余额系统一定能处理成功呢</strong>”？如果支付系统在完成支付订单状态更新后，MQ<strong>消息发送失败</strong>或者用户<strong>余额系统消息处理失败</strong>的话，都会导致Joe支付扣款成功，而自己的余额账户却没到账的情况发生。</p><p>为了解决这个问题，按照目前的系统设计是需要“<strong>支付系统-MQ服务-用户余额系统</strong>”三者的处理满足数据的一致性要求。例如，如果支付系统感知到消息发送失败后还可以进行重新投递，从而确保支付系统与用户余额数据的最终一致性。</p><p>而上述问题就是事务消息要解决的问题，在具体了解RocketMQ提供的事务消息机制之前，我们先来看下在RocketMQ的早期版本不支持事务消息，或者因为历史原因选择的消息中间件本身就不支持事务消息的情况下，一些大公司是怎么解决这个问题的？</p><p>早期为了实现基于MQ异步调用的多个服务间，业务逻辑执行要么一起成功、要么一起失败，具备事务特点，通常会采用<strong>可靠消息最终一致性方案</strong>，来实现分布式事务。还是以Joe充值这件事来举例，可靠消息方案实现过程如下：<br><img src="/images/java/distributed-transaction-2.png" alt="原理"></p><p>在可靠消息最终一致性方案中，为了实现分布式事务，需要确保上游服务本地事务的处理与MQ消息的投递具有原子性，也就是说上游服务本地事务处理成功后要确保消息一定要成功投递到MQ服务，否则消息就不应该被投递到MQ服务；同样，被成功投递到MQ服务的消息，也一定要被下游服务成功处理，否则就需要重新投递MQ消息。</p><p>为了实现双向的原子性，可靠消息服务需要对<strong>消息进行状态标记</strong>，与此同时还需要对消息进行状态检查，从而实现重新投递及消息状态的最终一致性。核心流程说明如下：</p><p><font color='red'>1、上游服务（支付系统）如何确保完成自身支付成功状态更新后消息100%的能够投递到下游服务（用户余额系统）指定的Topic中？</font></p><p>在这个流程中上游服务在进行本地数据库事务操作前，会先发送一个状态为“<strong>待确认</strong>”的消息至可靠消息服务，而不是直接将消息投递到MQ服务的指定Topic。可靠消息服务此时会将该消息记录到自身服务的消息数据库中（<strong>消息状态为-&gt;待确认</strong>），完成后可靠消息服务会回调上游服务表示收到了消息，你们可以进行本地事务的操作了。</p><p>之后上游服务就会开启本地数据库事务执行业务逻辑操作，这里支付系统就会将该笔支付订单状态更新为“已成功”。（注意，这里只是举个示例场景，在真正的实践中一般是不会把支付订单本身的状态与业务端回调放在一个事务流程中的，关于这部分的详细说明我们在下面的场景说明中再讨论）。</p><p>如果上游服务本地数据库事务执行成功，则继续向可靠消息服务发送<strong>消息确认消息</strong>，此时可靠消息服务就会正式将消息投递到MQ服务，并且同时<strong>更新消息数据库中的消息状态为“已发送”</strong>。（注意，这里可靠消息服务更新消息状态与投递消息至MQ也必须是在一个原子操作中，即<strong>消息投递成功则一定要将消息状态更新为“已发送”</strong>，所以在编程的细节中，可靠消息服务一般会先更新消息状态，然后再进行消息投递，<strong>这样即使消息投递失败，也可以对消息状态进行回滚-&gt;“待确认”</strong>，相反如果先进行消息投递再更新消息状态，可能就不好控制了）。</p><p>相反，如果上游本地数据库事务执行失败，则需要向可靠消息服务发送<strong>消息删除消息</strong>，可靠消息服务此时就会将消息删除，这样就意味着事务在上游消息投递过程中就被回滚了，而流程也就此结束了，此时上游服务可以需要通过业务逻辑的设计进行重发，这个就不再分布式事务的讨论范畴了。</p><p>说到这里，大家可能会有疑问了！因为在上述描述中，即使上游服务本地数据库事务执行成功了，但是在发送确认消息至可靠消息服务的过程中，以及可靠消息服务在投递消息至MQ服务的过程中，还是会存在失败的风险，这样的话还是会导致支付服务更新了状态，但是用户余额系统连消息都没有收到的情况发生？</p><p>实际上，实现数据一致性是一个复杂的活。在这个方案中可靠消息服务作为基础性的服务除了执行正常的逻辑外，还得处理复杂的异常场景。在实现过程中可靠消息服务需要启动相应的后台线程，不断轮训消息的状态，这里会轮训消息状态为“<strong>待确认</strong>”的消息，并判断该消息的状态的持续时间是否超过了规定的时间，如果超过规定时间的消息还处于“待确认”的状态，就会触发<strong>上游服务状态询问机制</strong>。</p><p>可靠消息服务就会调用上游服务提供的相关借口，询问这笔消息的处理情况，如果这笔消息在上游服务处理成功，则后台线程就会继续触发上图中的步骤5，更新消息状态为“已发送”并投递消息至MQ服务；反之如果这笔消息上游服务处理失败，可靠消息服务则会进行消息删除。通过这样以上机制就确保了“<strong>上游服务本地事务成功处理+消息成功投递</strong>”处于一个原子操作了。</p><p><font color='red'>2、下游服务（用户余额系统）如何确保对MQ服务Topic消息的消费100%都能处理成功？</font></p><p>在1的过程中，确保了上游服务逻辑处理与MQ消息的投递具备原子性，那么当消息被成功投递到了MQ服务的指定Topic后，下游服务如何才能确保消息的消费一定能被成功处理呢？</p><p>在正常的流程中，下游服务等待消费Topic的消息并进行自身本地数据库事务的处理，如果<strong>处理成功则会主动通知可靠消息服务，可靠消息服务此时就会将消息的状态更新为“已完成”</strong>；反之，处理失败下游服务就无法再主动向可靠消息服务发送通知消息了。</p><p>此时，与消息投递过程中的异常逻辑一样，可靠消息服务也会启动相应的后台线程，轮询一直处于“<strong>已发送</strong>”状态的消息，判断状态持续时间是否超过了规定时间，如果超时，可靠消息服务就会再次向MQ服务投递此消息，从而确保消息能被再次消费处理。（注意，也可能出现下游服务处理成功，但是通知消息发送失败的情况，所以为了确保幂等，下游服务也需要在业务逻辑上做好相应的防重处理）。</p><h3 id="RocketMQ事务消息机制"><a href="#RocketMQ事务消息机制" class="headerlink" title="RocketMQ事务消息机制"></a>RocketMQ事务消息机制</h3><p>在👆面第2小节的内容中，我们演示了一个自编写的中间服务+MQ来实现事务消息的示例。但是在现实的工作场景中，开发和维护一套可靠消息服务是一件很耗费资源和成本的事情，实际上，RocketMQ的最新版本（4.3.0+）中已经实现了可靠消息服务的所有功能，并且在保证高并发、高可用、高性能方面做了更为优秀的架构实现。</p><p>从设计逻辑上看RocketMQ所支持的分布式事务特性与上节中阐述的可靠消息服务基本上是一致的。只是RocketMQ在实现上相比较于可靠消息服务而言做了更为复杂的设计，并且因为天然与MQ服务本身紧密结合，所以在高可用、可靠性、性能等方面直接继承了MQ服务本身的架构优势。</p><p>下面我们就结合流程并通过示例代码的分析来和大家一起理解下利用RocketMQ是如何实现分布式事务操作的？</p><p><img src="/images/java/distributed-transaction-3.png" alt="原理"></p><p>在应用场景中分布式服务通过MQ通信的过程中，发送消息的一方我们称之为<strong>Producer</strong>，接收消费消息的一方我们称之为<strong>Consumer</strong>。如果Producer自身业务逻辑本地事务执行成功与否希望和消息的发送保持一个原子性（也就是说如果Producer本地事务执行成功，那么这笔消息就一定要被成功的发送到RocketMQ服务的指定Topic，并且Consumer一定要被消费成功；反之，如果Producer本地事务执行失败，那么这笔消息就应该被RocketMQ服务器丢弃）的话，RocketMQ是怎么做的呢？</p><ol><li><p>Producer选择使用RockerMQ提供的事务消息方法向RocketMQ服务发送事务消息(设置消息属性<strong>TRAN_MSG=TRUE</strong>)；</p></li><li><p>RocketMQ服务端在收到消息后会判断消息的属性是否为事务消息，如果是普通消息就直接Push给Consumer；如果是事务消息就会对该消息进行特殊处理设置事务ID，并暂时设置该消息对Consumer不可见，之后向Producer返回Pre消息发送状态(<strong>SEND_OK</strong>)。</p></li><li><p>之后Producer就会开始执行本地事务逻辑，并设置本地事务处理状态后向RocketMQ服务器发送该事务消息的确认/回滚消息(<strong>COMMIT_MESSAGE／ROLLBACK_MESSAGE</strong>)。</p></li><li><p>RocketMQ服务器根据该笔事务消息的本地事务执行状态决定是否将消息Push给Consumer还是删除该消息。</p></li><li><p>之后Consumer就会消费该消息，执行Consumer的本地事务逻辑，如果执行成功则向RocketMQ返回“<strong>CONSUME_SUCCESS</strong>”；反之出现异常则需要返回“<strong>RECONSUME_LATER</strong>”，以便RocketMQ再次Push该消息，<strong>这一点在实际编程中需要控制好</strong>。</p></li></ol><h3 id="RocketMQ事务消息实现"><a href="#RocketMQ事务消息实现" class="headerlink" title="RocketMQ事务消息实现"></a>RocketMQ事务消息实现</h3><p>相信看到这里，大家对于RocketMQ的分布式事务消息的理解应该有了一个相对清晰的概念了，那么在代码中如何编写呢？</p><p>在开发中使用RocketMQ的分布式事务消息Consumer的代码不需要有什么特别的变化与普通消息Consumer代码一致就可以。</p><p>Consumer示例代码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> static <span class="type">void</span> main(String[] args) throws InterruptedException, MQClientException &#123;</span><br><span class="line"> </span><br><span class="line">    // Instantiate <span class="keyword">with</span> specified consumer <span class="keyword">group</span> <span class="type">name</span>.</span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="built_in">new</span> DefaultMQPushConsumer("CID_PAY_ACCOUNT");</span><br><span class="line"></span><br><span class="line">    // Specify <span class="type">name</span> <span class="keyword">server</span> addresses.</span><br><span class="line">    consumer.setNamesrvAddr("10.211.55.4:9876;10.211.55.5:9876;10.211.55.6:9876");</span><br><span class="line"></span><br><span class="line">    // Subscribe one more more topics <span class="keyword">to</span> consume.</span><br><span class="line">    consumer.subscribe("PAY_ACCOUNT", "*");</span><br><span class="line">    // Register callback <span class="keyword">to</span> <span class="keyword">execute</span> <span class="keyword">on</span> arrival <span class="keyword">of</span> messages fetched <span class="keyword">from</span> brokers.</span><br><span class="line">    consumer.registerMessageListener(<span class="built_in">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="built_in">public</span> ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,</span><br><span class="line">            ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">            <span class="keyword">for</span> (MessageExt messageExt : msgs) &#123;</span><br><span class="line">                <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="built_in">new</span> String(messageExt.getBody()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //Launch the consumer instance.</span><br><span class="line">    consumer.<span class="keyword">start</span>();</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.printf("Consumer Started.%n");</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的改变是在Producer代码，我们需要额外编写一个实现执行本地事务逻辑，以及检查本地事务状态的类。示例代码如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">TransactionListenerImpl</span> <span class="symbol">implements</span> <span class="symbol">TransactionListener</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> AtomicInteger transactionIndex = new AtomicInteger(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; localTrans = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;</span><br><span class="line">        <span class="built_in">int</span> value = transactionIndex.getAndIncrement();</span><br><span class="line">        <span class="built_in">int</span> status = value % <span class="number">3</span>;</span><br><span class="line">        localTrans.put(msg.getTransactionId(), status);</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> LocalTransactionState checkLocalTransaction(MessageExt msg) &#123;</span><br><span class="line">        Integer status = localTrans.<span class="keyword">get</span>(msg.getTransactionId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != status) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Producer示例代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> TransactionProducerTest &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws MQClientException, InterruptedException &#123;</span><br><span class="line">        TransactionListener transactionListener = <span class="keyword">new</span> <span class="constructor">TransactionListenerImpl()</span>;</span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> <span class="constructor">TransactionMQProducer(<span class="string">"CID_PAY_ACCOUNT"</span>)</span>;</span><br><span class="line">        producer.set<span class="constructor">NamesrvAddr(<span class="string">"10.211.55.4:9876;10.211.55.5:9876;10.211.55.6:9876"</span>)</span>;</span><br><span class="line"> </span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> <span class="constructor">ThreadPoolExecutor(2, 5, 100, TimeUnit.SECONDS, <span class="params">new</span> ArrayBlockingQueue&lt;Runnable&gt;(2000)</span>, <span class="keyword">new</span> <span class="constructor">ThreadFactory()</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Thread <span class="keyword">new</span><span class="constructor">Thread(Runnable <span class="params">r</span>)</span> &#123;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">r</span>)</span>;</span><br><span class="line">                thread.set<span class="constructor">Name(<span class="string">"client-transaction-msg-check-thread"</span>)</span>;</span><br><span class="line">                return thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        producer.set<span class="constructor">ExecutorService(<span class="params">executorService</span>)</span>;</span><br><span class="line">        producer.set<span class="constructor">TransactionListener(<span class="params">transactionListener</span>)</span>;</span><br><span class="line">        producer.start<span class="literal">()</span>;</span><br><span class="line"> </span><br><span class="line">        String<span class="literal">[]</span> tags = <span class="keyword">new</span> String<span class="literal">[]</span> &#123;<span class="string">"TagA"</span>, <span class="string">"TagB"</span>, <span class="string">"TagC"</span>, <span class="string">"TagD"</span>, <span class="string">"TagE"</span>&#125;;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;String, String&gt; paramMap = <span class="keyword">new</span> HashMap&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">            paramMap.put(<span class="string">"type"</span>, <span class="string">"6"</span>);</span><br><span class="line">            paramMap.put(<span class="string">"bizOrderId"</span>, <span class="string">"15414012438257823"</span>);</span><br><span class="line">            paramMap.put(<span class="string">"payOrderId"</span>, <span class="string">"15414012438257823"</span>);</span><br><span class="line">            paramMap.put(<span class="string">"amount"</span>, <span class="string">"10"</span>);</span><br><span class="line">            paramMap.put(<span class="string">"userId"</span>, <span class="string">"200001"</span>);</span><br><span class="line">            paramMap.put(<span class="string">"tradeType"</span>, <span class="string">"charge"</span>);</span><br><span class="line">            paramMap.put(<span class="string">"financeStatus"</span>, <span class="string">"0"</span>);<span class="comment">//财务状态，应收</span></span><br><span class="line">            paramMap.put(<span class="string">"channel"</span>, <span class="string">"a"</span>);<span class="comment">//余额</span></span><br><span class="line">            paramMap.put(<span class="string">"tradeTime"</span>, <span class="string">"20190101202022"</span>);</span><br><span class="line">            paramMap.put(<span class="string">"nonce_str"</span>, <span class="string">"xkdkskskdksk"</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//拼凑消息体</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> <span class="constructor">Message(<span class="string">"PAY_ACCOUNT"</span>, <span class="string">"pre"</span>,<span class="params">paramMap</span>.<span class="params">toString</span>()</span>.get<span class="constructor">Bytes(RemotingHelper.DEFAULT_CHARSET)</span>);</span><br><span class="line">            SendResult sendResult = producer.send<span class="constructor">MessageInTransaction(<span class="params">msg</span>, <span class="params">null</span>)</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line"> </span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; catch (MQClientException <span class="pattern-match">| <span class="constructor">UnsupportedEncodingException</span> e) &#123;</span></span><br><span class="line"><span class="pattern-match">            e.print<span class="constructor">StackTrace()</span>;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match"> </span></span><br><span class="line"><span class="pattern-match">        <span class="constructor">Thread</span>.sleep(10<span class="operator">*</span>1000);</span></span><br><span class="line"><span class="pattern-match">        producer.shutdown();</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><p>与非事务消息直接调用RocketMQ Client的send方法不同，事务消息发送需要设置事务监听器类，并调用sendMessageInTransaction方法，而这个方法的具体逻辑也就是上述流程中描述的那样，具体大家可以看下。</p><h3 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h3><p>目前RocketMQ消息中间件的使用场景比较广泛，对于需要通过MQ进行异步解耦的分布式应用系统来说，RocketMQ无疑是一个不错的技术选择。接下来，我们就以<strong>对数据一致性要求非常高</strong>的分布式支付系统为例，来看看基于RocketMQ的事务消息适用于哪些特定场景，从而实现支付系统数据的高度一致性。</p><p>事实上，<strong>支付系统的数据一致性是一个复杂的问题</strong>，原因在于支付流程的各个环节都存在异步的不确定性，例如支付系统需要跟第三方渠道进行交互，不同的支付渠道交互流程存在差异，并且有异步支付结果回调的情况。</p><p>除此以外，支付系统内部本身又是由多个不同子系统组成，除核心支付系统外，还有账务系统、商户通知系统等等，而核心支付系统本身也会被拆分为多个不同的服务模块，如风控、路由等用以实现不同的功能逻辑。<strong>某些场景我们无法通过分布式事务来实现数据一致性，只能通过额外的业务补偿手段</strong>，如二次轮训、支付对账等来实现数据最终一致性。</p><p>综上所述，<strong>支付系统是一个复杂的系统，要完全实现数据的一致性单靠某一种手段是无法实现的</strong>，大部分情况下我们可以通过额外的业务补偿逻辑来实现数据最终一致性，只是这样补偿逻辑需要以更多的业务开发逻辑为代价，并且在时效性上会存在延迟的问题。</p><p>举个例子，支付核心系统支付成功后会更新自己的订单状态为支付成功，整个核心交易流程是一个比较实时同步的场景，如果出现数据不一致，<strong>会有额外的补偿逻辑如二次支付订单状态轮询、T+1日对账等用以确保支付状态数据的最终一致性</strong>。但是除了核心支付外，支付成功的结果是需要通知到支付账务系统、以及业务端系统，而为了确保性能，一般后续的通知就不会与主流程一样设计成实时同步，而是通过MQ异步解耦发送消息给独立的“通知响应模块”，而“<strong>通知响应模块</strong>”此时就可以通过分布式事务消息来与支付账户系统、业务端等系统实现数据一致性，从而<strong>减少需要补偿手段处理的范围，提高系统的数据一致性等级和灵敏度</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 芝士点心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> RocketMQ </tag>
            
            <tag> 最终一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven依赖本地jar包</title>
      <link href="/2020/03/14/java/maven%E4%BE%9D%E8%B5%96%E6%9C%AC%E5%9C%B0jar%E5%8C%85/"/>
      <url>/2020/03/14/java/maven%E4%BE%9D%E8%B5%96%E6%9C%AC%E5%9C%B0jar%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h3 id="项目情况"><a href="#项目情况" class="headerlink" title="项目情况"></a>项目情况</h3><p>没有搭建私仓，多模块依赖的父子模块（工程），需要依赖提供商提供的jar包。期望：</p><ol><li>在需要依赖该模块的模块下依赖，不将该jar影响其他模块</li><li>打包简单，在其他同事启动项目是不要手动处理这个jar包。</li></ol><p>本文介绍三种方式：</p><ol><li>打包时，将jar移至BOOT-INF</li><li>打包时，将jar安装至本地仓库</li><li>创建一个不同的本地仓库</li></ol><h3 id="将jar移至BOOT-INF"><a href="#将jar移至BOOT-INF" class="headerlink" title="将jar移至BOOT-INF"></a>将jar移至BOOT-INF</h3><h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><p>将jar放置需要依赖的模块下面。<br><img src="/images/java/maven-jar-1.png" alt="项目结构"></p><p>然后直接依赖就好了，groupId、artifactId、version，随意写，方便你认识就好。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;dependencies&gt;</span></span><br><span class="line">    <span class="params">&lt;dependency&gt;</span></span><br><span class="line">        <span class="params">&lt;groupId&gt;</span>com.alibaba<span class="params">&lt;/groupId&gt;</span></span><br><span class="line">        <span class="params">&lt;artifactId&gt;</span>taobao-sdk<span class="params">&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="params">&lt;version&gt;</span><span class="number">0.1</span><span class="params">&lt;/version&gt;</span></span><br><span class="line">        <span class="params">&lt;scope&gt;</span>system<span class="params">&lt;/scope&gt;</span></span><br><span class="line">        <span class="params">&lt;systemPath&gt;</span>$&#123;project.basedir&#125;<span class="meta-keyword">/lib/</span>taobao-sdk.jar<span class="params">&lt;/systemPath&gt;</span></span><br><span class="line">    <span class="params">&lt;/dependency&gt;</span></span><br><span class="line"><span class="params">&lt;/dependencies&gt;</span></span><br></pre></td></tr></table></figure><p>这是在你代码中已经可以i使用该jar了，但是启动会找不到类。还需要在打包时将该jar包放置BOOT-INF目录下。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;<span class="class"><span class="keyword">lib</span>&lt;/<span class="title">directory</span>&gt;</span></span><br><span class="line">            &lt;targetPath&gt;<span class="regexp">/BOOT-INF/lib</span><span class="regexp">/&lt;/target</span>Path&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;<span class="keyword">include</span>&gt;**<span class="regexp">/*.jar&lt;/include</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/includes&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/resource</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/resources&gt;</span></span><br><span class="line"><span class="regexp">&lt;/build</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h4><p>这种方案之所以推荐，是因为存在弊端，springboot的main提供没有问题，但是打成war使用tomcat启动会找不到类。要解决这个问题，需要在springboot的启动模块中，再引入该jar包，然后将其放置WEB-INF下。</p><h3 id="将jar安装至本地仓库-推荐"><a href="#将jar安装至本地仓库-推荐" class="headerlink" title="将jar安装至本地仓库(推荐)"></a>将jar安装至本地仓库(推荐)</h3><p>在 pom 文件中使用 maven-install-plugin 插件的方式，这种方式会在 maven initialize 阶段将相应的 jar 包安装到本地仓库，后续使用只需正常maven依赖即可。<strong>但是这个动作得在你所需要依赖的模块打包之前</strong>，我是新建一个模块用来完成这个动作，然后在所需要依赖模块中依赖新建的模块。</p><p>将jar包放置新建的模块的lib目录下，然后在pom中添加</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;build&gt;</span></span><br><span class="line">    <span class="params">&lt;plugins&gt;</span></span><br><span class="line">        <span class="params">&lt;plugin&gt;</span></span><br><span class="line">            <span class="params">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="params">&lt;/groupId&gt;</span></span><br><span class="line">            <span class="params">&lt;artifactId&gt;</span>maven-install-plugin<span class="params">&lt;/artifactId&gt;</span></span><br><span class="line">            <span class="params">&lt;version&gt;</span><span class="number">2.5</span><span class="params">&lt;/version&gt;</span></span><br><span class="line">            <span class="params">&lt;executions&gt;</span></span><br><span class="line">                <span class="params">&lt;execution&gt;</span></span><br><span class="line">                    <span class="params">&lt;phase&gt;</span>initialize<span class="params">&lt;/phase&gt;</span></span><br><span class="line">                    <span class="params">&lt;goals&gt;</span></span><br><span class="line">                        <span class="params">&lt;goal&gt;</span>install-file<span class="params">&lt;/goal&gt;</span></span><br><span class="line">                    <span class="params">&lt;/goals&gt;</span></span><br><span class="line">                    <span class="params">&lt;configuration&gt;</span></span><br><span class="line">                        <span class="params">&lt;groupId&gt;</span>com.alibaba<span class="params">&lt;/groupId&gt;</span></span><br><span class="line">                        <span class="params">&lt;artifactId&gt;</span>taobao-sdk<span class="params">&lt;/artifactId&gt;</span></span><br><span class="line">                        <span class="params">&lt;version&gt;</span><span class="number">0.1</span><span class="params">&lt;/version&gt;</span></span><br><span class="line">                        <span class="params">&lt;packaging&gt;</span>jar<span class="params">&lt;/packaging&gt;</span></span><br><span class="line">                        <span class="params">&lt;file&gt;</span>$&#123;project.basedir&#125;<span class="meta-keyword">/lib/</span>taobao-sdk.jar<span class="params">&lt;/file&gt;</span></span><br><span class="line">                    <span class="params">&lt;/configuration&gt;</span></span><br><span class="line">                <span class="params">&lt;/execution&gt;</span></span><br><span class="line">            <span class="params">&lt;/executions&gt;</span></span><br><span class="line">        <span class="params">&lt;/plugin&gt;</span></span><br><span class="line">    <span class="params">&lt;/plugins&gt;</span></span><br><span class="line"><span class="params">&lt;/build&gt;</span></span><br></pre></td></tr></table></figure><p>接着在所需要依赖jar包的模块中，直接依赖即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 新建的模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>taobao-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建一个不同的本地仓库"><a href="#创建一个不同的本地仓库" class="headerlink" title="创建一个不同的本地仓库"></a>创建一个不同的本地仓库</h3><p>不同在于 jar 包安装的仓库位置。假如我们有一个本地仓库，名称为 maven-repository,位置在 ${basedir}(pom.xml所在的根路径)。第一步要做的就是将 jar 包部署到本地仓库，如下所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy:deploy-file <span class="attribute">-Dfile</span>=&lt;path-to-file&gt; <span class="attribute">-DgroupId</span>=&lt;group-id&gt; <span class="attribute">-DartifactId</span>=&lt;artifact-id&gt; <span class="attribute">-Dversion</span>=&lt;version&gt; <span class="attribute">-Dpackaging</span>=jar <span class="attribute">-Durl</span>=file:./maven-repository/ <span class="attribute">-DrepositoryId</span>=maven-repository <span class="attribute">-DupdateReleaseInfo</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>通常 Maven 命令 deploy:deploy-file 会将 artificial 安装在远端仓库中，但是在本例子中仓库地址在本地。 添加完 jar 包后需要在对应的 pom 文件添加对应的仓库：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>maven-repository<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>file:///$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="xml">/maven-repository<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>然后添加对应的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>taobao-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 芝士点心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算-linux权限管理</title>
      <link href="/2020/03/12/java/%E4%BD%8D%E8%BF%90%E7%AE%97-linux%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>/2020/03/12/java/%E4%BD%8D%E8%BF%90%E7%AE%97-linux%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux基于位运算的权限控制"><a href="#Linux基于位运算的权限控制" class="headerlink" title="Linux基于位运算的权限控制"></a>Linux基于位运算的权限控制</h3><p>Linux权限控制是基于位运算实现的。</p><p>在Linux权限系统中，读、写、执行权限分别对应三个状态位：</p><table><thead><tr><th>读</th><th>写</th><th>执行</th><th>==&gt;</th><th>二进制</th><th>==&gt;</th><th>十进制</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>==&gt;</td><td>001</td><td>==&gt;</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td><td>==&gt;</td><td>010</td><td>==&gt;</td><td>2</td></tr><tr><td>1</td><td>0</td><td>0</td><td>==&gt;</td><td>100</td><td>==&gt;</td><td>4</td></tr><tr><td>0</td><td>1</td><td>1</td><td>==&gt;</td><td>011</td><td>==&gt;</td><td>3</td></tr><tr><td>1</td><td>0</td><td>1</td><td>==&gt;</td><td>101</td><td>==&gt;</td><td>5</td></tr><tr><td>1</td><td>1</td><td>0</td><td>==&gt;</td><td>110</td><td>==&gt;</td><td>6</td></tr><tr><td>1</td><td>1</td><td>1</td><td>==&gt;</td><td>111</td><td>==&gt;</td><td>7</td></tr></tbody></table><p>如上所示</p><ul><li>“执行”权限使用二进制为001，即：十进制1。</li><li>“写入”权限使用二进制为010，即：十进制2。</li><li>“读取”权限使用二进制为100，即：十进制4。</li></ul><h3 id="实现权限的添加-或运算"><a href="#实现权限的添加-或运算" class="headerlink" title="实现权限的添加(或运算)"></a>实现权限的添加(或运算)</h3><p>增加权限使用或（|）运算实现。</p><p>如，为用户增加“读取”、“写入”两种权限</p><table><thead><tr><th>读</th><th>写</th><th>执行</th><th>==&gt;</th><th>二进制</th><th>==&gt;</th><th>十进制</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>==&gt;</td><td>000</td><td>==&gt;</td><td>0</td><td>已有权限（没有任何权限）</td></tr><tr><td>1</td><td>0</td><td>0</td><td>==&gt;</td><td>100</td><td>==&gt;</td><td>4</td><td>待增加的权限，读</td></tr><tr><td>0</td><td>1</td><td>0</td><td>==&gt;</td><td>010</td><td>==&gt;</td><td>2</td><td>待增加的权限，写</td></tr></tbody></table><p>用户现有的权限码为0，为其增加“读取”、“写入”两种权限，即4，2<br>使用或运算结果如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>|<span class="number">4</span>=<span class="number">4</span> <span class="comment">//增加读取权限</span></span><br><span class="line"><span class="number">4</span>|<span class="number">2</span>=<span class="number">6</span> <span class="comment">//增加写入权限</span></span><br></pre></td></tr></table></figure><h3 id="实现权限的减少（非运算）"><a href="#实现权限的减少（非运算）" class="headerlink" title="实现权限的减少（非运算）"></a>实现权限的减少（非运算）</h3><p>位运算同样可以实现用户权限的减少，减少用户权限使用非（^）运算。<br>如，将权限码为7用户，移除执行权限：</p><table><thead><tr><th>读</th><th>写</th><th>执行</th><th>==&gt;</th><th>二进制</th><th>==&gt;</th><th>十进制</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>==&gt;</td><td>111</td><td>==&gt;</td><td>7</td><td>已有权限</td></tr><tr><td>1</td><td>0</td><td>0</td><td>==&gt;</td><td>100</td><td>==&gt;</td><td>4</td><td>待判断的权限，读</td></tr></tbody></table><p>权限码7（111）和1（001）的非运算结果为6，即：7^1=6。<br>权限码6，则为权限码7移除执行后的权限码。</p><h3 id="实现权限的判断（与运算）"><a href="#实现权限的判断（与运算）" class="headerlink" title="实现权限的判断（与运算）"></a>实现权限的判断（与运算）</h3><p>在需要进行用户权限判断时，可以使用与（&amp;）运算判断用户是否具有某项权限。</p><p>如，判断权限码为6用户是否有“读取”，“执行”权限：</p><table><thead><tr><th>读</th><th>写</th><th>执行</th><th>==&gt;</th><th>二进制</th><th>==&gt;</th><th>十进制</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0</td><td>==&gt;</td><td>110</td><td>==&gt;</td><td>6</td><td>已有权限</td></tr><tr><td>1</td><td>0</td><td>0</td><td>==&gt;</td><td>100</td><td>==&gt;</td><td>4</td><td>待判断的权限，读</td></tr><tr><td>0</td><td>0</td><td>1</td><td>==&gt;</td><td>001</td><td>==&gt;</td><td>1</td><td>待判断的权限，执行</td></tr></tbody></table><p>权限码6（110）和4（100）的与运算结果为4，即：6&amp;4=4。<br>权限码6（110）和1（001）的与运算结果为0，即：0=6&amp;1。</p><p>根据与运算的计算规律，当运算结果为所要判断权限本身值时，我们可以认为用户具有这个权限。而当运算结果为 0 时，我们可以认为用户不具有这个权限。</p><h3 id="优点和缺陷"><a href="#优点和缺陷" class="headerlink" title="优点和缺陷"></a>优点和缺陷</h3><p>位运算的运算对象是二进制的位，速度快，效率高，而且节省存储空间，位运算做权限控制又相当地灵活。但是，位运算也有很大的局限，因为在32位计算机上，位移不能超过32次，这就要求权限数量不超过32种。而mySQL数据库的BIGINT，其存储空间为8Byte，使用BIGINT存储存储码时，权限数不能多于64个(8*8-1)。</p>]]></content>
      
      
      <categories>
          
          <category> 芝士点心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>埋点-淘宝SPM流量跟踪体系</title>
      <link href="/2020/03/09/java/%E5%9F%8B%E7%82%B9-%E6%B7%98%E5%AE%9DSPM%E6%B5%81%E9%87%8F%E8%B7%9F%E8%B8%AA%E4%BD%93%E7%B3%BB/"/>
      <url>/2020/03/09/java/%E5%9F%8B%E7%82%B9-%E6%B7%98%E5%AE%9DSPM%E6%B5%81%E9%87%8F%E8%B7%9F%E8%B8%AA%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>本文转载：<a href="https://www.biaodianfu.com/spm.html" target="_blank" rel="noopener">https://www.biaodianfu.com/spm.html</a></p><h3 id="什么是SPM"><a href="#什么是SPM" class="headerlink" title="什么是SPM"></a>什么是SPM</h3><p>SPM是淘宝社区电商业务（xTao）为外部合作伙伴（外站）提供的一套跟踪引导成交效果数据的解决方案。下面是一个跟踪点击到宝贝详情页的引导成交效果数据的SPM示例：<a href="http://detail.tmall.com/item.htm?id=3716461318&amp;&amp;spm=2014.123456789.1.2" target="_blank" rel="noopener">http://detail.tmall.com/item.htm?id=3716461318&amp;&amp;spm=2014.123456789.1.2</a> 其中spm=2014.123456789.1.2 便是下文所说的SPM编码。</p><p>SPM编码：用来跟踪页面模块位置的编码，标准spm编码由4段组成，采用a.b.c.d的格式（建议全部使用数字），其中，</p><ul><li>a代表站点类型，对于xTao合作伙伴（外站），a为固定值，a=2014</li><li>b代表外站ID（即外站所使用的TOP appkey），比如您的站点使用的TOP appkey=123456789，则b=123456789</li><li>c代表b站点上的频道ID，比如是外站某个团购频道，某个逛街频道，某个试用频道 等</li><li>d代表c频道上的页面ID，比如是某个团购详情页，某个宝贝详情页，某个试用详情页 等</li></ul><p>如果是站内，则SPM编码会有第五个参数，具体为：</p><ul><li>a：网站ID，每一个单独的网站（域名），分配唯一的ID，如<a href="http://www.taobao.com的aID为1，list.taobao.com的aID为a217f，item.taobao.com的aID为a217v，tmall是3，聚划算是608，搜索是a230r" target="_blank" rel="noopener">www.taobao.com的aID为1，list.taobao.com的aID为a217f，item.taobao.com的aID为a217v，tmall是3，聚划算是608，搜索是a230r</a></li><li>b：网页ID，为同一个网站下每一个网页，分配唯一的ID，页面A ID为7274553，页面BID为7289245</li><li>c：频道ID，为网站中不同区域划分频道，每个频道分配唯一ID，</li><li>d：产品ID，为每个频道内的每个独立产品，分配唯一ID</li><li>e：同一个链接请求，为每次请求分配一个随机特征码，保证每次点击spm值的唯一性。</li></ul><p>注意：spm的四位总长度32位，并且不支持%、&amp;等特殊字符，请尽量使用英文以及数字</p><p>SPM的应用场景因为spm编码本身是有层次的，因此，我们可以：</p><ul><li>单独统计spm的a部分，我们可以知道某一类站点的访问和点击情况，以及后续引导和成交情况。</li><li>单独统计spm的a.b部分，我们可以用来评估某一个站点的访问和点击效果，以及后续引导和成交情况。</li><li>单独统计spm的a.b.c部分，我们可以用来评估某一个站点上某一频道的访问和点击效果，以及后续引导和成交情况。</li><li>单独统计spm的a.b.c.d部分，我们可以用来评估某一个频道上某一具体页面的点击效果，以及后续引导和成交情况。</li></ul><p>SPM的效果指标和数据查看基于SPM可以得到的效果统计指标：</p><ul><li>PV：通过指定spm编码引导到宝贝详情页面的PV</li><li>UV：通过指定spm编码引导到宝贝详情页面的UV</li><li>支付宝成交人数：通过指定spm编码引导到宝贝详情页面的用户当天对同店商品的支付宝成交人数</li><li>支付宝成交笔数：通过指定spm编码引导到宝贝详情页面的用户当天对同店商品的支付宝成交笔数</li><li>支付宝成交金额：通过指定spm编码引导到宝贝详情页面的用户当天对同店商品的支付宝成交金额</li><li>客单价=支付宝成交金额/支付宝成交人数，代表通过指定spm编码引导过来的购买用户的消费能力</li><li>转化率=支付宝成交人数/UV，代表通过指定spm编码引导的用户最终转化为购买用户的比率</li></ul><p>除此之外，还有许多其他参数，分别代表其他含义或者适用于其他业务统计需求。如pos代表的是位置，另外一个比较重要的参数为：scm=1003.632.1102.1</p><ul><li>1003：投放系统ID，比如1003标识阿拉丁投放系统</li><li>632：算法ID，标识投放的具体算法</li><li>1102：标识投放算法的版本信息</li><li>1：标示投放针对的具体投放人群分类等信息</li></ul><p>类似的跟踪方式还有凡客的体系，凡客与淘宝最主要的区别是跟踪参数ref的参数一直有继承，即是下一个点击会继承上一个点击产生ref，目前是继承到10级，然后就开始从原始的减少，一直保持10级。具体如下：<br><a href="http://item.vancl.com/2810450.html#ref=hp-hp-yc-1_1-v:n|hp-hp-head-logo-v:n|s-s-c_rs_28806-1_3-6373505_Sort01_qb_000-v|hp-hp-classman-3_2-v:n" target="_blank" rel="noopener">http://item.vancl.com/2810450.html#ref=hp-hp-yc-1_1-v:n|hp-hp-head-logo-v:n|s-s-c_rs_28806-1_3-6373505_Sort01_qb_000-v|hp-hp-classman-3_2-v:n</a></p><h3 id="SPM体系有何作用"><a href="#SPM体系有何作用" class="headerlink" title="SPM体系有何作用"></a>SPM体系有何作用</h3><p>流量实现精准定位</p><ul><li>流量可以标识到频道、页面、区块、位置任意层级</li><li>资源位的稳定唯一标识意味着效果可持续跟踪</li><li>位置和内容的分离标识，将土地和庄稼分开评估</li></ul><p>运算资源消耗降低</p><ul><li>通过编码的配置圈定多样的流量业务归属</li><li>CPU运算资源的大幅度减低</li></ul><p>建立效果评估体系</p><ul><li>流量资源价值的统一评估标准</li><li>建立以资源位为中心的数据体系和运营体系</li></ul><p>流量运营的宏观调控+市场经济时代</p><ul><li>资源位估值和定价</li><li>资源位的分层管理和运营</li><li>资源位商业化通道和流动机制</li><li>资源位竞价和排期</li></ul><p>如何搭建SPM体系</p><ul><li>流程约定 — 通过侵入页面发布流程，规范打点过程</li><li>工具支持 — 提供低成本进行流量资源布点工具集</li><li>技术保障 — 用户点击链接时，由全局js生成标识编码，有效避免标识重复和疏漏<br><img src="/images/java/SPM.jpg" alt="spm"></li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>1、统计投放效果<br>如一个双11的广告页需要投放到微博、知乎和优酷等渠道，只需要为每个渠道指定一个编码，后续可以统计每个渠道的投放效果，事后按流量计费进行费用结算。</p><p>2、分析用户行为<br>假设现在有一个淘宝女装的专题页，为了进行活动引流，会在淘宝首页多处区块放置引流入口，怎么统计各个入口进行淘宝女装专题的量呢，以便后续进行优化提高入口曝光度？</p><p>一种常见的思路是每个入口进行布点，当用户进行点击时，同时向日志服务器发送一条埋点日志。但是这个方案有天然的弊端：<br>（1）在页面跳转时，埋点日志请求可能会丢失<br>（2）日志请求过多。</p><p>SPM通过指定编码解决了这个问题，只需要进入页面的时发送一次埋点日志请求即可。</p><p>3、分析链路转化<br>如新用户的注册过程中，往往包含多个步骤，输入账号，验证手机，设置密码和上传头像等等，这么长的链路过程中，任何一个产品或者技术优化，都可能直接作用到用户的流失率，为了直观的看到这个效果，一般会采用漏斗图。而SPM的采集数据包括了精细化的来源数据，可以做出丰富的漏斗图出来分析链路转化率问题。</p>]]></content>
      
      
      <categories>
          
          <category> 芝士点心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 埋点 </tag>
            
            <tag> SPM </tag>
            
            <tag> 行为分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo番外篇-bug之【aop失效】</title>
      <link href="/2020/01/07/java/dubbo%E7%95%AA%E5%A4%96%E7%AF%87-bug%E4%B9%8B%E3%80%90aop%E5%A4%B1%E6%95%88%E3%80%91/"/>
      <url>/2020/01/07/java/dubbo%E7%95%AA%E5%A4%96%E7%AF%87-bug%E4%B9%8B%E3%80%90aop%E5%A4%B1%E6%95%88%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>本文浅述：在使用dubbo时，spring aop失效问题。如果你也遇到该问题，先检查是否使用@Reference注入dubbo服务的。</p><h3 id="场景还原"><a href="#场景还原" class="headerlink" title="场景还原"></a>场景还原</h3><p><strong>版本</strong>：我使用的dubbo版本是2.6.<br><strong>场景</strong>：我想消费者在调用我的dubbo接口时，都将自己应用名传过来，方便我鉴权，所以我在我提供的二方包中，提供aop，想通过dubbo的附加参数，将应用名传过来。大致代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxxx.service;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XxxxService</span> </span>&#123;</span><br><span class="line">    DicResponseDTO&lt;List&lt;String&gt;&gt; getAllFormKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxAspect</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Around</span>(<span class="string">"execution(* com.xxxx.service.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundApi</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">         <span class="comment">// todo set attachment param</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> XxxxService xxxxServiceRe;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object allFormKey =</span><br><span class="line">                xxxxServiceRe.getAllFormKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后肯定没有如我所愿，要不然也不会有这一篇文章了。现象呢，始终走不到aop中。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>一切看起来很奇怪，我还特地验证了会不会因为我切入的是interface的问题。我在消费者项目中新建一个接口，然后用aop切人，用@Autowired注入，调用时aop能正常工作。</p><p>那么aop切入点是dubbo的接口时，为什么就走不到aop呢？这两个case对于调用者来说，唯一的区别就是一个用@Reference注入，一个用@Autowired注入。正好我也想看一下dubbo的@Reference的工作原理，就趁此机会看一眼。</p><p>废话不说，ctrl+shift+f搜索“Reference.class”，我找到了DubboConsumerAutoConfiguration，看到代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DubboConsumerAutoConfiguration</span> <span class="keyword">extends</span> <span class="title">DubboCommonAutoConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> static <span class="keyword">final</span> <span class="type">Map</span>&lt;<span class="type">ClassIdBean</span>, <span class="type">Object</span>&gt; <span class="type">DUBBO_REFERENCES_MAP</span> =</span><br><span class="line">      <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>&lt;<span class="type">ClassIdBean</span>, <span class="type">Object</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  public <span class="type">BeanPostProcessor</span> beanPostProcessor() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">BeanPostProcessor</span>() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      public <span class="type">Object</span> postProcessBeforeInitialization(<span class="type">Object</span> bean, <span class="type">String</span> beanName)</span><br><span class="line">          <span class="keyword">throws</span> <span class="type">BeansException</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">Field</span> field : objClz.getDeclaredFields()) &#123;</span><br><span class="line">            <span class="type">Reference</span> reference = field.getAnnotation(<span class="type">Reference</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (reference != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="type">DubboConsumerAutoConfiguration</span>.<span class="keyword">this</span></span><br><span class="line">                  .initIdConfigMap(<span class="type">DubboConsumerAutoConfiguration</span>.<span class="keyword">this</span>.properties);</span><br><span class="line">              <span class="type">ReferenceBean</span>&lt;?&gt; referenceBean =</span><br><span class="line">                  <span class="type">DubboConsumerAutoConfiguration</span>.<span class="keyword">this</span>.getConsumerBean(beanName, field, reference);</span><br><span class="line">  <span class="type">Object</span> dubboReference = ...;</span><br><span class="line">              field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">              field.set(bean, dubboReference);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">BeanCreationException</span>(beanName, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">      &#125;</span><br><span class="line">     ...</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，Reference是想通过spring注入BeanPostProcessor，在spring bean创建之后、初始化之前，将标注了@Reference注解的字段，为其new一个ReferenceBean，并保存application、registry等参数。而ReferenceBean实现了FactoryBean，则可以通过getObject()返回该字段的对象，当然其中还有缓存啥的，各位可以自己了解。然后拿到这个对象之后，通过反射调用field.set(bean, dubboReference)来注入。</p><p>至此，@Reference工作原理到此解释详尽。那么回顾aop。aop是spring提供的功能，再看看@Reference工作原理跟spring有半毛钱关系嘛？是不是完全没有经过spring 的 ioc ，那么spring怎么能给你实现aop的功能呢！！！！</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="注入ioc中的bean"><a href="#注入ioc中的bean" class="headerlink" title="注入ioc中的bean"></a>注入ioc中的bean</h4><p>明白了原因了，那么我们就避免使用@Reference，然后用spring 的 @Autowired注入不就行了嘛。于是我用xml+@Autowired进行以下测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference <span class="class"><span class="keyword">interface</span></span>=<span class="string">"com.xxxx.service.XxxxService"</span> id=<span class="string">"xxxService"</span> check=<span class="string">"false"</span></span><br><span class="line">        timeout=<span class="string">"5000"</span> retries=<span class="string">"-1"</span>/&gt;</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> XxxxService xxxxServiceRe;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object allFormKey =</span><br><span class="line">                xxxxServiceRe.getAllFormKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这次结果肯定是令我满意的，aop工作的很好，那么我做的是中台应用，要是对方不愿意使用xml+@Autowired注入怎么办呢？</p><h4 id="自己解决不了就抛出去"><a href="#自己解决不了就抛出去" class="headerlink" title="自己解决不了就抛出去"></a>自己解决不了就抛出去</h4><p>哈哈，在dubbo群里有小伙伴，可能看到聊天记录了，在很久之前我就把它抛给小马哥了。还挺佩服阿里的工作效率的，我当天说完，提完issue，当天就定为新特性，第二天就fix掉了。</p><p>issue：<a href="https://github.com/apache/dubbo/issues/5446" target="_blank" rel="noopener">https://github.com/apache/dubbo/issues/5446</a><br>pr：<a href="https://github.com/apache/dubbo/pull/5454" target="_blank" rel="noopener">https://github.com/apache/dubbo/pull/5454</a></p><p>该问题在 2.7.6 中，当作新特性上线，大家也可以升级到这个版本，来解决这一问题。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> dubbo </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring源码之IOC - 注解 - 注册指定bean定义</title>
      <link href="/2019/11/23/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20%E6%B3%A8%E8%A7%A3%20-%20%E6%B3%A8%E5%86%8C%E6%8C%87%E5%AE%9Abean%E5%AE%9A%E4%B9%89/"/>
      <url>/2019/11/23/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20%E6%B3%A8%E8%A7%A3%20-%20%E6%B3%A8%E5%86%8C%E6%8C%87%E5%AE%9Abean%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>上一章总结到，AnnotationConfigApplicationContext提供两种方式注册bean，一是注册指定的bean，二是扫描指定的包。本章主要描述前者的过程。</p><h3 id="注册指定的bean"><a href="#注册指定的bean" class="headerlink" title="注册指定的bean"></a>注册指定的bean</h3><p>AnnotatedBeanDefinitionReader.register()向容器注册指定bean。该方法完成整个过程的调用，其总结步骤如下</p><ol><li>解析元数据信息，如作用域</li><li>对bean定义的通用注解处理</li><li>对qualifiers数据处理</li><li>根据作用域创建代理对象</li><li>注册BeanDefinition</li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> register(<span class="keyword">Class</span>&lt;?&gt;... annotatedClasses) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">Class</span>&lt;?&gt; annotatedClass : annotatedClasses) &#123;</span><br><span class="line">registerBean(annotatedClass);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> registerBean(<span class="keyword">Class</span>&lt;?&gt; annotatedClass) &#123;</span><br><span class="line">doRegisterBean(annotatedClass, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="keyword">void</span> doRegisterBean(<span class="keyword">Class</span>&lt;T&gt; annotatedClass, @Nullable Supplier&lt;T&gt; instanceSupplier, @Nullable String name,</span><br><span class="line">@Nullable <span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> Annotation&gt;[] qualifiers, BeanDefinitionCustomizer... definitionCustomizers) &#123;</span><br><span class="line"><span class="comment">// 创建BeanDefinition的实现对象，用于封装配置信息</span></span><br><span class="line">AnnotatedGenericBeanDefinition abd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(annotatedClass);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abd.setInstanceSupplier(instanceSupplier);</span><br><span class="line"><span class="comment">// 解析作用域，例如@Scoper("singleton")</span></span><br><span class="line">ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line"><span class="comment">// 保存到BeanDefinition对象中</span></span><br><span class="line">abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line"><span class="comment">// 为bean生成名字</span></span><br><span class="line">String beanName = (name != <span class="keyword">null</span> ? name : <span class="keyword">this</span>.beanNameGenerator.generateBeanName(abd, <span class="keyword">this</span>.registry));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理通用bean定义注解，如@Lazy、@Primary</span></span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line"><span class="comment">// 对@Qualifier处理，如果自动装配配置了该注解，则使用该注解名字进行装配</span></span><br><span class="line"><span class="keyword">if</span> (qualifiers != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> Annotation&gt; qualifier : qualifiers) &#123;</span><br><span class="line"><span class="comment">// 如果配置了@Primary，则使用该bean进行注入</span></span><br><span class="line"><span class="keyword">if</span> (Primary.<span class="keyword">class</span> == qualifier) &#123;</span><br><span class="line">abd.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果配置了@Lazy，则设置延迟加载</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Lazy.<span class="keyword">class</span> == qualifier) &#123;</span><br><span class="line">abd.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不是@Primary、@Lazy注解，则为bean添加自动装配时的限定符，既：根据名字进行装配</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">abd.addQualifier(<span class="keyword">new</span> AutowireCandidateQualifier(qualifier));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (BeanDefinitionCustomizer customizer : definitionCustomizers) &#123;</span><br><span class="line">customizer.customize(abd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将BeanDefinition封装成Holder对象，用于方便注册。</span></span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(abd, beanName);</span><br><span class="line"><span class="comment">//根据bean的作用域（singleton、prototype） 创建代理对象</span></span><br><span class="line">definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line"><span class="comment">// 像IOC注册BeanDefinition</span></span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析元数据信息"><a href="#解析元数据信息" class="headerlink" title="解析元数据信息"></a>解析元数据信息</h3><p>该过程由AnnotationScopeMetadataResolver.resolveScopeMetadata()实现，主要用于解析bean是原生类型（prototype）还是单例类型（singleton）。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function">ScopeMetadata <span class="title">resolveScopeMetadata</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">ScopeMetadata metadata = <span class="keyword">new</span> ScopeMetadata();</span><br><span class="line"><span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;</span><br><span class="line"><span class="comment">// annDef.getMetadata()在AnnotatedBeanDefinition构造中初始化的，用数组存储着bean所标注的注解，管理着所有注解和注解的值.</span></span><br><span class="line"><span class="comment">// 从所有的注解中获取scope的值，即@Scope注解的值</span></span><br><span class="line">AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(</span><br><span class="line">annDef.getMetadata(), <span class="keyword">this</span>.scopeAnnotationType);</span><br><span class="line"><span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 将Scope中的值保存到返回值中</span></span><br><span class="line">metadata.setScopeName(attributes.getString(<span class="string">"value"</span>));</span><br><span class="line">ScopedProxyMode proxyMode = attributes.getEnum(<span class="string">"proxyMode"</span>);</span><br><span class="line"><span class="keyword">if</span> (proxyMode == ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">proxyMode = <span class="keyword">this</span>.defaultProxyMode;</span><br><span class="line">&#125;</span><br><span class="line">metadata.setScopedProxyMode(proxyMode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理通用注解"><a href="#处理通用注解" class="headerlink" title="处理通用注解"></a>处理通用注解</h3><p>这里为啥叫通用注解，我其实觉得不太合适，我就是英文直译过来的。因为在我看来通用注解不应该只包含@Lazy、@Primary、@DependsOn。或者从某个角度来说，所有注解都应该通用。不过好像除了通用能简单描述一下，好像也没有其他更合适的词了。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static void process<span class="constructor">CommonDefinitionAnnotations(AnnotatedBeanDefinition <span class="params">abd</span>)</span> &#123;</span><br><span class="line">process<span class="constructor">CommonDefinitionAnnotations(<span class="params">abd</span>, <span class="params">abd</span>.<span class="params">getMetadata</span>()</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void process<span class="constructor">CommonDefinitionAnnotations(AnnotatedBeanDefinition <span class="params">abd</span>, AnnotatedTypeMetadata <span class="params">metadata</span>)</span> &#123;</span><br><span class="line"><span class="comment">// 处理@Lazy注解</span></span><br><span class="line">AnnotationAttributes <span class="keyword">lazy</span> = attributes<span class="constructor">For(<span class="params">metadata</span>, Lazy.<span class="params">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">lazy</span> != null) &#123;</span><br><span class="line">abd.set<span class="constructor">LazyInit(<span class="params">lazy</span>.<span class="params">getBoolean</span>(<span class="string">"value"</span>)</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (abd.get<span class="constructor">Metadata()</span> != metadata) &#123;</span><br><span class="line"><span class="comment">// 这里我选择的这个流程，通过重载方法进来的，二者一定相等。</span></span><br><span class="line"><span class="keyword">lazy</span> = attributes<span class="constructor">For(<span class="params">abd</span>.<span class="params">getMetadata</span>()</span>, <span class="module-access"><span class="module"><span class="identifier">Lazy</span>.</span></span><span class="keyword">class</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">lazy</span> != null) &#123;</span><br><span class="line">abd.set<span class="constructor">LazyInit(<span class="params">lazy</span>.<span class="params">getBoolean</span>(<span class="string">"value"</span>)</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理@Primary注解，标记自动装配时首选该bean</span></span><br><span class="line"><span class="keyword">if</span> (metadata.is<span class="constructor">Annotated(Primary.<span class="params">class</span>.<span class="params">getName</span>()</span>)) &#123;</span><br><span class="line">abd.set<span class="constructor">Primary(<span class="params">true</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @DependsOn注解，用于标注该bean所依赖的其他bean</span></span><br><span class="line"><span class="comment">// 在实例化该bean之前，spring会先实例化它所依赖的bean</span></span><br><span class="line">AnnotationAttributes dependsOn = attributes<span class="constructor">For(<span class="params">metadata</span>, DependsOn.<span class="params">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (dependsOn != null) &#123;</span><br><span class="line">abd.set<span class="constructor">DependsOn(<span class="params">dependsOn</span>.<span class="params">getStringArray</span>(<span class="string">"value"</span>)</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (abd instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">AbstractBeanDefinition absBd = (AbstractBeanDefinition) abd;</span><br><span class="line">AnnotationAttributes role = attributes<span class="constructor">For(<span class="params">metadata</span>, Role.<span class="params">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (role != null) &#123;</span><br><span class="line">absBd.set<span class="constructor">Role(<span class="params">role</span>.<span class="params">getNumber</span>(<span class="string">"value"</span>)</span>.<span class="built_in">int</span><span class="constructor">Value()</span>);</span><br><span class="line">&#125;</span><br><span class="line">AnnotationAttributes description = attributes<span class="constructor">For(<span class="params">metadata</span>, Description.<span class="params">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (description != null) &#123;</span><br><span class="line">absBd.set<span class="constructor">Description(<span class="params">description</span>.<span class="params">getString</span>(<span class="string">"value"</span>)</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据作用域创建代理对象"><a href="#根据作用域创建代理对象" class="headerlink" title="根据作用域创建代理对象"></a>根据作用域创建代理对象</h3><p>这个方法存在的意义是为了区分使用jdk代理还是cglib代理，这里主要为引入AOP埋下伏笔，主要还是在AOP中使用。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BeanDefinitionHolder applyScopedProxyMode(</span><br><span class="line">ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刚刚所获取的元数据信息</span></span><br><span class="line">ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();</span><br><span class="line"><span class="comment">// 如果proxy-mode的值为NO，表示不需要代理</span></span><br><span class="line"><span class="keyword">if</span> (scopedProxyMode.equals(ScopedProxyMode.NO)) &#123;</span><br><span class="line"><span class="keyword">return</span> definition;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断设置的值是TARGET_CLASS，还是INTERFACES</span></span><br><span class="line"><span class="keyword">boolean</span> proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);</span><br><span class="line"><span class="comment">// 根据是为INTERFACES，判断使用JDK动态代理还是CGLIB来生成代理对象</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> ScopedProxyCreator.<span class="title">createScopedProxy</span><span class="params">(definition, registry, proxyTargetClass)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册BeanDefinition"><a href="#注册BeanDefinition" class="headerlink" title="注册BeanDefinition"></a>注册BeanDefinition</h3><p>向IOC中注册BeanDefinition跟XML一样，都调用的是BeanDefinitionReaderUtils.registerBeanDefinition()。<a href="https://www.ofcoder.com/2019/11/19/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20xml%20-%20%E6%B3%A8%E5%86%8CBeanDefinition/">spring源码之IOC - xml - 注册BeanDefinition</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整体来说，注解配置bean比XML要简单，在spring内部实现也要简单。没有复杂的xml解析过程，对应的Class属性值、id、name，都能直接获取的到，然后将其保存在BeanDefinition中，并注册IOC就完成了容器启动。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
            <tag> IOC </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring源码之IOC - 注解 - 扫描指定的包</title>
      <link href="/2019/11/23/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20%E6%B3%A8%E8%A7%A3%20-%20%E6%89%AB%E6%8F%8F%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8C%85/"/>
      <url>/2019/11/23/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20%E6%B3%A8%E8%A7%A3%20-%20%E6%89%AB%E6%8F%8F%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>AnnotationConfigApplicationContext另一种方式，可以直接传入所需扫描的包。该容器会将扫描该包及其子包下所有类，并通过默认的过滤器将配置了@Component、@Service等注解的类转换成BeanDefinition，并注册。</p><h3 id="开始扫描"><a href="#开始扫描" class="headerlink" title="开始扫描"></a>开始扫描</h3><p>整体来说，扫描包跟注册指定bean，多了一个步骤就是：根据包扫描到BeanDefinition。后续两者相差不多。即：</p><ol start="0"><li>扫描指定包下的类</li><li>解析元数据信息，如作用域</li><li>对bean定义的通用注解处理</li><li>对qualifiers数据处理（扫描包没有该步骤）</li><li>根据作用域创建代理对象</li><li>注册BeanDefinition</li></ol><p>上述步骤，1、2、4、5、6跟注册指定bean一致，可前往上一章查看，本章的目的则在于简述第0步。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">int</span> scan(String... basePackages) &#123;</span><br><span class="line"><span class="comment">// 获取容器中已注册BeanDefinition个数</span></span><br><span class="line"><span class="built_in">int</span> beanCountAtScanStart = this.registry.get<span class="constructor">BeanDefinitionCount()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动扫描</span></span><br><span class="line"><span class="keyword">do</span><span class="constructor">Scan(<span class="params">basePackages</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊注册注解配置（annotation config）处理器</span></span><br><span class="line"><span class="keyword">if</span> (this.includeAnnotationConfig) &#123;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">AnnotationConfigUtils</span>.</span></span>register<span class="constructor">AnnotationConfigProcessors(<span class="params">this</span>.<span class="params">registry</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回本次所注册的BeanDefinition个数</span></span><br><span class="line">return (this.registry.get<span class="constructor">BeanDefinitionCount()</span> - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Set&lt;BeanDefinitionHolder&gt; <span class="keyword">do</span><span class="constructor">Scan(String<span class="operator">...</span> <span class="params">basePackages</span>)</span> &#123;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Assert</span>.</span></span>not<span class="constructor">Empty(<span class="params">basePackages</span>, <span class="string">"At least one base package must be specified"</span>)</span>;</span><br><span class="line"><span class="comment">// 存放所有扫描到的BeanDefinition</span></span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;<span class="literal">()</span>;</span><br><span class="line"><span class="comment">// 遍历指定的包</span></span><br><span class="line">for (String basePackage : basePackages) &#123;</span><br><span class="line"><span class="comment">// 调用父类方法，扫描BeanDefinition</span></span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = find<span class="constructor">CandidateComponents(<span class="params">basePackage</span>)</span>;</span><br><span class="line"><span class="comment">// 遍历所扫描到的BeanDefinition，后续就跟注册指定bean有点像了。</span></span><br><span class="line">for (BeanDefinition candidate : candidates) &#123;</span><br><span class="line"><span class="comment">// 获取@Scope的值，即作用域。</span></span><br><span class="line">ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolve<span class="constructor">ScopeMetadata(<span class="params">candidate</span>)</span>;</span><br><span class="line">candidate.set<span class="constructor">Scope(<span class="params">scopeMetadata</span>.<span class="params">getScopeName</span>()</span>);</span><br><span class="line"><span class="comment">// 生成bean的名字</span></span><br><span class="line">String beanName = this.beanNameGenerator.generate<span class="constructor">BeanName(<span class="params">candidate</span>, <span class="params">this</span>.<span class="params">registry</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果扫描到的bean不是注解bean，则为bena设置默认值，即bean的自动依赖注入属性。</span></span><br><span class="line"><span class="keyword">if</span> (candidate instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">post<span class="constructor">ProcessBeanDefinition((AbstractBeanDefinition)</span> candidate, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果扫描到的bean是注解bean，则处理其通用注解@Lazy、@Primary等</span></span><br><span class="line"><span class="keyword">if</span> (candidate instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line"><span class="comment">// 在上一章已经简述了</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">AnnotationConfigUtils</span>.</span></span>process<span class="constructor">CommonDefinitionAnnotations((AnnotatedBeanDefinition)</span> candidate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据bean名字检查bean是否需要注册，是否在容器中存在冲突</span></span><br><span class="line"><span class="keyword">if</span> (check<span class="constructor">Candidate(<span class="params">beanName</span>, <span class="params">candidate</span>)</span>) &#123;</span><br><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> <span class="constructor">BeanDefinitionHolder(<span class="params">candidate</span>, <span class="params">beanName</span>)</span>;</span><br><span class="line"><span class="comment">// 根据作用域生成代理类</span></span><br><span class="line">definitionHolder =</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">AnnotationConfigUtils</span>.</span></span>apply<span class="constructor">ScopedProxyMode(<span class="params">scopeMetadata</span>, <span class="params">definitionHolder</span>, <span class="params">this</span>.<span class="params">registry</span>)</span>;</span><br><span class="line">beanDefinitions.add(definitionHolder);</span><br><span class="line"><span class="comment">// 向容器中注册</span></span><br><span class="line">register<span class="constructor">BeanDefinition(<span class="params">definitionHolder</span>, <span class="params">this</span>.<span class="params">registry</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扫描指定包下的类"><a href="#扫描指定包下的类" class="headerlink" title="扫描指定包下的类"></a>扫描指定包下的类</h3><p>具体扫描由ClassPathScanningCandidateComponentProvider实现，其中findCandidateComponents()方法也只能看个步骤，因为大部分内容通过汇编实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; findCandidateComponents(<span class="built_in">String</span> basePackage) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.componentsIndex != <span class="literal">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line"><span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="keyword">this</span>.componentsIndex, basePackage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; addCandidateComponentsFromIndex(CandidateComponentsIndex index, <span class="built_in">String</span> basePackage) &#123;</span><br><span class="line"><span class="comment">// 用于保存的扫描到的BeanDefinition</span></span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Set&lt;<span class="built_in">String</span>&gt; types = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">// 在该类构造中会初始化默认扫描规则，即includeFilters</span></span><br><span class="line"><span class="comment">// 包含@Component、@Repository、@Service、@Controller的bean，以及@ManagedBean、@Name</span></span><br><span class="line"><span class="keyword">for</span> (TypeFilter filter : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line"><span class="built_in">String</span> stereotype = extractStereotype(filter);</span><br><span class="line"><span class="keyword">if</span> (stereotype == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Failed to extract stereotype from "</span>+ filter);</span><br><span class="line">&#125;</span><br><span class="line">types.addAll(index.getCandidateTypes(basePackage, stereotype));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">boolean</span> traceEnabled = logger.isTraceEnabled();</span><br><span class="line"><span class="built_in">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">String</span> <span class="keyword">type</span> : types) &#123;</span><br><span class="line"><span class="comment">// 过去指定资源下的元数据读取器，通过汇编读取资源元信息</span></span><br><span class="line">MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(<span class="keyword">type</span>);</span><br><span class="line"><span class="comment">// 判断扫描的类，是否符合容器所配置的过滤规则</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line"><span class="comment">// 通过汇编读取字节码中的bean定义元信息</span></span><br><span class="line">AnnotatedGenericBeanDefinition sbd = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(</span><br><span class="line">metadataReader.getAnnotationMetadata());</span><br><span class="line"><span class="comment">// 判断扫描的类，是否符合容器所配置的过滤规则，则添加</span></span><br><span class="line"><span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">"Using candidate component class from index: "</span> + <span class="keyword">type</span>);</span><br><span class="line">&#125;</span><br><span class="line">candidates.add(sbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">"Ignored because not a concrete top-level class: "</span> + <span class="keyword">type</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (traceEnabled) &#123;</span><br><span class="line">logger.trace(<span class="string">"Ignored because matching an exclude filter: "</span> + <span class="keyword">type</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"I/O failure during classpath scanning"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致内容就是，可分为两步</p><ol><li>在类的构造中初始化扫描规则，即对excludeFilters、includeFilters的赋值，注意@Service、@Controller为组合注解。</li><li>通过汇编读取字节码中的元信息后，判断是否为所需扫描的类，源码如下：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> boolean isCandidateComponent(MetadataReader metadataReader) throws IOException &#123;</span><br><span class="line"><span class="comment">// 判断是否处于过滤规则中，则返回false</span></span><br><span class="line"><span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断是否处于所需扫描的类中，则返回true</span></span><br><span class="line"><span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line"><span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line"><span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
            <tag> IOC </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring源码之IOC - 注解 - 容器初始化</title>
      <link href="/2019/11/20/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20%E6%B3%A8%E8%A7%A3%20-%20%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2019/11/20/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20%E6%B3%A8%E8%A7%A3%20-%20%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>为了简化bean的配置，spring提供了注解方式，用来取代xml配置文件。在spring中管理注解的bean定义容器有两个：AnnotationConfigApplicationContext、AnnotationConfigWebApplicationContext，两者的用法以及对注解的处理几乎没有区别。这里以AnnotationConfigApplicationContext为例。</p><h3 id="容器初始化"><a href="#容器初始化" class="headerlink" title="容器初始化"></a>容器初始化</h3><p>先从AnnotationConfigApplicationContext的初始化看起。该容器会先初始化bean定义读取器和bean定义扫描，后续所有的操作都是基于这两者。在两者初始化完之后，在构造方法中会调用各自的register()或scan()，开始对bean的处理。</p><p>其中register()或scan()，是分别对注解处理的两种方式。</p><ol><li>register()，直接将需要注册的bean传入，注册到IOC中</li><li>scan()，通过传入指定包，扫描包下及其子包下的所有类进行处理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfigApplicationContext</span> <span class="keyword">extends</span> <span class="title">GenericApplicationContext</span> <span class="keyword">implements</span> <span class="title">AnnotationConfigRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AnnotatedBeanDefinitionReader reader;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassPathBeanDefinitionScanner scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个构造最后都会调用此构造，初始化reader和scanner</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(beanFactory);</span><br><span class="line"><span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入配置类，实现相应配置类中bean自动注册到容器中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>();</span><br><span class="line">register(annotatedClasses);</span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描指定包路径下的所有类，自动识别所有spring bean，并注册到容器中。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>();</span><br><span class="line">scan(basePackages);</span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为容器注册一个要被处理的注解bean，新注册的bean，需手动调用refresh()方法，触发IOC对新注册bean的处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>&#123;</span><br><span class="line">Assert.notEmpty(annotatedClasses, <span class="string">"At least one annotated class must be specified"</span>);</span><br><span class="line"><span class="keyword">this</span>.reader.register(annotatedClasses);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扫描指定包路径下的注解类，同样的新注册的bean，需手动调用refresh()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line"><span class="keyword">this</span>.scanner.scan(basePackages);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码中，可以看到，该容器在启动时会调用register()、scan()方法，而这两个方法为public，也可以由使用者在容器创建之后调用新注册的bean。但是需要注意的是，新注册的bean，必须手动调用refresh()，spring才会对其做后续的处理。</p><h3 id="注册指定的bean"><a href="#注册指定的bean" class="headerlink" title="注册指定的bean"></a>注册指定的bean</h3><p><a href="https://www.ofcoder.com/2019/11/23/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20%E6%B3%A8%E8%A7%A3%20-%20%E6%B3%A8%E5%86%8C%E6%8C%87%E5%AE%9Abean%E5%AE%9A%E4%B9%89/">点击查看</a></p><h3 id="扫描指定包bean定义"><a href="#扫描指定包bean定义" class="headerlink" title="扫描指定包bean定义"></a>扫描指定包bean定义</h3><p><a href="https://ofcoder.com/2019/11/20/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20%E6%B3%A8%E8%A7%A3%20-%20%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/" target="_blank" rel="noopener">点击查看</a></p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
            <tag> IOC </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring源码之IOC - xml - 注册BeanDefinition</title>
      <link href="/2019/11/19/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20xml%20-%20%E6%B3%A8%E5%86%8CBeanDefinition/"/>
      <url>/2019/11/19/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20xml%20-%20%E6%B3%A8%E5%86%8CBeanDefinition/</url>
      
        <content type="html"><![CDATA[<p>在上面几章，描述了整个xml解析成BeanDefinition的过程。还剩余最后一个步骤就是向IOC中注册BeanDefinition。回到DefaultBeanDefinitionDocumentReader中，通过BeanDefinitionParserDelegate.parseBeanDefinitionElement()获得BeanDefinitionHolder，再会通过BeanDefinitionReaderUtils.registerBeanDefinition()将其注册。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> static void registerBeanDefinition(</span><br><span class="line"><span class="keyword">BeanDefinitionHolder </span>definitionHolder, <span class="keyword">BeanDefinitionRegistry </span>registry)</span><br><span class="line">throws <span class="keyword">BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">// 获取<span class="keyword">bean的名称</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">String </span><span class="keyword">beanName </span>= definitionHolder.getBeanName()<span class="comment">;</span></span><br><span class="line">// 向IOC注册<span class="keyword">BeanDefinition</span></span><br><span class="line"><span class="keyword"></span>registry.registerBeanDefinition(<span class="keyword">beanName, </span>definitionHolder.getBeanDefinition())<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 如果存在别名，则向IOC保存<span class="meta">alias</span>到name的映射关系</span><br><span class="line"><span class="keyword">String[] </span>aliases = definitionHolder.getAliases()<span class="comment">;</span></span><br><span class="line"><span class="meta">if</span> (aliases != null) &#123;</span><br><span class="line">for (<span class="keyword">String </span><span class="meta">alias</span> : aliases) &#123;</span><br><span class="line">registry.registerAlias(<span class="keyword">beanName, </span><span class="meta">alias</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="保存beanName-gt-beanDefinition的映射关系"><a href="#保存beanName-gt-beanDefinition的映射关系" class="headerlink" title="保存beanName-&gt;beanDefinition的映射关系"></a>保存beanName-&gt;beanDefinition的映射关系</h3><p>DefaultListableBeanFactory使用的是HashMap保存BeanDefinition。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</span><br><span class="line">throws BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非空校验</span></span><br><span class="line">Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验解析的BeanDefinition</span></span><br><span class="line"><span class="keyword">if</span> (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">&#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.<span class="keyword">get</span>(beanName);</span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line"><span class="keyword">throw</span> new ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.warn(...);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.info(....);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line"><span class="keyword">this</span>.logger.debug(...);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 开始注册</span></span><br><span class="line"><span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line"><span class="comment">// 保证线程同步</span></span><br><span class="line">synchronized (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">updatedDefinitions.add(beanName);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">updatedSingletons.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Still in startup registration phase</span></span><br><span class="line"><span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line"><span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line"><span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否注册同名的BeanDefinition</span></span><br><span class="line"><span class="keyword">if</span> (oldBeanDefinition != <span class="literal">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line"><span class="comment">// 重置已注册过的缓存</span></span><br><span class="line">resetBeanDefinition(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="保存alias-gt-beanName的映射关系"><a href="#保存alias-gt-beanName的映射关系" class="headerlink" title="保存alias-&gt;beanName的映射关系"></a>保存alias-&gt;beanName的映射关系</h3><p>注册别名，在xml的IOC分支中，解析alias标签的时候就已经注册了，点击查看：<a href="https://www.ofcoder.com/2019/11/13/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20xml%20-%20%E5%8A%A0%E8%BD%BDbean%E5%AE%9A%E4%B9%89%202%20%E8%A7%A3%E6%9E%90import%E3%80%81alias%E6%A0%87%E7%AD%BE/#%E8%A7%A3%E6%9E%90-alias-%E6%A0%87%E7%AD%BE">解析 alias 标签</a></p><p>至此，BeanDefinition全部解析完成并交由IOC管理，才完成整个IOC的启动，后续IOC的bean的创建，依赖注入等所有的工作都依赖于此时的BeanDefinition。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
            <tag> IOC </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger增加接口版本管理</title>
      <link href="/2019/11/17/java/swagger%E5%A2%9E%E5%8A%A0%E6%8E%A5%E5%8F%A3%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
      <url>/2019/11/17/java/swagger%E5%A2%9E%E5%8A%A0%E6%8E%A5%E5%8F%A3%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>怎么使用swagger，这里就不说了，本站已经跟各大搜索引擎达成合作，只要你在各大搜索引擎中输入关键词springboot swagger，就会在第一页返回给你集成教程。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>swagger确实很不错，可以自动生成接口文档，省去另外写文档的工作量，但是毕竟自动生成，肯定有不适合我们自己需求的地方。比如所有的接口文档没有分类，放在一起，前端很难找到所需的接口。还有接口文档有更新，没有任何地方提现处理。需要口头通知前端修改，如果前端忘了，后续还会怪后端没有通知到，以及发生各种扯皮。</p><p>我这里通过swagger提供的group功能进行增强，对接口文档进行分类、和版本管理。原生提供的group功能需要硬编码，生成Docket，使用起来极其不友好。如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket app<span class="constructor">_api()</span> &#123;</span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">Docket(DocumentationType.SWAGGER_2)</span>.select<span class="literal">()</span>.apis(<span class="module-access"><span class="module"><span class="identifier">RequestHandlerSelectors</span>.</span></span>any<span class="literal">()</span>)</span><br><span class="line">            .paths(<span class="module-access"><span class="module"><span class="identifier">PathSelectors</span>.</span></span>ant(<span class="string">"/api/**"</span>)).build<span class="literal">()</span>.group<span class="constructor">Name(<span class="string">"APP接口文档V4.4"</span>)</span>.path<span class="constructor">Mapping(<span class="string">"/"</span>)</span></span><br><span class="line">            .api<span class="constructor">Info(<span class="params">apiInfo</span>(<span class="string">"APP接口文档V4.4及之前"</span>,<span class="string">"文档中可以查询及测试接口调用参数和结果"</span>,<span class="string">"4.4"</span>)</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Docket wap<span class="constructor">_api()</span> &#123;</span><br><span class="line">    return <span class="keyword">new</span> <span class="constructor">Docket(DocumentationType.SWAGGER_2)</span>.select<span class="literal">()</span>.apis(<span class="module-access"><span class="module"><span class="identifier">RequestHandlerSelectors</span>.</span></span>any<span class="literal">()</span>)</span><br><span class="line">            .paths(<span class="module-access"><span class="module"><span class="identifier">PathSelectors</span>.</span></span>ant(<span class="string">"/web/**"</span>)).build<span class="literal">()</span>.group<span class="constructor">Name(<span class="string">"WEB接口文档V4.4"</span>)</span>.path<span class="constructor">Mapping(<span class="string">"/"</span>)</span></span><br><span class="line">            .api<span class="constructor">Info(<span class="params">apiInfo</span>(<span class="string">"WEB接口文档V4.4及之前"</span>,<span class="string">"文档中可以查询及测试接口调用参数和结果"</span>,<span class="string">"4.4"</span>)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>本篇记录的是，swagger自动生成group，实现对接口版本管理。这里我们公司习惯使用git分支进行管理，所有接口文档也跟着git分支做为版本管理。</p><h4 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h4><p>定义注解，用于在标注接口所属哪个版本。内部枚举，用来定义分支。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> @interface ApiVersion &#123;</span><br><span class="line"></span><br><span class="line">    Version[] value();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> Version &#123;</span><br><span class="line">        MASTER(<span class="string">"master"</span>),</span><br><span class="line">        INTERESTING(<span class="string">"20190701intersting"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">String</span> <span class="built_in">display</span>;</span><br><span class="line"></span><br><span class="line">        Version(<span class="keyword">String</span> <span class="built_in">display</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.<span class="built_in">display</span> = <span class="built_in">display</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">display</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重写group生成规则"><a href="#重写group生成规则" class="headerlink" title="重写group生成规则"></a>重写group生成规则</h4><p>这里代码看似又臭又长，其实不然，就是找到group生成的入口，然后遍历我们自定义的注解，生成多个group。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">SwaggerPluginRegistry</span> <span class="symbol">extends</span> <span class="symbol">OrderAwarePluginRegistry</span>&lt;<span class="symbol">DocumentationPlugin, <span class="symbol">DocumentationType</span></span>&gt; <span class="symbol">implements</span> <span class="symbol">PluginRegistry</span>&lt;<span class="symbol">DocumentationPlugin, <span class="symbol">DocumentationType</span></span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> SwaggerPluginRegistry(List&lt;Docket&gt; plugins, Comparator&lt;? <span class="keyword">super</span> DocumentationPlugin&gt; comparator) &#123;</span><br><span class="line">        <span class="keyword">super</span>(plugins, comparator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> List&lt;DocumentationPlugin&gt; getPlugins() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPlugins();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Primary</span><br><span class="line">@ConditionalOnProperty(prefix = <span class="string">"swagger"</span>, value = &#123;<span class="string">"enable"</span>&#125;, havingValue = <span class="string">"true"</span>)</span><br><span class="line">@EnableSwagger2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerDocumentationPluginsManager</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">DocumentationPluginsManager</span></span> </span>&#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> Iterable&lt;DocumentationPlugin&gt; documentationPlugins() throws IllegalStateException &#123;</span><br><span class="line">        List&lt;DocumentationPlugin&gt; plugins = registry().getPlugins();</span><br><span class="line">        ensureNoDuplicateGroups(plugins);</span><br><span class="line">        <span class="keyword">if</span> (plugins.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span><span class="type">ArrayList</span>(defaultDocumentationPlugin());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> plugins;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void ensureNoDuplicateGroups(List&lt;DocumentationPlugin&gt; allPlugins) throws IllegalStateException &#123;</span><br><span class="line">        Multimap&lt;<span class="keyword">String</span>, DocumentationPlugin&gt; plugins = Multimaps.index(allPlugins, byGroupName());</span><br><span class="line">        Iterable&lt;<span class="keyword">String</span>&gt; duplicateGroups = from(plugins.asMap().entrySet()).filter(duplicates()).transform(toGroupNames());</span><br><span class="line">        <span class="keyword">if</span> (Iterables.size(duplicateGroups) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="keyword">String</span>.format(<span class="string">"Multiple Dockets with the same group name are not supported. "</span></span><br><span class="line">                    + <span class="string">"The following duplicate groups were discovered. %s"</span>, Joiner.on(<span class="string">','</span>).join(duplicateGroups)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Function&lt;? <span class="keyword">super</span> DocumentationPlugin, <span class="keyword">String</span>&gt; byGroupName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Function</span>&lt;DocumentationPlugin, <span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">String</span> apply(DocumentationPlugin input) &#123;</span><br><span class="line">                <span class="keyword">return</span> Optional.fromNullable(input.getGroupName()).or(<span class="string">"default"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Function&lt;? <span class="keyword">super</span> Map.Entry&lt;<span class="keyword">String</span>, Collection&lt;DocumentationPlugin&gt;&gt;, <span class="keyword">String</span>&gt; toGroupNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Function</span>&lt;Map.Entry&lt;<span class="keyword">String</span>, Collection&lt;DocumentationPlugin&gt;&gt;, <span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">String</span> apply(Map.Entry&lt;<span class="keyword">String</span>, Collection&lt;DocumentationPlugin&gt;&gt; input) &#123;</span><br><span class="line">                <span class="keyword">return</span> input.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Predicate&lt;? <span class="keyword">super</span> Map.Entry&lt;<span class="keyword">String</span>, Collection&lt;DocumentationPlugin&gt;&gt;&gt; duplicates() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Predicate</span>&lt;Map.Entry&lt;<span class="keyword">String</span>, Collection&lt;DocumentationPlugin&gt;&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> boolean apply(Map.Entry&lt;<span class="keyword">String</span>, Collection&lt;DocumentationPlugin&gt;&gt; input) &#123;</span><br><span class="line">                <span class="keyword">return</span> input.getValue().size() &gt; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DocumentationPlugin defaultDocumentationPlugin() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Docket</span>(DocumentationType.SWAGGER_2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SwaggerPluginRegistry registry() &#123;</span><br><span class="line">        List&lt;Docket&gt; list = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ApiVersion.Version version : <span class="type">ApiVersion</span>.Version.values()) &#123;</span><br><span class="line">            Docket docket = <span class="keyword">new</span> <span class="type">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                    .apiInfo(apiInfo())</span><br><span class="line">                    .groupName(version.getDisplay())</span><br><span class="line">                    .select()</span><br><span class="line">                    .apis(input -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (ApiVersion.Version.MASTER.equals(version)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ApiVersion apiVersion = input.getHandlerMethod().getMethodAnnotation(ApiVersion.class);</span><br><span class="line">                        <span class="keyword">if</span> (apiVersion != <span class="literal">null</span> &amp;&amp; Arrays.asList(apiVersion.value()).contains(version)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .paths(PathSelectors.any())</span><br><span class="line">                    .build()</span><br><span class="line">                    .securitySchemes(securitySchemes())</span><br><span class="line">                    .securityContexts(securityContexts());</span><br><span class="line"></span><br><span class="line">            list.add(docket);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SwaggerPluginRegistry registry = <span class="keyword">new</span> <span class="type">SwaggerPluginRegistry</span>(list, <span class="keyword">new</span> <span class="type">AnnotationAwareOrderComparator</span>());</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo apiInfo() &#123;</span><br><span class="line">        Contact contact = <span class="keyword">new</span> <span class="type">Contact</span>(<span class="string">"技术部"</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">"ofcoder接口文档"</span>)</span><br><span class="line">                .description(<span class="string">"ofcoder接口文档"</span>)</span><br><span class="line">                .version(<span class="string">"1.0.0"</span>)</span><br><span class="line">                .contact(contact)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ApiKey&gt; securitySchemes() &#123;</span><br><span class="line">        List&lt;ApiKey&gt; arrayList = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="type">ApiKey</span>(<span class="string">"Authorization"</span>, <span class="string">"token"</span>, <span class="string">"header"</span>));</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;SecurityContext&gt; securityContexts() &#123;</span><br><span class="line">        List&lt;SecurityContext&gt; arrayList = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(SecurityContext.builder()</span><br><span class="line">                .securityReferences(defaultAuth())</span><br><span class="line">                .build());</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;SecurityReference&gt; defaultAuth() &#123;</span><br><span class="line">        AuthorizationScope authorizationScope = <span class="keyword">new</span> <span class="type">AuthorizationScope</span>(<span class="string">"global"</span>, <span class="string">"accessEverything"</span>);</span><br><span class="line">        AuthorizationScope[] authorizationScopes = <span class="keyword">new</span> <span class="type">AuthorizationScope</span>[<span class="number">1</span>];</span><br><span class="line">        authorizationScopes[<span class="number">0</span>] = authorizationScope;</span><br><span class="line">        List&lt;SecurityReference&gt; arrayList = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="type">SecurityReference</span>(<span class="string">"Authorization"</span>, authorizationScopes));</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>只需要对所要进行管理的接口上，增加该注解，value的值支持多个，也就是说你可以同时标注多个分支。我觉某个接口每修改一次，value的值则增加一个分支，方便后续追述在那些分支上做了修改，就可以定位到git的哪一次提交了。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@ApiVersion</span>(ApiVersion.Version.INTERESTING)</span><br><span class="line"><span class="variable">@RequestMapping</span>(value = <span class="string">"ofcoder.com"</span>)</span><br><span class="line">public void hello()&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 芝士点心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API设计 </tag>
            
            <tag> swagger </tag>
            
            <tag> 文档管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring源码之IOC - xml - 加载bean定义 3 解析bean标签</title>
      <link href="/2019/11/16/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20xml%20-%20%E5%8A%A0%E8%BD%BDbean%E5%AE%9A%E4%B9%89%203%20%E8%A7%A3%E6%9E%90bean%E6%A0%87%E7%AD%BE/"/>
      <url>/2019/11/16/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20xml%20-%20%E5%8A%A0%E8%BD%BDbean%E5%AE%9A%E4%B9%89%203%20%E8%A7%A3%E6%9E%90bean%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<p>上一章，在解析bean标签的时候，还剩余两个方法没有深入</p><ol><li>parseBeanDefinitionElement()</li><li>registerBeanDefinition()</li></ol><p>前者用于解析bean标签中的元素，后者用于将解析得到的BeanDefinition注册到IOC。前者又分为几个步骤：</p><ol><li>处理id、name属性，parseBeanDefinitionElement()</li><li>处理其他属性</li><li>处理bean标签下的子标签。constructor-arg、property…</li></ol><h3 id="处理id、name属性"><a href="#处理id、name属性" class="headerlink" title="处理id、name属性"></a>处理id、name属性</h3><p>解析bean的配置信息，spring会单独对id、name进行处理，如果没有配置，则会生成唯一的值用来注册。而这整个过程交由BeanDefinitionParserDelegate实现。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// 重载后，所调用的方法</span><br><span class="line"><span class="symbol">public</span> <span class="keyword">BeanDefinitionHolder </span>parseBeanDefinitionElement(Element ele, <span class="comment">@Nullable BeanDefinition containingBean) &#123;</span></span><br><span class="line">// 获取<span class="keyword">bean的id属性</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">String </span>id = ele.getAttribute(ID_ATTRIBUTE)<span class="comment">;</span></span><br><span class="line">// 获取<span class="keyword">bean的name属性</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">String </span>nameAttr = ele.getAttribute(NAME_ATTRIBUTE)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 将<span class="keyword">bean的name属性，分割后存入alias中</span></span><br><span class="line"><span class="keyword"></span>List&lt;<span class="keyword">String&gt; </span>aliases = new ArrayList&lt;&gt;()<span class="comment">;</span></span><br><span class="line"><span class="meta">if</span> (<span class="keyword">StringUtils.hasLength(nameAttr)) </span>&#123;</span><br><span class="line"><span class="keyword">String[] </span>nameArr = <span class="keyword">StringUtils.tokenizeToStringArray(nameAttr, </span><span class="keyword">MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span></span><br><span class="line"><span class="keyword"></span>aliases.<span class="keyword">addAll(Arrays.asList(nameArr));</span></span><br><span class="line"><span class="keyword"></span>&#125;</span><br><span class="line"></span><br><span class="line">//如果id属性没有设置，则使用<span class="meta">alias</span>中的第一个</span><br><span class="line"><span class="keyword">String </span><span class="keyword">beanName </span>= id<span class="comment">;</span></span><br><span class="line"><span class="meta">if</span> (!<span class="keyword">StringUtils.hasText(beanName) </span>&amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">beanName </span>= aliases.remove(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line"><span class="meta">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + <span class="keyword">beanName </span>+</span><br><span class="line"><span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 检查<span class="keyword">bean的id、alias，是否存在重复</span></span><br><span class="line"><span class="keyword"></span><span class="meta">if</span> (containingBean == null) &#123;</span><br><span class="line">checkNameUniqueness(<span class="keyword">beanName, </span>aliases, ele)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对<span class="keyword">bean标签中其他属性进行解析</span></span><br><span class="line"><span class="keyword"></span>AbstractBeanDefinition <span class="keyword">beanDefinition </span>= parseBeanDefinitionElement(ele, <span class="keyword">beanName, </span>containingBean)<span class="comment">;</span></span><br><span class="line"><span class="meta">if</span> (<span class="keyword">beanDefinition </span>!= null) &#123;</span><br><span class="line"><span class="meta">if</span> (!<span class="keyword">StringUtils.hasText(beanName)) </span>&#123;</span><br><span class="line">try &#123;</span><br><span class="line"><span class="meta">if</span> (containingBean != null) &#123;</span><br><span class="line">// 如果<span class="keyword">bean标签中，没有配置id、name，也没有包含子元素</span></span><br><span class="line"><span class="keyword"></span>// 则为该<span class="keyword">bean生成一个唯一的beanName用于注册</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">beanName </span>= <span class="keyword">BeanDefinitionReaderUtils.generateBeanName(</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">beanDefinition, </span>this.readerContext.getRegistry(), true)<span class="comment">;</span></span><br><span class="line">&#125; <span class="meta">else</span> &#123;</span><br><span class="line">// 如果<span class="keyword">bean标签中，没有配置id、name，包含子元素</span></span><br><span class="line"><span class="keyword"></span>// 则将解析的<span class="keyword">Bean使用别名向IOC中注册</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">beanName </span>= this.readerContext.generateBeanName(<span class="keyword">beanDefinition);</span></span><br><span class="line"><span class="keyword"></span>// 为了解析<span class="keyword">bean使用别名注册时，向后兼容</span></span><br><span class="line"><span class="keyword"></span>// Spring <span class="number">1</span>.<span class="number">2</span>/<span class="number">2</span>.<span class="number">0</span> 给别名添加后缀</span><br><span class="line"><span class="keyword">String </span><span class="keyword">beanClassName </span>= <span class="keyword">beanDefinition.getBeanClassName();</span></span><br><span class="line"><span class="keyword"></span><span class="meta">if</span> (<span class="keyword">beanClassName </span>!= null &amp;&amp;</span><br><span class="line"><span class="keyword">beanName.startsWith(beanClassName) </span>&amp;&amp; <span class="keyword">beanName.length() </span>&gt; <span class="keyword">beanClassName.length() </span>&amp;&amp;</span><br><span class="line">!this.readerContext.getRegistry().<span class="keyword">isBeanNameInUse(beanClassName)) </span>&#123;</span><br><span class="line">aliases.<span class="keyword">add(beanClassName);</span></span><br><span class="line"><span class="keyword"></span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line"><span class="string">"using generated bean name ["</span> + <span class="keyword">beanName </span>+ <span class="string">"]"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception ex) &#123;</span><br><span class="line">error(ex.getMessage(), ele)<span class="comment">;</span></span><br><span class="line">return null<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">String[] </span>aliasesArray = <span class="keyword">StringUtils.toStringArray(aliases);</span></span><br><span class="line"><span class="keyword"></span>return new <span class="keyword">BeanDefinitionHolder(beanDefinition, </span><span class="keyword">beanName, </span>aliasesArray)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 加载失败返回null</span><br><span class="line">return null<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理其他属性"><a href="#处理其他属性" class="headerlink" title="处理其他属性"></a>处理其他属性</h3><p>对id、name，做完默认处理之后，则会对bean标签的其他属性进行解析，并将其set到BeanDefinition对象中，这里都只是初始化BeanDefinition，不会真正实例化。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">public</span> AbstractBeanDefinition parseBeanDefinitionElement(</span><br><span class="line">Element ele, <span class="keyword">String </span><span class="keyword">beanName, </span><span class="comment">@Nullable BeanDefinition containingBean) &#123;</span></span><br><span class="line"></span><br><span class="line">this.parseState.<span class="keyword">push(new </span><span class="keyword">BeanEntry(beanName));</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">// 获取class属性，这里只是记录，放入<span class="keyword">BeanDefinition，不会实例化。</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">String </span>className = null<span class="comment">;</span></span><br><span class="line"><span class="meta">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">className = ele.getAttribute(CLASS_ATTRIBUTE).trim()<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取parent属性</span><br><span class="line"><span class="keyword">String </span>parent = null<span class="comment">;</span></span><br><span class="line"><span class="meta">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">parent = ele.getAttribute(PARENT_ATTRIBUTE)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">// new 一个 <span class="keyword">BeanDefinition </span>对象，将className, parent放入对象中</span><br><span class="line">AbstractBeanDefinition <span class="keyword">bd </span>= createBeanDefinition(className, parent)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 初始化一些其他属性，放入<span class="keyword">BeanDefinition中，如:singleton, </span>scope, abstract, lazy-init....</span><br><span class="line">parseBeanDefinitionAttributes(ele, <span class="keyword">beanName, </span>containingBean, <span class="keyword">bd);</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, </span>DESCRIPTION_ELEMENT))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 解析<span class="keyword">bean标签的meta(元信息)属性解析</span></span><br><span class="line"><span class="keyword"></span>parseMetaElements(ele, <span class="keyword">bd);</span></span><br><span class="line"><span class="keyword"></span>// 解析<span class="keyword">bean标签的lookup-method属性解析</span></span><br><span class="line"><span class="keyword"></span>parseLookupOverrideSubElements(ele, <span class="keyword">bd.getMethodOverrides());</span></span><br><span class="line"><span class="keyword"></span>// 解析<span class="keyword">bean标签的replace-method属性解析</span></span><br><span class="line"><span class="keyword"></span>parseReplacedMethodSubElements(ele, <span class="keyword">bd.getMethodOverrides());</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">// 解析构造方法</span><br><span class="line">parseConstructorArgElements(ele, <span class="keyword">bd);</span></span><br><span class="line"><span class="keyword"></span>// 解析<span class="keyword">bean标签下，property标签</span></span><br><span class="line"><span class="keyword"></span>parsePropertyElements(ele, <span class="keyword">bd);</span></span><br><span class="line"><span class="keyword"></span>// 解析<span class="keyword">bean标签的qualifier属性解析</span></span><br><span class="line"><span class="keyword"></span>parseQualifierElements(ele, <span class="keyword">bd);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">// 解析<span class="keyword">bean所需的资源和依赖对象</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">bd.setResource(this.readerContext.getResource());</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">bd.setSource(extractSource(ele));</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">return <span class="keyword">bd;</span></span><br><span class="line"><span class="keyword"></span>&#125; catch (ClassNotFoundException ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">this.parseState.<span class="keyword">pop();</span></span><br><span class="line"><span class="keyword"></span>&#125;</span><br><span class="line"></span><br><span class="line">return null<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析property标签"><a href="#解析property标签" class="headerlink" title="解析property标签"></a>解析property标签</h3><p>bean标签下的子标签很多很多，有一些我还没用过，看了源码才知道有这些东西，汗颜。挑一个内容多点property继续看一下。整理一下步骤，如下：</p><ol><li>遍历所有子标签，判断是否property标签，则往下解析</li><li>解析name属性，以及重名处理</li><li>解析property子标签，如果是ref、value，则保存其引用，其他的list、array、map、等标签，继续解析</li><li>回到第2点的方法中，将其保存到BeanDefinition中</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">public void parse<span class="constructor">PropertyElements(Element <span class="params">beanEle</span>, BeanDefinition <span class="params">bd</span>)</span> &#123;</span><br><span class="line">NodeList nl = beanEle.get<span class="constructor">ChildNodes()</span>;</span><br><span class="line"><span class="comment">// 遍历所有子节点标签</span></span><br><span class="line">for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nl.get<span class="constructor">Length()</span>; i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="comment">// 判断是否为property标签</span></span><br><span class="line"><span class="keyword">if</span> (is<span class="constructor">CandidateElement(<span class="params">node</span>)</span><span class="operator"> &amp;&amp; </span>node<span class="constructor">NameEquals(<span class="params">node</span>, PROPERTY_ELEMENT)</span>) &#123;</span><br><span class="line"><span class="comment">// 开始解析property标签</span></span><br><span class="line">parse<span class="constructor">PropertyElement((Element)</span> node, bd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析标签中的属性</span></span><br><span class="line">public void parse<span class="constructor">PropertyElement(Element <span class="params">ele</span>, BeanDefinition <span class="params">bd</span>)</span> &#123;</span><br><span class="line"><span class="comment">// 获取名字</span></span><br><span class="line">String propertyName = ele.get<span class="constructor">Attribute(NAME_ATTRIBUTE)</span>;</span><br><span class="line"><span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>has<span class="constructor">Length(<span class="params">propertyName</span>)</span>) &#123;</span><br><span class="line">error(<span class="string">"Tag 'property' must have a 'name' attribute"</span>, ele);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">this.parseState.push(<span class="keyword">new</span> <span class="constructor">PropertyEntry(<span class="params">propertyName</span>)</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 如果一个bean中，配置两个property标签，他们名字相同，则不加载</span></span><br><span class="line"><span class="comment">// 即：如果一个bean中配置两个名字相同的property标签，则只有第一个生效。</span></span><br><span class="line"><span class="keyword">if</span> (bd.get<span class="constructor">PropertyValues()</span>.contains(propertyName)) &#123;</span><br><span class="line">error(<span class="string">"Multiple 'property' definitions for property '"</span> + propertyName + <span class="string">"'"</span>, ele);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析property标签中其他属性，如：ref、value等...</span></span><br><span class="line">Object <span class="keyword">val</span> = parse<span class="constructor">PropertyValue(<span class="params">ele</span>, <span class="params">bd</span>, <span class="params">propertyName</span>)</span>;</span><br><span class="line"><span class="comment">// 将name和各个属性值封装成PropertyValue对象</span></span><br><span class="line">PropertyValue pv = <span class="keyword">new</span> <span class="constructor">PropertyValue(<span class="params">propertyName</span>, <span class="params">val</span>)</span>;</span><br><span class="line">parse<span class="constructor">MetaElements(<span class="params">ele</span>, <span class="params">pv</span>)</span>;</span><br><span class="line">pv.set<span class="constructor">Source(<span class="params">extractSource</span>(<span class="params">ele</span>)</span>);</span><br><span class="line"><span class="comment">// 将其保存到BeanDefinition中</span></span><br><span class="line">bd.get<span class="constructor">PropertyValues()</span>.add<span class="constructor">PropertyValue(<span class="params">pv</span>)</span>;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">this.parseState.pop<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Object parse<span class="constructor">PropertyValue(Element <span class="params">ele</span>, BeanDefinition <span class="params">bd</span>, @Nullable String <span class="params">propertyName</span>)</span> &#123;</span><br><span class="line">String elementName = (propertyName != null) ?</span><br><span class="line"><span class="string">"&lt;property&gt; element for property '"</span> + propertyName + <span class="string">"'"</span> :</span><br><span class="line"><span class="string">"&lt;constructor-arg&gt; element"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前property有子标签，只能是ref, value, list, etc中的一种</span></span><br><span class="line">NodeList nl = ele.get<span class="constructor">ChildNodes()</span>;</span><br><span class="line">Element subElement = null;</span><br><span class="line">for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nl.get<span class="constructor">Length()</span>; i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (node instanceof Element<span class="operator"> &amp;&amp; </span>!node<span class="constructor">NameEquals(<span class="params">node</span>, DESCRIPTION_ELEMENT)</span> &amp;&amp;</span><br><span class="line">!node<span class="constructor">NameEquals(<span class="params">node</span>, META_ELEMENT)</span>) &#123;</span><br><span class="line"><span class="comment">// Child element is what we're looking for.</span></span><br><span class="line"><span class="keyword">if</span> (subElement != null) &#123;</span><br><span class="line">error(elementName + <span class="string">" must not contain more than one sub-element"</span>, ele);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 当前property包含的子元素</span></span><br><span class="line">subElement = (Element) node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断属性值是ref还是value，不允许既是ref又是value</span></span><br><span class="line">boolean hasRefAttribute = ele.has<span class="constructor">Attribute(REF_ATTRIBUTE)</span>;</span><br><span class="line">boolean hasValueAttribute = ele.has<span class="constructor">Attribute(VALUE_ATTRIBUTE)</span>;</span><br><span class="line"><span class="keyword">if</span> ((hasRefAttribute<span class="operator"> &amp;&amp; </span>hasValueAttribute) <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">((has<span class="constructor">RefAttribute</span> <span class="operator">||</span> has<span class="constructor">ValueAttribute</span>) <span class="operator">&amp;&amp;</span> sub<span class="constructor">Element</span> != null)) &#123;</span></span><br><span class="line"><span class="pattern-match">error(element<span class="constructor">Name</span> +</span></span><br><span class="line"><span class="pattern-match">" is only allowed <span class="keyword">to</span> contain either '<span class="built_in">ref</span>' attribute <span class="constructor">OR</span> 'value' attribute <span class="constructor">OR</span> sub-element", ele);</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"><span class="keyword">if</span> (has<span class="constructor">RefAttribute</span>) &#123;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span> 如果是<span class="built_in">ref</span>，创建一个对象<span class="constructor">RuntimeBeanReference</span>，封装<span class="built_in">ref</span></span></span><br><span class="line"><span class="pattern-match"><span class="constructor">String</span> <span class="built_in">ref</span><span class="constructor">Name</span> = ele.get<span class="constructor">Attribute(REF_ATTRIBUTE)</span>;</span></span><br><span class="line"><span class="pattern-match"><span class="keyword">if</span> (!<span class="constructor">StringUtils</span>.has<span class="constructor">Text(<span class="params">refName</span>)</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">error(element<span class="constructor">Name</span> + " contains empty '<span class="built_in">ref</span>' attribute", ele);</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match"><span class="constructor">RuntimeBeanReference</span> <span class="built_in">ref</span> = <span class="keyword">new</span> <span class="constructor">RuntimeBeanReference(<span class="params">refName</span>)</span>;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span> 设置这个<span class="built_in">ref</span>数据对象被当前对象所引用</span></span><br><span class="line"><span class="pattern-match"><span class="built_in">ref</span>.set<span class="constructor">Source(<span class="params">extractSource</span>(<span class="params">ele</span>)</span>);</span></span><br><span class="line"><span class="pattern-match">return <span class="built_in">ref</span>;</span></span><br><span class="line"><span class="pattern-match">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (has<span class="constructor">ValueAttribute</span>) &#123;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span> 如果是value，创建一个<span class="constructor">TypedStringValue</span>对象，封装value</span></span><br><span class="line"><span class="pattern-match"><span class="constructor">TypedStringValue</span> value<span class="constructor">Holder</span> = <span class="keyword">new</span> <span class="constructor">TypedStringValue(<span class="params">ele</span>.<span class="params">getAttribute</span>(VALUE_ATTRIBUTE)</span>);</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span> 设置这个value的数据对象，被当前对象所引用</span></span><br><span class="line"><span class="pattern-match">value<span class="constructor">Holder</span>.set<span class="constructor">Source(<span class="params">extractSource</span>(<span class="params">ele</span>)</span>);</span></span><br><span class="line"><span class="pattern-match">return value<span class="constructor">Holder</span>;</span></span><br><span class="line"><span class="pattern-match">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sub<span class="constructor">Element</span> != null) &#123;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span> 如果存在子标签，则继续解析子标签</span></span><br><span class="line"><span class="pattern-match">return parse<span class="constructor">PropertySubElement(<span class="params">subElement</span>, <span class="params">bd</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="pattern-match"><span class="operator">/</span><span class="operator">/</span> <span class="constructor">Neither</span> child element nor "<span class="built_in">ref</span>" <span class="keyword">or</span> "value" attribute found.</span></span><br><span class="line"><span class="pattern-match">error(element<span class="constructor">Name</span> + " must specify a <span class="built_in">ref</span> <span class="keyword">or</span> value", ele);</span></span><br><span class="line"><span class="pattern-match">return null;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure><p>property子标签的子标签还很多，都在parsePropertySubElement()中解析，比如idref、value、array、set、map、props等，这里不能一一贴出来了，到了这里相信理解下面的子标签也不难。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
            <tag> IOC </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring源码之IOC - xml - 加载bean定义 2 解析import、alias标签</title>
      <link href="/2019/11/13/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20xml%20-%20%E5%8A%A0%E8%BD%BDbean%E5%AE%9A%E4%B9%89%202%20%E8%A7%A3%E6%9E%90import%E3%80%81alias%E6%A0%87%E7%AD%BE/"/>
      <url>/2019/11/13/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20xml%20-%20%E5%8A%A0%E8%BD%BDbean%E5%AE%9A%E4%B9%89%202%20%E8%A7%A3%E6%9E%90import%E3%80%81alias%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<p>这一章开始真正解析xml的标签，逻辑不复杂，但是内容比较多，所有单独放一篇文章。继续上一章的BeanDefinitionDocumentReader.registerBeanDefinitions()，该接口只有一个实现类就是：DefaultBeanDefinitionDocumentReader。以下面xml为例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:cache</span>=<span class="string">"http://www.springframework.org/schema/cache"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath*:/spring/job-timer.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"some"</span> <span class="attr">class</span>=<span class="string">"src.com.Some"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"some"</span> <span class="attr">alias</span>=<span class="string">"someJava,oneBean,twoBean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="区分xml结构定义"><a href="#区分xml结构定义" class="headerlink" title="区分xml结构定义"></a>区分xml结构定义</h3><p>registerBeanDefinitions()处理逻辑从xml的根节点开始。调用doRegisterBeanDefinitions()，判断xml是否为spring所定义的xml结构，分别处理。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span>(<span class="params">Document doc, XmlReaderContext readerContext</span>)</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line"><span class="comment">// 获取根节点标签 &lt;beans&gt;</span></span><br><span class="line">Element root = doc.getDocumentElement();</span><br><span class="line">doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理传入的节点标签下的子节点标签，存在递归调用</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span>(<span class="params">Element root</span>)</span> &#123;</span><br><span class="line">BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.<span class="keyword">delegate</span>;</span><br><span class="line"><span class="keyword">this</span>.<span class="keyword">delegate</span> = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理使用spring默认的xml结构定义</span></span><br><span class="line"><span class="comment">// 例如：例子中http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.<span class="keyword">delegate</span>.isDefaultNamespace(root)) &#123;</span><br><span class="line">String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line"><span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line"><span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供空方法作为钩子，供子类增强</span></span><br><span class="line">preProcessXml(root);</span><br><span class="line">parseBeanDefinitions(root, <span class="keyword">this</span>.<span class="keyword">delegate</span>);</span><br><span class="line"><span class="comment">// 提供空方法作为钩子，供子类增强</span></span><br><span class="line">postProcessXml(root);</span><br><span class="line"><span class="keyword">this</span>.<span class="keyword">delegate</span> = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span>(<span class="params">Element root, BeanDefinitionParserDelegate <span class="keyword">delegate</span></span>)</span> &#123;</span><br><span class="line"><span class="comment">// 处理使用spring默认的xml结构定义</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">delegate</span>.isDefaultNamespace(root)) &#123;</span><br><span class="line"><span class="comment">// 获得所有子节点标签</span></span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line"><span class="comment">// 遍历子节点标签</span></span><br><span class="line">Node node = nl.item(i);</span><br><span class="line"><span class="keyword">if</span> (node instanceof Element) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">delegate</span>.isDefaultNamespace(ele)) &#123;</span><br><span class="line">parseDefaultElement(ele, <span class="keyword">delegate</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果没有使用spring默认的xml结构定义，则使用用户自定义的结构，进行解析</span></span><br><span class="line"><span class="keyword">delegate</span>.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 根节点没有使用spring的定义的xml结构</span></span><br><span class="line"><span class="comment">// 使用自定义的解析规则解析根节点</span></span><br><span class="line"><span class="keyword">delegate</span>.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码看出，xml的文档接口，可以有我们自定义，也就是我们所说的DTD。spring默认的结构定义使用XSD，是基于 XML 的 DTD 替代者。</p><h3 id="使用spring的xml结构解析"><a href="#使用spring的xml结构解析" class="headerlink" title="使用spring的xml结构解析"></a>使用spring的xml结构解析</h3><p>对xml结构解析是从parseDefaultElement()开始的，该方法分别对import、alias、bean、beans标签进行路由调用指定的方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void parse<span class="constructor">DefaultElement(Element <span class="params">ele</span>, BeanDefinitionParserDelegate <span class="params">delegate</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (delegate.node<span class="constructor">NameEquals(<span class="params">ele</span>, IMPORT_ELEMENT)</span>) &#123;</span><br><span class="line"><span class="comment">// 解析 &lt;import&gt; 标签</span></span><br><span class="line">import<span class="constructor">BeanDefinitionResource(<span class="params">ele</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.node<span class="constructor">NameEquals(<span class="params">ele</span>, ALIAS_ELEMENT)</span>) &#123;</span><br><span class="line"><span class="comment">// 解析 &lt;alias&gt; 标签</span></span><br><span class="line">process<span class="constructor">AliasRegistration(<span class="params">ele</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.node<span class="constructor">NameEquals(<span class="params">ele</span>, BEAN_ELEMENT)</span>) &#123;</span><br><span class="line"><span class="comment">// 解析 &lt;bean&gt; 标签</span></span><br><span class="line">process<span class="constructor">BeanDefinition(<span class="params">ele</span>, <span class="params">delegate</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.node<span class="constructor">NameEquals(<span class="params">ele</span>, NESTED_BEANS_ELEMENT)</span>) &#123;</span><br><span class="line"><span class="comment">// 递归调用，本篇开始的方法</span></span><br><span class="line"><span class="keyword">do</span><span class="constructor">RegisterBeanDefinitions(<span class="params">ele</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析-import-标签"><a href="#解析-import-标签" class="headerlink" title="解析 import 标签"></a>解析 import 标签</h3><p>importBeanDefinitionResource()，先获得resource属性的值，也就是需要导入的资源路径。判断该路径是否为绝对路径还是相对路径分别处理。逻辑跟ioc启动时传入的location地址处理方式大相径庭，先解析地址获得Resource对象，然后继续往下解析。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">importBeanDefinitionResource</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取resource参数的值，也就是要导入的文件路径</span></span><br><span class="line"><span class="comment">// 例如：例子中的classpath*:/spring/job-timer.xml</span></span><br><span class="line"><span class="keyword">String</span> location = ele.getAttribute(RESOURCE_ATTRIBUTE);</span><br><span class="line"><span class="comment">// 非空判断，不做处理</span></span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(location)) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Resource location must not be empty"</span>, ele);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用系统变量值："$&#123;user.dir&#125;"解析location值</span></span><br><span class="line">location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);</span><br><span class="line"></span><br><span class="line">Set&lt;Resource&gt; actualResources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记location值是否为绝对路径</span></span><br><span class="line"><span class="keyword">boolean</span> absoluteLocation = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();</span><br><span class="line">&#125; <span class="keyword">catch</span> (URISyntaxException ex) &#123;</span><br><span class="line"><span class="comment">// 不能转为URI对象，则为相对地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (absoluteLocation) &#123;</span><br><span class="line"><span class="comment">// 为绝对地址</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 加载给定文件的bean资源。里面逻辑还是一样的，先获取到Resource对象，然后继续加载</span></span><br><span class="line"><span class="keyword">int</span> importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Imported "</span> + importCount + <span class="string">" bean definitions from URL location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(</span><br><span class="line"><span class="string">"Failed to import bean definitions from URL location ["</span> + location + <span class="string">"]"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 相对路径处理逻辑</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> importCount;</span><br><span class="line">Resource relativeResource = getReaderContext().getResource().createRelative(location);</span><br><span class="line"><span class="keyword">if</span> (relativeResource.<span class="built_in">exists</span>()) &#123;</span><br><span class="line"><span class="comment">// 相对路径地址存在，继续加载Resource</span></span><br><span class="line">importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);</span><br><span class="line">actualResources.add(relativeResource);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 相对路径不存在，则使用ioc资源读取器的基本路径</span></span><br><span class="line"><span class="keyword">String</span> baseLocation = getReaderContext().getResource().getURL().toString();</span><br><span class="line"><span class="comment">// 使用ioc读取器的基本路径加载给定的路径资源</span></span><br><span class="line">importCount = getReaderContext().getReader().loadBeanDefinitions(</span><br><span class="line">StringUtils.applyRelativePath(baseLocation, location), actualResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Imported "</span> + importCount + <span class="string">" bean definitions from relative location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Failed to resolve current resource location"</span>, ele, ex);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">getReaderContext().error(<span class="string">"Failed to import bean definitions from relative location ["</span> + location + <span class="string">"]"</span>,</span><br><span class="line">ele, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Resource[] actResArray = actualResources.toArray(<span class="keyword">new</span> Resource[actualResources.<span class="built_in">size</span>()]);</span><br><span class="line"><span class="comment">// 解析完后，发送“导入其他资源”处理完成的通知事件</span></span><br><span class="line">getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析-alias-标签"><a href="#解析-alias-标签" class="headerlink" title="解析 alias 标签"></a>解析 alias 标签</h3><p>processAliasRegistration()先获取到name、alias属性的值，非空处理之后，调用registerAlias()向IOC中注册别名。registerAlias()的逻辑为：将别名保存到Map中，由alias映射到name。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="type">void</span> processAliasRegistration(Element ele) &#123;</span><br><span class="line">// 获得<span class="type">name</span>属性、<span class="keyword">alias</span>属性</span><br><span class="line">// 例如：例子中 <span class="type">name</span>="some" <span class="keyword">alias</span>="someJava,oneBean,twoBean"</span><br><span class="line">String <span class="type">name</span> = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">String <span class="keyword">alias</span> = ele.getAttribute(ALIAS_ATTRIBUTE);</span><br><span class="line"><span class="type">boolean</span> <span class="keyword">valid</span> = <span class="keyword">true</span>;</span><br><span class="line">// 非空处理，做标记</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(<span class="type">name</span>)) &#123;</span><br><span class="line">getReaderContext().error("Name must not be empty", ele);</span><br><span class="line"><span class="keyword">valid</span> = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">alias</span>)) &#123;</span><br><span class="line">getReaderContext().error("Alias must not be empty", ele);</span><br><span class="line"><span class="keyword">valid</span> = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">valid</span>) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// 向容器中注册别名</span><br><span class="line">getReaderContext().getRegistry().registerAlias(<span class="type">name</span>, <span class="keyword">alias</span>);</span><br><span class="line">&#125;</span><br><span class="line">catch (<span class="keyword">Exception</span> ex) &#123;</span><br><span class="line">getReaderContext().error("Failed to register alias '" + <span class="keyword">alias</span> +</span><br><span class="line">"' for bean with name '" + <span class="type">name</span> + "'", ele, ex);</span><br><span class="line">&#125;</span><br><span class="line">// 发送别名处理完的事件</span><br><span class="line">getReaderContext().fireAliasRegistered(<span class="type">name</span>, <span class="keyword">alias</span>, extractSource(ele));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SimpleAliasRegistry</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> registerAlias(String <span class="type">name</span>, String <span class="keyword">alias</span>) &#123;</span><br><span class="line">// 非空处理</span><br><span class="line"><span class="keyword">Assert</span>.hasText(<span class="type">name</span>, "'name' must not be empty");</span><br><span class="line"><span class="keyword">Assert</span>.hasText(<span class="keyword">alias</span>, "'alias' must not be empty");</span><br><span class="line">// 如果<span class="keyword">alias</span>和<span class="type">name</span>一致，相当于没有取别名。</span><br><span class="line">// remove已注册的别名，节省别名映射的性能</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">alias</span>.equals(<span class="type">name</span>)) &#123;</span><br><span class="line">this.aliasMap.remove(<span class="keyword">alias</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">String registeredName = this.aliasMap.<span class="keyword">get</span>(<span class="keyword">alias</span>);</span><br><span class="line">// 如果已注册该别名，则判断之前注册的和本次注册的是否指向同一个bean。否则抛异常</span><br><span class="line">// 之所以要判断之前注册的和本次注册的是否指向同一个bean，是因为在最后注册BeanDefinition要兼容其他的IOC容器，也会调用registerAlias()</span><br><span class="line"><span class="keyword">if</span> (registeredName != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (registeredName.equals(<span class="type">name</span>)) &#123;</span><br><span class="line">// An existing <span class="keyword">alias</span> - <span class="keyword">no</span> need <span class="keyword">to</span> re-register</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!allowAliasOverriding()) &#123;</span><br><span class="line">throw <span class="built_in">new</span> IllegalStateException("Cannot register alias '" + <span class="keyword">alias</span> + "' for name '" +</span><br><span class="line"><span class="type">name</span> + "': It is already registered for name '" + registeredName + "'.");</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">checkForAliasCircle(<span class="type">name</span>, <span class="keyword">alias</span>);</span><br><span class="line">// 注册别名</span><br><span class="line">this.aliasMap.put(<span class="keyword">alias</span>, <span class="type">name</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析-bean-标签"><a href="#解析-bean-标签" class="headerlink" title="解析 bean 标签"></a>解析 bean 标签</h3><p>processBeanDefinition()先将bean标签解析成BeanDefinitionHolder，再将BeanDefinitionHolder注册到IOC中。而BeanDefinitionHolder是对BeanDefinition的封装。如果说BeanDefinition是bean的描述，那么BeanDefinitionHolder则是对这个描述取一个名字，告诉这个BeanDefinition属于谁。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected void process<span class="constructor">BeanDefinition(Element <span class="params">ele</span>, BeanDefinitionParserDelegate <span class="params">delegate</span>)</span> &#123;</span><br><span class="line"><span class="comment">// 对bean标签进行解析</span></span><br><span class="line">BeanDefinitionHolder bdHolder = delegate.parse<span class="constructor">BeanDefinitionElement(<span class="params">ele</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (bdHolder != null) &#123;</span><br><span class="line">bdHolder = delegate.decorate<span class="constructor">BeanDefinitionIfRequired(<span class="params">ele</span>, <span class="params">bdHolder</span>)</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 这里是将BeanDefinition注册到IOC的入口</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">BeanDefinitionReaderUtils</span>.</span></span>register<span class="constructor">BeanDefinition(<span class="params">bdHolder</span>, <span class="params">getReaderContext</span>()</span>.get<span class="constructor">Registry()</span>);</span><br><span class="line">&#125; catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">get<span class="constructor">ReaderContext()</span>.error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">bdHolder.get<span class="constructor">BeanName()</span> + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发送BeanDefinition注册完成的事件通知</span></span><br><span class="line">get<span class="constructor">ReaderContext()</span>.fire<span class="constructor">ComponentRegistered(<span class="params">new</span> BeanComponentDefinition(<span class="params">bdHolder</span>)</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最重要的两个方法parseBeanDefinitionElement()和registerBeanDefinition()，这里不方便细讲，bean标签里面的子标签、属性太多，留给一下章细说。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
            <tag> IOC </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring源码之IOC - xml - 加载bean定义 1 加载资源文件</title>
      <link href="/2019/11/11/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20xml%20-%20%E5%8A%A0%E8%BD%BDbean%E5%AE%9A%E4%B9%89%201%20%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
      <url>/2019/11/11/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20xml%20-%20%E5%8A%A0%E8%BD%BDbean%E5%AE%9A%E4%B9%89%201%20%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>上一章讲到refreshBeanFactory做了两件事情，一件是创建容器，一件是加载BeanDefinition，即loadBeanDefinitions()。加载BeanDefinition包含两个过程。本章讲第一点。</p><ol><li>加载bean配置文件</li><li>解析bean配置文件</li></ol><h3 id="bean配置文件整体加载过程"><a href="#bean配置文件整体加载过程" class="headerlink" title="bean配置文件整体加载过程"></a>bean配置文件整体加载过程</h3><p>加载bean配置文件的过程可以分为三个：</p><ol><li>初始化XmlBeanDefinitionReader</li><li>解析资源文件路径</li><li>加载文件内容</li></ol><p>loadBeanDefinitions()为抽象方法，由AbstractXmlApplicationContext实现。具体代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">protected void load<span class="constructor">BeanDefinitions(DefaultListableBeanFactory <span class="params">beanFactory</span>)</span> throws BeansException, IOException &#123;</span><br><span class="line"><span class="comment">// 创建一个Bean读取器，用于读取bean的配置资源，即我们在之前提到的BeanDefinitionReader</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> <span class="constructor">XmlBeanDefinitionReader(<span class="params">beanFactory</span>)</span>;</span><br><span class="line"></span><br><span class="line">beanDefinitionReader.set<span class="constructor">Environment(<span class="params">this</span>.<span class="params">getEnvironment</span>()</span>);</span><br><span class="line"><span class="comment">// 设置spring资源加载器，其本身继承了DefaultResourceLoader，也是一个ResourceLoader</span></span><br><span class="line">beanDefinitionReader.set<span class="constructor">ResourceLoader(<span class="params">this</span>)</span>;</span><br><span class="line"><span class="comment">// 设置xml解析器</span></span><br><span class="line">beanDefinitionReader.set<span class="constructor">EntityResolver(<span class="params">new</span> ResourceEntityResolver(<span class="params">this</span>)</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化bean读取器的上下文，主要在这里设置了是否校验xml的开关</span></span><br><span class="line">init<span class="constructor">BeanDefinitionReader(<span class="params">beanDefinitionReader</span>)</span>;</span><br><span class="line"><span class="comment">// 真正实现加载BeanDefinition</span></span><br><span class="line">load<span class="constructor">BeanDefinitions(<span class="params">beanDefinitionReader</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected void load<span class="constructor">BeanDefinitions(XmlBeanDefinitionReader <span class="params">reader</span>)</span> throws BeansException, IOException &#123;</span><br><span class="line">Resource<span class="literal">[]</span> configResources = get<span class="constructor">ConfigResources()</span>;</span><br><span class="line"><span class="keyword">if</span> (configResources != null) &#123;</span><br><span class="line">reader.load<span class="constructor">BeanDefinitions(<span class="params">configResources</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">String<span class="literal">[]</span> configLocations = get<span class="constructor">ConfigLocations()</span>;</span><br><span class="line"><span class="keyword">if</span> (configLocations != null) &#123;</span><br><span class="line">reader.load<span class="constructor">BeanDefinitions(<span class="params">configLocations</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正实现加载BeanDefinition是由loadBeanDefinitions()来处理，这里getConfigResources()默认返回null，所以会走到第二个reader.loadBeanDefinitions()。第二个loadBeanDefinitions()在最后也会将configLocations转换成Resource对象，然后会调用到一个loadBeanDefinitions()。源码如下:</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个loadBeanDefinitions()，多次调用重载方法后的源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> loadBeanDefinitions(<span class="keyword">String</span> location, @Nullable Set&lt;Resource&gt; actualResources) <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"><span class="comment">// 获取初始化时，设置的resourceLoader</span></span><br><span class="line">ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line"><span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Cannot import bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 将指定位置的bean配置信息解析为spring所封装的Resource对象</span></span><br><span class="line">Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line"><span class="comment">// 使用委派调用XmlBeanDefinitionReader.loadBeanDefinitions()。也就是上面第一个loadBeanDefinitions()</span></span><br><span class="line"><span class="built_in">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line"><span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">actualResources.<span class="built_in">add</span>(resource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loadCount;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 加载指定单个的Resource对象</span></span><br><span class="line">Resource resource = resourceLoader.getResource(location);</span><br><span class="line"><span class="comment">// 使用委派调用XmlBeanDefinitionReader.loadBeanDefinitions()</span></span><br><span class="line"><span class="built_in">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line"><span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">actualResources.<span class="built_in">add</span>(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> loadCount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结一下。经过一系列的重载、委托，最后都会走到XmlBeanDefinitionReader.loadBeanDefinitions(Resource)。这也就是真正的加载方法，会在第三小节说明。而走到这个方法，所需要的Resource对象，则是通过resourceLoader.getResources()而来的。</p><h3 id="解析资源文件路径"><a href="#解析资源文件路径" class="headerlink" title="解析资源文件路径"></a>解析资源文件路径</h3><p>这里需要重提的是，在初始化XmlBeanDefinitionReader的时候，设置resourceLoader，传入的this，也就是ClassPathXmlApplicationContext对象。这里调用resourceLoader.getResources()则是父类(DefaultResourceLoader)所实现的方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public Resource get<span class="constructor">Resource(String <span class="params">location</span>)</span> &#123;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Assert</span>.</span></span>not<span class="constructor">Null(<span class="params">location</span>, <span class="string">"Location must not be null"</span>)</span>;</span><br><span class="line"></span><br><span class="line">for (ProtocolResolver protocolResolver : this.protocolResolvers) &#123;</span><br><span class="line">Resource resource = protocolResolver.resolve(location, this);</span><br><span class="line"><span class="keyword">if</span> (resource != null) &#123;</span><br><span class="line">return resource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (location.starts<span class="constructor">With(<span class="string">"/"</span>)</span>) &#123;</span><br><span class="line"><span class="comment">// 如果是文件路径，走默认处理</span></span><br><span class="line">return get<span class="constructor">ResourceByPath(<span class="params">location</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (location.starts<span class="constructor">With(CLASSPATH_URL_PREFIX)</span>) &#123;</span><br><span class="line">return <span class="keyword">new</span> <span class="constructor">ClassPathResource(<span class="params">location</span>.<span class="params">substring</span>(CLASSPATH_URL_PREFIX.<span class="params">length</span>()</span>), get<span class="constructor">ClassLoader()</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 如果是URL路径，特殊处理</span></span><br><span class="line">URL url = <span class="keyword">new</span> <span class="constructor">URL(<span class="params">location</span>)</span>;</span><br><span class="line">return (<span class="module-access"><span class="module"><span class="identifier">ResourceUtils</span>.</span></span>is<span class="constructor">FileURL(<span class="params">url</span>)</span> ? <span class="keyword">new</span> <span class="constructor">FileUrlResource(<span class="params">url</span>)</span> : <span class="keyword">new</span> <span class="constructor">UrlResource(<span class="params">url</span>)</span>);</span><br><span class="line">&#125; catch (MalformedURLException ex) &#123;</span><br><span class="line"><span class="comment">// 既不是文件路径、也不是url形式路径</span></span><br><span class="line">return get<span class="constructor">ResourceByPath(<span class="params">location</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected Resource get<span class="constructor">ResourceByPath(String <span class="params">path</span>)</span> &#123;</span><br><span class="line">return <span class="keyword">new</span> <span class="constructor">ClassPathContextResource(<span class="params">path</span>, <span class="params">getClassLoader</span>()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要区分location是不是为url方法传入。如果是直接new一个UrlResource对象，否则会走到getResourceByPath()，而该方法为protected，允许子类重写，例如FileSystemXmlApplicationContext就重写了该方法，处理文件路径的location。如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected Resource getResourceByPath(String <span class="type">path</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="type">path</span>.startsWith("/")) &#123;</span><br><span class="line"><span class="type">path</span> = <span class="type">path</span>.substring(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">new</span> FileSystemResource(<span class="type">path</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载文件内容"><a href="#加载文件内容" class="headerlink" title="加载文件内容"></a>加载文件内容</h3><p>回到第一节留下的坑，XmlBeanDefinitionReader.loadBeanDefinitions(Resource)。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非空处理</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 开始解析，将资源文件转成sax所需的InputSource对象</span></span><br><span class="line">InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line"><span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 真实读取xml内容过程</span></span><br><span class="line"><span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">inputStream.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line"><span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">currentResources.remove(encodedResource);</span><br><span class="line"><span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class="line"><span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 将其转成Document对象，到这里就慢慢的像我们自己写的代码了</span></span><br><span class="line">Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="comment">// 继续将Document往下传，完成解析</span></span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">registerBeanDefinitions</span><span class="params">(doc, resource)</span></span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> ....&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function">Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler,</span><br><span class="line">getValidationModeForResource(resource), isNamespaceAware());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里为止，又分为两条路，一条就是加载Document对象，一条就是继续真正解析。前者是DefaultDocumentLoader调用jdk的JAXP将xml转换为所需要的Document对象，写过xml的应该很了解，这一块代码就不深入分析了。且看后者：registerBeanDefinitions()</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">int</span> register<span class="constructor">BeanDefinitions(Document <span class="params">doc</span>, Resource <span class="params">resource</span>)</span> throws BeanDefinitionStoreException &#123;</span><br><span class="line"><span class="comment">// 使用委派，获得解析xml的对象</span></span><br><span class="line">BeanDefinitionDocumentReader documentReader = create<span class="constructor">BeanDefinitionDocumentReader()</span>;</span><br><span class="line"><span class="built_in">int</span> countBefore = get<span class="constructor">Registry()</span>.get<span class="constructor">BeanDefinitionCount()</span>;</span><br><span class="line"><span class="comment">// 解析过程的入口，具体实现由DefaultBeanDefinitionDocumentReader实现。</span></span><br><span class="line">documentReader.register<span class="constructor">BeanDefinitions(<span class="params">doc</span>, <span class="params">createReaderContext</span>(<span class="params">resource</span>)</span>);</span><br><span class="line"><span class="comment">// 统计解析bean数量</span></span><br><span class="line">return get<span class="constructor">Registry()</span>.get<span class="constructor">BeanDefinitionCount()</span> - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，从最开始的loadBeanDefinitions()方法说起</p><ol><li>初始化XmlBeanDefinitionReader。</li><li>由XmlBeanDefinitionReader调用loadBeanDefinitions()，该方法分两步：解析文件路径、加载文件内容。</li><li>解析文件路径，分别处理传入的location方式，封装成所需的Resource对象。</li><li>加载文件内容，又分为两步。通过jdk的JAXP将xml转换成文档对象、将该文档对象进行解析。</li></ol><p>第4点中的第二个步骤:registerBeanDefinitions()下章单独描述。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
            <tag> IOC </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring源码之IOC - xml - 创建容器</title>
      <link href="/2019/11/10/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20xml%20-%20%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8/"/>
      <url>/2019/11/10/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20xml%20-%20%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>IOC初始化可归纳为两个步骤，创建容器、加载bean定义。本文以ApplicationContext为例讲解创建容器过程，其实现类为ClassPathXmlApplicationContext。</p><p>ApplicationContext允许嵌套上下文，可以将父上下文维护在一个上下文中，其原理很类似双亲委托加载。对于使用的话，加载一个bean，会先检查当前上下文，然后检索父上下文，逐级向上。这样为spring应用提供一个共享的bean环境，而不用在多个上下文之间来回切换。</p><h3 id="寻找入口"><a href="#寻找入口" class="headerlink" title="寻找入口"></a>寻找入口</h3><p>ApplicationContext主要实现类很多，AnnotationConfigApplicationContext、XmlWebApplicationContext。都继承自父容器AbstractApplicationContext，最后都会调到refresh方法启动，这里以ClassPathXmlApplicationContext为例。通过main方法启动spring。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test<span class="constructor">ConfigLocation()</span> &#123;</span><br><span class="line">ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> <span class="constructor">ClassPathXmlApplicationContext(<span class="string">"application.xml"</span>)</span>;</span><br><span class="line">Service service = (Service) ctx.get<span class="constructor">Bean(<span class="string">"service"</span>)</span>;</span><br><span class="line">ctx.close<span class="literal">()</span>;</span><br><span class="line"><span class="keyword">assert</span><span class="constructor">True(<span class="params">service</span>.<span class="params">isProperlyDestroyed</span>()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中只有主要new一个ClassPathXmlApplicationContext对象，就可以使用IOC获取bean了，那么它的初始化，那么我们只有一个入口，也就是它的构造，而在这个构造中，最后会调用以下重载构造方法。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">ClassPathXmlApplicationContext</span>(</span><br><span class="line">String[] configLocations, boolean refresh, <span class="variable">@Nullable</span> ApplicationContext parent)</span><br><span class="line"><span class="selector-tag">throws</span> <span class="selector-tag">BeansException</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">super</span>(parent);</span><br><span class="line"><span class="selector-tag">setConfigLocations</span>(configLocations);</span><br><span class="line"><span class="selector-tag">if</span> (refresh) &#123;</span><br><span class="line"><span class="selector-tag">refresh</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载配置"><a href="#加载配置" class="headerlink" title="加载配置"></a>加载配置</h3><p>通过上面构造方法，在调用refresh()之前会调用父类构造，和调用setConfigLocations()处理传进来配置文件。<br>我们先看父类构造，会一直往上调用，直到AbstractApplicationContext，最后我将多个构造合并之后结果如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> ...</span>&#123;</span><br><span class="line"><span class="keyword">public</span> AbstractApplicationContext(<span class="meta">@Nullable</span> ApplicationContext parent) &#123;</span><br><span class="line"><span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">setParent(parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于读取spring bean配置信息</span></span><br><span class="line"><span class="keyword">protected</span> ResourcePatternResolver getResourcePatternResolver() &#123;</span><br><span class="line"><span class="keyword">return</span> new PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实就是准备一下工作，接下来就是setConfigLocations()了，该方法由AbstractRefreshableConfigApplicationContext实现，进行bean配置的定义。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> setConfigLocations(@Nullable <span class="keyword">String</span>... locations) &#123;</span><br><span class="line"><span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">Assert.noNullElements(locations, <span class="string">"Config locations must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.configLocations = <span class="keyword">new</span> <span class="keyword">String</span>[locations.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line"><span class="comment">//解析bean定义资源文件路径</span></span><br><span class="line"><span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).<span class="built_in">trim</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最重要的是resolvePath()，该方法为同一个类中将字符串解析为路劲。并将其保存。</p><h3 id="整体启动过程"><a href="#整体启动过程" class="headerlink" title="整体启动过程"></a>整体启动过程</h3><p>之前多多少少都应该知道spring启动是调用refresh()方法的。但是refresh()却是一个模板方法，只规定了spring启动流程，许多实现逻辑，需要深入它的子类实现中。这一节整体的看一下refresh()。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public void refresh<span class="literal">()</span> throws BeansException, IllegalStateException &#123;</span><br><span class="line">synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// 容器刷新前，预处理方法。获取启动时间，以及各种标记处理</span></span><br><span class="line">prepare<span class="constructor">Refresh()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供抽象方法refreshBeanFactory，由子类刷新BeanFactory</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtain<span class="constructor">FreshBeanFactory()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给BeanFactory对象配置类加载器、事件处理器等</span></span><br><span class="line">prepare<span class="constructor">BeanFactory(<span class="params">beanFactory</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 提供默认方法供子类重写。用于在标准初始化之后，某些子类需要修改应用程序上下文的内部beanFactory。此时IOC初始化已经完成。</span></span><br><span class="line">post<span class="constructor">ProcessBeanFactory(<span class="params">beanFactory</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用所以注册的BeanFactoryPostProcessor的bean</span></span><br><span class="line">invoke<span class="constructor">BeanFactoryPostProcessors(<span class="params">beanFactory</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为BeanFacytory注册Post事件处理器，BeanPostProcessor为bean创建后置处理器，可用于监听事件。</span></span><br><span class="line">register<span class="constructor">BeanPostProcessors(<span class="params">beanFactory</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信息源，国际化</span></span><br><span class="line">init<span class="constructor">MessageSource()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化容器事件传播器</span></span><br><span class="line">init<span class="constructor">ApplicationEventMulticaster()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供默认方法供子类重写，处理特殊bean初始化</span></span><br><span class="line">on<span class="constructor">Refresh()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为事件传播器注册监听器</span></span><br><span class="line">register<span class="constructor">Listeners()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化所有剩余的单例bean，(非懒加载的)</span></span><br><span class="line">finish<span class="constructor">BeanFactoryInitialization(<span class="params">beanFactory</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布IOC启动完事件</span></span><br><span class="line">finish<span class="constructor">Refresh()</span>;</span><br><span class="line">&#125; catch (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.is<span class="constructor">WarnEnabled()</span>) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁bean</span></span><br><span class="line">destroy<span class="constructor">Beans()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要刷新操作，重置同步标识</span></span><br><span class="line">cancel<span class="constructor">Refresh(<span class="params">ex</span>)</span>;</span><br><span class="line"></span><br><span class="line">throw ex;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line"><span class="comment">// 重设公共缓存</span></span><br><span class="line">reset<span class="constructor">CommonCaches()</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实refresh()方法主要为IOC容器的bean管理生命周期。IOC容器载入bean配置信息，由子类的refreshBeanFactory()实现，也就是说obtainFreshBeanFactory()以后的代码都在注册容器的信息源和生命周期。</p><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p>从obtainFreshBeanFactory()进入，查看其子类的AbstractRefreshableApplicationContext.refreshBeanFactory()。该方法真正完成了IOC的初始化过程。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected final void refresh<span class="constructor">BeanFactory()</span> throws BeansException &#123;</span><br><span class="line"><span class="comment">// 注销之前所有创建beanFactory</span></span><br><span class="line"><span class="keyword">if</span> (has<span class="constructor">BeanFactory()</span>) &#123;</span><br><span class="line">destroy<span class="constructor">Beans()</span>;</span><br><span class="line">close<span class="constructor">BeanFactory()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建IOC</span></span><br><span class="line">DefaultListableBeanFactory beanFactory = create<span class="constructor">BeanFactory()</span>;</span><br><span class="line">beanFactory.set<span class="constructor">SerializationId(<span class="params">getId</span>()</span>);</span><br><span class="line"><span class="comment">// 设置一些启动参数，注解装配等</span></span><br><span class="line">customize<span class="constructor">BeanFactory(<span class="params">beanFactory</span>)</span>;</span><br><span class="line"><span class="comment">// 加载bean配置，由子类实现</span></span><br><span class="line">load<span class="constructor">BeanDefinitions(<span class="params">beanFactory</span>)</span>;</span><br><span class="line">synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">this.beanFactory = beanFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (IOException ex) &#123;</span><br><span class="line">throw <span class="keyword">new</span> <span class="constructor">ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + <span class="params">getDisplayName</span>()</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">protected DefaultListableBeanFactory create<span class="constructor">BeanFactory()</span> &#123;</span><br><span class="line">return <span class="keyword">new</span> <span class="constructor">DefaultListableBeanFactory(<span class="params">getInternalParentBeanFactory</span>()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>refreshBeanFactory()值得注意的是，它会先销毁之前的beanfactory，然后在createBeanFactory()方法中new一个DefaultListableBeanFactory的对象，以保证后续所有的方法，都调用先创建的beanFactory。它还做了另一件事情就是loadBeanDefinitions()这个方法用于解析bean的配置信息，然后转换成BeanDefinition对象，供spring使用。下一章再详细解说。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
            <tag> IOC </tag>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring源码之IOC - 源码预读</title>
      <link href="/2019/11/09/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20%E6%BA%90%E7%A0%81%E9%A2%84%E8%AF%BB/"/>
      <url>/2019/11/09/java/spring%E6%BA%90%E7%A0%81%E4%B9%8BIOC%20-%20%E6%BA%90%E7%A0%81%E9%A2%84%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>spring作为粘合剂，其中IOC是它的基础，即控制反转，将项目中对对象的创建、依赖，交给IOC容器来完成。而每一个对象创建方式都各不相同，那么IOC要集中管理这一切，肯定不是一件简单的工作。本篇将介绍IOC容器整体启动的过程。</p><h3 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h3><p>IOC容器，是一个典型的工厂模式实现，BeanFactory是IOC最顶层的接口，规范了IOC最基础的功能。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface BeanFactory &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于配合FactoryBean的使用，当需要取得FactoryBean本身的对象时，需要加上该字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">String</span> FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从IOC容器中获取bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">Object</span> getBean(<span class="keyword">String</span> name) <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T getBean(<span class="keyword">String</span> name, @Nullable Class&lt;T&gt; requiredType) <span class="keyword">throws</span> BeansException;</span><br><span class="line"><span class="keyword">Object</span> getBean(<span class="keyword">String</span> name, <span class="keyword">Object</span>... args) <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T getBean(Class&lt;T&gt; requiredType) <span class="keyword">throws</span> BeansException;</span><br><span class="line">&lt;T&gt; T getBean(Class&lt;T&gt; requiredType, <span class="keyword">Object</span>... args) <span class="keyword">throws</span> BeansException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检索bean，是否存在于IOC容器中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">boolean</span> containsBean(<span class="keyword">String</span> name);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否为单例bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">boolean</span> isSingleton(<span class="keyword">String</span> name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line"><span class="built_in">boolean</span> isPrototype(<span class="keyword">String</span> name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"><span class="built_in">boolean</span> isTypeMatch(<span class="keyword">String</span> name, ResolvableType typeToMatch) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"><span class="built_in">boolean</span> isTypeMatch(<span class="keyword">String</span> name, @Nullable Class&lt;?&gt; typeToMatch) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据bean名字，返回bean的class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Nullable</span><br><span class="line">Class&lt;?&gt; getType(<span class="keyword">String</span> name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">String</span>[] getAliases(<span class="keyword">String</span> name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanFactory有三个重要的子接口：ListableBeanFactory、AutowireCapableBeanFactory、HierarchicalBeanFactory，最后都由DefaultListableBeanFactory来实现，之所以分别定义这么接口，是为了区别每一个接口的使用场合，对对象的数据访问做限制。例如</p><ul><li>ListableBeanFactory 规范了bean的集合，表示bean可列表化。</li><li>AutowireCapableBeanFactory 规范了bean的行为，表示自动装配规则。</li><li>HierarchicalBeanFactory 规范了bean之间的关系，表示bean有继承关系，可能存在父bean。</li></ul><p>我们通常说的ApplicationContext接口，是spring提供对BeanFactory功能增强的规范。spring提供了很多对IOC的实现，比如GenericApplicationContext、ClassPathXmlApplicationContext等。</p><h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>每一个bean初始化的规则都不一样，我们通过xml或者注解配置bean的依赖关系后，spring会将其转换成BeanDefinition保存在IOC容器中，待bean真正创建的时候使用。所以BeanDefinition描述了整个bean的信息，包含依赖关系。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例还是原型定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">String</span> SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line"><span class="keyword">String</span> SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * bean的角色定义，表示用户定义bean、外部配置、完全与用户无关角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类名字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(@Nullable <span class="keyword">String</span> parentName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class名字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(@Nullable <span class="keyword">String</span> beanClassName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单例还是原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(@Nullable <span class="keyword">String</span> scope)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否懒加载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(@Nullable <span class="keyword">String</span>... dependsOn)</span></span>;</span><br><span class="line"><span class="keyword">String</span>[] getDependsOn();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(@Nullable <span class="keyword">String</span> factoryBeanName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(@Nullable <span class="keyword">String</span> factoryMethodName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasConstructorArgumentValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !getConstructorArgumentValues().isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !getPropertyValues().isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">getResourceDescription</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一路看下来，spring的方法名字感觉挺符合中国人取名字的习惯，一看就能懂得那种。所以也没有写得过细。</p><h3 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h3><p>看上面BeanDefinition所描述的信息，就知道bean解析非常复杂，而BeanDefinition中所描述的信息，spring都需要留出可扩展的地方，保证足够灵活，而xml解析过程由BeanDefinitionReader来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"><span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ClassLoader <span class="title">getBeanClassLoader</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BeanNameGenerator <span class="title">getBeanNameGenerator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析bean定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原理预透"><a href="#原理预透" class="headerlink" title="原理预透"></a>原理预透</h3><p>IOC初始化，基本可以理解成两个动作。准备容器、加载BeanDefinition。而加载BeanDefinition大致过程分为：</p><ol><li>由ResourceLoader来完成资源文件的定位</li><li>将Resource对象交给BeanDefinitionReader来完成解析</li><li>容器解析得到BeanDefinition后，需要在IOC中注册，由BeanDefinitionRegistry来完成</li></ol><p>多说一句，BeanDefinitionRegistry的注册过程就是在IOC内部维护了一个Map，用来保存BeanDefinition，后续对bean的所有操作都围绕这个Map来完成。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
            <tag> IOC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring源码解析</title>
      <link href="/2019/11/09/java/spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/11/09/java/spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>本系列博客为看书留下的笔记，记录整个spring运行过程。主要分为四个模块，如下</p><ul><li>spring 启动(ClassPathXmlApplicationContext)<ul><li>分割传入location路径</li><li>refresh()模板启动<ul><li>IOC 启动(obtainFreshBeanFactory())<ul><li>准备容器<ul><li>销毁之前容器</li><li>创建新容器</li></ul></li><li>加载BeanDefinition<ul><li>初始化XmlBeanDefinitionReader</li><li>解析资源文件路径(分别处理location为文件路径、URL路径、等情况，封装成Resource对象)</li><li>加载文件内容(根据Resource对象，加载xml的Document对象)</li><li>解析xml，封装成BeanDefinition<ul><li>import标签(获得location，继续上述步骤)</li><li>alias标签(向Map中保存alias-&gt;name的关系)</li><li>bean标签<ul><li>处理id、name属性(非空、重复等处理)</li><li>处理其他属性，保存至BeanDefinition中</li><li>处理子标签（propertity、list等）</li></ul></li></ul></li><li>向IOC中注册BeanDefinition<ul><li>向IOC中的Map保存beanName-&gt;beanDefinition的映射关系</li><li>向IOC中的Map保存alias-&gt;beanName的映射关系</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="IOC总结"><a href="#IOC总结" class="headerlink" title="IOC总结"></a>IOC总结</h3><p>IOC初始化入口从refresh()方法进入，obtainFreshBeanFactory()完后容器创建和bean定义的加载，其中加载bean定义由ResourceLoader来完成资源文件的定位，DefaultResourceLoader给出它的实现，可以通过类路径、文件路径、URL等方式来定位资源，最后封装成Resource对象，交由IOC处理。BeanDefinitionReader根据Resource来完成bean定义解析和bean定义注册，其中bean定义解析由BeanDefinitionParseDelegate完成并封装成BeanDefinition。然后BeanDefinitionReader完成第二步骤：注册Bean定义，注册的过程就是将其保存在IOC中的HashMap中，后续对bean的操作全都依赖该Map。</p><ol start="2"><li>DI</li><li>AOP</li><li>springMVC</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo番外篇-【mock上游服务】</title>
      <link href="/2019/10/29/java/dubbo%E7%95%AA%E5%A4%96%E7%AF%87-%E3%80%90mock%E4%B8%8A%E6%B8%B8%E6%9C%8D%E5%8A%A1%E3%80%91/"/>
      <url>/2019/10/29/java/dubbo%E7%95%AA%E5%A4%96%E7%AF%87-%E3%80%90mock%E4%B8%8A%E6%B8%B8%E6%9C%8D%E5%8A%A1%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>系统生态化后，最头疼的事请就是强依赖上游系统提供的服务。当服务链路太长，开发过程要求部署整套服务，这个需要的资源是巨大的。最近着手解决这个问题，今天记录下来。</p><p>在解决这个问题的过程中，得到三种解决方案。如下：</p><ol><li>dubbo提供的服务降级（本地伪装）</li><li>dubbo客户端本地存根</li><li>手动替换<br>我选择的是第三种，至于为什么选择第三种，是因为前两种都需要修改原有的代码来实现，以及我还需要一个开关来控制是否需要调用mock服务。所以最后选择自己实现。</li></ol><h3 id="dubbo提供的服务降级"><a href="#dubbo提供的服务降级" class="headerlink" title="dubbo提供的服务降级"></a>dubbo提供的服务降级</h3><p>dubbo本身是提供降级服务的，不过比较简单，在官方解释中，也叫做本地伪装。</p><p>服务降级，设计是，在当服务提供方宕机或者超时后，客户端不抛出异常，而是通过mock数据返回所设定的值。</p><p>在spring配置文件中，按照以下方式配置：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference <span class="keyword">interface</span>=<span class="string">"com.ofcoder.IWelcome"</span> mock=<span class="string">"com.ofcoder.WelcomeMock"</span> /&gt;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference(mock=<span class="meta-string">"com.ofcoder.WelcomeMock"</span>)</span></span><br></pre></td></tr></table></figure><p>然后你需要提供所指定的Mock类，该类要求继承所需要降级的接口。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeMock</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">IWelcome</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> sayHello(<span class="keyword">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hey guy."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当上游服务调用失败后，则会自动触发降级服务。mock的值还支持return、throw、force等关键字。</p><h4 id="return"><a href="#return" class="headerlink" title="return"></a>return</h4><p>使用 return 来返回一个字符串表示的对象，作为 Mock 的返回值。合法的字符串可以是：</p><ol><li>empty: 代表空，基本类型的默认值，或者集合类的空值</li><li>null: null</li><li>true: true</li><li>false: false</li><li>JSON 格式: 反序列化 JSON 所得到的对象</li></ol><h4 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h4><p>使用 throw 来返回一个 Exception 对象，作为 Mock 的返回值。</p><p>抛出默认的RPCException</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference <span class="keyword">interface</span>=<span class="string">"com.ofcoder.IWelcome"</span> mock=<span class="string">"throw"</span> /&gt;</span><br></pre></td></tr></table></figure><p>抛出指定的Exception：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference <span class="keyword">interface</span>=<span class="string">"com.ofcoder.IWelcome"</span> mock=<span class="string">"throw com.ofcoder.MockException"</span> /&gt;</span><br></pre></td></tr></table></figure><h4 id="force"><a href="#force" class="headerlink" title="force"></a>force</h4><p>force用来强制执行降级服务，这种情况不会调用远程服务。</p><p>强制抛异常：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference <span class="keyword">interface</span>=<span class="string">"com.ofcoder.IWelcome"</span> mock=<span class="string">"force:throw com.ofcoder.MockException"</span> /&gt;</span><br></pre></td></tr></table></figure><h3 id="dubbo客户端存根"><a href="#dubbo客户端存根" class="headerlink" title="dubbo客户端存根"></a>dubbo客户端存根</h3><p>降级是在服务调用之后，根据调用结果判断是否需要返回mock数据，而存根（Stub）是在调用之前增强服务。可以理解成AOP增强。</p><p>实现原理是由，dubbo把客户端某个接口生成Proxy实例，通过Stub的构造方法传给Stub对象，这个Stub对象由用户实现，用户可根据具体场景判断是否需要继续调用上游服务。可用来ThreadLocal缓存，提前验证参数，调用失败后伪造容错数据等等。</p><p>如果将服务降级加进来，调用过程可以归纳为：xxxStub -&gt; xxxProxy -&gt; xxxMock</p><p>使用方式跟降级很相似：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service <span class="keyword">interface</span>=<span class="string">"com.ofcoder.IWelcome"</span> stub=<span class="string">"com.ofcoder.WelcomeStub"</span> /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeStub</span> <span class="title">implements</span> <span class="title">IWelcome</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IWelcome welcome;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Stub 必须有可传入 Proxy 的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WelcomeStub</span><span class="params">(IWelcome welcome)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.welcome = welcome;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> welcome.sayHello(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hey guys"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手动替换"><a href="#手动替换" class="headerlink" title="手动替换"></a>手动替换</h3><p>实现过程是，在spring的IOC初始化之后，扫描@Reference注解，将用该注解标注的接口，使用mocktio生成mock对象，然后替换掉spring中bean，并反射将mock值塞入指定对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboMock</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DubboMock<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCANNER_PACKAGE = <span class="string">"com.ofcoder.remote"</span>;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;ofcoder.mock.dubbo.enable&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mockEnable;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerMock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultListableBeanFactory defaultListableBeanFactory = (DefaultListableBeanFactory) applicationContext.getAutowireCapableBeanFactory();</span><br><span class="line"></span><br><span class="line">        IWelcome welcome = Mockito.mock(IWelcome<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Mockito.doReturn(<span class="keyword">new</span> Result(ResultEnum.SUCCESS)).when(welcome).sayHello(Mockito.any());</span><br><span class="line">        defaultListableBeanFactory.registerSingleton(IWelcome<span class="class">.<span class="keyword">class</span>.<span class="title">getCanonicalName</span>(), <span class="title">welcome</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doMock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Reflections reflections = <span class="keyword">new</span> Reflections(<span class="keyword">new</span> ConfigurationBuilder().setUrls(ClasspathHelper</span><br><span class="line">                .forPackage(SCANNER_PACKAGE)).setScanners(<span class="keyword">new</span> FieldAnnotationsScanner()));</span><br><span class="line"></span><br><span class="line">        Set&lt;Field&gt; fields = reflections.getFieldsAnnotatedWith(Reference<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            Class&lt;?&gt; declaringClass = field.getDeclaringClass();</span><br><span class="line">            Class&lt;?&gt; fieldClass = field.getType();</span><br><span class="line">            logger.info(<span class="string">"======declaringClass:&#123;&#125;, fieldClass:&#123;&#125;====="</span>, declaringClass, fieldClass);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object target = applicationContext.getBean(declaringClass);</span><br><span class="line">                Object rpcObj = applicationContext.getBean(fieldClass);</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                field.set(target, rpcObj);</span><br><span class="line">                logger.info(<span class="string">"======mock &#123;&#125;.&#123;&#125; success. this is a thing worth cheering.====="</span>, declaringClass.getName(), field.getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.warn(String.format(<span class="string">"======mock %s.%s occur exception. e.getMessage: %s"</span>, declaringClass.getSimpleName(), field.getName(), e.getMessage()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mockEnable) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        registerMock();</span><br><span class="line"></span><br><span class="line">        doMock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做有一个缺点，在启动的时候需要上游系统提供了服务，不然dubbo会报no provider的错误，这里建议启动时不检查服务</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="constructor">Reference(<span class="params">check</span> = <span class="params">false</span>)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
            <tag> mock </tag>
            
            <tag> 服务降级 </tag>
            
            <tag> 存根 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写dubbo 12-基于tomcat实现RPC(番外篇)</title>
      <link href="/2019/10/28/java/%E6%89%8B%E5%86%99dubbo%2012-%E5%9F%BA%E4%BA%8Etomcat%E5%AE%9E%E7%8E%B0RPC(%E7%95%AA%E5%A4%96%E7%AF%87)/"/>
      <url>/2019/10/28/java/%E6%89%8B%E5%86%99dubbo%2012-%E5%9F%BA%E4%BA%8Etomcat%E5%AE%9E%E7%8E%B0RPC(%E7%95%AA%E5%A4%96%E7%AF%87)/</url>
      
        <content type="html"><![CDATA[<p>博客中代码地址：<a href="https://github.com/farliu/farpc.git" target="_blank" rel="noopener">https://github.com/farliu/farpc.git</a><br><img src="/images/java/dubbo/dubbo_implement_1_1.png" alt="dubbo架构"></p><p>直至上一章，手写dubbo全部介绍完了，这一章作为番外篇，了解如何使用内嵌tomcat。</p><h3 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h3><p><img src="/images/java/dubbo/dubbo_implement_2_1.png" alt="项目结构"><br>本节涉及博客中代码的module，farpc-rpc（远程调用）。</p><h3 id="内嵌tomcat使用"><a href="#内嵌tomcat使用" class="headerlink" title="内嵌tomcat使用"></a>内嵌tomcat使用</h3><p>使用tomcat，自然就是http协议，我们先导入tomcat的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继续实现之前留下的扩展接口IConsumerServer、IProviderServer。在实现IProviderServer之前，我们需要先得到一个Servlet用于处理请求。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void service(<span class="type">HttpServletRequest</span> req, <span class="type">HttpServletResponse</span> resp) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">HttpServerHandler</span>().handle(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便扩展，我在servlet中调用定义的Handler，后续如果需要增加Handler，也只要修改这里就行了。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> HttpServerHandler &#123;</span><br><span class="line">    <span class="keyword">private</span> static final Logger logger = <span class="module-access"><span class="module"><span class="identifier">LoggerFactory</span>.</span></span>get<span class="constructor">Logger(HttpServerHandler.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    public void handle(HttpServletRequest req, HttpServletResponse resp) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServletInputStream inputStream = req.get<span class="constructor">InputStream()</span>;</span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> <span class="constructor">ObjectInputStream(<span class="params">inputStream</span>)</span>;</span><br><span class="line">            RequestDTO requestDTO = (RequestDTO) objectInputStream.read<span class="constructor">Object()</span>;</span><br><span class="line"></span><br><span class="line">            Object result = <span class="keyword">new</span> <span class="constructor">Object()</span>;</span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">"receive request.. &#123;&#125;"</span>, requestDTO);</span><br><span class="line">            <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Container</span>.</span></span>get<span class="constructor">Providers()</span>.contains<span class="constructor">Key(<span class="params">requestDTO</span>.<span class="params">getClassName</span>()</span>)) &#123;</span><br><span class="line">                Object provider = <span class="module-access"><span class="module"><span class="identifier">Container</span>.</span></span>get<span class="constructor">Providers()</span>.get(requestDTO.get<span class="constructor">ClassName()</span>);</span><br><span class="line"></span><br><span class="line">                Class&lt;?&gt; providerClazz = provider.get<span class="constructor">Class()</span>;</span><br><span class="line">                Method <span class="keyword">method</span> = providerClazz.get<span class="constructor">Method(<span class="params">requestDTO</span>.<span class="params">getMethodName</span>()</span>, requestDTO.get<span class="constructor">Types()</span>);</span><br><span class="line">                result = <span class="keyword">method</span>.invoke(provider, requestDTO.get<span class="constructor">Params()</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> <span class="constructor">ObjectOutputStream(<span class="params">resp</span>.<span class="params">getOutputStream</span>()</span>);</span><br><span class="line">            objectOutputStream.write<span class="constructor">Object(<span class="params">result</span>)</span>;</span><br><span class="line">            objectOutputStream.flush<span class="literal">()</span>;</span><br><span class="line">            objectOutputStream.close<span class="literal">()</span>;</span><br><span class="line"><span class="comment">//            IOUtils.write(result.toString(), resp.getOutputStream());</span></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler的代码也很容易理解，就是从Request中获得请求参数，然后根据请求参数反射执行对应的方法，然后输出到输出流中。</p><p>对于IConsumerServer的实现，就是Http调用了，代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> HttpConsumerServer implements IConsumerServer &#123;</span><br><span class="line">    public Object execute(String address, RequestDTO requestDTO) &#123;</span><br><span class="line">        String<span class="literal">[]</span> addrs = address.split(<span class="string">":"</span>);</span><br><span class="line">        String ip = addrs<span class="literal">[<span class="number">0</span>]</span>;</span><br><span class="line">        Integer port = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">addrs</span>[1])</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> <span class="constructor">URL(<span class="string">"http"</span>, <span class="params">ip</span>, <span class="params">port</span>, <span class="string">"/"</span>)</span>;</span><br><span class="line">            HttpURLConnection httpURLConnection = (HttpURLConnection) url.<span class="keyword">open</span><span class="constructor">Connection()</span>;</span><br><span class="line">            httpURLConnection.set<span class="constructor">RequestMethod(<span class="string">"POST"</span>)</span>;</span><br><span class="line">            httpURLConnection.set<span class="constructor">DoOutput(<span class="params">true</span>)</span>;</span><br><span class="line">            httpURLConnection.set<span class="constructor">DoInput(<span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">            OutputStream outputStream = httpURLConnection.get<span class="constructor">OutputStream()</span>;</span><br><span class="line">            ObjectOutputStream objectOutputStream = <span class="keyword">new</span> <span class="constructor">ObjectOutputStream(<span class="params">outputStream</span>)</span>;</span><br><span class="line">            objectOutputStream.write<span class="constructor">Object(<span class="params">requestDTO</span>)</span>;</span><br><span class="line">            objectOutputStream.flush<span class="literal">()</span>;</span><br><span class="line">            objectOutputStream.close<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            InputStream inputStream = httpURLConnection.get<span class="constructor">InputStream()</span>;</span><br><span class="line">            ObjectInputStream objectInputStream = <span class="keyword">new</span> <span class="constructor">ObjectInputStream(<span class="params">inputStream</span>)</span>;</span><br><span class="line">            Object result =  objectInputStream.read<span class="constructor">Object()</span>;</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有别忘了增加SPI扩展点</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http=com<span class="selector-class">.ofcoder</span><span class="selector-class">.farpc</span><span class="selector-class">.rpc</span><span class="selector-class">.http</span>.HttpConsumerServer</span><br><span class="line"></span><br><span class="line">http=com<span class="selector-class">.ofcoder</span><span class="selector-class">.farpc</span><span class="selector-class">.rpc</span><span class="selector-class">.http</span>.HttpProviderServer</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试代码位于farpc-demo的模块下。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void provider<span class="constructor">Test()</span> throws IOException &#123;</span><br><span class="line">    IProviderServer server = <span class="module-access"><span class="module"><span class="identifier">RpcFactory</span>.</span></span>get<span class="constructor">ProviderServer()</span>;</span><br><span class="line">    server.start(<span class="string">"127.0.0.1:20880"</span>);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span><span class="keyword">in</span>.read<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void consumer<span class="constructor">Test()</span>&#123;</span><br><span class="line">    IWelcome welcome = <span class="module-access"><span class="module"><span class="identifier">ConsumerProxy</span>.</span></span>create(<span class="module-access"><span class="module"><span class="identifier">IWelcome</span>.</span></span><span class="keyword">class</span>);</span><br><span class="line">    String far = welcome.greet(<span class="string">"far"</span>);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(far);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以分别看到相应的日志。服务提供端日志如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">十月 28, 2019 9<span class="selector-pseudo">:55</span><span class="selector-pseudo">:57</span> 下午 <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.coyote</span><span class="selector-class">.AbstractProtocol</span> <span class="selector-tag">init</span></span><br><span class="line">信息: <span class="selector-tag">Initializing</span> <span class="selector-tag">ProtocolHandler</span> <span class="selector-attr">[<span class="string">"http-nio-20880"</span>]</span></span><br><span class="line">十月 28, 2019 9<span class="selector-pseudo">:55</span><span class="selector-pseudo">:57</span> 下午 <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.catalina</span><span class="selector-class">.core</span><span class="selector-class">.StandardService</span> <span class="selector-tag">startInternal</span></span><br><span class="line">信息: <span class="selector-tag">Starting</span> <span class="selector-tag">service</span> <span class="selector-attr">[Tomcat]</span></span><br><span class="line">十月 28, 2019 9<span class="selector-pseudo">:55</span><span class="selector-pseudo">:57</span> 下午 <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.catalina</span><span class="selector-class">.core</span><span class="selector-class">.StandardEngine</span> <span class="selector-tag">startInternal</span></span><br><span class="line">信息: <span class="selector-tag">Starting</span> <span class="selector-tag">Servlet</span> <span class="selector-tag">engine</span>: <span class="selector-attr">[Apache Tomcat/9.0.27]</span></span><br><span class="line">十月 28, 2019 9<span class="selector-pseudo">:55</span><span class="selector-pseudo">:57</span> 下午 <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.coyote</span><span class="selector-class">.AbstractProtocol</span> <span class="selector-tag">start</span></span><br><span class="line">信息: <span class="selector-tag">Starting</span> <span class="selector-tag">ProtocolHandler</span> <span class="selector-attr">[<span class="string">"http-nio-20880"</span>]</span></span><br></pre></td></tr></table></figure><p>消费端：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[<span class="number">28</span>/<span class="number">10</span>/<span class="number">19</span> <span class="number">21</span>:<span class="number">56</span>:<span class="number">56</span>:<span class="number">191</span> CST] main-EventThread  INFO state.ConnectionStateManager: State change: CONNECTED</span><br><span class="line">hello far, welcome to ofcoder.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> tomcat </tag>
            
            <tag> dubbo </tag>
            
            <tag> 源码 </tag>
            
            <tag> RPC </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写dubbo 11-动态代理的应用</title>
      <link href="/2019/10/24/java/%E6%89%8B%E5%86%99dubbo%2011-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2019/10/24/java/%E6%89%8B%E5%86%99dubbo%2011-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>博客中代码地址：<a href="https://github.com/farliu/farpc.git" target="_blank" rel="noopener">https://github.com/farliu/farpc.git</a><br><img src="/images/java/dubbo/dubbo_implement_1_1.png" alt="dubbo架构"></p><p>上一章我们了解了dubbo最核心的一块，就是数据传输和调用，我们知道真正调用的原理。以及更早的时候还介绍注册中心的实现，用来管理每一个服务提供者的信息，供消费者路由到相关的服务提供者上去。这个过程细想，做的事情还挺多的。dubbo不可能为每一个服务都去实现从注册中心拿到提供者，负载均衡后调用指定的提供者，而且这个给框架使用者去实现也不合适。那么dubbo解决这一问题的方案就是动态代理。</p><p>在更早之前也有提到过这一块,感兴趣可以先了解:<a href="https://www.ofcoder.com/2019/04/09/java/%E8%B0%88%E8%B0%88mybatis%E3%80%81dubbo%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/">谈谈mybatis、dubbo基础原理</a></p><p>这章基本内容就是为提供的api接口,生成代理类,在代理类中实现上述所说的,调用注册中心、负载均衡、远程调用等等</p><h3 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h3><p><img src="/images/java/dubbo/dubbo_implement_2_1.png" alt="项目结构"><br>本节涉及博客中代码的两个module，farpc-rpc（远程调用）、farpc-demo。</p><h3 id="代理实现"><a href="#代理实现" class="headerlink" title="代理实现"></a>代理实现</h3><p>ConsumerProxy需要做的事情,上面讲的很详细了,这里罗列一下.</p><ol><li>生成代理类</li><li>调用注册中心</li><li>远程调用<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> ConsumerProxy &#123;</span><br><span class="line">    <span class="keyword">private</span> static final Logger logger = <span class="module-access"><span class="module"><span class="identifier">LoggerFactory</span>.</span></span>get<span class="constructor">Logger(ConsumerProxy.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; T create(final Class&lt;T&gt; interfaceClass) &#123;</span><br><span class="line">        Object o = <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">interfaceClass</span>.<span class="params">getClassLoader</span>()</span>, <span class="keyword">new</span> Class<span class="literal">[]</span>&#123;interfaceClass&#125;</span><br><span class="line">                , <span class="keyword">new</span> <span class="constructor">InvocationHandler()</span> &#123;</span><br><span class="line">                    public Object invoke(Object proxy, Method <span class="keyword">method</span>, Object<span class="literal">[]</span> args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 封装调用参数</span></span><br><span class="line">                        RequestDTO requestDTO = <span class="keyword">new</span> <span class="constructor">RequestDTO()</span>;</span><br><span class="line">                        requestDTO.set<span class="constructor">ClassName(<span class="params">method</span>.<span class="params">getDeclaringClass</span>()</span>.get<span class="constructor">Name()</span>);</span><br><span class="line">                        requestDTO.set<span class="constructor">MethodName(<span class="params">method</span>.<span class="params">getName</span>()</span>);</span><br><span class="line">                        requestDTO.set<span class="constructor">Types(<span class="params">method</span>.<span class="params">getParameterTypes</span>()</span>);</span><br><span class="line">                        requestDTO.set<span class="constructor">Params(<span class="params">args</span>)</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 获取服务提供者</span></span><br><span class="line">                        IRegistrar registrar = <span class="module-access"><span class="module"><span class="identifier">RegistrarFactory</span>.</span></span>get<span class="constructor">Registrar()</span>;</span><br><span class="line">                        String service = interfaceClass.get<span class="constructor">Name()</span>;</span><br><span class="line">                        String serivceAddress = registrar.discover(service);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 调用上一章写的远程调用</span></span><br><span class="line">                        Object result = <span class="module-access"><span class="module"><span class="identifier">RpcFactory</span>.</span></span>get<span class="constructor">ConsumerService()</span>.execute(serivceAddress, requestDTO);</span><br><span class="line">                        return result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        return (T) o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>由于这里实现只是rpc调用,没有完整的生命周期,也就是说在消费者调用这里还可以优化.比如像dubbo一样在项目启动时去解析xml或者扫描Reference注解.这一块是本系列博客所缺少的.</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在启动服务端后,我们再测试直接调用接口的代理对象,对于扫描Reference注解,然后像spring那样注入到具体对象中,也可以再做更深的了解.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void consumer<span class="constructor">Test()</span>&#123;</span><br><span class="line">    IWelcome welcome = <span class="module-access"><span class="module"><span class="identifier">ConsumerProxy</span>.</span></span>create(<span class="module-access"><span class="module"><span class="identifier">IWelcome</span>.</span></span><span class="keyword">class</span>);</span><br><span class="line">    String far = welcome.greet(<span class="string">"far"</span>);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(far);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于上面的运行结果,也肯定是令人满意的,期待各位自己测试.</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> dubbo </tag>
            
            <tag> 源码 </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写dubbo 10-基于netty实现RPC</title>
      <link href="/2019/10/21/java/%E6%89%8B%E5%86%99dubbo%2010-%E5%9F%BA%E4%BA%8Enetty%E5%AE%9E%E7%8E%B0RPC/"/>
      <url>/2019/10/21/java/%E6%89%8B%E5%86%99dubbo%2010-%E5%9F%BA%E4%BA%8Enetty%E5%AE%9E%E7%8E%B0RPC/</url>
      
        <content type="html"><![CDATA[<p>博客中代码地址：<a href="https://github.com/farliu/farpc.git" target="_blank" rel="noopener">https://github.com/farliu/farpc.git</a><br><img src="/images/java/dubbo/dubbo_implement_1_1.png" alt="dubbo架构"></p><p>本文实现的是远程调用，也就是图片中的第4步，dubbo作为一款RPC框架，这是它的核心功能，dubbo提供了很多种方式，如下图：<br><img src="/images/java/dubbo/dubbo_implement_6_1.png" alt="dubbo module"></p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>首先科普一下RPC三个字母，即Remote Procedure Call。简单来说就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。</p><p>回想一下，java本地方法调用。假如在电脑ComputerA上有一个类ClassA，其中有methodA()方法，我们调用的话，就是new一个ClassA的对象classA，然后classA.methodA()来调用。这其中值得深思，凭什么我们能new一个ClassA的对象？我们能不能new一个ComputerB机器上的类ClassB的对象呢？</p><p>第二个答案肯定都知道，肯定是不行。第一个问题，我们为什么能在ComputerA上new一个ClassA的对象，是因为在ComputerA上存在ClassA类的class文件，通过JVM加载后，我们可以实现对它的调用。所以为了解决第二个问题，前辈们还真想出了办法。你不是只要class文件就行了嘛，那就给你，ComputerA打个jar包给ComputerB去加载。也就达到了调用的效果。</p><p>以上其实就是解决两个应用之间交互的​早期办法。但是当系统依赖复杂后，这种方式极为不妥，每一个系统都得加载子系统的所有class，非常不合适。以及还有敏感代码允许泄露等问题。</p><p>为了解决这个问题，我们也就出现RPC服务，就是当ComputerA要调用ComputerB的方法时，ComputerA通过某种方式告诉ComputerB，再由ComputerB执行完之后，将结果告诉ComputerA。这就是RPC最初的设想。我们归纳一下几个步骤</p><ol><li>ComputerA将自己的需要调用的方法和参数准备封装好。</li><li>按照约定的方式，将封装好的参数传给ComputerB</li><li>ComputerB收到约定的数据后，解析获得ComputerA需要调用的方法和参数。</li><li>ComputerB按照ComputerA给的数据，执行对应的方法。</li><li>ComputerB将执行结果按照约定返回ComputerA。</li></ol><p>可以看到这个过程，极为重要的就是数据传输，为了实现数据传输，我们搞出了很多花样。比较通常的就是，将参数转成xml，通过Http传送给另一台机器，后来发现xml体积太大，我们又将json代替了xml。再后来我们又觉得每次用http协议，都得重新连接，又使用socket实现长连接。再后来觉得socket实现阻塞IO，效率不高，又推送了NIO，以及selector、channel这些专业术语。这都是在优化传输过程，本章采用netty来实现传输。</p><p>对于ComputerB执行相应的方法，基于以上的约定，ComputerB拿到所需的参数后，使用java反射就能调用具体的方法了。</p><h3 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h3><p><img src="/images/java/dubbo/dubbo_implement_2_1.png" alt="项目结构"><br>本节涉及博客中代码的module，farpc-rpc（远程调用）、farpc-demo。</p><h3 id="初始化netty"><a href="#初始化netty" class="headerlink" title="初始化netty"></a>初始化netty</h3><p>本章使用netty实现rpc，自然要导入jar包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.36.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>秉承可扩展设计，提供两个接口。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FarSPI</span>(<span class="string">"netty"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> IProviderServer &#123;</span><br><span class="line">    <span class="built_in">void</span> start(<span class="built_in">String</span> selfAddress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FarSPI</span>(<span class="string">"netty"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> IConsumerServer &#123;</span><br><span class="line">    <span class="built_in">Object</span> execute(<span class="built_in">String</span> address, RequestDTO requestDTO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端就是常规的netty代码，启动服务，然后配置Handler，处理接收的信息。值得一提的是，在服务端启动的时候，我会去扫描所有标注了Provider注解的类，然后将其注入到注册中心，并为一个container保存对应的对象，用于反射执行指定方法。</p><p>Provider模拟dubbo中的@Service注解，用于注册服务。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Provider &#123;</span><br><span class="line">    Class interfaceClazz();</span><br><span class="line"></span><br><span class="line">    String name() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Container扫描被Provider修饰的类，然后反射生成对象，将其保存到本地容器供反射执行指定的方法、保存到注册中心供消费端发现服务。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final Logger logger = LoggerFactory.getLogger(Container.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IRegistrar registrar = RegistrarFactory.getRegistrar();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;<span class="keyword">String</span>, Object&gt; providers = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;<span class="keyword">String</span>, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Reflections reflections = <span class="keyword">new</span> <span class="type">Reflections</span>(<span class="keyword">new</span> <span class="type">ConfigurationBuilder</span>()</span><br><span class="line">                .setUrls(ClasspathHelper.forPackage(<span class="string">"com.ofcoder"</span>))</span><br><span class="line">                .setScanners(<span class="keyword">new</span> <span class="type">TypeAnnotationsScanner</span>()));</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = reflections.getTypesAnnotatedWith(Provider.class, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : <span class="type">classes</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Provider annotation = clazz.getAnnotation(Provider.class);</span><br><span class="line">                Object provider = clazz.<span class="keyword">new</span><span class="type">Instance</span>();</span><br><span class="line">                <span class="keyword">String</span> canonicalName = annotation.interfaceClazz().getCanonicalName();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 保存到本地容器</span></span><br><span class="line">                providers.put(canonicalName, provider);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void registerSelf(<span class="keyword">String</span> selfAddress)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> service : <span class="type">providers</span>.keySet()) &#123;</span><br><span class="line">            registrar.register(selfAddress, service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;<span class="keyword">String</span>, Object&gt; getProviders() &#123;</span><br><span class="line">        <span class="keyword">return</span> providers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NettyProviderHandler用来处理收到的信息，然后根据收到的数据，从本地容器中取得对象，调用指定的方法，并将执行结果返回给消费端。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> NettyProviderHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    <span class="keyword">private</span> static final Logger logger = <span class="module-access"><span class="module"><span class="identifier">LoggerFactory</span>.</span></span>get<span class="constructor">Logger(NettyProviderHandler.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channel<span class="constructor">Read(ChannelHandlerContext <span class="params">ctx</span>, Object <span class="params">msg</span>)</span> throws Exception &#123;</span><br><span class="line">        super.channel<span class="constructor">Read(<span class="params">ctx</span>, <span class="params">msg</span>)</span>;</span><br><span class="line">        RequestDTO requestDTO = (RequestDTO) msg;</span><br><span class="line">        Object result = <span class="keyword">new</span> <span class="constructor">Object()</span>;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"receive request.. &#123;&#125;"</span>, requestDTO);</span><br><span class="line">        <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Container</span>.</span></span>get<span class="constructor">Providers()</span>.contains<span class="constructor">Key(<span class="params">requestDTO</span>.<span class="params">getClassName</span>()</span>)) &#123;</span><br><span class="line">            Object provider = <span class="module-access"><span class="module"><span class="identifier">Container</span>.</span></span>get<span class="constructor">Providers()</span>.get(requestDTO.get<span class="constructor">ClassName()</span>);</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; providerClazz = provider.get<span class="constructor">Class()</span>;</span><br><span class="line">            Method <span class="keyword">method</span> = providerClazz.get<span class="constructor">Method(<span class="params">requestDTO</span>.<span class="params">getMethodName</span>()</span>, requestDTO.get<span class="constructor">Types()</span>);</span><br><span class="line">            <span class="comment">// 反射执行指定的方法</span></span><br><span class="line">            result = <span class="keyword">method</span>.invoke(provider, requestDTO.get<span class="constructor">Params()</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结果输出到消费端</span></span><br><span class="line">        ctx.write(result);</span><br><span class="line">        ctx.flush<span class="literal">()</span>;</span><br><span class="line">        ctx.close<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NettyProviderServer就是监听指定的端口，启动服务。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> NettyProviderServer implements IProviderServer &#123;</span><br><span class="line">    <span class="keyword">private</span> static final Logger logger = <span class="module-access"><span class="module"><span class="identifier">LoggerFactory</span>.</span></span>get<span class="constructor">Logger(NettyProviderServer.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    public void start(String selfAddress) &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Container</span>.</span></span>register<span class="constructor">Self(<span class="params">selfAddress</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String<span class="literal">[]</span> addrs = selfAddress.split(<span class="string">":"</span>);</span><br><span class="line">        String ip = addrs<span class="literal">[<span class="number">0</span>]</span>;</span><br><span class="line">        Integer port = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">addrs</span>[1])</span>;</span><br><span class="line"></span><br><span class="line">        publisher(ip, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void publisher(String ip, Integer port) &#123;</span><br><span class="line">        <span class="comment">// 启动服务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            EventLoopGroup bossGroup = <span class="keyword">new</span> <span class="constructor">NioEventLoopGroup()</span>;</span><br><span class="line">            EventLoopGroup workerGroup = <span class="keyword">new</span> <span class="constructor">NioEventLoopGroup()</span>;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> <span class="constructor">ServerBootstrap()</span>;</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(<span class="module-access"><span class="module"><span class="identifier">NioServerSocketChannel</span>.</span></span><span class="keyword">class</span>)</span><br><span class="line">                    .child<span class="constructor">Handler(<span class="params">new</span> ChannelInitializer&lt;Channel&gt;()</span> &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        protected void init<span class="constructor">Channel(Channel <span class="params">channel</span>)</span> throws Exception &#123;</span><br><span class="line">                            ChannelPipeline pipeline = channel.pipeline<span class="literal">()</span>;</span><br><span class="line">                            pipeline.add<span class="constructor">Last(<span class="params">new</span> ObjectEncoder()</span>);</span><br><span class="line">                            pipeline.add<span class="constructor">Last(<span class="params">new</span> ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.<span class="params">cacheDisabled</span>(NettyProviderServer.<span class="params">class</span>.<span class="params">getClassLoader</span>()</span>)));</span><br><span class="line">                            pipeline.add<span class="constructor">Last(<span class="params">new</span> NettyProviderHandler()</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).option(ChannelOption.SO_BACKLOG, <span class="number">128</span>).child<span class="constructor">Option(ChannelOption.SO_KEEPALIVE, <span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">            ChannelFuture future = bootstrap.bind(ip, port).sync<span class="literal">()</span>;</span><br><span class="line">            logger.info(<span class="string">"netty server is started..."</span>);</span><br><span class="line">            future.channel<span class="literal">()</span>.close<span class="constructor">Future()</span>.sync<span class="literal">()</span>;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><p>NettyConsumerServer用于发送请求，将封装好的参数发给服务提供者。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> NettyConsumerServer implements IConsumerServer &#123;</span><br><span class="line">    <span class="keyword">private</span> static final Logger logger = <span class="module-access"><span class="module"><span class="identifier">LoggerFactory</span>.</span></span>get<span class="constructor">Logger(NettyConsumerServer.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    public Object execute(String serivceAddress, RequestDTO requestDTO) &#123;</span><br><span class="line">        String<span class="literal">[]</span> addrs = serivceAddress.split(<span class="string">":"</span>);</span><br><span class="line">        String host = addrs<span class="literal">[<span class="number">0</span>]</span>;</span><br><span class="line">        Integer port = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">addrs</span>[1])</span>;</span><br><span class="line"></span><br><span class="line">        final NettyConsumerHandler consumerHandler = <span class="keyword">new</span> <span class="constructor">NettyConsumerHandler()</span>;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> <span class="constructor">NioEventLoopGroup()</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> <span class="constructor">Bootstrap()</span>;</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(<span class="module-access"><span class="module"><span class="identifier">NioSocketChannel</span>.</span></span><span class="keyword">class</span>)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;<span class="literal">()</span> &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        protected void init<span class="constructor">Channel(Channel <span class="params">channel</span>)</span> throws Exception &#123;</span><br><span class="line">                            ChannelPipeline pipeline = channel.pipeline<span class="literal">()</span>;</span><br><span class="line">                            pipeline.add<span class="constructor">Last( <span class="params">new</span> ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.<span class="params">cacheDisabled</span>(ConsumerProxy.<span class="params">class</span>.<span class="params">getClassLoader</span>()</span>)));</span><br><span class="line">                            pipeline.add<span class="constructor">Last( <span class="params">new</span> ObjectEncoder()</span>);</span><br><span class="line">                            pipeline.add<span class="constructor">Last(<span class="params">consumerHandler</span>)</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture future = bootstrap.connect(host, port).sync<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">            Channel channel = future.channel<span class="literal">()</span>;</span><br><span class="line">            channel.write<span class="constructor">AndFlush(<span class="params">requestDTO</span>)</span>;</span><br><span class="line">            logger.info(<span class="string">"send request..., &#123;&#125;"</span>, requestDTO);</span><br><span class="line">            channel.close<span class="constructor">Future()</span>.sync<span class="literal">()</span>;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            group.shutdown<span class="constructor">Gracefully()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return consumerHandler.get<span class="constructor">Response()</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NettyConsumerHandler用于处理提供端返回的结果，这里没有做过多处理，直接返回。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NettyConsumerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> response;</span><br><span class="line"></span><br><span class="line">    public <span class="type">Object</span> getResponse() &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void channelRead(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Object</span> msg) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        response = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用SPI整合"><a href="#使用SPI整合" class="headerlink" title="使用SPI整合"></a>使用SPI整合</h3><p>在上一章，已经把SPI集成的很不错了，这里我们可以按照上一章套路管理RPC服务。我们提供一个Factory，用来替代自适应扩展。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> RpcFactory &#123;</span><br><span class="line">    public static IConsumerServer get<span class="constructor">ConsumerService()</span> &#123;</span><br><span class="line">        String protocol = <span class="module-access"><span class="module"><span class="identifier">Property</span>.</span><span class="module"><span class="identifier">Rpc</span>.</span></span>protocol;</span><br><span class="line">        IConsumerServer extension = <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(IConsumerServer.<span class="params">class</span>)</span>.get<span class="constructor">Extension(<span class="params">protocol</span>)</span>;</span><br><span class="line">        return extension;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static IProviderServer get<span class="constructor">ProviderServer()</span> &#123;</span><br><span class="line">        String protocol = <span class="module-access"><span class="module"><span class="identifier">Property</span>.</span><span class="module"><span class="identifier">Rpc</span>.</span></span>protocol;</span><br><span class="line">        IProviderServer extension = <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(IProviderServer.<span class="params">class</span>)</span>.get<span class="constructor">Extension(<span class="params">protocol</span>)</span>;</span><br><span class="line">        return extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">com<span class="selector-class">.ofcoder</span><span class="selector-class">.farpc</span><span class="selector-class">.rpc</span>.IConsumerServer</span><br><span class="line">netty=com<span class="selector-class">.ofcoder</span><span class="selector-class">.farpc</span><span class="selector-class">.rpc</span><span class="selector-class">.netty</span>.NettyConsumerServer</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line">com<span class="selector-class">.ofcoder</span><span class="selector-class">.farpc</span><span class="selector-class">.rpc</span>.IProviderServer</span><br><span class="line">netty=com<span class="selector-class">.ofcoder</span><span class="selector-class">.farpc</span><span class="selector-class">.rpc</span><span class="selector-class">.netty</span>.NettyProviderServer</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> provider() throws IOException &#123;</span><br><span class="line">    IProviderServer providerServer = RpcFactory.getProviderServer();</span><br><span class="line">    providerServer.<span class="keyword">start</span>("127.0.0.1:20880");</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">in</span>.<span class="keyword">read</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> consumer() &#123;</span><br><span class="line">    IConsumerServer consumerService = RpcFactory.getConsumerService();</span><br><span class="line">    <span class="keyword">Object</span> <span class="keyword">execute</span> = consumerService.<span class="keyword">execute</span>("127.0.0.1:20880", <span class="built_in">new</span> RequestDTO());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先启动提供者，然后在执行消费。可以在提供者的控制台看到，相应的日志，也就说明达到我们需要的效果了。如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span><br><span class="line">main  <span class="builtin-name">INFO</span> netty.NettyProviderServer: netty<span class="built_in"> server </span>is started<span class="built_in">..</span>.</span><br><span class="line">nioEventLoopGroup-3-1  <span class="builtin-name">INFO</span> netty.NettyProviderHandler: receive request<span class="built_in">..</span> RequestDTO&#123;<span class="attribute">className</span>=<span class="string">'null'</span>, <span class="attribute">methodName</span>=<span class="string">'null'</span>, <span class="attribute">types</span>=<span class="literal">null</span>, <span class="attribute">params</span>=<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="dubbo源码"><a href="#dubbo源码" class="headerlink" title="dubbo源码"></a>dubbo源码</h3><p>这一节，来印证dubbo实现过程，也算是当作源码导读。这一节也分为两段分析，一消费端调用过程，二服务端收到请求处理过程。</p><p>整个过程可以总结为：首先服务消费者通过代理对象 Proxy 发起远程调用，接着通过网络客户端 Client 将编码后的请求发送给服务提供方的网络层上，也就是 Server。Server 在收到请求后，首先要做的事情是对数据包进行解码。然后将解码后的请求发送至分发器 Dispatcher，再由分发器将请求派发到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送与接收过程。</p><h4 id="消费端-1"><a href="#消费端-1" class="headerlink" title="消费端"></a>消费端</h4><p>消费端调用复杂在于链路太长，由Proxy调用开始，会经过一系列的Invoker，直到DubboInvoker再去真正发起请求</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span>greet</span><br><span class="line">  -&gt; <span class="module-access"><span class="module"><span class="identifier">InvokerInvocationHandler</span>.</span></span>invoke</span><br><span class="line">    -&gt; <span class="module-access"><span class="module"><span class="identifier">MockClusterInvoker</span>.</span></span>invoke</span><br><span class="line">      -&gt; ...</span><br><span class="line">        -&gt; <span class="module-access"><span class="module"><span class="identifier">AbstractInvoker</span>.</span></span>invoke</span><br><span class="line">          -&gt; <span class="module-access"><span class="module"><span class="identifier">DubboInvoker</span>.</span></span>doInvoke</span><br></pre></td></tr></table></figure><p>InvokerInvocationHandler用于排除调用toString()、equals()、hashCode()这些方法。MockClusterInvoker主要实现了降级逻辑，在服务调用失败后用于返回默认值。以及后续还有FailoverClusterInvoker，最后会调到DubboInvoker.doInvoke，着重关心这一块，中间那些增强的Invoker逻辑，可以自己了解。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">protected Result <span class="keyword">do</span><span class="constructor">Invoke(<span class="params">final</span> Invocation <span class="params">invocation</span>)</span> throws Throwable &#123;</span><br><span class="line">    RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">    final String methodName = <span class="module-access"><span class="module"><span class="identifier">RpcUtils</span>.</span></span>get<span class="constructor">MethodName(<span class="params">invocation</span>)</span>;</span><br><span class="line">    inv.set<span class="constructor">Attachment(PATH_KEY, <span class="params">getUrl</span>()</span>.get<span class="constructor">Path()</span>);</span><br><span class="line">    inv.set<span class="constructor">Attachment(VERSION_KEY, <span class="params">version</span>)</span>;</span><br><span class="line"></span><br><span class="line">    ExchangeClient currentClient;</span><br><span class="line">    <span class="keyword">if</span> (clients.length<span class="operator"> == </span><span class="number">1</span>) &#123;</span><br><span class="line">        currentClient = clients<span class="literal">[<span class="number">0</span>]</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentClient = clients<span class="literal">[<span class="identifier">index</span>.<span class="identifier">getAndIncrement</span>() % <span class="identifier">clients</span>.<span class="identifier">length</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 是否有返回值，true表示没有返回值。</span></span><br><span class="line">        boolean isOneway = <span class="module-access"><span class="module"><span class="identifier">RpcUtils</span>.</span></span>is<span class="constructor">Oneway(<span class="params">getUrl</span>()</span>, invocation);</span><br><span class="line">        <span class="built_in">int</span> timeout = get<span class="constructor">Url()</span>.get<span class="constructor">MethodParameter(<span class="params">methodName</span>, TIMEOUT_KEY, DEFAULT_TIMEOUT)</span>;</span><br><span class="line">        <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">            boolean isSent = get<span class="constructor">Url()</span>.get<span class="constructor">MethodParameter(<span class="params">methodName</span>, Constants.SENT_KEY, <span class="params">false</span>)</span>;</span><br><span class="line">            <span class="comment">// 发送请求</span></span><br><span class="line">            currentClient.send(inv, isSent);</span><br><span class="line">            <span class="comment">// 清空future </span></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">RpcContext</span>.</span></span>get<span class="constructor">Context()</span>.set<span class="constructor">Future(<span class="params">null</span>)</span>;</span><br><span class="line">            <span class="comment">// 不用关注返回值，返回默认RpcResult</span></span><br><span class="line">            return <span class="module-access"><span class="module"><span class="identifier">AsyncRpcResult</span>.</span></span><span class="keyword">new</span><span class="constructor">DefaultAsyncResult(<span class="params">invocation</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//该类实现Future接口，用于实现异步</span></span><br><span class="line">            AsyncRpcResult asyncRpcResult = <span class="keyword">new</span> <span class="constructor">AsyncRpcResult(<span class="params">inv</span>)</span>;</span><br><span class="line">            <span class="comment">// 发起调用，也返回的Future对象</span></span><br><span class="line">            CompletableFuture&lt;Object&gt; responseFuture = currentClient.request(inv, timeout);</span><br><span class="line">            <span class="comment">// 当发起调用的Future完成后，会通知到asyncRpcResult</span></span><br><span class="line">            asyncRpcResult.subscribe<span class="constructor">To(<span class="params">responseFuture</span>)</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">RpcContext</span>.</span></span>get<span class="constructor">Context()</span>.set<span class="constructor">Future(<span class="params">new</span> FutureAdapter(<span class="params">asyncRpcResult</span>)</span>);</span><br><span class="line">            return asyncRpcResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (TimeoutException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; catch (RemotingException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费端到此处，应分为第二段，既发送请求。这里dubbo会调用一系列Client，这些Client均是NettyClient的包装增强，对request()的调用都是一直往下传递。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">ReferenceCountExchangeClient</span>.</span></span>request</span><br><span class="line">  -&gt; <span class="module-access"><span class="module"><span class="identifier">HeaderExchangeClient</span>.</span></span>request</span><br><span class="line">    -&gt; <span class="module-access"><span class="module"><span class="identifier">HeaderExchangeChannel</span>.</span></span>request</span><br><span class="line">      -&gt; <span class="module-access"><span class="module"><span class="identifier">AbstractClient</span>.</span></span>send</span><br><span class="line">        -&gt; <span class="module-access"><span class="module"><span class="identifier">NettyChannel</span>.</span></span>send</span><br><span class="line">          -&gt; <span class="module-access"><span class="module"><span class="identifier">NioClientSocketChannel</span>.</span></span>write</span><br></pre></td></tr></table></figure><p>ReferenceCountExchangeClient为对象引用增加计数器，当close()调用时，该计数器减1。HeaderExchangeClient增加心跳检测，这里请求会转到Channel对象，并结束request()传递调用。HeaderExchangeChannel对Request的封装，并通过AbstractClient.getChannel()获取到NettyChannel对象并调用其send()方法。完成整个请求的发送。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> throws RemotingException </span>&#123;</span><br><span class="line">    super.send(message, sent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 发送消息(包含请求和响应消息)</span></span><br><span class="line">        ChannelFuture <span class="built_in">future</span> = channel.<span class="built_in">write</span>(message);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// sent 的值源于 &lt;dubbo:method sent="true/false" /&gt; 中 sent 的配置值，有两种配置值：</span></span><br><span class="line">        <span class="comment">//   1. true: 等待消息发出，消息发送失败将抛出异常</span></span><br><span class="line">        <span class="comment">//   2. false: 不等待消息发出，将消息放入 IO 队列，即刻返回</span></span><br><span class="line">        <span class="comment">// 默认情况下 sent = false；</span></span><br><span class="line">        <span class="keyword">if</span> (sent) &#123;</span><br><span class="line">            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">            <span class="comment">// 等待消息发出，若在规定时间没能发出，success 会被置为 false</span></span><br><span class="line">            success = <span class="built_in">future</span>.await(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        Throwable cause = <span class="built_in">future</span>.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause != null) &#123;</span><br><span class="line">            <span class="keyword">throw</span> cause;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 success 为 false，这里抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提供端"><a href="#提供端" class="headerlink" title="提供端"></a>提供端</h4><p>在服务提供端获取到请求之后，然后交由NettyHandler.messageReceived处理，该方法会进行和消费端相关操作，以此会执行MultiMessageHandlerH、eartbeatHandler，最后由ChannelHandler将操作逻辑封装到Runable对象中，交给线程池进行调用处理，这个过程也成为线程派发，dubbo提供5中派发模式。</p><table><thead><tr><th>策略</th><th>用途</th></tr></thead><tbody><tr><td>all</td><td>所有消息都派发到线程池，包括请求，响应，连接事件，断开事件等</td></tr><tr><td>direct</td><td>所有消息都不派发到线程池，全部在 IO 线程上直接执行</td></tr><tr><td>message</td><td>只有请求和响应消息派发到线程池，其它消息均在 IO 线程上执行</td></tr><tr><td>execution</td><td>只有请求消息派发到线程池，不含响应。其它消息均在 IO 线程上执行</td></tr><tr><td>connection</td><td>在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池</td></tr></tbody></table><p>dubbo默认选择策略是all，整理上述调用链路如下</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NettyHandler#messageReceived</span><br><span class="line">  -&gt; AbstractPeer#received</span><br><span class="line">    —&gt; MultiMessageHandler#received</span><br><span class="line">      —&gt; HeartbeatHandler#received</span><br><span class="line">        —&gt; ALLChannelHandler#received</span><br><span class="line">          —&gt; ExecutorService#execute</span><br></pre></td></tr></table></figure><p>ALLChannelHandler.received会初始化ChannelEventRunnable对象，由该对象真正完成调用，我们看看具体源码</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class ChannelEventRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 检测通道状态，对于请求或响应消息，此时 <span class="keyword">state</span> = RECEIVED</span><br><span class="line">        if (<span class="keyword">state</span> == ChannelState.RECEIVED) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                handler.received(channel, message);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"ChannelEventRunnable handle "</span> + <span class="keyword">state</span> + <span class="string">" operation error, channel is "</span> + channel</span><br><span class="line">                        + <span class="string">", message is "</span> + message, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            switch (<span class="keyword">state</span>) &#123;</span><br><span class="line">            case CONNECTED:</span><br><span class="line">                ...</span><br><span class="line">                break;</span><br><span class="line">            case DISCONNECTED:</span><br><span class="line">                ...</span><br><span class="line">                break;</span><br><span class="line">            case SENT:</span><br><span class="line">                ...</span><br><span class="line">                break;</span><br><span class="line">            case CAUGHT:</span><br><span class="line">                ...</span><br><span class="line">                break;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                logger.warn(<span class="string">"unknown state: "</span> + <span class="keyword">state</span> + <span class="string">", message is "</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里多说一句，先用if判断出现频率比较高的消息类型，然后用switch处理其他类型，不用把频率较高的类型和普通类型同级判断，以此提高效率。我们开发过程中也可借鉴这一点。<br>ChannelEventRunnable作用类似于路由，将消息分别交给各自的ChannelHandler去处理，这里的对象为DecodeHandler，该Handler就是对Request或Response进行解码后，继续传递到HeaderExchangeHandler。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> HeaderExchangeHandler implements ChannelHandlerDelegate &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void received(Channel channel, Object message) throws RemotingException &#123;</span><br><span class="line">        channel.set<span class="constructor">Attribute(KEY_READ_TIMESTAMP, System.<span class="params">currentTimeMillis</span>()</span>);</span><br><span class="line">        final ExchangeChannel exchangeChannel = <span class="module-access"><span class="module"><span class="identifier">HeaderExchangeChannel</span>.</span></span>get<span class="constructor">OrAddChannel(<span class="params">channel</span>)</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (message instanceof Request) &#123;</span><br><span class="line">                <span class="comment">// handle request.</span></span><br><span class="line">                Request request = (Request) message;</span><br><span class="line">                <span class="keyword">if</span> (request.is<span class="constructor">Event()</span>) &#123;</span><br><span class="line">                    handler<span class="constructor">Event(<span class="params">channel</span>, <span class="params">request</span>)</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 是否为单/双向调用，判断是否需要接收返回结果</span></span><br><span class="line">                    <span class="keyword">if</span> (request.is<span class="constructor">TwoWay()</span>) &#123;</span><br><span class="line">                        handle<span class="constructor">Request(<span class="params">exchangeChannel</span>, <span class="params">request</span>)</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        handler.received(exchangeChannel, request.get<span class="constructor">Data()</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message instanceof Response) &#123;</span><br><span class="line">                handle<span class="constructor">Response(<span class="params">channel</span>, (Response)</span> message);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message instanceof String) &#123;</span><br><span class="line">                <span class="comment">// telnet 相关</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler.received(exchangeChannel, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">HeaderExchangeChannel</span>.</span></span>remove<span class="constructor">ChannelIfDisconnected(<span class="params">channel</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response handle<span class="constructor">Request(ExchangeChannel <span class="params">channel</span>, Request <span class="params">req</span>)</span> throws RemotingException &#123;</span><br><span class="line">        Response res = <span class="keyword">new</span> <span class="constructor">Response(<span class="params">req</span>.<span class="params">getId</span>()</span>, req.get<span class="constructor">Version()</span>);</span><br><span class="line">        <span class="comment">// 检测请求是否合法，不合法则返回状态码为 BAD_REQUEST 的响应</span></span><br><span class="line">        <span class="keyword">if</span> (req.is<span class="constructor">Broken()</span>) &#123;</span><br><span class="line">            Object data = req.get<span class="constructor">Data()</span>;</span><br><span class="line"></span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">if</span> (data<span class="operator"> == </span>null)</span><br><span class="line">                msg = null;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span></span><br><span class="line">                (data instanceof Throwable) msg = <span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span><span class="keyword">to</span><span class="constructor">String((Throwable)</span> data);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                msg = data.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">            res.set<span class="constructor">ErrorMessage(<span class="string">"Fail to decode request due to: "</span> + <span class="params">msg</span>)</span>;</span><br><span class="line">            <span class="comment">// 设置 BAD_REQUEST 状态</span></span><br><span class="line">            res.set<span class="constructor">Status(Response.BAD_REQUEST)</span>;</span><br><span class="line"></span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取 data 字段值，也就是 RpcInvocation 对象</span></span><br><span class="line">        Object msg = req.get<span class="constructor">Data()</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 继续向下调用</span></span><br><span class="line">            Object result = handler.reply(channel, msg);</span><br><span class="line">            <span class="comment">// 设置 OK 状态码</span></span><br><span class="line">            res.set<span class="constructor">Status(Response.OK)</span>;</span><br><span class="line">            <span class="comment">// 设置调用结果</span></span><br><span class="line">            res.set<span class="constructor">Result(<span class="params">result</span>)</span>;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// 若调用过程出现异常，则设置 SERVICE_ERROR，表示服务端异常</span></span><br><span class="line">            res.set<span class="constructor">Status(Response.SERVICE_ERROR)</span>;</span><br><span class="line">            res.set<span class="constructor">ErrorMessage(StringUtils.<span class="params">toString</span>(<span class="params">e</span>)</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来要说的就是定义在DubboProtocol类中匿名对象的reply方法，既ExchangeHandlerAdapter.reply()</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> DubboProtocol extends AbstractProtocol &#123;</span><br><span class="line">    <span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> <span class="constructor">ExchangeHandlerAdapter()</span> &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object reply(ExchangeChannel channel, Object message) throws RemotingException &#123;</span><br><span class="line">            <span class="keyword">if</span> (message instanceof Invocation) &#123;</span><br><span class="line">                Invocation inv = (Invocation) message;</span><br><span class="line">                <span class="comment">// 获取 Invoker 实例</span></span><br><span class="line">                Invoker&lt;?&gt; invoker = get<span class="constructor">Invoker(<span class="params">channel</span>, <span class="params">inv</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Boolean</span>.</span><span class="module"><span class="identifier">TRUE</span>.</span></span><span class="keyword">to</span><span class="constructor">String()</span>.equals(inv.get<span class="constructor">Attachments()</span>.get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">                    <span class="comment">// 回调相关，忽略</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">RpcContext</span>.</span></span>get<span class="constructor">Context()</span>.set<span class="constructor">RemoteAddress(<span class="params">channel</span>.<span class="params">getRemoteAddress</span>()</span>);</span><br><span class="line">                <span class="comment">// 通过 Invoker 调用具体的服务</span></span><br><span class="line">                return invoker.invoke(inv);</span><br><span class="line">            &#125;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">RemotingException(<span class="params">channel</span>, <span class="string">"Unsupported request: ..."</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先通过getInvoker()获取Invoker实例，然后调用invoke方法。getInvoker()方法先从缓存中获取，没命中则调用DubboExporter.getInvoker()继续创建。而Invoker的invoke方法是由AbstractProxyInvoker实现，</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract <span class="keyword">class</span> AbstractProxyInvoker&lt;T&gt; implements Invoker&lt;T&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object value = <span class="keyword">do</span><span class="constructor">Invoke(<span class="params">proxy</span>, <span class="params">invocation</span>.<span class="params">getMethodName</span>()</span>, invocation.get<span class="constructor">ParameterTypes()</span>, invocation.get<span class="constructor">Arguments()</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将结果封装到AsyncRpcResult，然后返回</span></span><br><span class="line">            ...</span><br><span class="line">            return asyncRpcResult;</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">            return <span class="module-access"><span class="module"><span class="identifier">AsyncRpcResult</span>.</span></span><span class="keyword">new</span><span class="constructor">DefaultAsyncResult(<span class="params">null</span>, <span class="params">e</span>.<span class="params">getTargetException</span>()</span>, invocation);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">RpcException(<span class="string">"Failed to invoke remote proxy method "</span> + <span class="params">invocation</span>.<span class="params">getMethodName</span>()</span> + <span class="string">" to "</span> + get<span class="constructor">Url()</span> + <span class="string">", cause: "</span> + e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩余的最后一个doInvoke，是一个抽象方法，由子类实现，而Invoker实现类是由JavassistProxyFactory 动态生成，具体可查看JavassistProxyFactory.getInvoker()方法。最后生成的代理类逻辑如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Wrapper0 是在运行时生成的，可使用 Arthas 进行反编译 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper0</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Wrapper</span></span> <span class="keyword"><span class="keyword">implements</span> <span class="type">ClassGenerator</span></span>.<span class="title">DC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span>[] pns;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map pts;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span>[] mns;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span>[] dmns;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class[] mts0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object invokeMethod(Object object, <span class="keyword">String</span> string, Class[] arrclass, Object[] arrobject) throws InvocationTargetException &#123;</span><br><span class="line">        DemoService demoService;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 类型转换</span></span><br><span class="line">            demoService = (DemoService)object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据方法名调用指定的方法</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"sayHello"</span>.equals(string) &amp;&amp; arrclass.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> demoService.sayHello((<span class="keyword">String</span>)arrobject[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvocationTargetException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchMethodException</span>(<span class="keyword">new</span> <span class="type">StringBuffer</span>().append(<span class="string">"Not found method \""</span>).append(string).append(<span class="string">"\" in class com.alibaba.dubbo.demo.DemoService."</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，最后不是通过反射去执行的，而是根据具体方法名路由的，然后调用执行的。所以以后谁要说反射执行，就拿这篇文章呼他的脸。不过话说回来，我们实现的调用还是通过反射，我们也看到了dubbo的实现太复杂了，如果再造一个轮子没必要，主要是弄清楚原理。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> dubbo </tag>
            
            <tag> 源码 </tag>
            
            <tag> netty </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写dubbo 9-SPI实现</title>
      <link href="/2019/10/20/java/%E6%89%8B%E5%86%99dubbo%209-SPI%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/10/20/java/%E6%89%8B%E5%86%99dubbo%209-SPI%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>博客中代码地址：<a href="https://github.com/farliu/farpc.git" target="_blank" rel="noopener">https://github.com/farliu/farpc.git</a><br><img src="/images/java/dubbo/dubbo_implement_1_1.png" alt="dubbo架构"></p><h3 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h3><p><img src="/images/java/dubbo/dubbo_implement_2_1.png" alt="项目结构"><br>本节涉及博客中代码的三个module，farpc-registry（服务治理）、farpc-cluster（集群管理），farpc-common。</p><p>本章重点就是farpc-common。而SPI具体实现方案就是ExtensionLoader。本章大部分代码都从dubbo源码中提取。</p><p>我们在贴代码之前还是讲讲涉及到的类前后推理的逻辑。ExtensionLoader为SPI重要实现类，本章实现的简单的SPI其实有这个类就够了。但是在dubbo中还提供了两个辅助类，我觉得有必要就也加进来一起聊聊，一个是FarSPI注解，一个是Holder。</p><h3 id="SPI实现"><a href="#SPI实现" class="headerlink" title="SPI实现"></a>SPI实现</h3><p>本章代码量有点大，下面贴代码会导致篇幅过长，我们针对涉及的几个都分别解析一下，具体代码大家可以上github自己clone。我们对照项目结构一个个分析。</p><p><img src="/images/java/dubbo/dubbo_implement_5_2.png" alt="项目结构"></p><h4 id="FarSPI"><a href="#FarSPI" class="headerlink" title="FarSPI"></a>FarSPI</h4><p>FarSPI注解用来标注接口的默认配置对象。</p><h4 id="Holder"><a href="#Holder" class="headerlink" title="Holder"></a>Holder</h4><p>Holder用来包装对象实例，上两章中有提到dubbo中很多地方用到了double-check-lock，它虽然能保证并发，但是出现重排序时，调用者拿到的对象可能是一个未初始化的地址。所以<strong>使用Holder对其包装，利用volatile保证可见性</strong>。</p><h4 id="ExtensionLoader"><a href="#ExtensionLoader" class="headerlink" title="ExtensionLoader"></a>ExtensionLoader</h4><p>ExtensionLoader做SPI重点，代码中都有标注有注释，应该很清楚。这里看一下怎么使用。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ILoadbalance extension = <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(ILoadbalance.<span class="params">class</span>)</span>.get<span class="constructor">Extension(<span class="params">loadbalance</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="Property、PropertyUtil"><a href="#Property、PropertyUtil" class="headerlink" title="Property、PropertyUtil"></a>Property、PropertyUtil</h4><p>这两个类是为了读取用户的配置写的，dubbo会解析xml，我这里由用户在application.properties中指定。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>SPI其实就靠上面几个类就能运行了，现在说说怎么使用，我在ExtensionLoader中读取META-INF/farpc/下面的文件，我们需要将SPI的配置放在该文件夹下，文件名字为接口的全路径。</p><p>例如：让SPI创建ILoadbalance的对象。在之前我们实现了两个ILoadbalance的方案RoundLoadBalanceImpl、RandomLoadbalanceImpl。<br><img src="/images/java/dubbo/dubbo_implement_5_3.png" alt="项目结构"></p><p>以及在之前我们实现了两种注册中心，也可以交由SPI初始化对象</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void spi<span class="constructor">Test()</span>&#123;</span><br><span class="line">    ILoadbalance round = <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(ILoadbalance.<span class="params">class</span>)</span></span><br><span class="line">            .get<span class="constructor">Extension(<span class="string">"round"</span>)</span>;</span><br><span class="line">    ILoadbalance random = <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(ILoadbalance.<span class="params">class</span>)</span></span><br><span class="line">            .get<span class="constructor">Extension(<span class="string">"random"</span>)</span>;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(round.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span>);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(random.get<span class="constructor">Class()</span>.get<span class="constructor">Name()</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line">com.ofcoder.farpc.cluster.loadbalance.RoundLoadBalanceImpl</span><br><span class="line">com.ofcoder.farpc.cluster.loadbalance.RandomLoadbalanceImpl</span><br></pre></td></tr></table></figure><h3 id="在项目中优雅使用"><a href="#在项目中优雅使用" class="headerlink" title="在项目中优雅使用"></a>在项目中优雅使用</h3><h4 id="SPI扩展负载均衡"><a href="#SPI扩展负载均衡" class="headerlink" title="SPI扩展负载均衡"></a>SPI扩展负载均衡</h4><p>在项目启动时，Property类会加载用户的配置。我在代码中是由一个LoadbalanceFactory去调用SPI的。就是类似dubbo SPI的自适应机制，在dubbo中自适应机制是由dubbo生成代理类去完成对实现类调用的路由，我这里是直接写死由Factory去管理。</p><p>在之前讲述服务发现的代码时，我也留下了伏笔AbstractRegistrar，那么这一节，我们可以在AbstractRegistrar中调用LoadbalanceFactory。例如</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistrar</span> <span class="keyword">implements</span> <span class="title">IRegistrar</span> </span>&#123;</span><br><span class="line">    public <span class="built_in">String</span> discover(<span class="built_in">String</span> service) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; providers = lookup(service);</span><br><span class="line">        ILoadbalance loadbalance = LoadbalanceFactory.getLoadbalance();</span><br><span class="line">        <span class="built_in">String</span> select = loadbalance.select(providers);</span><br><span class="line">        <span class="keyword">return</span> select;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">abstract</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; lookup(<span class="built_in">String</span> service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在配置文件application.properties中，指定loadbalance方式，就可以由Factory路由要你需要的负载均衡算法。如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">farpc.cluster.loadbalance</span>=random</span><br></pre></td></tr></table></figure><h4 id="SPI扩展注册中心"><a href="#SPI扩展注册中心" class="headerlink" title="SPI扩展注册中心"></a>SPI扩展注册中心</h4><p>按照上面的设计模式，我们其实还可以管理注册中心、调用协议、序列化方式，等等等等….例如，我们在使用SPI加载注册中心。</p><p>注册中心的地址和端口，一般也是不会变的，我也把它放在配置文件中，在AbstractRegistrar的构造中将注册中心的地址传给ZookeeperRegistrarImpl和RedisRegistrarImpl，交由他们各自去实现，并AbstractRegistrar来调用。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> abstract <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistrar</span> <span class="title">implements</span> <span class="title">IRegistrar</span> &#123;</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> FOLDER = <span class="string">"/faregistrys"</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> SEPARATOR = <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractRegistrar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> address = Property.Registry.address;</span><br><span class="line">        init(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">discover</span><span class="params">(<span class="keyword">String</span> service)</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; providers = lookup(service);</span><br><span class="line">        ILoadbalance loadbalance = LoadbalanceFactory.getLoadbalance();</span><br><span class="line">        <span class="keyword">String</span> select = loadbalance.select(providers);</span><br><span class="line">        <span class="keyword">return</span> select;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> abstract <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">String</span> address)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> abstract List&lt;<span class="keyword">String</span>&gt; <span class="title">lookup</span><span class="params">(<span class="keyword">String</span> service)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">farpc.registry.protocol</span>=zookeeper</span><br><span class="line"><span class="attr">farpc.registry.address</span>=<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span></span><br><span class="line"><span class="attr">farpc.cluster.loadbalance</span>=random</span><br></pre></td></tr></table></figure><p>完成上面的优化，我们调用时就可以极其简洁，并且新拓展其他注册中心也只要实现AbstractRegistrar的抽象接口就行，对已有的代码没有任何侵入。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void spi<span class="constructor">Test()</span> throws IOException &#123;</span><br><span class="line">    IRegistrar registrar = <span class="module-access"><span class="module"><span class="identifier">RegistrarFactory</span>.</span></span>get<span class="constructor">Registrar()</span>;</span><br><span class="line">    registrar.register(<span class="string">"127.0.0.1:62880"</span>, <span class="module-access"><span class="module"><span class="identifier">IWelcome</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">Name()</span>);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span><span class="keyword">in</span>.read<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一节没有对各个类的代码讲述，可能有点跳跃。不过代码很简单，稍微瞥一眼就行。这个系列，我们实现的RPC调用，意义在于了解整个调用过程。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> dubbo </tag>
            
            <tag> 源码 </tag>
            
            <tag> netty </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写dubbo 8-SPI 自适应扩展机制</title>
      <link href="/2019/10/17/java/%E6%89%8B%E5%86%99dubbo%208-SPI%20%E8%87%AA%E9%80%82%E5%BA%94%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/10/17/java/%E6%89%8B%E5%86%99dubbo%208-SPI%20%E8%87%AA%E9%80%82%E5%BA%94%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>博客中代码地址：<a href="https://github.com/farliu/farpc.git" target="_blank" rel="noopener">https://github.com/farliu/farpc.git</a><br><img src="/images/java/dubbo/dubbo_implement_1_1.png" alt="dubbo架构"></p><p>本章讲解自适应扩展机制，单独将这一块拿出来，是因为这段代码逻辑复杂，处理分支较多。如果不是从上一章看过来的，建议先看看上一章讲的IOC部分。基础不牢地动山摇的情况下无法分析。</p><p>自适应扩展机制解决了一个什么问题呢？下面取自dubbo官方的一段话：</p><blockquote><p>有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。</p></blockquote><p>这句话意思表达还是很明显，就是在方法被调用的才去选择调用哪个扩展点。但是这时问题来了，“选择”这个动作怎么来做？谁来做？对于这个两个问题，怎么做？是自适应扩展机制的核心。而谁来做？是自适应扩展机制的解决方案。弄清楚这两点，基本差不多了。我们先看一个demo。</p><h3 id="自适应扩展机制示例"><a href="#自适应扩展机制示例" class="headerlink" title="自适应扩展机制示例"></a>自适应扩展机制示例</h3><p>取自dubbo的单测（dubbo-common模块）。</p><p>org.apache.dubbo.common.extension.ext1.SimpleExt</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment 1</span></span><br><span class="line"><span class="attr">impl1</span>=org.apache.dubbo.common.extension.ext1.impl.SimpleExtImpl1<span class="comment">#Hello World</span></span><br><span class="line"><span class="attr">impl2</span>=org.apache.dubbo.common.extension.ext1.impl.SimpleExtImpl2  <span class="comment"># Comment 2</span></span><br><span class="line"><span class="attr">impl3</span>=org.apache.dubbo.common.extension.ext1.impl.SimpleExtImpl3 <span class="comment"># with head space</span></span><br></pre></td></tr></table></figure><p>ExtensionLoader_Adaptive_Test</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test<span class="constructor">_getAdaptiveExtension_defaultAdaptiveKey()</span> throws Exception &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        SimpleExt ext = <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(SimpleExt.<span class="params">class</span>)</span>.get<span class="constructor">AdaptiveExtension()</span>;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;<span class="literal">()</span>;</span><br><span class="line">        URL url = <span class="keyword">new</span> <span class="constructor">URL(<span class="string">"p1"</span>, <span class="string">"1.2.3.4"</span>, 1010, <span class="string">"path1"</span>, <span class="params">map</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String echo = ext.echo(url, <span class="string">"haha"</span>);</span><br><span class="line">        <span class="keyword">assert</span><span class="constructor">Equals(<span class="string">"Ext1Impl1-echo"</span>, <span class="params">echo</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        SimpleExt ext = <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(SimpleExt.<span class="params">class</span>)</span>.get<span class="constructor">AdaptiveExtension()</span>;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;<span class="literal">()</span>;</span><br><span class="line">        map.put(<span class="string">"simple.ext"</span>, <span class="string">"impl2"</span>);</span><br><span class="line">        URL url = <span class="keyword">new</span> <span class="constructor">URL(<span class="string">"p1"</span>, <span class="string">"1.2.3.4"</span>, 1010, <span class="string">"path1"</span>, <span class="params">map</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String echo = ext.echo(url, <span class="string">"haha"</span>);</span><br><span class="line">        <span class="keyword">assert</span><span class="constructor">Equals(<span class="string">"Ext1Impl2-echo"</span>, <span class="params">echo</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>test_getAdaptiveExtension_defaultAdaptiveKey中的两个代码块唯一的区别就是，第二个代码块传入的map中保存了simple.ext-&gt;impl2的键值对，就拿到了SimpleExtImpl2的对象。这也正是自适应扩展机制解决的问题。</p><h3 id="原理概括"><a href="#原理概括" class="headerlink" title="原理概括"></a>原理概括</h3><p>为了更好的理解，先把原理交个底。我总觉得一步步验证比一步步发掘要更能理解一件事物。至于自适应机制的原理，dubbo会给需要自适应的方法生成一个代理类，通过javassist或jdk编译这段代码，得到Class。而代理类里面的逻辑，就是根据传入的Url对象中的变量取得扩展对象并调用。</p><p>SimpleExt接口定义如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">SPI</span>(<span class="string">"impl1"</span>)</span><br><span class="line"><span class="keyword">public</span> interface SimpleExt &#123;</span><br><span class="line">    <span class="comment">// @Adaptive example, do not specify a explicit key.</span></span><br><span class="line">    @Adaptive</span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">echo</span><span class="params">(URL url, <span class="keyword">String</span> s)</span></span>;</span><br><span class="line"></span><br><span class="line">    @Adaptive(&#123;<span class="string">"key1"</span>, <span class="string">"key2"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">yell</span><span class="params">(URL url, <span class="keyword">String</span> s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no @Adaptive</span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">bang</span><span class="params">(URL url, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dubbo为其生成自适应代理类如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.dubbo.common.extension.ext1;</span><br><span class="line"></span><br><span class="line">import org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> SimpleExt$Adaptive implements org.apache.dubbo.common.extension.ext1.SimpleExt &#123;</span><br><span class="line">    public java.lang.String bang(org.apache.dubbo.common.URL arg0, <span class="built_in">int</span> arg1) &#123;</span><br><span class="line">        <span class="comment">// 没有标注@Adaptive，自适应调用直接抛异常</span></span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">UnsupportedOperationException(<span class="string">"The method public abstract java.lang.String org.apache.dubbo.common.extension.ext1.SimpleExt.bang(org.apache.dubbo.common.URL,int) of interface org.apache.dubbo.common.extension.ext1.SimpleExt is not adaptive method!"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public java.lang.String yell(org.apache.dubbo.common.URL arg0, java.lang.String arg1) &#123;</span><br><span class="line">        <span class="comment">// 判断URL是否空</span></span><br><span class="line">        <span class="keyword">if</span> (arg0<span class="operator"> == </span>null) throw <span class="keyword">new</span> <span class="constructor">IllegalArgumentException(<span class="string">"url == null"</span>)</span>;</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0;</span><br><span class="line">        <span class="comment">// key1和key2，是@Adaptive中所获得的值。根据这两个key从URL中获取值，默认值为impl1，从类上的SPI注解中获取</span></span><br><span class="line">        String extName = url.get<span class="constructor">Parameter(<span class="string">"key1"</span>, <span class="params">url</span>.<span class="params">getParameter</span>(<span class="string">"key2"</span>, <span class="string">"impl1"</span>)</span>);</span><br><span class="line">        <span class="keyword">if</span> (extName<span class="operator"> == </span>null)</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.common.extension.ext1.SimpleExt) name from url ("</span> + <span class="params">url</span>.<span class="params">toString</span>()</span> + <span class="string">") use keys([key1, key2])"</span>);</span><br><span class="line">        <span class="comment">// 普通的SPI扩展对象生成</span></span><br><span class="line">        org.apache.dubbo.common.extension.ext1.SimpleExt extension = (org.apache.dubbo.common.extension.ext1.SimpleExt) <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(<span class="params">org</span>.<span class="params">apache</span>.<span class="params">dubbo</span>.<span class="params">common</span>.<span class="params">extension</span>.<span class="params">ext1</span>.SimpleExt.<span class="params">class</span>)</span>.get<span class="constructor">Extension(<span class="params">extName</span>)</span>;</span><br><span class="line">        <span class="comment">// 调用目标方法</span></span><br><span class="line">        return extension.yell(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public java.lang.String echo(org.apache.dubbo.common.URL arg0, java.lang.String arg1) &#123;</span><br><span class="line">        <span class="comment">// 判断URL是否空</span></span><br><span class="line">        <span class="keyword">if</span> (arg0<span class="operator"> == </span>null) throw <span class="keyword">new</span> <span class="constructor">IllegalArgumentException(<span class="string">"url == null"</span>)</span>;</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0;</span><br><span class="line">        <span class="comment">// 从URL中取出simple.ext的值，默认值为impl1，从类上的SPI注解中获取</span></span><br><span class="line">        String extName = url.get<span class="constructor">Parameter(<span class="string">"simple.ext"</span>, <span class="string">"impl1"</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (extName<span class="operator"> == </span>null)</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.common.extension.ext1.SimpleExt) name from url ("</span> + <span class="params">url</span>.<span class="params">toString</span>()</span> + <span class="string">") use keys([simple.ext])"</span>);</span><br><span class="line">        <span class="comment">// 普通的SPI扩展对象生成</span></span><br><span class="line">        org.apache.dubbo.common.extension.ext1.SimpleExt extension = (org.apache.dubbo.common.extension.ext1.SimpleExt) <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(<span class="params">org</span>.<span class="params">apache</span>.<span class="params">dubbo</span>.<span class="params">common</span>.<span class="params">extension</span>.<span class="params">ext1</span>.SimpleExt.<span class="params">class</span>)</span>.get<span class="constructor">Extension(<span class="params">extName</span>)</span>;</span><br><span class="line">        <span class="comment">// 调用目标方法</span></span><br><span class="line">        return extension.echo(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是dubbo自适应扩展的原理，看到这里是不是觉得自适应扩展也就那么回事。原本看起来如此神奇的功能，原理竟然如此简单。果然早在一百年前，周树人同志就告诫我们：“悲剧,是把美好的东西撕碎了给人看。”</p><p>话说回来，这里还有一点值得说。串通整个过程的@Adaptive注解，用起来有讲究。这一点很多博客都直接复制官网内容，一带而过。我想说的是，该注解确实可以标注在类和方法上，标注在方法上，用于自适应扩展机制，也就是本章的重点。而标注在类上，约定这个自适应扩展机制由程序员手动实现，不用dubbo生成扩展类。这里值得注意，dubbo为了这种扩展方式在很多地方都做了兼容。比如：</p><ol><li>加载配置文件时，loadClass()中对标注了@Adaptive的类做缓存</li><li>createAdaptiveExtension()中为标注了@Adaptive的类再做了一次注入</li><li>getAdaptiveExtensionClass()在执行loadClass()还不存在已缓存的自适应扩展，也就是不存在标注了@Adaptive的类，才会创建。</li></ol><p>还有需要注意一点，可以看到，上述所说的原理完全依赖于入参中是否存在URL，那么当入参中不存在URL对象，dubbo会怎么处理呢？直接抛异常？还是有妥善处理方式？</p><h3 id="源码验证"><a href="#源码验证" class="headerlink" title="源码验证"></a>源码验证</h3><p>我们以getAdaptiveExtension()为入口，该方法中常规的DCL校验缓存，然后调用createAdaptiveExtension()方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T create<span class="constructor">AdaptiveExtension()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        get<span class="constructor">ExtensionClasses()</span>;</span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass != null) &#123;</span><br><span class="line">            return cachedAdaptiveClass;</span><br><span class="line">        &#125;</span><br><span class="line">        cachedAdaptiveClass = create<span class="constructor">AdaptiveExtensionClass()</span>;</span><br><span class="line">        return inject<span class="constructor">Extension((T)</span> cachedAdaptiveClass.<span class="keyword">new</span><span class="constructor">Instance()</span>);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">IllegalStateException(<span class="string">"Can't create adaptive extension "</span> + <span class="params">type</span> + <span class="string">", cause: "</span> + <span class="params">e</span>.<span class="params">getMessage</span>()</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createAdaptiveExtension()是整个自适应扩展机制的全景。主要包含了三个逻辑：</p><ol><li>调用getExtensionClasses()获取所有扩展实现类</li><li>createAdaptiveExtensionClass()自动生成自适应实现类</li><li>injectExtension()为标注@Adaptive的类再做了一次注入</li></ol><h4 id="加载自适应代理类"><a href="#加载自适应代理类" class="headerlink" title="加载自适应代理类"></a>加载自适应代理类</h4><p>getExtensionClasses()在上一章详细讲了，该方法用来加载配置文件中所有的扩展实现类。而需要再次提一下的是，在它调用的loadClass()中，对标注@Adaptive的类进行单独缓存，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">void</span> loadClass(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, <span class="built_in">String</span> name) throws NoSuchMethodException &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 检测类是否标注Adaptive注解，使用一个变量保存起来</span></span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cachedAdaptiveClass = clazz;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"More than 1 adaptive class found: "</span></span><br><span class="line">                    + cachedAdaptiveClass.getName()</span><br><span class="line">                    + <span class="string">", "</span> + clazz.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getExtensionClasses()在读取配置文件后，一个个加载其中的实现类，会检查该类是否标注@Adaptive，如果标注了则会将其保存在cachedAdaptiveClass变量中。这里也就是加载程序员人工编写自适应扩展类，这里有一个要求，一个接口只允许存在一个自适应扩展类。否则，抛异常。</p><h4 id="自动生成自适应实现类"><a href="#自动生成自适应实现类" class="headerlink" title="自动生成自适应实现类"></a>自动生成自适应实现类</h4><p>经过上述加载后，如果不存在人工编写的自适应扩展类，也还没自己创建自适应扩展类，那么开始由dubbo生成。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; create<span class="constructor">AdaptiveExtensionClass()</span> &#123;</span><br><span class="line">    <span class="comment">// 生成自适应扩展类的代码</span></span><br><span class="line">    String code = <span class="keyword">new</span> <span class="constructor">AdaptiveClassCodeGenerator(<span class="params">type</span>, <span class="params">cachedDefaultName</span>)</span>.generate<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">// 这里就想尽办法获得一个非空的ClassLoader</span></span><br><span class="line">    ClassLoader classLoader = find<span class="constructor">ClassLoader()</span>;</span><br><span class="line">    <span class="comment">// 获取Compiler对象，默认使用javassist</span></span><br><span class="line">    org.apache.dubbo.common.compiler.Compiler compiler = <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(<span class="params">org</span>.<span class="params">apache</span>.<span class="params">dubbo</span>.<span class="params">common</span>.<span class="params">compiler</span>.Compiler.<span class="params">class</span>)</span>.get<span class="constructor">AdaptiveExtension()</span>;</span><br><span class="line">    <span class="comment">// 编译，生成class</span></span><br><span class="line">    return compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createAdaptiveExtensionClass()总得来说就是完成两件事，一是生成自适应扩展类的代码，二是编译，生成class。于第二点，不做详细解释，我们主要查看代码生成规则。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public String generate<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="comment">// 校验是否存在有@Adaptive修改的方法，没有则抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (!has<span class="constructor">AdaptiveMethod()</span>) &#123;</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">IllegalStateException(<span class="string">"No adaptive method exist on extension "</span> + <span class="params">type</span>.<span class="params">getName</span>()</span> + <span class="string">", refuse to create the adaptive class!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder code = <span class="keyword">new</span> <span class="constructor">StringBuilder()</span>;</span><br><span class="line"><span class="comment">// 生成包，如：package org.apache.dubbo.common.extension.ext1;</span></span><br><span class="line">    code.append(generate<span class="constructor">PackageInfo()</span>);</span><br><span class="line">    <span class="comment">// 生成import，如：import com.alibaba.dubbo.common.extension.ExtensionLoader;</span></span><br><span class="line">    code.append(generate<span class="constructor">Imports()</span>);</span><br><span class="line">    <span class="comment">// 生成类定义，如：public class SimpleExt$Adaptive implements org.apache.dubbo.common.extension.ext1.SimpleExt &#123;</span></span><br><span class="line">    code.append(generate<span class="constructor">ClassDeclaration()</span>);</span><br><span class="line"></span><br><span class="line">    Method<span class="literal">[]</span> methods = <span class="keyword">type</span>.get<span class="constructor">Methods()</span>;</span><br><span class="line">    for (Method <span class="keyword">method</span> : methods) &#123;</span><br><span class="line">        code.append(generate<span class="constructor">Method(<span class="params">method</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    code.append(<span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.is<span class="constructor">DebugEnabled()</span>) &#123;</span><br><span class="line">        logger.debug(code.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return code.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>generate()中生成包、import、类定义，这三块代码实现都是通过String.format()，逻辑简单，这里一笔带过。generateMethod()逻辑分为生成方法主体、生成方法参数、生成方法定义异常，然后拼接在一起。而生成方法主体的逻辑分支较多，我先捋出一条思路，再一点点看。</p><ol><li>分别处理是否有@Adaptive修饰的方法</li><li>定位URL对象的值</li><li>获取该接口自适应路由的key，用户获取URL中实现类的名字，并非空判断</li><li>通过实现类的名字，调用普通的SPI，生成扩展对象</li><li>调用目标方法</li></ol><h5 id="检测-Adaptive修饰"><a href="#检测-Adaptive修饰" class="headerlink" title="检测@Adaptive修饰"></a>检测@Adaptive修饰</h5><p>对于没有Adaptive修饰的方法，以SimpleExt.bang()方法为例。dubbo则不会为该方法生成具体逻辑，而是直接抛出异常，生成逻辑如下：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> String CODE_UNSUPPORTED = <span class="string">"throw new UnsupportedOperationException(\"The method %s of interface %s is not adaptive method!\");\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String generateMethodContent(<span class="function"><span class="keyword">Method</span> <span class="title">method</span>) &#123;</span></span><br><span class="line">    Adaptive adaptiveAnnotation = <span class="function"><span class="keyword">method</span>.<span class="title">getAnnotation</span>(</span>Adaptive<span class="class">.<span class="keyword">class</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(CODE_UNSUPPORTED, <span class="function"><span class="keyword">method</span>, <span class="title">type</span>.<span class="title">getName</span>(</span>));</span><br><span class="line">    &#125; </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定位URL对象的值"><a href="#定位URL对象的值" class="headerlink" title="定位URL对象的值"></a>定位URL对象的值</h5><p>上文说到，自适应扩展机制，完全依赖URL对象，当不存在URL对象时，无法实现自适应扩展。而不是所有方法都需要URL做为入参的，那么dubbo是怎么处理的呢？</p><ol><li>对于入参中存在URL对象，获取方式就是直接遍历获得。</li><li>对不入参不存在URL对象的方法，dubbo会遍历入参，通过反射调用入参中是否存在以get开头、返回值为URL的方法，并调用。</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static final String CODE_URL_NULL_CHECK = <span class="string">"if (arg%d == null) throw new IllegalArgumentException(\"url == null\");\n%s url = arg%d;\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String generate<span class="constructor">MethodContent(Method <span class="params">method</span>)</span> &#123;</span><br><span class="line">    Adaptive adaptiveAnnotation = <span class="keyword">method</span>.get<span class="constructor">Annotation(Adaptive.<span class="params">class</span>)</span>;</span><br><span class="line">    StringBuilder code = <span class="keyword">new</span> <span class="constructor">StringBuilder(512)</span>;</span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation<span class="operator"> == </span>null) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取URL对象在入参的位置</span></span><br><span class="line">        <span class="built_in">int</span> urlTypeIndex = get<span class="constructor">UrlTypeIndex(<span class="params">method</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (urlTypeIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 存在URL对象，生成代码：判断该对象是否为空并赋值。如：if (arg0 == null) throw new IllegalArgumentException("url == null");org.apache.dubbo.common.URL url = arg0;</span></span><br><span class="line">            code.append(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(CODE_URL_NULL_CHECK, urlTypeIndex, <span class="module-access"><span class="module"><span class="identifier">URL</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">Name()</span>, index));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             Class&lt;?&gt;<span class="literal">[]</span> pts = <span class="keyword">method</span>.get<span class="constructor">ParameterTypes()</span>;</span><br><span class="line">        <span class="comment">// 遍历所有入参</span></span><br><span class="line">        for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line">                <span class="comment">// 遍历每一个入参中的所有方法</span></span><br><span class="line">            for (Method m : pts<span class="literal">[<span class="identifier">i</span>]</span>.get<span class="constructor">Methods()</span>) &#123;</span><br><span class="line">                String name = m.get<span class="constructor">Name()</span>;</span><br><span class="line">                <span class="keyword">if</span> ((name.starts<span class="constructor">With(<span class="string">"get"</span>)</span><span class="operator"> || </span>name.length<span class="literal">()</span> &gt; <span class="number">3</span>)</span><br><span class="line">                            <span class="comment">// 是否为public方法</span></span><br><span class="line"><span class="operator">                        &amp;&amp; </span><span class="module-access"><span class="module"><span class="identifier">Modifier</span>.</span></span>is<span class="constructor">Public(<span class="params">m</span>.<span class="params">getModifiers</span>()</span>)</span><br><span class="line">                            <span class="comment">// 不是static方法</span></span><br><span class="line"><span class="operator">                        &amp;&amp; </span>!<span class="module-access"><span class="module"><span class="identifier">Modifier</span>.</span></span>is<span class="constructor">Static(<span class="params">m</span>.<span class="params">getModifiers</span>()</span>)</span><br><span class="line">                            <span class="comment">// 没有入参</span></span><br><span class="line"><span class="operator">                        &amp;&amp; </span>m.get<span class="constructor">ParameterTypes()</span>.length<span class="operator"> == </span><span class="number">0</span></span><br><span class="line">                            <span class="comment">// 返回值是URL</span></span><br><span class="line"><span class="operator">                        &amp;&amp; </span>m.get<span class="constructor">ReturnType()</span><span class="operator"> == </span><span class="module-access"><span class="module"><span class="identifier">URL</span>.</span></span><span class="keyword">class</span>) &#123;</span><br><span class="line">                        <span class="comment">// 生成代码：判断该入参是否为空、判断入参调用get方法返回值是否为空并赋值。</span></span><br><span class="line">                    return generate<span class="constructor">GetUrlNullCheck(<span class="params">i</span>, <span class="params">pts</span>[<span class="params">i</span>], <span class="params">name</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getter method not found, throw</span></span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">IllegalStateException(<span class="string">"Failed to create adaptive class for interface "</span> + <span class="params">type</span>.<span class="params">getName</span>()</span></span><br><span class="line">                        + <span class="string">": not found url parameter or url attribute in parameters of method "</span> + <span class="keyword">method</span>.get<span class="constructor">Name()</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取URL中实现类的名字"><a href="#获取URL中实现类的名字" class="headerlink" title="获取URL中实现类的名字"></a>获取URL中实现类的名字</h5><p>获取实现类的名字，需要先获取URL对象中key。获取这个key，dubbo会先从Adaptive注解中取得，倘若注解中没有设置该值，则根据类名生成一个简单的名字当做key。比如SimpleExt，处理后会生成simple.ext当做key。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String generate<span class="constructor">MethodContent(Method <span class="params">method</span>)</span> &#123;</span><br><span class="line">    Adaptive adaptiveAnnotation = <span class="keyword">method</span>.get<span class="constructor">Annotation(Adaptive.<span class="params">class</span>)</span>;</span><br><span class="line">    StringBuilder code = <span class="keyword">new</span> <span class="constructor">StringBuilder(512)</span>;</span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation<span class="operator"> == </span>null) &#123;</span><br><span class="line">...      </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">        String<span class="literal">[]</span> value = adaptiveAnnotation.value<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span> (value.length<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 注解中没有指定key。</span></span><br><span class="line">            String splitName = <span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>camel<span class="constructor">ToSplitName(<span class="params">type</span>.<span class="params">getSimpleName</span>()</span>, <span class="string">"."</span>);</span><br><span class="line">            value = <span class="keyword">new</span> String<span class="literal">[]</span>&#123;splitName&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，是由上述生成key值，调用generateExtNameAssignment()从URL取得扩展名字。这段代码根据各类情况，分别处理，if判断很长，需要慢慢捋清楚。最终会生成一下代码</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> extName = (<span class="built_in">url</span>.getProtocol() == <span class="literal">null</span> ? <span class="string">"impl1"</span> : <span class="built_in">url</span>.getProtocol());</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line"><span class="built_in">String</span> extName = <span class="built_in">url</span>.getMethodParameter(methodName, <span class="string">"loadbalance"</span>, <span class="string">"random"</span>);</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line"><span class="built_in">String</span> extName = <span class="built_in">url</span>.getParameter(<span class="string">"key1"</span>, <span class="built_in">url</span>.getParameter(<span class="string">"key2"</span>, <span class="string">"impl1"</span>));</span><br></pre></td></tr></table></figure><h5 id="生成扩展对象、调用目标方法"><a href="#生成扩展对象、调用目标方法" class="headerlink" title="生成扩展对象、调用目标方法"></a>生成扩展对象、调用目标方法</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static final String CODE_EXTENSION_ASSIGNMENT = <span class="string">"%s extension = (%&lt;s)%s.getExtensionLoader(%s.class).getExtension(extName);\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String generate<span class="constructor">MethodContent(Method <span class="params">method</span>)</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 生成调用SPI生成扩展对象的代码</span></span><br><span class="line">        code.append(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(CODE_EXTENSION_ASSIGNMENT, <span class="keyword">type</span>.get<span class="constructor">Name()</span>, <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">SimpleName()</span>, <span class="keyword">type</span>.get<span class="constructor">Name()</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法，并返回值</span></span><br><span class="line">        code.append(generate<span class="constructor">ReturnAndInvocation(<span class="params">method</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return code.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String generate<span class="constructor">ReturnAndInvocation(Method <span class="params">method</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否void返回类型的方法</span></span><br><span class="line">    String returnStatement = <span class="keyword">method</span>.get<span class="constructor">ReturnType()</span>.equals(void.<span class="keyword">class</span>) ? <span class="string">""</span> : <span class="string">"return "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接入参</span></span><br><span class="line">    String args = <span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>range(<span class="number">0</span>, <span class="keyword">method</span>.get<span class="constructor">Parameters()</span>.length)</span><br><span class="line">            .map<span class="constructor">ToObj(<span class="params">i</span> -&gt; String.<span class="params">format</span>(CODE_EXTENSION_METHOD_INVOKE_ARGUMENT, <span class="params">i</span>)</span>)</span><br><span class="line">            .collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span>joining(<span class="string">", "</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用目标方法</span></span><br><span class="line">    return returnStatement + <span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">"extension.%s(%s);\n"</span>, <span class="keyword">method</span>.get<span class="constructor">Name()</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，生成代理类代码的逻辑都在上述过程中，后续就是dubbo调用Compiler生成class，然后使用了。SPI到本文，源码讲解就结束了，后面就是我们自己手动实现SPI了。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> dubbo </tag>
            
            <tag> 源码 </tag>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写dubbo 7-SPI(dubbo和jdk的区别)</title>
      <link href="/2019/10/14/java/%E6%89%8B%E5%86%99dubbo%207-SPI(dubbo%E5%92%8Cjdk%E7%9A%84%E5%8C%BA%E5%88%AB)/"/>
      <url>/2019/10/14/java/%E6%89%8B%E5%86%99dubbo%207-SPI(dubbo%E5%92%8Cjdk%E7%9A%84%E5%8C%BA%E5%88%AB)/</url>
      
        <content type="html"><![CDATA[<p>博客中代码地址：<a href="https://github.com/farliu/farpc.git" target="_blank" rel="noopener">https://github.com/farliu/farpc.git</a><br><img src="/images/java/dubbo/dubbo_implement_1_1.png" alt="dubbo架构"></p><p>这章继续了解SPI，上一章我们列举了dubbo选择SPI的背景和SPI的简单使用。不过，dubbo并未使用 Java 原生的SPI机制，而是对其进行了增强，使其能够更好的满足需求。我列举两点dubbo增强的优势。本章也对其进行展开。</p><ol><li>按需加载接口实现类</li><li>增加了IOC和AOP等特性，向拓展对象中注入依赖</li></ol><h3 id="dubbo-SPI示例"><a href="#dubbo-SPI示例" class="headerlink" title="dubbo SPI示例"></a>dubbo SPI示例</h3><p>dubbo SPI 的相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。dubbo SPI 所需的配置文件需放置在 META-INF/dubbo 路径下。以下例子，取自dubbo的单测（dubbo-common模块）。</p><p>org.apache.dubbo.common.extension.ext1.SimpleExt</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment 1</span></span><br><span class="line"><span class="attr">impl1</span>=org.apache.dubbo.common.extension.ext1.impl.SimpleExtImpl1<span class="comment">#Hello World</span></span><br><span class="line"><span class="attr">impl2</span>=org.apache.dubbo.common.extension.ext1.impl.SimpleExtImpl2  <span class="comment"># Comment 2</span></span><br><span class="line"><span class="attr">impl3</span>=org.apache.dubbo.common.extension.ext1.impl.SimpleExtImpl3 <span class="comment"># with head space</span></span><br></pre></td></tr></table></figure><p>ExtensionLoaderTest</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test<span class="constructor">_getExtension()</span> throws Exception &#123;</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">True(ExtensionLoader.<span class="params">getExtensionLoader</span>(SimpleExt.<span class="params">class</span>)</span>.get<span class="constructor">Extension(<span class="string">"impl1"</span>)</span> instanceof SimpleExtImpl1);</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">True(ExtensionLoader.<span class="params">getExtensionLoader</span>(SimpleExt.<span class="params">class</span>)</span>.get<span class="constructor">Extension(<span class="string">"impl2"</span>)</span> instanceof SimpleExtImpl2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果单测肯定是通过的。也就是说我们通过impl1和impl2分别获取到了各自的实现类的对象。</p><h3 id="总揽全局原理"><a href="#总揽全局原理" class="headerlink" title="总揽全局原理"></a>总揽全局原理</h3><p>我们粗略归纳一下，以上单测的运行逻辑，主要包含两个方法getExtensionLoader()和getExtension()，前者用于从缓存中获取与拓展类对应的 ExtensionLoader，若缓存未命中，则创建一个新的实例，并创建一个objectFactory用于实现IOC注入。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;<span class="type">T</span>&gt; <span class="type">ExtensionLoader</span>&lt;<span class="type">T</span>&gt; getExtensionLoader(<span class="type">Class</span>&lt;<span class="type">T</span>&gt; <span class="class"><span class="keyword">type</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//一系列安全检查</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="class"><span class="keyword">type</span> <span class="title">==</span> <span class="title">null</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"Extension type == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="class"><span class="keyword">type</span>.<span class="title">isInterface</span>(<span class="params"></span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"Extension type ("</span> + <span class="class"><span class="keyword">type</span> <span class="title">+</span> ") <span class="title">is</span> <span class="title">not</span> <span class="title">an</span> <span class="title">interface!</span>")</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!withExtensionAnnotation(<span class="class"><span class="keyword">type</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"Extension type ("</span> + <span class="class"><span class="keyword">type</span> <span class="title">+</span></span></span><br><span class="line"><span class="class">                ") <span class="title">is</span> <span class="title">not</span> <span class="title">an</span> <span class="title">extension</span>, <span class="title">because</span> <span class="title">it</span> <span class="title">is</span> <span class="title">NOT</span> <span class="title">annotated</span> <span class="keyword">with</span> <span class="title">@</span>" <span class="title">+</span> <span class="title">SPI</span>.<span class="title">class</span>.<span class="title">getSimpleName</span>(<span class="params"></span>) <span class="title">+</span> "<span class="title">!</span>")</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从缓存中获取与拓展类对应的 ExtensionLoader</span></span><br><span class="line">    <span class="type">ExtensionLoader</span>&lt;<span class="type">T</span>&gt; loader = (<span class="type">ExtensionLoader</span>&lt;<span class="type">T</span>&gt;) <span class="type">EXTENSION_LOADERS</span>.get(<span class="class"><span class="keyword">type</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建并保存在缓存中</span></span><br><span class="line">        <span class="type">EXTENSION_LOADERS</span>.putIfAbsent(<span class="class"><span class="keyword">type</span>, <span class="title">new</span> <span class="title">ExtensionLoader&lt;T&gt;</span>(<span class="params">type</span>))</span>;</span><br><span class="line">        loader = (<span class="type">ExtensionLoader</span>&lt;<span class="type">T</span>&gt;) <span class="type">EXTENSION_LOADERS</span>.get(<span class="class"><span class="keyword">type</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建ExtensionLoader对象</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExtensionFactory</span> objectFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="type">ExtensionLoader</span>(<span class="type">Class</span>&lt;?&gt; <span class="class"><span class="keyword">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span><span class="class">.<span class="keyword">type</span> </span>= <span class="class"><span class="keyword">type</span></span>;</span><br><span class="line">    <span class="comment">//用于后续注入其他的扩展对象</span></span><br><span class="line">    objectFactory = (<span class="class"><span class="keyword">type</span> <span class="title">==</span> <span class="title">ExtensionFactory</span>.<span class="title">class</span> <span class="title">?</span> <span class="title">null</span> </span>: <span class="type">ExtensionLoader</span>.getExtensionLoader(<span class="type">ExtensionFactory</span><span class="class">.<span class="keyword">class</span>).<span class="title">getAdaptiveExtension</span>(<span class="params"></span>))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getExtension()代码的逻辑比较简单，首先检查缓存，缓存未命中则调用createExtension()创建拓展对象。值得一提的是Holder，该类使用volatile修饰，使用Holder包装保证可见性。看源码更重要的时候学到这些细节，dubbo中对细节处理很到位，很多地方用到了双重检查和缓存等优化，这些平常到不能再平常的处理，让我对dubbo源码心生敬畏。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public T getExtension(String name) &#123;</span><br><span class="line">    //一系列安全检查</span><br><span class="line">   <span class="built_in"> if </span>(StringUtils.isEmpty(name)) &#123;</span><br><span class="line">       <span class="built_in"> throw </span>new IllegalArgumentException(<span class="string">"Extension name == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in"> if </span>(<span class="string">"true"</span>.equals(name)) &#123;</span><br><span class="line">        // 获取默认的拓展实现类</span><br><span class="line">       <span class="built_in"> return </span>getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //从缓存中获取，没有则new一个并保存</span><br><span class="line">    Holder&lt;Object&gt; holder = getOrCreateHolder(name);</span><br><span class="line">    Object<span class="built_in"> instance </span>= holder.get();</span><br><span class="line">    // 双重检查</span><br><span class="line">   <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">        synchronized (holder) &#123;</span><br><span class="line">           <span class="built_in"> instance </span>= holder.get();</span><br><span class="line">           <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">                // 创建拓展实例</span><br><span class="line">               <span class="built_in"> instance </span>= createExtension(name);</span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="built_in"> return </span>(T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createExtension()是SPI一览全景的方法，这个方法包含了创建对象的所有精髓。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private T createExtension(String <span class="type">name</span>) &#123;</span><br><span class="line">    // 根据传入的扩展名获取到对应实现类</span><br><span class="line">    <span class="keyword">Class</span>&lt;?&gt; clazz = getExtensionClasses().<span class="keyword">get</span>(<span class="type">name</span>);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        throw findException(<span class="type">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        T instance = (T) EXTENSION_INSTANCES.<span class="keyword">get</span>(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            // 通过反射创建实例</span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.<span class="keyword">get</span>(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        // 向实例中注入依赖</span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        <span class="keyword">Set</span>&lt;<span class="keyword">Class</span>&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (wrapperClasses != <span class="keyword">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;</span><br><span class="line">            // 循环创建 <span class="keyword">Wrapper</span> 实例</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">Class</span>&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                // 将当前 instance 作为参数传给 <span class="keyword">Wrapper</span> 的构造方法，并通过反射创建 <span class="keyword">Wrapper</span> 实例。</span><br><span class="line">                // 然后向 <span class="keyword">Wrapper</span> 实例中注入依赖，最后将 <span class="keyword">Wrapper</span> 实例再次赋值给 instance 变量</span><br><span class="line">                instance = injectExtension(</span><br><span class="line">                    (T) wrapperClass.getConstructor(<span class="keyword">type</span>).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        throw <span class="built_in">new</span> IllegalStateException("...");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createExtension()方法主要包含了如下的步骤：</p><ol><li>根据传入的扩展名获取到对应实现类</li><li>通过反射创建拓展对象</li><li>向拓展对象中注入依赖</li><li>将拓展对象包裹在相应的Wrapper对象中</li></ol><p>第一步是加载拓展类的关键，第二步是SPI的核心，第三和第四个步骤是dubbo IOC与AOP的具体实现。接下来主要细品这些内容。</p><h3 id="细品：按需加载接口实现类"><a href="#细品：按需加载接口实现类" class="headerlink" title="细品：按需加载接口实现类"></a>细品：按需加载接口实现类</h3><p>getExtensionClasses()该方法配置文件中加载所有的拓展类，返回Map&lt;String, Class&lt;?&gt;&gt;用来保存“配置项名称”到“配置类”的关系。代码逻辑简单，就是常规的使用DCL检查缓存，最后通过 loadExtensionClasses()加载拓展类。我们以loadExtensionClasses()为入口进行分析。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; load<span class="constructor">ExtensionClasses()</span> &#123;</span><br><span class="line">    <span class="comment">//从接口上的SPI注解里提取并缓存默认扩展名</span></span><br><span class="line">    cache<span class="constructor">DefaultExtensionName()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载指定文件夹下的配置文件，由于我的源码是2.7+，所以有对alibaba的包名做兼容处理</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">    load<span class="constructor">Directory(<span class="params">extensionClasses</span>, DUBBO_INTERNAL_DIRECTORY, <span class="params">type</span>.<span class="params">getName</span>()</span>);</span><br><span class="line">    load<span class="constructor">Directory(<span class="params">extensionClasses</span>, DUBBO_INTERNAL_DIRECTORY, <span class="params">type</span>.<span class="params">getName</span>()</span>.replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>));</span><br><span class="line">    load<span class="constructor">Directory(<span class="params">extensionClasses</span>, DUBBO_DIRECTORY, <span class="params">type</span>.<span class="params">getName</span>()</span>);</span><br><span class="line">    load<span class="constructor">Directory(<span class="params">extensionClasses</span>, DUBBO_DIRECTORY, <span class="params">type</span>.<span class="params">getName</span>()</span>.replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>));</span><br><span class="line">    load<span class="constructor">Directory(<span class="params">extensionClasses</span>, SERVICES_DIRECTORY, <span class="params">type</span>.<span class="params">getName</span>()</span>);</span><br><span class="line">    load<span class="constructor">Directory(<span class="params">extensionClasses</span>, SERVICES_DIRECTORY, <span class="params">type</span>.<span class="params">getName</span>()</span>.replace(<span class="string">"org.apache"</span>, <span class="string">"com.alibaba"</span>));</span><br><span class="line">    return extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadExtensionClasses()一共做两件事，一是从接口上的SPI注解里提取并缓存默认扩展名，这段代码逻辑简单。二是调用loadDirectory()加载制定目录下所有的配置文件，我们重点关注第二点。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void load<span class="constructor">Directory(Map&lt;String, Class&lt;?&gt;&gt; <span class="params">extensionClasses</span>, String <span class="params">dir</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 文件夹路径 + type 全限定名。</span></span><br><span class="line">    <span class="comment">// 例如：META-INF/dubbo/internal/com.alibaba.dubbo.common.extension.ext1.SimpleExt</span></span><br><span class="line">    String fileName = dir + <span class="keyword">type</span>.get<span class="constructor">Name()</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls;</span><br><span class="line">        <span class="comment">// 通过一切办法得到一个非空的classLoader</span></span><br><span class="line">        ClassLoader classLoader = find<span class="constructor">ClassLoader()</span>;</span><br><span class="line">        <span class="comment">// 加载同名的所有资源文件</span></span><br><span class="line">        <span class="keyword">if</span> (classLoader != null) &#123;</span><br><span class="line">            urls = classLoader.get<span class="constructor">Resources(<span class="params">fileName</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            urls = <span class="module-access"><span class="module"><span class="identifier">ClassLoader</span>.</span></span>get<span class="constructor">SystemResources(<span class="params">fileName</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (urls != null) &#123;</span><br><span class="line">            <span class="keyword">while</span> (urls.has<span class="constructor">MoreElements()</span>) &#123;</span><br><span class="line">                java.net.URL resourceURL = urls.next<span class="constructor">Element()</span>;</span><br><span class="line">                <span class="comment">// 加载资源</span></span><br><span class="line">                load<span class="constructor">Resource(<span class="params">extensionClasses</span>, <span class="params">classLoader</span>, <span class="params">resourceURL</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadDirectory()主要是通过classLoader加载和fileName同名的所有资源文件，这里的资源也就是配置文件，然后调用loadResource()解析配置文件。其实findClassLoader()也建议大家好好端详一番，感受一下大佬的细致。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> loadResource(Map&lt;<span class="keyword">String</span>, Class&lt;?&gt;&gt; extensionClasses, </span><br><span class="line">ClassLoader classLoader, java.net.URL resourceURL) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">BufferedReader</span> reader = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(</span><br><span class="line">            <span class="keyword">new</span> InputStreamReader(resourceURL.openStream(), <span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">String</span> <span class="built_in">line</span>;</span><br><span class="line">            <span class="keyword">while</span> ((<span class="built_in">line</span> = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 定位注释位置，删除#之后的内容</span></span><br><span class="line">                <span class="keyword">final</span> <span class="built_in">int</span> ci = <span class="built_in">line</span>.indexOf(<span class="string">'#'</span>);</span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">line</span> = <span class="built_in">line</span>.substring(<span class="number">0</span>, ci);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">line</span> = <span class="built_in">line</span>.<span class="built_in">trim</span>();</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">line</span>.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">String</span> name = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="built_in">int</span> i = <span class="built_in">line</span>.indexOf(<span class="string">'='</span>);</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 以等于号 = 分割，截取键与值</span></span><br><span class="line">                            name = <span class="built_in">line</span>.substring(<span class="number">0</span>, i).<span class="built_in">trim</span>();</span><br><span class="line">                            <span class="built_in">line</span> = <span class="built_in">line</span>.substring(i + <span class="number">1</span>).<span class="built_in">trim</span>();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">line</span>.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 加载类，并通过 loadClass 方法对类进行缓存</span></span><br><span class="line">                            loadClass(extensionClasses, resourceURL, </span><br><span class="line">                                      Class.forName(<span class="built_in">line</span>, <span class="keyword">true</span>, classLoader), name);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        IllegalStateException e = <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to load extension class..."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">"Exception when load extension class..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadResource()就是读取文件内容并解析，通过Class.forName()加载类，然后调用loadClass操作缓存。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private <span class="type">void</span> loadClass(Map&lt;String, <span class="keyword">Class</span>&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, <span class="keyword">Class</span>&lt;?&gt; clazz, String <span class="type">name</span>) throws NoSuchMethodException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">type</span>.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        throw <span class="built_in">new</span> IllegalStateException("Error occurred when loading extension class (interface: " +</span><br><span class="line">                <span class="keyword">type</span> + ", class line: " + clazz.getName() + "), class "</span><br><span class="line">                + clazz.getName() + " is not subtype of interface.");</span><br><span class="line">    &#125;</span><br><span class="line">    // 检测类是否标注Adaptive注解，使用一个变量保存起来</span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.<span class="keyword">class</span>)) &#123;</span><br><span class="line">        cacheAdaptiveClass(clazz);</span><br><span class="line">    &#125; </span><br><span class="line">    // 检测<span class="keyword">class</span>是否是Wapper类型，使用一个变量保存起来</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">        cacheWrapperClass(clazz);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clazz.getConstructor();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(<span class="type">name</span>)) &#123;</span><br><span class="line">            // <span class="type">name</span>为空，则尝试从 <span class="keyword">Extension</span> 注解中获取 <span class="type">name</span></span><br><span class="line">            <span class="type">name</span> = findAnnotationName(clazz);</span><br><span class="line">            <span class="keyword">if</span> (<span class="type">name</span>.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                throw <span class="built_in">new</span> IllegalStateException("No such extension name for the class " + clazz.getName() + " in the config " + resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] names = NAME_SEPARATOR.split(<span class="type">name</span>);</span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isNotEmpty(names)) &#123;</span><br><span class="line">            // 如果存在Activate注解，存储<span class="type">name</span>到Activate注解对象的映射关系</span><br><span class="line">            cacheActivateClass(clazz, names[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                // 保存<span class="keyword">Class</span>到名称的关系</span><br><span class="line">                cacheName(clazz, n);</span><br><span class="line">                // 保存名称到<span class="keyword">Class</span>的关系到extensionClasses，以此返回</span><br><span class="line">                saveInExtensionClass(extensionClasses, clazz, <span class="type">name</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，第一个特性按需加载接口实现类，所有实现都结束了，这个过程逻辑并不复杂，顺着这个思路或跟着断点走一遍基本上心里都有个七七八八。createExtension()的第二步通过反射获取对象，这里没有过多追述的。</p><h3 id="细品：IOC-和-AOP-特性"><a href="#细品：IOC-和-AOP-特性" class="headerlink" title="细品：IOC 和 AOP 特性"></a>细品：IOC 和 AOP 特性</h3><h4 id="SPI中的IOC"><a href="#SPI中的IOC" class="headerlink" title="SPI中的IOC"></a>SPI中的IOC</h4><p>dubbo IOC是通过判断是否存在set方法，通过前文说的ObjectFactory对象获取注入对象。然后将注入对象通过反射调用set方法赋值到目标对象中。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T inject<span class="constructor">Extension(T <span class="params">instance</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (objectFactory != null) &#123;</span><br><span class="line">            for (Method <span class="keyword">method</span> : instance.get<span class="constructor">Class()</span>.get<span class="constructor">Methods()</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (is<span class="constructor">Setter(<span class="params">method</span>)</span>) &#123;</span><br><span class="line">                    <span class="comment">// 判断是否禁用注入，可用来防止覆盖已有的值</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">method</span>.get<span class="constructor">Annotation(DisableInject.<span class="params">class</span>)</span> != null) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 获取set方法的入参类型，就是需要注入的对象的class</span></span><br><span class="line">                    Class&lt;?&gt; pt = <span class="keyword">method</span>.get<span class="constructor">ParameterTypes()</span><span class="literal">[<span class="number">0</span>]</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">ReflectUtils</span>.</span></span>is<span class="constructor">Primitives(<span class="params">pt</span>)</span>) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String property = get<span class="constructor">SetterProperty(<span class="params">method</span>)</span>;</span><br><span class="line">                        <span class="comment">// 从 ObjectFactory 中获取依赖对象</span></span><br><span class="line">                        Object object = objectFactory.get<span class="constructor">Extension(<span class="params">pt</span>, <span class="params">property</span>)</span>;</span><br><span class="line">                        <span class="keyword">if</span> (object != null) &#123;</span><br><span class="line">                            <span class="comment">// 反射调用set方法</span></span><br><span class="line">                            <span class="keyword">method</span>.invoke(instance, object);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        logger.error(<span class="string">"Failed to inject via method "</span> + <span class="keyword">method</span>.get<span class="constructor">Name()</span></span><br><span class="line">                                + <span class="string">" of interface "</span> + <span class="keyword">type</span>.get<span class="constructor">Name()</span> + <span class="string">": "</span> + e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        logger.error(e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲起来，这就是IOC的所有的代码了，还是比较容易理解。这里可以继续深入的就是objectFactory.getExtension()，ExtensionFactory每个实现类的getExtension()代码都容易理解。只是多提一下，ExtensionFactory三个实现类的作用。SpiExtensionFactory用于创建自适应的拓展、SpringExtensionFactory用于从Spring的IOC容器中获取所需的拓展、AdaptiveExtensionFactory内部为一个List，遍历所有的getExtension()。</p><h4 id="SPI中的AOP"><a href="#SPI中的AOP" class="headerlink" title="SPI中的AOP"></a>SPI中的AOP</h4><p>dubbo对于SPI所增强的AOP，根本原理是在目标对象上包了一层Wrapper类，Wrapper也实现了目标接口，通过Wrapper的构造将目标对象保存至Wrapper对象中，而ExtensionLoader 返回扩展对象时，返回的Wrapper类的对象。我们将扩展对象的公共逻辑移至Wrapper类中，达到AOP的效果。Wrapper可以根据需要新增，切面的执行顺序按照配置文件中顺序决定。</p><p>了解了基础原理，我们先看一个简单的demo，该代码取自dubbo-common中的单元测试。</p><p>org.apache.dubbo.common.extension.ext6_wrap.WrappedExt</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">impl1=org<span class="selector-class">.apache</span><span class="selector-class">.dubbo</span><span class="selector-class">.common</span><span class="selector-class">.extension</span><span class="selector-class">.ext6_wrap</span><span class="selector-class">.impl</span>.Ext5Impl1</span><br><span class="line">impl2=org<span class="selector-class">.apache</span><span class="selector-class">.dubbo</span><span class="selector-class">.common</span><span class="selector-class">.extension</span><span class="selector-class">.ext6_wrap</span><span class="selector-class">.impl</span>.Ext5Impl2</span><br><span class="line">wrapper1=org<span class="selector-class">.apache</span><span class="selector-class">.dubbo</span><span class="selector-class">.common</span><span class="selector-class">.extension</span><span class="selector-class">.ext6_wrap</span><span class="selector-class">.impl</span>.Ext5Wrapper1</span><br><span class="line">wrapper2=org<span class="selector-class">.apache</span><span class="selector-class">.dubbo</span><span class="selector-class">.common</span><span class="selector-class">.extension</span><span class="selector-class">.ext6_wrap</span><span class="selector-class">.impl</span>.Ext5Wrapper2</span><br></pre></td></tr></table></figure><p>ExtensionLoaderTest</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test<span class="constructor">_getExtension_WithWrapper()</span> throws Exception &#123;</span><br><span class="line">    WrappedExt impl1 = <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(WrappedExt.<span class="params">class</span>)</span>.get<span class="constructor">Extension(<span class="string">"impl1"</span>)</span>;</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">That(<span class="params">impl1</span>, <span class="params">anyOf</span>(<span class="params">instanceOf</span>(Ext5Wrapper1.<span class="params">class</span>)</span>, instance<span class="constructor">Of(Ext5Wrapper2.<span class="params">class</span>)</span>));</span><br><span class="line"></span><br><span class="line">    WrappedExt impl2 = <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(WrappedExt.<span class="params">class</span>)</span>.get<span class="constructor">Extension(<span class="string">"impl2"</span>)</span>;</span><br><span class="line">    <span class="keyword">assert</span><span class="constructor">That(<span class="params">impl2</span>, <span class="params">anyOf</span>(<span class="params">instanceOf</span>(Ext5Wrapper1.<span class="params">class</span>)</span>, instance<span class="constructor">Of(Ext5Wrapper2.<span class="params">class</span>)</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们打断点，先证实我上面所说的原理，观察impl1所返回的对象来自哪个类。<br><img src="/images/java/dubbo/dubbo_implement_7_1.png" alt="SPI AOP"></p><p>可以看到ExtensionLoader返回的扩展对象并非Ext5Impl1，而是Ext5Wrapper1，而Ext5Wrapper1中存在一个instance变量，该变量存的对象是Ext5Impl2，Ext5Impl2中的instance存的才是Ext5Impl1的对象。也就是说当我们调用WrappedExt接口中的方法时，会依次经过Ext5Wrapper1 &gt; Ext5Wrapper2 &gt; Ext5Impl1。</p><p>这也印证了之前说的执行顺序，执行顺序除了受配置文件中的顺序决定以外，还有一点值得注意。在上文分析的loadExtensionClasses()方法中有loadDirectory()一说，Wrapper的执行还跟加载文件夹有关。也就是：internal &gt; META-INF/dubbo/ &gt; META-INF/services/</p><p>基本基础知识了解了，再来看看怎么实现的，其实在上文中，都隐约有提到对于Wrapper的东西。这里再次将关键代码提取出来，应该更能理解。</p><p>createExtension() &gt; getExtensionClasses() &gt; loadExtensionClasses() &gt; loadDirectory() &gt; loadResource() &gt; loadClass()</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> void load<span class="constructor">Class(Map&lt;String, Class&lt;?&gt;&gt; <span class="params">extensionClasses</span>, <span class="params">java</span>.<span class="params">net</span>.URL <span class="params">resourceURL</span>, Class&lt;?&gt; <span class="params">clazz</span>, String <span class="params">name</span>)</span> throws NoSuchMethodException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (clazz.is<span class="constructor">AnnotationPresent(Adaptive.<span class="params">class</span>)</span>) &#123;</span><br><span class="line">        cache<span class="constructor">AdaptiveClass(<span class="params">clazz</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is<span class="constructor">WrapperClass(<span class="params">clazz</span>)</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedWrapperClasses<span class="operator"> == </span>null) &#123;</span><br><span class="line">            cachedWrapperClasses = <span class="keyword">new</span> ConcurrentHashSet&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 将Wrapper类保存到Set&lt;Class&lt;?&gt;&gt;中</span></span><br><span class="line">        cachedWrapperClasses.add(clazz);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> boolean is<span class="constructor">WrapperClass(Class&lt;?&gt; <span class="params">clazz</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据是否存在参数为扩展对象的构造，来判断是否是Wrapper类</span></span><br><span class="line">        clazz.get<span class="constructor">Constructor(<span class="params">type</span>)</span>;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createExtension()</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T create<span class="constructor">Extension(String <span class="params">name</span>)</span> &#123;</span><br><span class="line">...</span><br><span class="line">Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">    <span class="comment">// 判断该接口，存不存在Wrapper类</span></span><br><span class="line"><span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">CollectionUtils</span>.</span></span>is<span class="constructor">NotEmpty(<span class="params">wrapperClasses</span>)</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果有，那就一层一层的包起来，赋值给instance</span></span><br><span class="line">    for (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">        instance = inject<span class="constructor">Extension((T)</span> wrapperClass.get<span class="constructor">Constructor(<span class="params">type</span>)</span>.<span class="keyword">new</span><span class="constructor">Instance(<span class="params">instance</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    return instance;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，dubbo SPI的特性全部解析清楚，剩下一个扩展点自适应机制，该机制逻辑晦涩难懂，这里讲诉篇幅过长，后续再做安排。本章有点啰嗦，后续可能不会这么详细，尽快的覆盖到整个dubbo，再做细致讲解。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> dubbo </tag>
            
            <tag> 源码 </tag>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入JVM探讨一道了争论了七年的面试题</title>
      <link href="/2019/08/11/java/%E6%B7%B1%E5%85%A5JVM%E6%8E%A2%E8%AE%A8%E4%B8%80%E9%81%93%E4%BA%86%E4%BA%89%E8%AE%BA%E4%BA%86%E4%B8%83%E5%B9%B4%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/08/11/java/%E6%B7%B1%E5%85%A5JVM%E6%8E%A2%E8%AE%A8%E4%B8%80%E9%81%93%E4%BA%86%E4%BA%89%E8%AE%BA%E4%BA%86%E4%B8%83%E5%B9%B4%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>经过四天的努力，终于把这道题目搞清楚了，收获很多，一起分享给大家。这道题目是这样的，一位网友在群里发了他的面试题目，然后在群里持续了两天的讨论。引起了我的兴趣。先来看看原题目。<br><img src="/images/java/interview_questions1-1.png" alt="原题"> </p><ol><li>这段代码执行结果？会不会死循环？</li><li>什么问题造成死循环？怎么解决死循环？</li></ol><p>面试官既然都这样问了，肯定是会死循环的。实践下来也的确如此。此时，还有群友提出，在while中，加入 System.out.println();就会跳出循环，类似</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">...</span></span><br><span class="line"><span class="keyword">while</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"far"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="params">...</span></span><br></pre></td></tr></table></figure><p>那么这就更奇怪了，将群内的气氛推向高潮，为什么会有这种玄学？我一开始，也邀请了我们的公司大神一起寻找答案。我们一开始从编译器优化开始，没有找到我们要的答案。后来寄希望于线程可见性，我们一直了解到CPU缓存一致性，就是那几个状态（MESI协议）。也不能合理的解释这个玄学。</p><p>最后得到一丝线索是来自effective java中的一条案例，这本真的是java圣书，每次遇到玄学，我都会先拿出来它。在effective java的第66条中，有举例说到这样一个案例，跟我们的题目很像。<br><img src="/images/java/interview_questions1-2.png" alt="effective java"> </p><p>但是书中并没有给出原因，只是告诉我们，这时一种优化，这种优化称作提升。这正是HotSpot Server VM的工作，然后给出建议是加synchronized或者volatile。这段话好像也没有解决我们的问题，effective java只是抛出了一个问题，就没管了。但是它给我提供了一个关键字HotSpot Server VM。说实话，以前确实没有了解过这个，就抱着试一下的态度上谷歌。第一次认识它，毕竟是新鲜的，这时那个面试题已经不重要了，相对于HotSpot这个新玩物来说，真的不值一提。</p><p>多说一句，多谢R大，国内JVM大牛，也是在他博客中找到这个题目的论证思路。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h4 id="fastdebug版的jdk"><a href="#fastdebug版的jdk" class="headerlink" title="fastdebug版的jdk"></a>fastdebug版的jdk</h4><p>你可以自己根据你使用的jdk版本，自己编译debug版的jdk。<br>我这里也有1.8现成的，也可以自取。主要我压缩的分两卷，请把两卷一起下载解压。<br><a href="https://www.lanzous.com/b894096/" target="_blank" rel="noopener">https://www.lanzous.com/b894096/</a><br>密码:f1ov</p><h4 id="jdk1-6-jdk1-7"><a href="#jdk1-6-jdk1-7" class="headerlink" title="jdk1.6 | jdk1.7"></a>jdk1.6 | jdk1.7</h4><p>下面的可视化（IGV）工具不支持1.8，所以下载一个吧。</p><h4 id="ideal-graph-visualizer（IGV）"><a href="#ideal-graph-visualizer（IGV）" class="headerlink" title="ideal graph visualizer（IGV）"></a>ideal graph visualizer（IGV）</h4><p>将C2（HotSpot Server Compiler）编译方法时内部数据结构的状态，输出可视化。<br>下载地址：<a href="https://www.lanzous.com/i5ixf1c" target="_blank" rel="noopener">https://www.lanzous.com/i5ixf1c</a><br>解压后修改etc下面的idealgraphvisualizer.conf</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdkhome</span>=<span class="string">"$&#123;你jdk1.6的地址&#125;"</span></span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="获取编译时阶段数据"><a href="#获取编译时阶段数据" class="headerlink" title="获取编译时阶段数据"></a>获取编译时阶段数据</h4><p>根据R大所说，验证一个优化是否真的在起作用，可以先获取C2编译时每个阶段内部数据结构的状态，然后用IGV，观察某些优化发生过程。例如我们可以使用-XX:PrintIdealGraphLevel=2 -XX:PrintIdealGraphFile=ideal.xml，将数据输出到ideal.xml文件中。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\fastdebug<span class="number">-1.8</span><span class="number">.0</span><span class="number">.111</span><span class="number">-1</span>\bin&gt;javac LoopTest.java</span><br><span class="line"></span><br><span class="line">D:\fastdebug<span class="number">-1.8</span><span class="number">.0</span><span class="number">.111</span><span class="number">-1</span>\bin&gt;java -XX:PrintIdealGraphLevel=<span class="number">2</span> -XX:PrintIdealGraphFile=ideal.xml LoopTest</span><br></pre></td></tr></table></figure><p>-XX:PrintIdealGraphLevel=2输出的Ideal graph记录。另外，-XX:+PrintOptoAssembly所输出的近似汇编的日志也比真的汇编包含更多上层信息，更便于理解。</p><p>本次编译的ideal记录，可以在此下载，本次分析也仅针对本次编译。<a href="https://www.lanzous.com/i5ktacb" target="_blank" rel="noopener">https://www.lanzous.com/i5ktacb</a></p><p>IGV的主界面显示出C2编译到这个阶段时的中间代码（Intermediate Representation）的图。R大解释：C2所采用的IR是一种名为“Ideal”的静态单赋值（SSA）形式的程序依赖图（Program Dependence Graph）这里我没有过细研究，各位有兴趣的话可以慢慢探索。</p><p>现在获取到编译时每一个阶段的变化，我们就可以用IGV输出可视化分析了，我们主要观察两个阶段After Parsing和Iter GVN 1，如图<br><img src="/images/java/interview_questions1-3.png" alt="IGV"></p><h4 id="After-Parsing"><a href="#After-Parsing" class="headerlink" title="After Parsing"></a>After Parsing</h4><p>After Parsing这个阶段的图。C2编译一个Java方法时，需要先把字节码解析（parse）为C2的IR，然后才可以继续做分析和优化，最终生成代码。“After Parsing”就是C2刚完成parse过程，把这个方法完整的IR图建立好的时候；这个状态代表了C2对要编译的方法的初步认识。</p><p>我们先知道怎么看这张图，我们要知道图中的每一个基本块之间控制流怎么对应我们的java代码，我是这样定位的，大家可以借鉴，先设置节点的显示的内容，输出dump_spec数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[idx] [name]  </span><br><span class="line">[dump_spec]</span><br></pre></td></tr></table></figure><p>回忆本案例中的是否死循环是由一个num变量控制的，而effective java中提到案例解释到C2在编译时会将stopRequested当作循环不变量提升到循环之外，以此来作为优化。那么我们也从num入手肯定是没错的，要论证的就是num的读会不会也像effective java中的stopRequested当作循环不变量来处理。</p><p>我们先定位程序读取num的节点，在IGV右上角搜索Load，我们可以找到两个节点，如下：<br><img src="/images/java/interview_questions1-4.png" alt="IGV"></p><p>我们定位到这两个节点，分别在B2和B12块中，我们可以看到该节点中name就是我们要找的num字段，如下：<br><img src="/images/java/interview_questions1-5.png" alt="IGV"></p><p>现在回到我们的代码，我们的代码中，也有两处读取num的地方，一次是修改num的值，一次是while循环中，刚好对应的上。我们暂且将B2、B12确认为这两处代码。我们现在打开右边工具栏Filters中的“C2 Only Control Flow”<br><img src="/images/java/interview_questions1-6.png" alt="IGV"></p><p>去掉数据流节点，我们先看各个基本块之间的控制流，方便与原本的java代码对应起来。这个图由于比较长就不放图了，在这个例子中我们可以看到。</p><ul><li>B6 是本次编译的入口，main方法入口</li><li>B5 Thread.sleep()</li><li>B4 new Thread()</li><li>B3 Thread.start()</li><li>B13 退出，包含异常退出，代码执行完退出</li><li>B2 代码入口，读取了num的值</li><li>B8、B10 做个标记，loop predicate失败，请求退回到解释器里继续执行，并且未来可能重新编译</li><li>B1、B7、B9 loop predicate相关</li><li>B12 循环的主体</li></ul><p>也就是说在此阶段，完成按照我们代码正常编译，还没有发生类似循环条件被看作循环不变量提升到循环之外的优化，循环体里还保留这那个循环条件。</p><h4 id="Iter-GVN-1"><a href="#Iter-GVN-1" class="headerlink" title="Iter GVN 1"></a>Iter GVN 1</h4><p>我们接下来看下一个阶段Iter GVN 1，此时搜索Load，却发现只有一个结果了<br><img src="/images/java/interview_questions1-7.png" alt="IGV"></p><p>这个Load存在B2中，而之前B12代码块中的Load已经不见了，也就是说此时C2把B12中的num看作与B2中的一致，当作不变量提升到循环外了，便作此优化。</p><p>在IGV里重新回到After Parsing阶段，在当前阶段，对Iter GVN 1右键，选择 Differnce to current graph，可以看到两图之间的差异：<br><img src="/images/java/interview_questions1-8.png" alt="IGV"></p><p>图里红色的节点就是被消除了的节点，虚线的边也是已不复存在的边。B12中的Load是在 Iterative GVN被消除的。至此，无限循环就已经形成了。</p><p>最后R大还输出-XX:+TraceIterativeGVN日志，论证从第二次读取num的值开始，C2如何一步步将B12中的访问num的操作当作B2中的那个的。我在这里卡住了，后续解决了再更新。</p><p>R大原文地址：<a href="https://hllvm-group.iteye.com/group/topic/34932" target="_blank" rel="noopener">https://hllvm-group.iteye.com/group/topic/34932</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> HopSpot </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写dubbo 6-SPI(预热篇)</title>
      <link href="/2019/08/03/java/%E6%89%8B%E5%86%99dubbo%206-SPI(%E9%A2%84%E7%83%AD%E7%AF%87)/"/>
      <url>/2019/08/03/java/%E6%89%8B%E5%86%99dubbo%206-SPI(%E9%A2%84%E7%83%AD%E7%AF%87)/</url>
      
        <content type="html"><![CDATA[<p>博客中代码地址：<a href="https://github.com/farliu/farpc.git" target="_blank" rel="noopener">https://github.com/farliu/farpc.git</a><br><img src="/images/java/dubbo/dubbo_implement_1_1.png" alt="dubbo架构"></p><p>本章不讲述其他SPI博文所说的细节，SPI博文实在太多了。<strong>但你可以在本章了解到SPI作用以及其他博文中没有解释详细的地方</strong>。继续看上面这张图，SPI其实不属于图中的任何一个环节。但是它对dubbo尤为重要，也是非常值得一说的内容。</p><h3 id="dubbo选择SPI背景及作用"><a href="#dubbo选择SPI背景及作用" class="headerlink" title="dubbo选择SPI背景及作用"></a>dubbo选择SPI背景及作用</h3><p>在众多dubbo源码解析的博文，都会将SPI做重点来解说，可见它对dubbo多么重要。那么我们先来了解一下SPI的背景。我在官方的quick start中找到这样一句话。<br><img src="/images/java/dubbo/dubbo_implement_5_1.png" alt="dubbo doc"></p><p>大概的意思就是告诉我们，dubbo可以只依赖JDK，不依赖于任何三方库就可以运行。这其实也是dubbo设计者的一个夙求。</p><p>聊dubbo的SPI之前，我们先聊聊spring，spring最值得吹捧的功能就是IOC。而IOC自然也是整个开发历程的必然产物，因为当众多框架(MVC、ORM)诞生后，肯定是需要有这样一个东西来将多个框架粘合在一次的。而IOC就是这样一个粘合剂，它作为粘合剂实现的方案就是将大家的bean管理在一起，以此达到相互调用。</p><p>那么dubbo设计者不想让dubbo依赖任何第三方库就能运行，难道它就没有IOC这样的需求吗？自然是有的。那么dubbo选择的解决方案就是使用SPI，基于jdk原生的SPI帮助dubbo创建类的对象。那么我们暂且可以将SPI简单的理解为它帮助dubbo初始化对象。</p><p>SPI的作用，我们暂且这么理解了。那么dubbo用它来做了什么呢？我们模拟一下场景，dubbo作为一款优秀的框架，肯定需要适配各样的场景，例如：</p><ol><li>注册中心，用户可以选择zookeeper、redis…</li><li>rpc协议，用户可以选择netty、http…</li><li>负载均衡，用户需要根据自己硬件配置选择负载均衡策略</li></ol><p>这就到了SPI的登场的时候了。dubbo对于需要提供扩展的接口，例如我们上一章的ILoadbalance，使用SPI根据用户的配置初始化对应的实现类。而程序在运行时只需要关注调用对应的接口就行了。</p><h3 id="补充众多SPI博文中没有讲述的"><a href="#补充众多SPI博文中没有讲述的" class="headerlink" title="补充众多SPI博文中没有讲述的"></a>补充众多SPI博文中没有讲述的</h3><p>说SPI，众多博客中都会提到API，简单的说，api是给使用者使用的，spi是给拓展者使用的。这句话没错，但是为什么？<strong>为什么要设计SPI？还有所谓的拓展者是谁？</strong></p><p>从开发能力上说，框架作者能做到的功能，我们普通开发者也一定能做到，只是代码实现优雅，性能略有缺陷。作为一个使用者，肯定会有根据公司产品对某一方面定制化的需求。而dubbo作为一款通用框架，总会有一些什么地方满足不了你定制化的需求，比如说你要根据公司自己的传输协议，传输数据来调用dubbo，这个需求其实很合理。在rpc初级阶段，一些大厂都会自己尝试，就会定义各种自己公司特色的东西，那么dubbo这时肯定不支持。那么这时怎么处理，难道向dubbo开发方pull request?而分支，质量，合并，冲突都会很难管理。</p><p>以上是开发的一个痛点，那么dubbo是怎么解决的呢。他在很多地方使用SPI提供了扩展点，当你有定制化需求时，你可以根据SPI的规范，很容易的将自己定制好的某一个功能插在dubbo运行过程中。比如你要定义一个自己的协议。那么你只需要完成以下几步</p><ol><li>实现org.apache.dubbo.rpc.Protocol。实现定制化需求。</li><li>在resource/META-INF/dubbo，新建名字为org.apache.dubbo.rpc.Protocol的文件。将自己实现的协议维护在里面。<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org<span class="selector-class">.apache</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span>.Protocol：</span><br><span class="line">xxx=com<span class="selector-class">.xxx</span>.XxxProtocol</span><br></pre></td></tr></table></figure></li><li>在dubbo的配置中写上你的协议名字：xxx<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明协议，如果没有配置id，将以name为id --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">id</span>=<span class="string">"xxx1"</span> <span class="attr">name</span>=<span class="string">"xxx"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>那么这个时候可以回答那两个问题。为什么要设计SPI？<strong>设计SPI的目的就是为方便使用者对已有功能进行扩展，满足使用者定制化的需求</strong>。扩展者是谁？<strong>扩展者指的就是我们，当我们需要适配自己定制需求时，可以使用SPI扩展点进行扩展</strong>。</p><p>dubbo扩展点可在官网查看：<a href="http://dubbo.apache.org/zh-cn/docs/dev/impls/protocol.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/dev/impls/protocol.html</a></p><h3 id="SPI简单应用"><a href="#SPI简单应用" class="headerlink" title="SPI简单应用"></a>SPI简单应用</h3><p>本节使用jdk的SPI，尽量说明SPI的作用。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>IWelcome &#123;</span><br><span class="line">    void say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LadyWelcome</span> <span class="keyword">implements</span> <span class="title">IWelcome</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"lady: welcome to SPI."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GentlemenWelcome</span> <span class="keyword">implements</span> <span class="title">IWelcome</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"gentlemen: welcome to SPI."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建文件META-INF/services/com.ofcoder.xxx.IWelcome</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">com</span><span class="selector-class">.ofcoder</span><span class="selector-class">.xxx</span><span class="selector-class">.GentlemenWelcome</span></span><br><span class="line"><span class="selector-tag">com</span><span class="selector-class">.ofcoder</span><span class="selector-class">.xxx</span><span class="selector-class">.LadyWelcome</span></span><br></pre></td></tr></table></figure><p>测试代码，与结果。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Main &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        ServiceLoader&lt;IWelcome&gt; loads = ServiceLoader.<span class="keyword">load</span>(IWelcome.<span class="keyword">class</span>);</span><br><span class="line">        <span class="keyword">for</span> (IWelcome <span class="keyword">load</span> : loads) &#123;</span><br><span class="line">            <span class="keyword">load</span>.say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line">gentlemen: welcome <span class="keyword">to</span> SPI.</span><br><span class="line">lady: welcome <span class="keyword">to</span> SPI.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> dubbo </tag>
            
            <tag> 源码 </tag>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写dubbo 5-服务治理(redis番外篇)</title>
      <link href="/2019/07/14/java/%E6%89%8B%E5%86%99dubbo%205-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86(redis%E7%95%AA%E5%A4%96%E7%AF%87)/"/>
      <url>/2019/07/14/java/%E6%89%8B%E5%86%99dubbo%205-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86(redis%E7%95%AA%E5%A4%96%E7%AF%87)/</url>
      
        <content type="html"><![CDATA[<p>博客中代码地址：<a href="https://github.com/farliu/farpc.git" target="_blank" rel="noopener">https://github.com/farliu/farpc.git</a><br><img src="/images/java/dubbo/dubbo_implement_1_1.png" alt="dubbo架构"></p><p>在上两章中，我们基于zookeeper实现了dubbo的注册中心。本章是作为服务治理的番外篇讲述，对注册中心的另一种实现方案探讨。也为接下来讲述SPI做好铺垫。</p><p>那么本章是基于redis作为存储中间件，实现服务治理，也就是图片中的第1，2，3步，思路跟zookeeper实现方式一致，存储结构也大致相同。使用redis的list类型。想详细了解redis的，请跳转至<a href="https://www.ofcoder.com/2019/05/11/middleware/redis%E5%A6%99%E7%94%A8-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/">redis妙用</a>，这里讲述了redis的各种应用场景，以及将遇到的坑。</p><h3 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h3><p><img src="/images/java/dubbo/dubbo_implement_2_1.png" alt="项目结构"><br>本节涉及博客中代码的module，farpc-registry（服务治理），这章对IRegistrar进行了修改，将init()沉在AbstractRegistrar，在AbstractRegistrar的构造方法中调用init()，防止调用IRegistrar时，忘记调用init()，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">interface</span> <span class="title">IRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>注册服务</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param providerAddress 服务提供者地址</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param service 服务</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    <span class="keyword">void</span> register(<span class="built_in">String</span> providerAddress, <span class="built_in">String</span> service);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> discover(<span class="built_in">String</span> service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> abstract <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistrar</span> <span class="title">implements</span> <span class="title">IRegistrar</span> &#123;</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> FOLDER = <span class="string">"/faregistrys"</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> SEPARATOR = <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractRegistrar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> address = Property.Registry.address;</span><br><span class="line">        init(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">discover</span><span class="params">(<span class="keyword">String</span> service)</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; providers = lookup(service);</span><br><span class="line">        ILoadbalance loadbalance = <span class="keyword">new</span> RoundLoadBalanceImpl();</span><br><span class="line">        <span class="keyword">String</span> select = loadbalance.select(providers);</span><br><span class="line">        <span class="keyword">return</span> select;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> abstract <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">String</span> address)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> abstract List&lt;<span class="keyword">String</span>&gt; <span class="title">lookup</span><span class="params">(<span class="keyword">String</span> service)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redis实现注册中心"><a href="#redis实现注册中心" class="headerlink" title="redis实现注册中心"></a>redis实现注册中心</h3><p>使用redis作为注册中心跟zookeeper的逻辑是一样的，所以这章不会像之前那样一步步推理了，直接铺代码了。我们先依赖maven，我们选择jedis操作redis。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后这里新增了两个类，RedisOparetor、RedisRegistrarImpl，RedisOparetor用来初始化redis连接，RedisRegistrarImpl主要继承AbstractRegistrar来实现IRegistrar。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisOparetor</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(RedisOparetor.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_ACTIVE = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_IDLE = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_WAIT = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> TIMEOUT = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> TEST_ON_BORROW = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool = null;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">String</span> addr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedisPool == null) &#123;</span><br><span class="line">            synchronized (RedisOparetor.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (jedisPool == null) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">String</span>[] split = addr.split(<span class="string">":"</span>);</span><br><span class="line">                        <span class="keyword">String</span> host = split[<span class="number">0</span>];</span><br><span class="line">                        Integer port = Integer.<span class="built_in">parseInt</span>(split[<span class="number">1</span>]);</span><br><span class="line">                        JedisPoolConfig <span class="built_in">config</span> = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">                        <span class="built_in">config</span>.setMaxTotal(MAX_ACTIVE);</span><br><span class="line">                        <span class="built_in">config</span>.setMaxIdle(MAX_IDLE);</span><br><span class="line">                        <span class="built_in">config</span>.setMaxWaitMillis(MAX_WAIT);</span><br><span class="line">                        <span class="built_in">config</span>.setTestOnBorrow(TEST_ON_BORROW);</span><br><span class="line">                        jedisPool = <span class="keyword">new</span> JedisPool(<span class="built_in">config</span>, host, port, TIMEOUT);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        logger.error(e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedisPool != null) &#123;</span><br><span class="line">                Jedis resource = jedisPool.getResource();</span><br><span class="line">                <span class="keyword">return</span> resource;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"call RedisOparetor.getJedis, connection is closed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 释放资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">returnResource</span><span class="params">(<span class="keyword">final</span> Jedis jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != null) &#123;</span><br><span class="line">            jedisPool.returnResource(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class RedisRegistrarImpl extends AbstractRegistrar &#123;</span><br><span class="line"></span><br><span class="line">    public void register(String providerAddress, String service) &#123;</span><br><span class="line">        RedisOparetor.getJedis().lpush(FOLDER + SEPARATOR + service, providerAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void init(String address) &#123;</span><br><span class="line">        RedisOparetor.init(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;String&gt; lookup(String service) &#123;</span><br><span class="line">        List&lt;String&gt; <span class="keyword">lrange</span> = RedisOparetor.getJedis().<span class="keyword">lrange</span>(FOLDER + SEPARATOR + service, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lrange</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">redisTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    IRegistrar registrar = <span class="keyword">new</span> RedisRegistrarImpl();</span><br><span class="line">    registrar.register(<span class="string">"127.0.0.1:20880"</span>, <span class="string">"com.ofcoder.farpc.demo.api.IWelcome"</span>);</span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    IRegistrar registrar = <span class="keyword">new</span> RedisRegistrarImpl();</span><br><span class="line">    System.out.println(registrar.discover(<span class="string">"com.ofcoder.farpc.demo.api.IWelcome"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:20880</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实我没啥好总结的，就是预测一下下一章，下一章讲述的是dubbo值得一吹的SPI。我们使用SPI整合redis、zookeeper。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> dubbo </tag>
            
            <tag> 源码 </tag>
            
            <tag> 服务治理 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分组后取每组的前几</title>
      <link href="/2019/07/14/sql/%E5%88%86%E7%BB%84%E5%90%8E%E5%8F%96%E6%AF%8F%E7%BB%84%E7%9A%84%E5%89%8D%E5%87%A0/"/>
      <url>/2019/07/14/sql/%E5%88%86%E7%BB%84%E5%90%8E%E5%8F%96%E6%AF%8F%E7%BB%84%E7%9A%84%E5%89%8D%E5%87%A0/</url>
      
        <content type="html"><![CDATA[<p>这是一个我遇到的需求啊，要做一个简单的报表。就是找出每一个城市的分数最高的前10。</p><p>首先我第一想到的就是分组，分组之后取前几嘛。但是这有个问题，要说的sql的单值原则。group之后的，对于分组以外的列都必须是明确唯一的，比如你可以group之后，取每组的最大或最小，但是你不能取每组中的一个list。</p><p>首先这个group这个解决方案从一开始就是错的，就导致陷入死胡同。最后解决是通过开窗函数解决，记录一下。</p><h3 id="方案一（推荐）"><a href="#方案一（推荐）" class="headerlink" title="方案一（推荐）"></a>方案一（推荐）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> city,score,<span class="keyword">rank</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> *,</span><br><span class="line"><span class="keyword">IF</span>(@p=city,</span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> @s=score <span class="keyword">THEN</span> @r</span><br><span class="line">        <span class="keyword">WHEN</span> @s:=score <span class="keyword">THEN</span> @r:=@r+<span class="number">1</span></span><br><span class="line">    <span class="keyword">END</span>,</span><br><span class="line">  @r:=<span class="number">1</span> ) <span class="keyword">AS</span> <span class="keyword">rank</span>,</span><br><span class="line">@p:=city,</span><br><span class="line">@s:=score</span><br><span class="line"><span class="keyword">FROM</span> cs,(<span class="keyword">SELECT</span> @p:=<span class="literal">NULL</span>,@s:=<span class="literal">NULL</span>,@r:=<span class="number">0</span>)r</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> city,score <span class="keyword">DESC</span> </span><br><span class="line">)s</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">rank</span> &lt;<span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> cs c</span><br><span class="line"><span class="keyword">WHERE</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">count</span>(*) <span class="keyword">FROM</span> cs</span><br><span class="line">    <span class="keyword">WHERE</span> city=c.city <span class="keyword">AND</span> score&gt;c.score )&lt;<span class="number">10</span></span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> city,score <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 芝士点心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写dubbo 4-服务治理(服务发现-zookeeper)</title>
      <link href="/2019/07/08/java/%E6%89%8B%E5%86%99dubbo%204-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86(%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-zookeeper)/"/>
      <url>/2019/07/08/java/%E6%89%8B%E5%86%99dubbo%204-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86(%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0-zookeeper)/</url>
      
        <content type="html"><![CDATA[<p>博客中代码地址：<a href="https://github.com/farliu/farpc.git" target="_blank" rel="noopener">https://github.com/farliu/farpc.git</a><br><img src="/images/java/dubbo/dubbo_implement_1_1.png" alt="dubbo架构"></p><p>本文实现的是服务的发现，也就是图片中的第2，3步，经过上一章的服务注册，对于服务发现我们只需要从zookeeper中取得对应的provider就行了。</p><h3 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h3><p><img src="/images/java/dubbo/dubbo_implement_2_1.png" alt="项目结构"></p><p>本节涉及博客中代码的两个module，farpc-registry（服务治理）、farpc-cluster（集群管理）。</p><p>在上一章的基础上，我们扩展IRegistrar接口，增加discover方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">interface</span> <span class="title">IRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>初始化</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param registerAddress zookeeper地址，例如127.0.0.1:2181</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    <span class="keyword">void</span> init(<span class="built_in">String</span> registerAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>注册服务</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param providerAddress 服务提供者地址</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param service 服务</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    <span class="keyword">void</span> register(<span class="built_in">String</span> providerAddress, <span class="built_in">String</span> service);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">String</span> discover(<span class="built_in">String</span> service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>farpc-cluster同样提供类似的接口ILoadbalance。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>ILoadbalance &#123;</span><br><span class="line"></span><br><span class="line">    String select(List&lt;String&gt; providers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>基于上一章的代码，zookeeper的连接已经在init方法中初始化了。那么本节要实现的服务发现就是，从zookeeper取得某一个服务下的所有节点，也就是provider。一起来看看代码怎么写。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> SEPARATOR = <span class="string">"/"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> FOLDER = <span class="string">"/faregistrys"</span>;</span><br><span class="line"><span class="keyword">private</span> Map&lt;<span class="keyword">String</span>, List&lt;<span class="keyword">String</span>&gt;&gt; serviceProviderMap = <span class="keyword">new</span> HashMap&lt;<span class="keyword">String</span>, List&lt;<span class="keyword">String</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">discover</span><span class="params">(<span class="keyword">String</span> service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">String</span> path = FOLDER + SEPARATOR + service;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// ---- 1</span></span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; provider = curatorFramework.getChildren().forPath(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 2</span></span><br><span class="line">        serviceProviderMap.<span class="built_in">put</span>(service, provider);</span><br><span class="line"></span><br><span class="line">        watchProvider(path);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> serviceProviderMap.<span class="built_in">get</span>(service).<span class="built_in">get</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="keyword">String</span>.format(<span class="string">"call ZookeeperRegistrarImpl.discover, occur exception, service:[%s], e.getMessage:[%s]"</span>, service, e.getMessage()), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">watchProvider</span><span class="params">(<span class="keyword">final</span> <span class="keyword">String</span> path)</span> </span>&#123;</span><br><span class="line">        PathChildrenCache childrenCache = <span class="keyword">new</span> PathChildrenCache(curatorFramework, path, <span class="literal">true</span>);</span><br><span class="line">        PathChildrenCacheListener listener = <span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> childEvent(CuratorFramework curatorFramework, PathChildrenCacheEvent pathChildrenCacheEvent) throws Exception &#123;</span><br><span class="line">                <span class="comment">//提供者有更新，则及时更新到内存中</span></span><br><span class="line">                serviceProviderMap.<span class="built_in">put</span>(path, curatorFramework.getChildren().forPath(path));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        childrenCache.getListenable().addListener(listener);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            childrenCache.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务发现的代码也很简单，就是从zookeeper中根据服务取到provider，这里没有做负载均衡，所以始终返回第一个。继续解析一下要注意的地方。</p><p>第一点，返回的是一个list，是因为某一个节点路径下肯定是存在多个节点的，也就意味着某一个服务应该有多个provider。</p><p>第二点，使用一个map保存，是为了监听zookeeper中provider的变化，也就是watchProvider()方法，给指定的路径添加监听器，当有更新时，更新map中的信息。而这里就是zookeeper提供的监听机制。达到服务动态发现的效果。</p><p>同样的我们测试一下代码，记得要先注册服务</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ConsumerTest</span> &#123;</span><br><span class="line">    @Test</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> test() throws IOException &#123;</span><br><span class="line">        IRegistrar registrar = new ZookeeperRegistrarImpl();</span><br><span class="line">        registrar.init(<span class="string">"127.0.0.1:2181"</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(registrar.discover(<span class="string">"com.ofcoder.farpc.demo.api.IWelcome"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">20880</span></span><br></pre></td></tr></table></figure><p>正确输出zookeeper中管理服务提供者地址。那么基于zookeeper的服务发现也就实现了。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>在文中一直有提到，从注册中心拿到的是一个list的provider，那么我们需要做一个类似负载均衡的东西，也就是从众多的provider中，取其中一个来真正调用。这里提供两种方式。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机取其中一个</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadbalanceImpl</span> <span class="title">implements</span> <span class="title">ILoadbalance</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">select</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; providers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = providers.<span class="built_in">size</span>();</span><br><span class="line">        Random <span class="built_in">random</span> = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> lucky = <span class="built_in">random</span>.nextInt(len);</span><br><span class="line">        <span class="keyword">return</span> providers.<span class="built_in">get</span>(lucky);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个个的遍历取</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundLoadBalanceImpl</span> <span class="title">implements</span> <span class="title">ILoadbalance</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger previous = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">select</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; providers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = providers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (previous.<span class="built_in">get</span>() &gt;= <span class="built_in">size</span>) &#123;</span><br><span class="line">            previous.<span class="built_in">set</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">String</span> provider = providers.<span class="built_in">get</span>(previous.<span class="built_in">get</span>());</span><br><span class="line">        previous.<span class="built_in">set</span>(previous.<span class="built_in">get</span>() + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么使用的话，我新建了一个抽象类实现IRegistrar，来完成负载均衡.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractRegistrar</span> <span class="keyword">implements</span> <span class="title">IRegistrar</span> </span>&#123;</span><br><span class="line">    public <span class="built_in">String</span> discover(<span class="built_in">String</span> service) &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; providers = lookup(service);</span><br><span class="line">        ILoadbalance loadbalance = <span class="keyword">new</span> RoundLoadBalanceImpl();</span><br><span class="line">        <span class="built_in">String</span> select = loadbalance.select(providers);</span><br><span class="line">        <span class="keyword">return</span> select;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">abstract</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; lookup(<span class="built_in">String</span> service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将之前ZookeeperRegistrarImpl实现AbstractRegistrar，在lookup中完成之前实现的服务发现。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistrarImpl</span> <span class="title">extends</span> <span class="title">AbstractRegistrar</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ZookeeperRegistrarImpl.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_TIMEOUT_MS = <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SLEEP_TIME_MS = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RETRIES = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> SEPARATOR = <span class="string">"/"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> FOLDER = <span class="string">"/faregistrys"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;<span class="keyword">String</span>, List&lt;<span class="keyword">String</span>&gt;&gt; serviceProviderMap = <span class="keyword">new</span> HashMap&lt;<span class="keyword">String</span>, List&lt;<span class="keyword">String</span>&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> CuratorFramework curatorFramework;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; <span class="title">lookup</span><span class="params">(<span class="keyword">String</span> service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> path = FOLDER + SEPARATOR + service;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;<span class="keyword">String</span>&gt; provider = curatorFramework.getChildren().forPath(path);</span><br><span class="line">            serviceProviderMap.<span class="built_in">put</span>(service, provider);</span><br><span class="line"></span><br><span class="line">            watchProvider(path);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> serviceProviderMap.<span class="built_in">get</span>(service);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="keyword">String</span>.format(<span class="string">"call ZookeeperRegistrarImpl.discover, occur exception, service:[%s], e.getMessage:[%s]"</span>, service, e.getMessage()), e);</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">watchProvider</span><span class="params">(<span class="keyword">final</span> <span class="keyword">String</span> path)</span> </span>&#123;</span><br><span class="line">        PathChildrenCache childrenCache = <span class="keyword">new</span> PathChildrenCache(curatorFramework, path, <span class="literal">true</span>);</span><br><span class="line">        PathChildrenCacheListener listener = <span class="keyword">new</span> PathChildrenCacheListener() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> childEvent(CuratorFramework curatorFramework, PathChildrenCacheEvent pathChildrenCacheEvent) throws Exception &#123;</span><br><span class="line">                <span class="comment">//提供者有更新，则及时更新到内存中</span></span><br><span class="line">                serviceProviderMap.<span class="built_in">put</span>(path, curatorFramework.getChildren().forPath(path));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        childrenCache.getListenable().addListener(listener);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            childrenCache.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上则为服务发现的所有代码，意在模拟dubbo，而不是照抄dubbo，希望可以帮助大家对dubbo服务治理有一定的了解。</p><h3 id="dubbo源码"><a href="#dubbo源码" class="headerlink" title="dubbo源码"></a>dubbo源码</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">ZookeeperRegistry.doSubscribe()</span><br><span class="line">public <span class="keyword">void</span> doSubscribe(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">            <span class="built_in">String</span> root = toRootPath();</span><br><span class="line">            ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.<span class="keyword">get</span>(url);</span><br><span class="line">            <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                zkListeners.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">                listeners = zkListeners.<span class="keyword">get</span>(url);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// ------------ 1</span></span><br><span class="line">            ChildListener zkListener = listeners.<span class="keyword">get</span>(listener);</span><br><span class="line">            <span class="keyword">if</span> (zkListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">                listeners.putIfAbsent(listener, (parentPath, currentChilds) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">String</span> child : currentChilds) &#123;</span><br><span class="line">                        child = URL.decode(child);</span><br><span class="line">                        <span class="keyword">if</span> (!anyServices.contains(child)) &#123;</span><br><span class="line">                            anyServices.add(child);</span><br><span class="line">                            subscribe(url.setPath(child).addParameters(INTERFACE_KEY, child,</span><br><span class="line">                                    Constants.CHECK_KEY, <span class="built_in">String</span>.valueOf(<span class="keyword">false</span>)), listener);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                zkListener = listeners.<span class="keyword">get</span>(listener);</span><br><span class="line">            &#125;</span><br><span class="line">           ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ZookeeperRegistry.lookup()</span><br><span class="line">public <span class="built_in">List</span>&lt;URL&gt; lookup(URL url) &#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"lookup url == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; providers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">String</span> path : toCategoriesPath(url)) &#123;</span><br><span class="line"><span class="comment">// ------------ 2</span></span><br><span class="line">            <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; children = zkClient.getChildren(path);</span><br><span class="line">            <span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123;</span><br><span class="line">                providers.addAll(children);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> toUrlsWithoutEmpty(url, providers);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to lookup "</span> + url + <span class="string">" from zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中标注的1，2点，是不是也看到了我们的代码影子，第一点使用zookeeper的监听器，第二点根据url获得一个list的provider。只是dubbo获取的方式不一样而已。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> dubbo </tag>
            
            <tag> 源码 </tag>
            
            <tag> 服务治理 </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写dubbo 3-服务治理(服务注册-zookeeper)</title>
      <link href="/2019/07/02/java/%E6%89%8B%E5%86%99dubbo%203-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86(%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C-zookeeper)/"/>
      <url>/2019/07/02/java/%E6%89%8B%E5%86%99dubbo%203-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86(%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C-zookeeper)/</url>
      
        <content type="html"><![CDATA[<p>博客中代码地址：<a href="https://github.com/farliu/farpc.git" target="_blank" rel="noopener">https://github.com/farliu/farpc.git</a><br><img src="/images/java/dubbo/dubbo_implement_1_1.png" alt="dubbo架构"></p><p>在前两章，铺垫的已经够多了，本章我们来看看具体如何基于zookeeper实现服务注册，show you my code.</p><h3 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h3><p><img src="/images/java/dubbo/dubbo_implement_2_1.png" alt="项目结构"></p><p>本节涉及博客中代码的module：farpc-registry（服务治理）。</p><p>farpc-registry秉承可扩展的设计思路，提供一个接口IRegistrar。统一规范管理注册中心的实现方式。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">interface</span> <span class="title">IRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>初始化</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param registerAddress zookeeper地址，例如127.0.0.1:2181</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    <span class="keyword">void</span> init(<span class="built_in">String</span> registerAddress);</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>注册服务</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param providerAddress 服务提供者地址</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param service 服务</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    <span class="keyword">void</span> register(<span class="built_in">String</span> providerAddress, <span class="built_in">String</span> service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化zookeeper"><a href="#初始化zookeeper" class="headerlink" title="初始化zookeeper"></a>初始化zookeeper</h3><p>本章使用zookeeper实现实现注册中心，首先要解决的就是程序如何使用zookeeper，这里选择curator操作zookeeper。那么先依赖maven。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里实现IRegistrar接口，分别介绍实现的两个方法，第一个初始化zookeeper的连接。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_TIMEOUT_MS = <span class="number">5000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SLEEP_TIME_MS = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RETRIES = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">String</span> registerAddress)</span></span>&#123;</span><br><span class="line">    curatorFramework = CuratorFrameworkFactory.builder()</span><br><span class="line">            .connectString(registerAddress)</span><br><span class="line">            .sessionTimeoutMs(SESSION_TIMEOUT_MS)</span><br><span class="line">            .retryPolicy(<span class="keyword">new</span> ExponentialBackoffRetry(SLEEP_TIME_MS, MAX_RETRIES))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    curatorFramework.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>服务注册，说到底就是在zookeeper中创建一个个的目录节点，由这一个个的节点来充当服务和服务提供者。代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> SEPARATOR = <span class="string">"/"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> FOLDER = <span class="string">"/faregistrys"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">String</span> providerAddress, <span class="keyword">String</span> service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">String</span> servicePath = FOLDER + SEPARATOR + service;</span><br><span class="line">        Stat stat = curatorFramework.checkExists().forPath(servicePath);</span><br><span class="line">        <span class="keyword">if</span> (stat == null) &#123;   <span class="comment">// ----- 1</span></span><br><span class="line"><span class="comment">//  ---  2</span></span><br><span class="line">            curatorFramework.create().creatingParentsIfNeeded()</span><br><span class="line">                    .withMode(CreateMode.PERSISTENT).forPath(servicePath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">String</span> provider = servicePath + SEPARATOR + providerAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 3</span></span><br><span class="line">        curatorFramework.create().withMode(CreateMode.EPHEMERAL)</span><br><span class="line">                .forPath(provider);</span><br><span class="line">        logger.info(<span class="string">"provider:&#123;&#125; is registered to &#123;&#125;"</span>, providerAddress, servicePath);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 假如我们要注册的服务为：com.ofcoder.farpc.demo.api.IWelcome。分别解析代码中所标注的1、2、3点。</p><p>第一点，就是判断/faregistrys/com.ofcoder.farpc.demo.api.IWelcome该目录是否存在，存在则不创建，因为我们有提到过，zookeeper中目录路径是唯一的。再创建会报错的昂。这里多说一句，你应该使用double-check-lock。</p><p>第二点和第三点，都是创建，不同的区别在于，CreateMode不同，分别传入的参数是<strong>PERSISTENT（永久）、EPHEMERAL（临时）</strong>。provider的信息为什么要设置成临时的。是因为，服务在注册后可以永久生效。但是provider可能因为发版或者服务宕机导致服务不可用，而这时它不应该存在该服务的provider列表中。设置为EPHEMERAL，当你的服务宕机时，zookeeper将自动移除掉这个路径。以此达到服务的<strong>动态注册和发现</strong></p><p>那么我们测试一下代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderTest</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> throws IOException </span>&#123;</span><br><span class="line">        IRegistrar registrar = <span class="keyword">new</span> ZookeeperRegistrarImpl();</span><br><span class="line">        registrar.init(<span class="string">"127.0.0.1:2181"</span>);</span><br><span class="line">        registrar.<span class="keyword">register</span>(<span class="string">"127.0.0.1:20880"</span>, <span class="string">"com.ofcoder.farpc.demo.api.IWelcome"</span>);</span><br><span class="line">        System.in.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开zookeeper客户端验证。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">6</span>] ls /faregistrys</span><br><span class="line">[com.ofcoder.farpc.demo.api.IWelcome]</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">7</span>] ls /faregistrys/com.ofcoder.farpc.demo.api.IWelcome</span><br><span class="line">[<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">20880</span>]</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">8</span>]</span><br></pre></td></tr></table></figure><h3 id="dubbo源码"><a href="#dubbo源码" class="headerlink" title="dubbo源码"></a>dubbo源码</h3><p>dubbo源码很容易找，我都是直接使用dubbo命名，我们可以在dubbo-registry找到对应的代码，可对比我们所实现的代码，肯定是有很多共性的。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">ZookeeperRegistry</span>.</span></span><span class="keyword">do</span><span class="constructor">Register()</span></span><br><span class="line">public void <span class="keyword">do</span><span class="constructor">Register(URL <span class="params">url</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        zkClient.create(<span class="keyword">to</span><span class="constructor">UrlPath(<span class="params">url</span>)</span>, url.get<span class="constructor">Parameter(DYNAMIC_KEY, <span class="params">true</span>)</span>);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">RpcException(<span class="string">"Failed to register "</span> + <span class="params">url</span> + <span class="string">" to zookeeper "</span> + <span class="params">getUrl</span>()</span> + <span class="string">", cause: "</span> + e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">AbstractZookeeperClient</span>.</span></span>create<span class="literal">()</span></span><br><span class="line">public void create(String path, boolean ephemeral) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ephemeral) &#123;</span><br><span class="line"><span class="comment">// 不存在则创建</span></span><br><span class="line">        <span class="keyword">if</span> (check<span class="constructor">Exists(<span class="params">path</span>)</span>) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> i = path.last<span class="constructor">IndexOf('<span class="operator">/</span>')</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        create(path.substring(<span class="number">0</span>, i), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ephemeral) &#123;</span><br><span class="line">        create<span class="constructor">Ephemeral(<span class="params">path</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        create<span class="constructor">Persistent(<span class="params">path</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上为服务注册的代码，是不是有跟我们逻辑一样的代码，例如：服务节点不存在则创建。而我们也同样找到了创建永久目录节点和临时目录节点的代码，createEphemeral(path);和 createPersistent(path);</p><p>我们还可以，可以在zookeeper的客户端，找到dubbo存储结构。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">4</span>] ls /dubbo/com.ofcoder.farpc.demo.api.IWelcome</span><br><span class="line">[consumers, configurators, routers, providers]</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">5</span>] ls /dubbo/com.ofcoder.farpc.demo.api.IWelcome/providers</span><br><span class="line">[dubbo%<span class="number">3</span>a%<span class="number">2f</span>%<span class="number">2f</span>127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span>%<span class="number">3</span>a20880%<span class="number">2f</span>com.ofcoder.farpc.demo.api.IWelcome%<span class="number">3f</span>anyhost%<span class="number">3</span>dtrue%<span class="number">26</span>application%<span class="number">3</span>ddubbo-demo%<span class="number">26</span><span class="keyword">default</span>.delay%<span class="number">3</span>d<span class="number">-1</span>%<span class="number">26</span><span class="keyword">default</span>.loadbalance%<span class="number">3</span>dleastactive%<span class="number">26</span><span class="keyword">default</span>.retries%<span class="number">3</span>d2%<span class="number">26</span><span class="keyword">default</span>.threadpool%<span class="number">3</span>dfixed%<span class="number">26</span><span class="keyword">default</span>.threads%<span class="number">3</span>d500%<span class="number">26</span><span class="keyword">default</span>.timeout%<span class="number">3</span>d5000%<span class="number">26</span>delay%<span class="number">3</span>d<span class="number">-1</span>%<span class="number">26</span>dubbo%<span class="number">3</span>d2<span class="number">.6</span><span class="number">.0</span>%<span class="number">26</span>generic%<span class="number">3</span>dfalse%<span class="number">26</span><span class="keyword">interface</span>%<span class="number">3</span>dcom.ofcoder.farpc.demo.api.IWelcome%<span class="number">26</span>methods%<span class="number">3</span>dgreet%<span class="number">26</span>organization%<span class="number">3</span>ddemo%<span class="number">26</span>owner%<span class="number">3</span>dofcoder%<span class="number">26</span>pid%<span class="number">3</span>d23541%<span class="number">26</span>revision%<span class="number">3</span>d0<span class="number">.0</span><span class="number">.1</span>-SNAPSHOT%<span class="number">26</span>side%<span class="number">3</span>dprovider%<span class="number">26</span>timestamp%<span class="number">3</span>d1561962179716]</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">6</span>]</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是zookeeper服务注册的一个实现。感觉写博客，直接贴代码是最傻的。但是又不知道如何表达我想说的，希望后面可以找到一个讲述清楚的方式吧。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> dubbo </tag>
            
            <tag> 源码 </tag>
            
            <tag> 服务治理 </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写dubbo 2-服务治理(zookeeper探讨)</title>
      <link href="/2019/06/29/java/%E6%89%8B%E5%86%99dubbo%202-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86(zookeeper%E6%8E%A2%E8%AE%A8)/"/>
      <url>/2019/06/29/java/%E6%89%8B%E5%86%99dubbo%202-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86(zookeeper%E6%8E%A2%E8%AE%A8)/</url>
      
        <content type="html"><![CDATA[<p>博客中代码地址：<a href="https://github.com/farliu/farpc.git" target="_blank" rel="noopener">https://github.com/farliu/farpc.git</a><br><img src="/images/java/dubbo/dubbo_implement_1_1.png" alt="dubbo架构"></p><p>开始进入主题，本文主要介绍的是服务的注册和发现，也就是图片中的第1，2，3步，既然要实现服务治理，那么我们需要一个统一管理服务东西，也就是注册中心。我们需要选择的注册中心是zookeeper。<br>这里多说一句，图中的2，3很明显是分两步来处理。如果只是从注册中心拿到provider而已，那为什么要分两步呢？而且我所认识的单词也有限，要是我取名的话我可能会给它取名叫做get、return。那它为什么要叫subscribe、notify呢？这里是为了多个服务的动态发现。当你有一个provider宕机的时候，zookeeper肯定不能给一个宕机的provider给你，那么这时就需要notify了，而不get。我不知道我说清楚没。这里可以等看完本章内容后，再细细思考。</p><h3 id="分析实现方案"><a href="#分析实现方案" class="headerlink" title="分析实现方案"></a>分析实现方案</h3><p>按照开发惯例，先确定实现方案。要实现服务注册和发现，就相当于管理服务，管理意味着存储，我们可以先确定存储服务的结构。</p><p>假如现在有一个服务为Dog.walk()，我们尝试使用Map来管理它，例如Map&lt;service, provider&gt;，当服务端启动时，将自己所有的服务put到这个Map中，consumer要使用某一个服务时，只需从这个Map中get就可以拿到provider对象，而这个provider对象是什么样的数据呢？我们只需要保存consumer连接provider的数据就行了，例如ip+port。事实上，dubbo保存的数据还不止这些，包括超时时间、是否异步调用等。</p><p>听起来好像上述完全可以解决我们的服务治理的功能。但是这只是对于单个provider来说。假如每一个服务有多个provider，那么我们需要对Map进行改变一下，例如Map&lt;service, List<provider>&gt;。consumer在获得provider的时候，拿到一个list，然后可以根据不同的负载均衡取得具体的provider。</p><p>这一切听起来很完美。不管我们接下来的实现方式是使用Map或者zookeeper，又或者是redis，只要是能按照以上存储结构都能实现我们需求。事实上dubbo也是这样干的。</p><h3 id="zookeeper介绍"><a href="#zookeeper介绍" class="headerlink" title="zookeeper介绍"></a>zookeeper介绍</h3><p>这里简单说一下zookeeper的三个特性，因为我们都要用到。三个特性包含：存储结构、临时节点，监听器，也正因为这三个特性，zookeeper才多了许多玩法。比如可以用来做：统一配置管理、统一命名服务、分布式锁、集群管理。</p><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>zookeeper的存储结构，zookeeper中管理的是一个类似文件目录的树。它是一层一层目录结构，每一个文件夹都是一个znode，如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">1</span>] ls /</span><br><span class="line">[zookeeper, faregistrys]</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">2</span>] ls /faregistrys</span><br><span class="line">[com<span class="selector-class">.ofcoder</span><span class="selector-class">.farpc</span><span class="selector-class">.demo</span><span class="selector-class">.api</span>.IWelcome]</span><br><span class="line">[zk: localhost:<span class="number">2181</span>(CONNECTED) <span class="number">3</span>] ls /faregistrys/com<span class="selector-class">.ofcoder</span><span class="selector-class">.farpc</span><span class="selector-class">.demo</span><span class="selector-class">.api</span>.IWelcome</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>zookeeper的根节点路径为/，ls是列出该路径下的所有的节点。上述zookeeper存储的结构用图表示可能更能理解，如下<br><img src="/images/java/dubbo/dubbo_implement_2_2.png" alt="zk存储结构"><br>这也是为什么zookeeper可以做为分布式锁的原因，因为目录路径只会存在唯一。每一次新建一个节点就相当于获得锁。这个后续会在另外的文章中讲述。</p><h4 id="临时节点"><a href="#临时节点" class="headerlink" title="临时节点"></a>临时节点</h4><p>其中zookeeper，它区分为临时节点（EPHEMERAL）和永久节点（PERSISTENT）。dubbo使用它来管理provider。</p><ul><li>短暂/临时(Ephemeral)：当客户端和服务端断开连接后，所创建的Znode(节点)会自动删除</li><li>临时顺序编号目录节点(EPHEMERAL_SEQUENTIAL)：客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</li><li>持久(Persistent)：当客户端和服务端断开连接后，所创建的Znode(节点)不会删除</li><li>持久化顺序编号目录节点(PERSISTENT_SEQUENTIAL)：客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</li></ul><h4 id="监听机制"><a href="#监听机制" class="headerlink" title="监听机制"></a>监听机制</h4><p>我们已经简单知道了zoKeeper的数据结构了，zooKeeper还配合了监听器才能够做那么多事的。客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。例如：集群管理。</p><p>集群管理无非在乎两点：机器的加入和退出。所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都会收到通知：某个兄弟目录被删除。对于机器加入也是一样。</p><h3 id="dubbo如何使用zookeeper作为注册中心"><a href="#dubbo如何使用zookeeper作为注册中心" class="headerlink" title="dubbo如何使用zookeeper作为注册中心"></a>dubbo如何使用zookeeper作为注册中心</h3><p>了解了zookeeper的特性，我们现在就可以确定如何用它来完成注册中心的功能，这里我们借鉴dubbo。</p><p>dubbo在使用zookeeper作为注册中心时。它将<strong>每一个服务作为一个节点，服务的provider作为该节点的子节点</strong>。这个结构相当于之前所说的Map&lt;service, List<provider>&gt;。其provider的节点为临时节点。当provider宕机或者断开zookeeper连接时，该节点也将销毁。</p><p>dubbo的consumer，使用zookeeper的监听机制，监听所有服务的节点，当某一个服务下的子节点也更新或者删除时，dubbo的consumer能及时收到信息，并更新provider列表。</p>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> dubbo </tag>
            
            <tag> 源码 </tag>
            
            <tag> 服务治理 </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写dubbo 1-基本原理</title>
      <link href="/2019/06/26/java/%E6%89%8B%E5%86%99dubbo%201-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2019/06/26/java/%E6%89%8B%E5%86%99dubbo%201-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>本系列，原本由之前挖的坑，现在来填。之间在讲述动态代理，谈及mybatis、dubbo的源码，大家也可以前往了解，<a href="https://www.ofcoder.com/2019/04/09/java/%E8%B0%88%E8%B0%88mybatis%E3%80%81dubbo%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/">点击查看</a>。手写dubbo，是为了更好的理解dubbo源码原理，顺便和大家一起看看dubbo实现过程。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>本系列博客，主要实现dubbo的服务调用，基于<strong>netty/http+zookeeper/redis</strong>。所以你有必要准备zookeeper和redis的环境。这个自行百度，这里讲述毫无意义。<br>毕竟是剖析dubbo源码，建议大家还是有必要将源码下载下来阅读一下，以及本博客中所有代码，可以通过下面链接下载。</p><ul><li>博客中代码<br><a href="https://github.com/farliu/farpc.git" target="_blank" rel="noopener">https://github.com/farliu/farpc.git</a></li><li>dubbo源码<br><a href="https://github.com/apache/dubbo.git" target="_blank" rel="noopener">https://github.com/apache/dubbo.git</a></li></ul><h3 id="dubbo介绍"><a href="#dubbo介绍" class="headerlink" title="dubbo介绍"></a>dubbo介绍</h3><p>Apache Dubbo |ˈdʌbəʊ| is a high-performance, light weight, java based RPC framework. Dubbo offers three key functionalities, which include <strong>interface based remote call, fault tolerance &amp; load balancing, and automatic service registration &amp; discovery</strong>.</p><p>这段介绍来自dubbo官网，打开官网就能看到，我认识的单词也不多，就把认识的标粗了。它告诉我们dubbo实现了三个功能</p><ol><li>远程接口调用</li><li>容错和负载均衡</li><li>服务自动注册和发现</li></ol><p>那么我们手写dubbo的话，自然也要实现官网中介绍的三个功能，也就是本系列博客的重点。与之对应的，官网还提供了一张图，描述了这个三功能如何配合使用的。如下</p><p><img src="/images/java/dubbo/dubbo_implement_1_1.png" alt="dubbo架构"></p><p>简单看一下这张图，provider在registry中注册自己的服务，consumer从register中subscribe服务。consumer拿到服务后，直接invoke对应的provider。其中dubbo还提供监控的功能，也就是monitor。那么我们接下来顺着这张图揣测一下dubbo三个功能的原理</p><h3 id="揣测dubbo原理"><a href="#揣测dubbo原理" class="headerlink" title="揣测dubbo原理"></a>揣测dubbo原理</h3><p>先回顾一下dubbo的诞生的场景。dubbo作为一款分布式服务治理框架，这是没有异议的。它帮助我们完成了应用之间的调用。那么在没有它之前我们想在两个系统之间调用对方的服务是怎么做的呢？</p><p>从单体应用系统开始说，我们现在有两个类Person、Dog，假如我们需要Person的对象调用Dog中walk()方法。那么我们的做法肯定都是new Dog().walk();。这个已经是习以为常的了，没什么好说的，但是我们为什么能new一个Dog对象，因为在我们系统中存在Dog的class文件，我们才能new。那么假如这两个类存在于两个系统中，它们需要互相调用，我们是怎么做的呢？存在以下两种解决方案</p><ol><li>A(provider)应用提供jar供B(consumer)应用调用，此时A应用的class文件会加载到B系统中，B可以直接new出A的对象。</li><li>通过网络调用，B(consumer)应用通过网络告诉A(provider)要调用那个方法，A调用完后将结果返回给B。</li></ol><p>第一种方案，没什么好说的。而dubbo也就是第二中方案的实现框架。那么一起来猜测一下dubbo怎么做到调用本方法那样去调用远程服务的。</p><h4 id="远程接口调用"><a href="#远程接口调用" class="headerlink" title="远程接口调用"></a>远程接口调用</h4><p>作为一款rpc框架，主要任务就是远程调用，那么我们从这里入手肯定是没错的。现在需求是A系统提供一个服务供B系统调用。那我们先确认两个概念，A也就是provider，B为consumer，那么一个个的来分析。</p><p>作为provider需要给别人提供服务，肯定是要给别人调用的。比如我们写的restful接口，别人使用http来调用我们的接口，那么作为provider我们也需要这样的程序。这里我们可以选择tomcat提供http协议的服务，也可以通过socket供客户端来连接。不管怎么样，这两种实现方式肯定是可以供consumer调用的。</p><p>provider提供调用的服务，我们可以解决了，那么客户端调用过来时候，provider怎么知道要执行哪个方法呢？这是你可能会想这个可以由consumer在调用时传几个参数告诉provider。对的。事实上dubbo也确实是这样做的，它会传输类似以下对象的数据给provider</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> clazz;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> method;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> types;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">String</span> params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，怎么调用解决了，要调用哪个服务也解决了，那么这时由provider通过反射执行对应方法。至此，我觉得provider的实现方式，这个方案是可行的。<br>接下来看consumer，consumer要做的事情就是调用provider的服务，如果provider提供的是http接口，那么我就通过httpClient来调用；如果provider提供的socket，那么就用socket来连接，这都是可以实现的。但是会存在一个问题，就是我们在调用是写HttpClient代码调用时，对不起，哥们，我觉得我是在调用服务端代码，这不是我想要的。而这时dubbo提供的解决方案就是动态代理，consumer像调用本地方法那样去调用某一个服务，由代理类去完成远程调用的过程。</p><p><strong>小小的总结一下，dubbo远程调用，由consumer在代理类中通过http/socket去调用provider提供的服务。</strong></p><h4 id="服务自动注册和发现"><a href="#服务自动注册和发现" class="headerlink" title="服务自动注册和发现"></a>服务自动注册和发现</h4><p>服务自动注册和发现，也就是图中registry。consumer需要去远程调用provider，那么肯定是要有一个ip和端口号的，要不然你怎么调用。当provider提供的服务比较多，或者同一个服务有多个provider时，它们都分别有自己的ip和端口号，那么consumer怎么去维护呢？这时注册中就显得尤为重要。</p><p>那么dubbo的注册和发现是怎么做的呢？其实要完成上面的需要，我们是不是只要有一个统一管理的地方就行了，对不对。最不济我弄一个Map&lt;service, provider&gt;，这样把它存下来就好了，provider启动时往这个map里put服务当作服务注册的过程，consumer要使用时，到这个map中取就好了。</p><p>上面的方案是可以实现的，但是dubbo提供的解决方案是zookeeper/redis，但是它们中间存储的数据结构类似Map中的数据，只是存储数据的载体不是Map而已，这个我们在写代码中会得以体现。</p><h4 id="容错和负载均衡"><a href="#容错和负载均衡" class="headerlink" title="容错和负载均衡"></a>容错和负载均衡</h4><p>博客中实现的负载均衡，只是从众多的provider中简单的random一个出来，其余的负载均衡选择算法，可以参照dubbo源码实现。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>根据我们上面的推理，dubbo原理总结为：provider提供服务，这个服务可以是<strong>http/socket</strong>，给consumer来调用，然后通过<strong>反射</strong>的方式执行对应的方法，将结果返回给consumer。为了让这个过程无感知，consumer使用<strong>动态代理</strong>的过程，完成调用过程。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ol><li>手写dubbo框架1-基本原理</li><li>手写dubbo框架2-服务治理和发现<br>2.1 分布式锁（redis+zookeeper）</li><li>手写dubbo框架3-spi治理redis和zk<br>3.1 spi详解</li><li>手写dubbo框架4-远程调用\动态代理（netty+http）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码狂想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> dubbo </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis妙用-zset类型</title>
      <link href="/2019/05/29/middleware/redis%E5%A6%99%E7%94%A8-zset%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/05/29/middleware/redis%E5%A6%99%E7%94%A8-zset%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>有序的set集合，根据每个值的分值来排序，分值相等根据element的ascii码排序。同样区分正数索引、负数索引。<strong>本节建议score有一定的业务含义，会适用于很多场景</strong>。<br><img src="/images/middleware/redis_zset_1.png" alt="zset"></p><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>ZADD key score element[…]</td><td>存储元素</td></tr><tr><td>ZREM key element[element…]</td><td>从集合中删除元素</td></tr><tr><td>ZSCORE key element</td><td>获取集合中元素的分值</td></tr><tr><td>ZINCRBY key {increment} element</td><td>对score增加{increment}，element不存在则新增</td></tr><tr><td>ZCARD key</td><td>获取集合中元素的个数</td></tr><tr><td>ZRANGE key start stop</td><td>正序过去集合，score从start到stop</td></tr><tr><td>ZREVRANGE key start stop</td><td>倒叙过去集合，score从start到stop</td></tr></tbody></table><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd whoisoldman <span class="number">18</span> far <span class="number">18</span> ally <span class="number">20</span> jayden</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ZRANGE whoisoldman <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"ally"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"far"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"jayden"</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="集合运算操作"><a href="#集合运算操作" class="headerlink" title="集合运算操作"></a>集合运算操作</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>ZINTERSTORE {resultKey} numkeys key [key…]</td><td>交集运算，保存到resultKey中</td></tr><tr><td>ZUNIONSTORE {resultKey} numkeys key [key…]</td><td>并集运算，保存到resultKey中</td></tr></tbody></table><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="统计运算排序"><a href="#统计运算排序" class="headerlink" title="统计运算排序"></a>统计运算排序</h4><p>统计两天内的每款手机销售总量，并排序。将销售数量当作score，然后取两天的并集。<br><img src="/images/middleware/redis_zset_2.png" alt="zset"></p><h4 id="热点新闻排行榜"><a href="#热点新闻排行榜" class="headerlink" title="热点新闻排行榜"></a>热点新闻排行榜</h4><p><img src="/images/middleware/redis_zset_3.png" alt="zset"></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将点击数作为score，没点一次进行加1</span></span><br><span class="line">ZINCRBY <span class="symbol">hotnews:</span>:<span class="number">20190528</span> <span class="number">1</span> 李可首位归化国脚</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示排行，倒叙取10条，并携带score输出</span></span><br><span class="line">ZREVRANGE <span class="symbol">hotnews:</span>:<span class="number">20190528</span> <span class="number">0</span> <span class="number">10</span> WITHSCORES  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现周榜、月榜，参照上一小节的统计运算</span></span><br><span class="line">SUNIONSTORE <span class="class"><span class="keyword">union</span>::20190527::201900602 <span class="title">hotnews::20190528</span> ... <span class="title">hotnews::201900602</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis妙用-set类型</title>
      <link href="/2019/05/17/middleware/redis%E5%A6%99%E7%94%A8-set%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/05/17/middleware/redis%E5%A6%99%E7%94%A8-set%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>set类型，在redis中是非常强大的存在，但是我们一般不会想到用它。所以我最想分享的也就是set类型，想让大家对set引起重视。因为在互联网中其实也有很多set的身影，只是我们不难么容易联想到而已。比如</p><ul><li>抽奖活动</li><li>点赞、签到</li><li>好友关注模型</li><li>电商商品筛选</li><li>大数据量对账</li></ul><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>SADD key member[member…]</td><td>存储元素</td></tr><tr><td>SREM key member[member…]</td><td>从集合中删除元素</td></tr><tr><td>SMEMBERS key</td><td>获取集合中所有元素</td></tr><tr><td>SCARD key</td><td>获取集合的元素个数</td></tr><tr><td>SISMEMBER key member</td><td>判断{member}是否存在集合中</td></tr><tr><td>SRANDMEMBER key [count]</td><td>从集合中随机选出{count}个元素，不删除</td></tr><tr><td>SPOP key [count]</td><td>从集合中随机选出{count}个元素，删除</td></tr></tbody></table><h4 id="集合运算操作"><a href="#集合运算操作" class="headerlink" title="集合运算操作"></a>集合运算操作</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>SINTER key [key…]</td><td>交集运算</td></tr><tr><td>SUNION key [key…]</td><td>并集运算</td></tr><tr><td>SDIFF key [key…]</td><td>差集运算</td></tr><tr><td>SINTERSTORE {resultKey} key [key…]</td><td>交集运算，保存到resultKey中</td></tr><tr><td>SUNIONSTORE {resultKey} key [key…]</td><td>并集运算，保存到resultKey中</td></tr><tr><td>SDIFFSTORE {resultKey} key [key…]</td><td>差集运算，保存到resultKey中</td></tr></tbody></table><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="抽奖活动"><a href="#抽奖活动" class="headerlink" title="抽奖活动"></a>抽奖活动</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 刷礼物或转发，将用户加入到抽奖集合中</span></span><br><span class="line">SADD <span class="built_in">key</span> &#123;userId&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta"># 抽取中奖用户</span></span><br><span class="line">SPOP/SRANDMEMBER <span class="built_in">key</span> [count]</span><br></pre></td></tr></table></figure><h4 id="点赞、签到"><a href="#点赞、签到" class="headerlink" title="点赞、签到"></a>点赞、签到</h4><p><img src="/images/middleware/redis_set_1.png" alt="set实现点赞"></p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SADD <span class="keyword">like</span>::&#123;articleId&#125; &#123;userId&#125;  <span class="meta"># 点赞</span></span><br><span class="line">SREM <span class="keyword">like</span>::&#123;articleId&#125; &#123;userId&#125;  <span class="meta"># 取消赞</span></span><br><span class="line">SISMEMBER <span class="keyword">like</span>::&#123;articleId&#125; &#123;userId&#125;  <span class="meta"># 检查用户是否点过赞</span></span><br><span class="line">SMEMBERS <span class="keyword">like</span>::&#123;articleId&#125;  <span class="meta"># 获取所有点赞用户列表</span></span><br><span class="line">SCARD <span class="keyword">like</span>::&#123;articleId&#125;  <span class="meta"># 获取点赞用户数</span></span><br></pre></td></tr></table></figure><h4 id="好友关注模型"><a href="#好友关注模型" class="headerlink" title="好友关注模型"></a>好友关注模型</h4><p><img src="/images/middleware/redis_set_2.png" alt="set关注列表"></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">far</span>关注的人：farsub -&gt;</span> &#123;<span class="string">"jayden"</span>, <span class="string">"james"</span>, <span class="string">"mic"</span>&#125;</span><br><span class="line"><span class="function"><span class="title">ally</span>关注的人：allysub -&gt;</span> &#123;<span class="string">"seven"</span>, <span class="string">"jack"</span>, <span class="string">"mic"</span>, <span class="string">"james"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">far</span>和ally共同关注的人：SINTER farsub allysub -&gt;</span> &#123;<span class="string">"mic"</span>, <span class="string">"james"</span>&#125;</span><br><span class="line">far关注的人是否关注了ally：SISMEMBER allysub jayden、 SISMEMBER allysub james</span><br><span class="line"><span class="function"><span class="title">far</span>可能认识的人：SDIFF allysub farsub -&gt;</span> &#123;<span class="string">"seven"</span>, <span class="string">"jack"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="电商商品筛选"><a href="#电商商品筛选" class="headerlink" title="电商商品筛选"></a>电商商品筛选</h4><p><img src="/images/middleware/redis_set_3.png" alt="set电商商品筛选"><br>在每个商品入库的时候，给没有商品建立它的静态标签，如品牌、尺寸、处理器、内存…。如下</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SADD </span><span class="keyword">brand::lenovo </span>拯救者y7000 Thinkpad-T480</span><br><span class="line"><span class="keyword">SADD </span>screenSize::<span class="number">15</span>.<span class="number">6</span> 拯救者y7000 雷神<span class="number">911</span>-M5TA</span><br><span class="line"><span class="keyword">SADD </span>cpu::i7 拯救者y7000 雷神<span class="number">911</span>-M5TA</span><br><span class="line"><span class="keyword">SADD </span>memory::<span class="number">8</span>G 拯救者y7000 Thinkpad-T480</span><br></pre></td></tr></table></figure><p>那么你在筛选查询的时候，将各个标签放在一起求交集就得到对应的结果，如下</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER brand::lenovo screenSize::<span class="number">15.6</span> cpu::i7 memory::<span class="number">8</span>G  -&gt; 拯救者y7000</span><br></pre></td></tr></table></figure><h4 id="订单对账的功能"><a href="#订单对账的功能" class="headerlink" title="订单对账的功能"></a>订单对账的功能</h4><p>场景是这样的，与第三方公司交互时，不能实时对账。第三方公司只能在第二天将前一天的所有订单都传过来，然后要跟我们自己这边的订单对账。<br>当你的数据量比较庞大时，一天几十万单的时候，你循环一个个遍历我们的订单是否存在对方的订单中，这样的操作肯定是不合适的。<br>使用redis解决方案。将我们要关注的字段值，比如订单号、金额组成一个值存入redis的set类型中，形成两个set集合，然后取差值。如下<br><img src="/images/middleware/redis_set_4.png" alt="set订单对账的功能"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis妙用-list类型</title>
      <link href="/2019/05/15/middleware/redis%E5%A6%99%E7%94%A8-list%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/05/15/middleware/redis%E5%A6%99%E7%94%A8-list%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><p>list类型存储结构如下，它区分正数索引、负数索引。索引可以帮我定位到具体几个元素，类似java中List的下标。<br><img src="/images/middleware/redis_list_1.png" alt="redis list结构"></p><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>LPUSH key value [value …]</td><td>往key的列表中的左边放入一个元素，key不存在则新建</td></tr><tr><td>RPUSH key value [value …]</td><td>往key的列表中的右边放入一个元素，key不存在则新建</td></tr><tr><td>LPOP key</td><td>从key的列表中的左边弹出一个元素</td></tr><tr><td>RPOP key</td><td>从key的列表中的右边弹出一个元素</td></tr><tr><td>LRANGE key start stop</td><td>获取列表下标为start到stop中的元素</td></tr><tr><td>BLPOP key[key…] timeout</td><td>阻塞的从key的列表中的左边弹出一个元素，timeout=0，一直阻塞</td></tr><tr><td>BRPOP key[key…] timeout</td><td>阻塞的从key的列表中的右边弹出一个元素，timeout=0，一直阻塞</td></tr></tbody></table><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; LPUSH<span class="built_in"> user </span>ally far jayden</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; LPOP user</span><br><span class="line"><span class="string">"jayden"</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE<span class="built_in"> user </span>0 -1</span><br><span class="line">1) <span class="string">"far"</span></span><br><span class="line">2) <span class="string">"ally"</span></span><br></pre></td></tr></table></figure><p><code>lrange user 0 -1</code>当你的key经过多次修改之后，你不知道有多少个值时，想拿到所有的值，使用该语句。0代表正数索引的开始，-1代表负数索引的结束。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="实现消息队列"><a href="#实现消息队列" class="headerlink" title="实现消息队列"></a>实现消息队列</h4><p>由于list的BLPOP命令的特性，我们是不是可以实现一个简单消息队列，其实在github，你可以找到类似的基于redis的消息队列框架，实现思路图如下。<br><img src="/images/middleware/redis_list_2.png" alt="list实现消息队列"><br>生产者在队列的左边push消息进去，而消费者使用BRPOP阻塞的监听队列，有消息到达时，消费者就会马上收到。</p><h4 id="新浪-twitter用户消息列表"><a href="#新浪-twitter用户消息列表" class="headerlink" title="新浪/twitter用户消息列表"></a>新浪/twitter用户消息列表</h4><p>far关注了ally，jayden…当他们发推文的时候，far在首页需要倒叙的显示出来。<br>先回想一下，如果是关系型数据，你怎么实现。<br>你将你所有的关注的人的微博使用关联查询关联起来，然后倒序？或者维护一张消息关系表，发微博时将哪些关注你的人都维护在这张消息关系表中？那么像eason这样的热点用户，关注的人可能有几千万，那么你怎么去维护消息的关系。</p><p><strong>看看使用redis怎么处理</strong></p><ol><li>ally发微博，消息id为10086<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH msgline::&#123;farId&#125; <span class="number">10086</span></span><br></pre></td></tr></table></figure></li><li>jayden发微博，消息id为10087<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH msgline::&#123;farId&#125; <span class="number">10087</span></span><br></pre></td></tr></table></figure></li><li>far登陆时，查看消息<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 第一页，每页<span class="number">10</span>条</span><br><span class="line">LRANGE msgline::&#123;farId&#125; <span class="number">0</span> <span class="number">1</span>*<span class="number">10</span></span><br></pre></td></tr></table></figure>那么用redis存储这么多数据，合适吗？传言，新浪微博组建了160T的redis集群来干这么一件事情。但是可以断定先期新浪微博就是这样实现的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis妙用-hash类型</title>
      <link href="/2019/05/13/middleware/redis%E5%A6%99%E7%94%A8-hash%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/05/13/middleware/redis%E5%A6%99%E7%94%A8-hash%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>hash类型，又叫作散列类型，它类似hashmap，通过一定的hash算法得到对应的索引位置，然后将数据保存在该索引所在的地方。本章讲述的东西，重点不在于应用场景，因为hash能做的事情，string也都能做。所以本章分享的是，试图<strong>揣测redis官方推出hash的意义，以及实现原理</strong>。</p><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><h4 id="针对字符串的操作"><a href="#针对字符串的操作" class="headerlink" title="针对字符串的操作"></a>针对字符串的操作</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>HSET key fieId value</td><td>存储一个散列键</td></tr><tr><td>HMSETNX key fieId value[fieId value …]</td><td>批量一个key的多个fieId</td></tr><tr><td>HSETNX key fieId value</td><td>存入一个不存在的散列键</td></tr><tr><td>HGET key fieId</td><td>获取key的一个键的值</td></tr><tr><td>HMGET key fieId[fieId …]</td><td>批量获取key的值</td></tr><tr><td>HDEL key fieId</td><td>删除一个散列键</td></tr></tbody></table><h4 id="针对数字的操作"><a href="#针对数字的操作" class="headerlink" title="针对数字的操作"></a>针对数字的操作</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>HINCRBY key fieId increment</td><td>对key散列中的fieId进行{increment}的增加</td></tr></tbody></table><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>像string类型一样，它的第一个应用场景作为缓存，我们考虑一下该表存在redis中怎么存储合适。<br><img src="/images/middleware/redis_user_data.png" alt="user"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 约定key生成规则为</span><br><span class="line">&#123;table&#125; &#123;id&#125;::name &#123;id&#125;::age</span><br><span class="line"></span><br><span class="line">-- 写入缓存</span><br><span class="line">HMSET<span class="built_in"> user </span>1::name ally 1::age 18</span><br><span class="line"></span><br><span class="line">-- 读取缓存</span><br><span class="line">HMGET<span class="built_in"> user </span>1::name 1::age</span><br></pre></td></tr></table></figure><h4 id="hash键意义何在？"><a href="#hash键意义何在？" class="headerlink" title="hash键意义何在？"></a>hash键意义何在？</h4><p>看完hash键的api，我们看到hash类型存在的命令，string类型都提供了，就连上面举例的缓存的应用场景，string类型也可以实现，那么这个时候hash类型的意义存在哪里？</p><ol><li>hash键可以将信息凝聚在一起，而不是直接分散的存储在整个redis中，方便管理数据，还可以避免一定的误操作</li><li>避免键名冲突</li><li>减少内存/cpu的消耗</li></ol><p>这里仅解释第三点，第三点怎么理解，当你给key设置一个过期时间的时候，redis会对所有的key进行扫描它有没有过期，而这种机制只会对hash键的key进行扫描，它的fieId层是不会被扫描的，所以减少的消耗。当你有一批key它们的过期时间一致，你使用string类型，他会扫描所有的key，而使用hash类型，redis只需扫描hash的第一层。</p><h4 id="哪些情况不适用hash？"><a href="#哪些情况不适用hash？" class="headerlink" title="哪些情况不适用hash？"></a>哪些情况不适用hash？</h4><ol><li>需要使用过期功能，过期功能只能使用在key上</li><li>二进制操作命令不适用hash，如：SETBIT，GETBIT，BITOP</li><li>需要考虑数据量分布问题</li></ol><p>这里仅解释第三点，第三点怎么理解，需要先了解redis集群存储方式（<strong>预分配hash槽</strong>），redis会将集群分为16384个槽，16384不会根据集群的数量而改变。然后将16384个槽平均分配给每一个redis节点去管理。如图所示<br><img src="/images/middleware/redis_hash_1.png" alt="user"></p><p>当一个key需要存储时，会对key进行取模计算，得到一个槽的位置，假如这个槽由redis的节点1管理，那么这个key的数据就会真正落在节点1的物理内存上。</p><p>这个时候来解释第三点的原因，假如我们使用hash类型，缓存的key约定为以上举例的情况，那么user表的所有数据都会落在某一个节点上，假如这个表的数据有一千万，那么一千万都落在一个节点上，其他的节点上没有数据，这肯定是不合适的。这个节点内存是会撑爆的。</p><p>那么回过头来，<strong>为什么redis要采用预分配hash槽作为集群管理的方案？</strong><br>主要是为了解决快速扩缩容的问题。假如我现在新加入一个节点，根据预分配hash槽的方案，该新加入的节点管理的槽为16384，16284…那么redis要做的操作只需将这些槽的数据迁移到新节点上就行了，不用像hashmap那样rehash的操作。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis妙用-string类型</title>
      <link href="/2019/05/11/middleware/redis%E5%A6%99%E7%94%A8-string%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/05/11/middleware/redis%E5%A6%99%E7%94%A8-string%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>string类型，是我们最常用的。以及一些特性，我们都比较熟悉，这一节一起回顾一下string的应用场景，以及对<strong>这些场景延申的一些思考</strong>。</p><ul><li>缓存，如何设计缓存存储，使用spring cache另当别论</li><li>分布式锁，锁续期</li><li>计数器</li><li>分布式全局序列，减少IO交互提高效率</li></ul><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><h4 id="针对字符串的操作"><a href="#针对字符串的操作" class="headerlink" title="针对字符串的操作"></a>针对字符串的操作</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>SET key value</td><td>存储字符串键</td></tr><tr><td>MSET key value[key value …]</td><td>批量存储字符串键</td></tr><tr><td>SETNX key value</td><td>存入一个存在在的字符串，若存在存储不成功</td></tr><tr><td>GET key</td><td>获取一个键的值</td></tr><tr><td>MGET key[key …]</td><td>批量获取键的值</td></tr></tbody></table><h4 id="针对数字的操作"><a href="#针对数字的操作" class="headerlink" title="针对数字的操作"></a>针对数字的操作</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>INCRBY key increment</td><td>对数字key进行{increment}的增加</td></tr><tr><td>DECRBY key decrement</td><td>对数字key进行{decrement}的减少</td></tr><tr><td>INCR key</td><td>对数字key自增1</td></tr><tr><td>DECR key</td><td>对数字key自减1</td></tr></tbody></table><h4 id="统一的操作"><a href="#统一的操作" class="headerlink" title="统一的操作"></a>统一的操作</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>DEL key[key …]</td><td>删除一个键</td></tr><tr><td>EXPIRE key seconds</td><td>设置key的过期时间（秒）</td></tr><tr><td>PEXPIRE key milliseconds</td><td>设置key的过期时间（毫秒）</td></tr></tbody></table><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>string数据类型，我们常用来做为缓存，一般都是使用spring cache这样的框架来管理缓存。那么考虑一下，在没有使用任何框架情况下，我们使用redis作为缓存，redis中key怎么设计呢？如下表。<br><img src="/images/middleware/redis_user_data.png" alt="user"><br>我们第一个会想到使用json、xml来将user的数据序列化之后保存到redis中，但是这样的话，不便于我们做修改操作，对不对。如果我们要修改的话，需要查询出来进行反序列化，才能做修改。</p><p>但是如果进行 这一串操作的话，又会产生第二个问题，就是并发情况下，其他线程会读到修改之前的数据。这里多说一句，我们在实际生产中解决这一问题的方案就是对数据做修改时，直接删除缓存，然后别的线程查询时，再写入缓存。</p><p>那么有没有其他的设计方式来解决这一问题呢？我们把解决思路放在缓存的key上，在设计缓存key时，制定一个约定熟成的规定来存储，比如</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 约定key生成规则为</span></span><br><span class="line"><span class="keyword">user</span>::&#123;id&#125;::<span class="type">name</span>、<span class="keyword">user</span>::&#123;id&#125;::age</span><br><span class="line"><span class="comment">-- 写入缓存</span></span><br><span class="line">MSET <span class="keyword">user</span>::<span class="number">1</span>::<span class="type">name</span> ally <span class="keyword">user</span>::<span class="number">1</span>::age <span class="number">18</span></span><br><span class="line"><span class="comment">-- 读取缓存</span></span><br><span class="line">MGET <span class="keyword">user</span>:<span class="number">1</span>::<span class="type">name</span> <span class="keyword">user</span>::<span class="number">1</span>::age</span><br></pre></td></tr></table></figure><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>分布式锁，通常会用到SETNX、EXPIRE，SETNX用来获取锁，而EXPIRE设置锁的失效时间，防止死锁。如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">SETNX</span><span class="params">(<span class="string">"couponcode::123456"</span>, <span class="number">1</span>)</span></span>     <span class="comment">//return 1，成功获得锁</span></span><br><span class="line"><span class="function"><span class="title">SETNX</span><span class="params">(<span class="string">"couponcode::123456"</span>, <span class="number">1</span>)</span></span>     <span class="comment">//return 0，有人持有该锁，获取失败</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">PEXPIRE</span><span class="params">(<span class="string">"couponcode"</span>, <span class="number">1000</span>)</span></span>      <span class="comment">//设置key的失效时间，防止系统宕机，导致死锁</span></span><br></pre></td></tr></table></figure><p>那么这个时候其实又会有另一个问题，SETNX和PEXPIRE是分两步执行，那么可能出现SETNX成功了，在执行PEXPIRE时失败了，就会导致死锁。那么redis给我们还提供了一个原子操作。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET couponcode <span class="number">1</span> EX <span class="number">10</span> NX    <span class="comment">//EX 表示失效时间，NX表示不存在则增加</span></span><br></pre></td></tr></table></figure><p>以上命令看似完美的解决了分布式锁的问题，既保证了原子性，又解决了死锁的问题。但是我们还忽略了一点，假如我们设置锁的超时时间为10秒，但是我们应用系统处理需要20秒，那么在多余的10秒内将会有其他的线程获得该锁，那么怎么解决呢？<br>其实对于处理redis的续期，业界比较正确的姿势是采用redisson这个客户端工具，具体可见同性恋交友网站github。</p><p><img src="/images/middleware/redis_string_1.png" alt="redisson文档"><br>redisson官方文档中，有明确的提到看门狗每30秒钟会帮我们检查锁的时间，并帮助我们续期。那么这时就问题来了，那么假如锁的时间为10秒，而看门狗的检查时间为30秒，那么不就可以有多个线程同时持有锁了嘛，虽然可以通过Config.lockWatchdogTimeout来指定，但是抱着对技术敬畏的心态，我们一起来看看看门狗是怎么实现的。那么我们写一个demo，跟这源码看看</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> RedissonLock &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        RedissonClient redissonClient = <span class="module-access"><span class="module"><span class="identifier">Redisson</span>.</span></span>create<span class="literal">()</span>;</span><br><span class="line">        RLock lock = redissonClient.get<span class="constructor">Lock(<span class="string">"lock"</span>)</span>;</span><br><span class="line"></span><br><span class="line">        lock.lock<span class="literal">()</span>;  <span class="comment">// 推测，要确认续期的时间，是在加锁时触发看门狗的。所以我们从此进入到RedissonLock.lock();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> void lock(long leaseTime, TimeUnit <span class="built_in">unit</span>, boolean interruptibly) throws InterruptedException &#123;</span><br><span class="line">        long threadId = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Id()</span>;</span><br><span class="line">        Long ttl = <span class="keyword">try</span><span class="constructor">Acquire(<span class="params">leaseTime</span>, <span class="params">unit</span>, <span class="params">threadId</span>)</span>;  <span class="comment">// 看名字就知道是我们要找的，尝试获得锁。</span></span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttl<span class="operator"> == </span>null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long <span class="keyword">try</span><span class="constructor">Acquire(<span class="params">long</span> <span class="params">leaseTime</span>, TimeUnit <span class="params">unit</span>, <span class="params">long</span> <span class="params">threadId</span>)</span> &#123;</span><br><span class="line">        return get(<span class="keyword">try</span><span class="constructor">AcquireAsync(<span class="params">leaseTime</span>, <span class="params">unit</span>, <span class="params">threadId</span>)</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="keyword">try</span><span class="constructor">AcquireAsync(<span class="params">long</span> <span class="params">leaseTime</span>, TimeUnit <span class="params">unit</span>, <span class="params">long</span> <span class="params">threadId</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">            return <span class="keyword">try</span><span class="constructor">LockInnerAsync(<span class="params">leaseTime</span>, <span class="params">unit</span>, <span class="params">threadId</span>, RedisCommands.EVAL_LONG)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//异步获得锁，返回Future对象，这里不明白的，可以补充一下多线程的知识</span></span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture = <span class="keyword">try</span><span class="constructor">LockInnerAsync(<span class="params">commandExecutor</span>.<span class="params">getConnectionManager</span>()</span>.get<span class="constructor">Cfg()</span>.get<span class="constructor">LockWatchdogTimeout()</span>, TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line"></span><br><span class="line">        ttlRemainingFuture.on<span class="constructor">Complete((<span class="params">ttlRemaining</span>, <span class="params">e</span>)</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// lock acquired</span></span><br><span class="line">            <span class="keyword">if</span> (ttlRemaining<span class="operator"> == </span>null) &#123;</span><br><span class="line"><span class="comment">// 开启调度重新续期</span></span><br><span class="line">                schedule<span class="constructor">ExpirationRenewal(<span class="params">threadId</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return ttlRemainingFuture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新续期</span></span><br><span class="line"><span class="keyword">private</span> void renew<span class="constructor">Expiration()</span> &#123;</span><br><span class="line">        ExpirationEntry ee = <span class="module-access"><span class="module"><span class="identifier">EXPIRATION_RENEWAL_MAP</span>.</span></span>get(get<span class="constructor">EntryName()</span>);</span><br><span class="line">        <span class="keyword">if</span> (ee<span class="operator"> == </span>null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Timeout task = commandExecutor.get<span class="constructor">ConnectionManager()</span>.<span class="keyword">new</span><span class="constructor">Timeout(<span class="params">new</span> TimerTask()</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run(Timeout timeout) throws Exception &#123;</span><br><span class="line">                ExpirationEntry ent = <span class="module-access"><span class="module"><span class="identifier">EXPIRATION_RENEWAL_MAP</span>.</span></span>get(get<span class="constructor">EntryName()</span>);</span><br><span class="line">                <span class="keyword">if</span> (ent<span class="operator"> == </span>null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                Long threadId = ent.get<span class="constructor">FirstThreadId()</span>;</span><br><span class="line">                <span class="keyword">if</span> (threadId<span class="operator"> == </span>null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                RFuture&lt;Boolean&gt; future = renew<span class="constructor">ExpirationAsync(<span class="params">threadId</span>)</span>;</span><br><span class="line">                future.on<span class="constructor">Complete((<span class="params">res</span>, <span class="params">e</span>)</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != null) &#123;</span><br><span class="line">                        log.error(<span class="string">"Can't update lock "</span> + get<span class="constructor">Name()</span> + <span class="string">" expiration"</span>, e);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                        <span class="comment">// reschedule itself</span></span><br><span class="line">                        renew<span class="constructor">Expiration()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, internalLockLeaseTime<span class="operator"> / </span><span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        </span><br><span class="line">        ee.set<span class="constructor">Timeout(<span class="params">task</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一切明白了，redisson在加锁成功后，开启一个定时任务，也是所谓的看门狗。定时任务每次执行会调用renewExpirationAsync(threadId)检查锁是否释放，没有释放则对锁进行续期 renewExpiration()。而定时任务每次调度时间差为internalLockLeaseTime/3，默认锁时间为30秒，那就是10秒。<br>那么也就是说不会出现我们担心的问题，当我们锁的时间为10秒时，看门狗会在该锁还剩7秒的时候对锁进行续期。</p><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>以下场景，我们要对每一个文章的阅读量进行统计<br><img src="/images/middleware/redis_incrby_1.png" alt="incr"></p><p>如果使用数据库要统计的话，我们将面对两个问题，并发修改和数据库压力。处理并发我们可以用cas，那么面对数据库压力我们毫无办法。这是我们可以使用redis提供的incr命令进行统计<br><img src="/images/middleware/redis_incrby_2.png" alt="incr"></p><h4 id="分布式全局序列"><a href="#分布式全局序列" class="headerlink" title="分布式全局序列"></a>分布式全局序列</h4><p>在你的业务系统到达一定的体量，特别是进行了分库分表后，分布式唯一键就显得尤为重要，原先的数据库自增id一定是用不了了。常规的解决办法我们多多少少有了解过，雪花算法，UUID。当然这里主要介绍redis生成全局唯一键，使用incr命令生成。<br>那么使用redis的incr就可以实现了啊，为什么还要单独拿出来说呢？其实使用incr命令会存在一个问题，那就是IO交互次数过多，想一想在分布式情况，尽管处于同一内网，还是会存在网络问题，过的IO交互就会影响效率，那么有没有解决办法呢？<br>redis官方其实有考虑到这一点，解决IO交互次数过多的办法就是，一次性获取多个唯一键，那就是incrby，他可以一其增加多个值</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrby read::<span class="number">1001</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>那么这种方案，虽然解决了IO交互次数，那么假如系统宕机了，我们就会丢失已经获取的那一段id值，所以在你的需求要求id连续的情况下，不建议采用这种方式。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis妙用-应用场景</title>
      <link href="/2019/05/11/middleware/redis%E5%A6%99%E7%94%A8-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/05/11/middleware/redis%E5%A6%99%E7%94%A8-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>分布式环境中，redis作为必不可少的中间件，我们都常有用到，但是我们大多数人基本都没有系统学习过，只是跟着潮流把redis当作一个缓存来用，或者用它来实现分布式锁、分布式自增键。而本章内容还继续讲这些就没有任何意义，因为这些东西都已经讲烂了，百度的资料都一大堆。本章我们回归初心，整理redis几种数据类型，以及列举应用场景。你会重新认识到redis的强大，而不是仅次于缓存。</p><p>先总结现在redis支持的几种数据类型，在开发中，相信都已经用过了string, set, list, zset, hash，这些数据结构。但是在官网中还有找到其他的一些数据结构，如hyperloglogs, geospatial，以及在5.0后出了一个streams，在这个数据结构出来之后，基本上redis的重心在往一个消息中间件偏移，所以你把redis当作一个缓存，是非常片面的。</p><p>本章对redis的几大基本类型进行罗列，以及各自应用场景，后来发现篇幅实在太大，得以拆分，大家可根据自身进行查略。</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>回顾string经典场景，以及对这些场景延申的一些思考。<a href="https://www.ofcoder.com/2019/05/11/middleware/redis%E5%A6%99%E7%94%A8-string%E7%B1%BB%E5%9E%8B/">点击查看</a></p><ol><li>缓存(如何设计缓存存储，使用spring cache另当别论)</li><li>分布式锁(锁续期)</li><li>计数器</li><li>分布式全局序列(减少IO交互提高效率)</li></ol><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>试图揣测redis官方推出hash的意义，以及实现原理。<a href="https://www.ofcoder.com/2019/05/13/middleware/redis%E5%A6%99%E7%94%A8-hash%E7%B1%BB%E5%9E%8B/">点击查看</a></p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><a href="https://www.ofcoder.com/2019/05/15/middleware/redis%E5%A6%99%E7%94%A8-list%E7%B1%BB%E5%9E%8B/">点击查看</a></p><ol><li>基于list实现消息队列</li><li>新浪/twitter用户消息列表</li></ol><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><a href="https://www.ofcoder.com/2019/05/17/middleware/redis%E5%A6%99%E7%94%A8-set%E7%B1%BB%E5%9E%8B/">点击查看</a></p><ol><li>抽奖活动</li><li>点赞、签到</li><li>好友关注模型</li><li>电商商品筛选</li><li>大数据量对账</li></ol><h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p><a href="https://www.ofcoder.com/2019/05/29/middleware/redis%E5%A6%99%E7%94%A8-zset%E7%B1%BB%E5%9E%8B/">点击查看</a></p><ol><li>统计运算</li><li>热点新闻排行榜</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本章中，其实所回顾的都是基础，没有过深的技术难点，但是它却解决了，互联网中比较难实现的场景。例如新浪消息列表、抽奖、好友关注模型、大数据对账、大数据排序等…这些功能在不依赖redis的时候，实现起来有多困难。而这些都是redis的基础知识。</p><p>其实我只是想说，回归初心脚踏实地巩固基础真的很重要。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈分表分库常见问题解决方案</title>
      <link href="/2019/04/21/java/%E8%B0%88%E8%B0%88%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/04/21/java/%E8%B0%88%E8%B0%88%E5%88%86%E8%A1%A8%E5%88%86%E5%BA%93%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>本章的思路，是先讲讲根据业务增长进行分表分库，以及实现方案探讨，对这些方案产生的一系列问题该如何解决，以及现在社区中活跃的第三方分表分库中间件。</p><h3 id="分表分库案例"><a href="#分表分库案例" class="headerlink" title="分表分库案例"></a>分表分库案例</h3><p>互联网时代，每天都会产生海量的数据。我觉得每一位程序员都应该或多或少的了解到存储这个数据的解决办法，特别是小公司的程序员更应自己多尝试，多实践。因为在小公司，我们没有优秀的架构师，没有前辈的指引，更没有性能良好的设备来支持大数据计算。那么遇到数据到达瓶颈了怎么办？难道让业务不发展了？公司不挣钱了？所以特别是小公司的人更应该考虑。这是我个人的观点。</p><p><strong>为什么不适用nosql/newsql？</strong>目前绝大部分公司的核心数据都是：以RDBMS存储为主，NoSQL/NewSQL存储为辅！互联网公司又以MySQL为主，国企&amp;银行等不差钱的企业以Oracle/DB2为主！NoSQL/NewSQL宣传的无论多牛逼，就现在各大公司对它的定位，都是RDBMS的补充，而不是取而代之！</p><h3 id="常用解决方案"><a href="#常用解决方案" class="headerlink" title="常用解决方案"></a>常用解决方案</h3><p>常用分表分库的方案有很多</p><ol><li>你可以自己实现物理的分库分表</li><li>常用数据库，如mysql有自己分表的解决方案，如：partitions</li><li>使用第三方中间件</li></ol><p>这一节讲的就是自己实现物理分库分表，在分表之前，首先需要选择适当的分表策略，使得数据能够较为均衡地分不到多张表中，并且不影响正常的查询！</p><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>对于互联网企业来说，大部分数据都是与用户关联的，因此，用户id是最常用的分表字段。因为大部分查询都需要带上用户id，这样既不影响查询，又能够使数据较为均衡地分布到各个表中(当然，有的场景也可能会出现冷热数据分布不均衡的情况)，如下图：<br><img src="/images/java/partition/partition_1.png" alt="逻辑图"></p><p>假设有一张表记录用户购买信息的日志表，由于日志记录条数太多，将被拆分成256张表。</p><p>拆分的记录根据user_id%256取得对应的表进行存储，前台应用则根据对应的user_id%256，找到对应日志存储的表进行访问。假如表结构如下</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">create</span> <span class="meta">table</span> order_log_(</span><br><span class="line">order_id bi<span class="meta">gint(</span>20) <span class="meta">primary</span> <span class="meta">key</span> auto_increment,</span><br><span class="line">user_id bi<span class="meta">gint(</span>20),</span><br><span class="line">user_nick varchar(50)</span><br><span class="line">....</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>那么要查询用户id为257的日志，就先算法hash值（257 % 256 = 1），确定到那一张表再查询.</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> order_log_1 <span class="keyword">where</span> user_id = <span class="number">257</span>;</span><br></pre></td></tr></table></figure><h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>对于分表来说，每张表的数据量是变小了，但是它们依然处于同一个数据库实例下，对于单个实例来说，吞吐量也是有限的。那么分库，你可以将多个schema部署在多个数据库实例上。如此的话，你需要在项目中配置多数据源，用来访问每个数据库实例，或者你也可以通过一个统一的微服务来做分表分库的路由。</p><p>与分表策略相似，分库可以采用通过一个关键字取模的方式，来对数据访问进行路由，如下图所示：<br><img src="/images/java/partition/partition_2.png" alt="逻辑图"></p><h4 id="分表分库"><a href="#分表分库" class="headerlink" title="分表分库"></a>分表分库</h4><p>有时数据库可能既面临着高并发访问的压力，又需要面对海量数据的存储问题，这时需要对数据库既采用分表策略，又采用分库策略，以便同时扩展系统的并发处理能力，以及提升单表的查询性能，这就是所谓的分库分表。那么这提供的一种策略就是：</p><ol><li>中间变量 = user_id % (分库数量 * 每个库的表数量)</li><li>库 = 取整数 (中间变量 / 每个库的表数量)</li><li>表 = 中间变量 % 每个库的表数量</li></ol><p>同样采用user_id作为路由字段，首先使用user_id 对库数量*每个库表的数量取模，得到一个中间变量；然后使用中间变量除以每个库表的数量，取整，便得到对应的库；而中间变量对每个库表的数量取模，即得到对应的表。</p><p>假设将原来的单库单表order拆分成256个库，每个库包含1024个表，那么按照前面所提到的路由策略，对于user_id=262145 的访问，路由的计算过程如下：</p><ol><li>中间变量 = 262145 % (256 * 1024) = 1</li><li>库 = 取整 (1/1024) = 0</li><li>表 = 1 % 1024 = 1</li></ol><p>这就意味着，对于user_id=262145 的订单记录的查询和修改，将被路由到第0个库的第1个order_1表中执行！</p><h3 id="副作用解决方案"><a href="#副作用解决方案" class="headerlink" title="副作用解决方案"></a>副作用解决方案</h3><p>分库分表的好处显而易见，解决了数据存储容量的问题，但也带来了诸多弊端。这里简单的来分析，以及怎么解决</p><p><strong>1. 如何能做到数据的平均拆分，防止某一库压力过大？</strong><br>系统开发者要结合业务特点来确定分库分表键，比如以userID为分库分表键，采用hash取模的方式将数据散列到不同的库中。<br>但并不是所有场景都适合用userID作为分库分表键的，若存在“大卖家”，则该userID可能有很多条记录，若简单的按照上述方法进行拆分，则可能打爆其中一个数据库。<br>一般来说，会将一段时间以前的数据归档（比如某个userID三个月之前的数据），存放到类似HBase这种非关系型数据库中，以此来解决上述问题。</p><p><strong>2. 分库分表之后就要求每个查询的where子句中必须携带分库分表键，但并非每个查询都能携带分库分表键的。</strong><br>比如订单库按照订单号hash取模之后存储，此时分库分表键为订单号，那么想查询某位买家所有的订单，查询时就没有了分库分表键，就会出现“全表扫描”的情况。<br>一般在实践中解决这种问题的方法是建立“异构索引表”，即采用异步机制将原表内的每次一创建或更新，都换一个维度保存一份完整的数据表或索引表，拿空间换时间。<br>在上面说到，订单库按照订单号hash取模之后存储，同时也按照userID维度进行hash取模，再存储一份数据，那么想要获取某一userID的全部订单时，就将userID作为分库分表键传进去即可，避免了全表扫描。</p><h3 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h3><p>分库分表虽好，但是带来的一系列问题也是需要解决的。比如对开发人员要求增加、工作量的增加、同时bug量也会增加。那么这些问题肯定会有中间件来帮我解决的。这里只列举社区中比较有知名度的几个：</p><ol><li>阿里的 TDDL、DRDS和cobar</li><li>开源社区的sharding-sphere</li><li>民间的mycat</li></ol><p>以及还有，360的Atlas、美团的zebra。具体中间件怎么使用，大家可以各自去了解。这么多的分库分表中间件全部可以归结为两大类型：</p><ol><li>CLIENT模式</li><li>PROXY模式</li></ol><p>CLIENT模式代表有阿里的TDDL，开源社区的sharding-jdbc（sharding-jdbc的3.x版本即sharding-sphere已经支持了proxy模式）。PROXY模式代表有阿里的cobar，民间组织的MyCAT。无论是CLIENT模式，还是PROXY模式。几个核心的步骤是一样的：<strong>SQL解析，重写，路由，执行，结果归并</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> mysql </tag>
            
            <tag> 分表分库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈mybatis、dubbo基础原理</title>
      <link href="/2019/04/09/java/%E8%B0%88%E8%B0%88mybatis%E3%80%81dubbo%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
      <url>/2019/04/09/java/%E8%B0%88%E8%B0%88mybatis%E3%80%81dubbo%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>本章只介绍简单的原理，思路如下，先谈谈动态代理，以熟悉的mybatis举例，如何做到注入mapper的，引申到dubbo。。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>本节知识点陈旧，可以跳过</strong>。先回顾一下什么是代理，代理模式是指给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。这种模式有什么用呢？它可以在原对象的基础上增强原对象的功能，比如在原对象调用一个方法的前后进行日志、事务操作等。Spring AOP就使用了代理模式。<br>代理分静态代理、动态代理。下面分别使用两种方式代理以下接口</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>People &#123;</span><br><span class="line">    void say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理是指我们设计模式中用到的那样，新建一个代理类，把要代理对象的传入到这个类中，手动调用这个代理类的方法。稍微感受一下。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PeopleProxy</span> <span class="keyword">implements</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> People <span class="keyword">target</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PeopleProxy</span><span class="params">(People <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Do something before call"</span>);</span><br><span class="line">        <span class="keyword">target</span>.say();</span><br><span class="line">        System.out.println(<span class="string">"Do something after call"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理主要分为JDK动态代理和cglib动态代理两大类，本文主要对JDK动态代理进行探讨。</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T getProxyObj(<span class="class"><span class="keyword">Class</span> <span class="title">clazz</span>) &#123;</span></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(getClass().getClassLoader(), <span class="keyword">new</span> <span class="class"><span class="keyword">Class</span>[]&#123;<span class="title">clazz</span>&#125;, <span class="title">this</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object invoke(Object proxy, <span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">args</span>) <span class="title">throws</span> <span class="title">Throwable</span> &#123;</span></span><br><span class="line">        System.out.println(<span class="string">"proxy the method: "</span> + <span class="function"><span class="keyword">method</span>.<span class="title">getDeclaringClass</span>(</span>).getName() + <span class="string">"."</span> + <span class="function"><span class="keyword">method</span>.<span class="title">getName</span>(</span>) + <span class="string">"();"</span>);</span><br><span class="line">        // do something.</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        People proxyObj = proxyFactory.getProxyObj(People<span class="class">.<span class="keyword">class</span>);</span></span><br><span class="line">        proxyObj.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码正确执行并输出<code>proxy the method:xxx;</code>，代码中没有写任何People的实现类，更不要说People的实例了，却能调用到say()方法。</p><p>总结一下，动态代理可以帮我们根据接口生成对应的接口的代理对象，而在这个代理对象执行时，我们还可以做一些增强处理。</p><h3 id="mybatis原理"><a href="#mybatis原理" class="headerlink" title="mybatis原理"></a>mybatis原理</h3><p>上面了解回顾动态代理实现和作用。是不是马上想到了，和我们在mybatis中写Mapper类很像。那么接下来我们寻找mybatis源码，一起验证上面的猜想。</p><p>在日常开发中，我们都或多或少了解到，mybatis为了代替手工使用 SqlSessionDaoSupport 或 SqlSessionTemplate 编写数据访问对象(DAO)的代码，MyBatis-Spring 提供了一个动态代理的实现MapperFactoryBean。那么我们从这下手一定可以找到怎么生成代理对象的，并且在代理对象中怎么执行sql的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> addToConfig = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//intentionally empty </span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperFactoryBean</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getSqlSession().getMapper(<span class="keyword">this</span>.mapperInterface);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码为MapperFactoryBean部分源码，它提供一个构造方法传入接口的Class对象，在getObject()方法中返回这个接口的代理对象，那么我们着重看getMapper()方法，一直往下，我们会找到调用MapperRegistry.getMapper()方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> MapperRegistry &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> final Configuration config;</span><br><span class="line">  <span class="keyword">private</span> final Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt;<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">  @<span class="constructor">SuppressWarnings(<span class="string">"unchecked"</span>)</span></span><br><span class="line">  public &lt;T&gt; T get<span class="constructor">Mapper(Class&lt;T&gt; <span class="params">type</span>, SqlSession <span class="params">sqlSession</span>)</span> &#123;</span><br><span class="line">    final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(<span class="keyword">type</span>);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory<span class="operator"> == </span>null) &#123;</span><br><span class="line">      throw <span class="keyword">new</span> <span class="constructor">BindingException(<span class="string">"Type "</span> + <span class="params">type</span> + <span class="string">" is not known to the MapperRegistry."</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      return mapperProxyFactory.<span class="keyword">new</span><span class="constructor">Instance(<span class="params">sqlSession</span>)</span>;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw <span class="keyword">new</span> <span class="constructor">BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + <span class="params">e</span>, <span class="params">e</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> MapperProxyFactory&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">  @<span class="constructor">SuppressWarnings(<span class="string">"unchecked"</span>)</span></span><br><span class="line">  protected T <span class="keyword">new</span><span class="constructor">Instance(MapperProxy&lt;T&gt; <span class="params">mapperProxy</span>)</span> &#123;</span><br><span class="line">    return (T) <span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">mapperInterface</span>.<span class="params">getClassLoader</span>()</span>, <span class="keyword">new</span> Class<span class="literal">[]</span> &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>走到这里，进入到mapperProxyFactory.newInstance();方法中，就会看到我们开章举例的动态代理代码。</p><p>至此，生成代理对象的过程到此结束，这里解释了为什么我们使用mybatis，只写一个对应的接口，为什么spring能注入这个接口的对象。</p><p>那么剩下的问题就是，怎么执行对应sql语句的。知道了mybatis通过动态代理生成代理对象的，那么我们推测应该是通过实现InvocationHandler接口的invoke方法中来统一执行sql的。那么接下来我们找到一个目标MapperProxy</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = -<span class="number">6424540398559729838</span>L;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">Class</span>&lt;<span class="title">T</span>&gt; <span class="title">mapperInterface</span>;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;<span class="function"><span class="keyword">Method</span>, <span class="title">MapperMethod</span>&gt; <span class="title">methodCache</span>;</span></span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> Object invoke(Object proxy, <span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">args</span>) <span class="title">throws</span> <span class="title">Throwable</span> &#123;</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) &#123;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">method</span>.<span class="title">invoke</span>(</span>this, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(<span class="function"><span class="keyword">method</span>)) &#123;</span></span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, <span class="function"><span class="keyword">method</span>, <span class="title">args</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(<span class="function"><span class="keyword">method</span>);</span></span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> MapperMethod cachedMapperMethod(<span class="function"><span class="keyword">Method</span> <span class="title">method</span>) &#123;</span></span><br><span class="line">    MapperMethod mapperMethod = methodCache.get(<span class="function"><span class="keyword">method</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (mapperMethod == <span class="literal">null</span>) &#123;</span><br><span class="line">      mapperMethod = <span class="keyword">new</span> MapperMethod(mapperInterface, <span class="function"><span class="keyword">method</span>, <span class="title">sqlSession</span>.<span class="title">getConfiguration</span>(</span>));</span><br><span class="line">      methodCache.put(<span class="function"><span class="keyword">method</span>, <span class="title">mapperMethod</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mapperMethod;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到invoke方法。由于mapper是一个代理对象，那么它就会运行到invoke方法里面，invoke首先判断是否一个类，显然这里mapper是一个接口，不是类所以判定失败。那么跟着就会生成MapperMethod对象，它是通过cachedMapperMethod方法对其初始化的，然后执行execute方法，把sqlSession和当前运行的参数传递进去。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> MapperMethod &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> final SqlCommand command;</span><br><span class="line">  <span class="keyword">private</span> final MethodSignature <span class="keyword">method</span>;</span><br><span class="line"></span><br><span class="line">  public <span class="constructor">MapperMethod(Class&lt;?&gt; <span class="params">mapperInterface</span>, Method <span class="params">method</span>, Configuration <span class="params">config</span>)</span> &#123;</span><br><span class="line">    this.command = <span class="keyword">new</span> <span class="constructor">SqlCommand(<span class="params">config</span>, <span class="params">mapperInterface</span>, <span class="params">method</span>)</span>;</span><br><span class="line">    this.<span class="keyword">method</span> = <span class="keyword">new</span> <span class="constructor">MethodSignature(<span class="params">config</span>, <span class="params">mapperInterface</span>, <span class="params">method</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Object execute(SqlSession sqlSession, Object<span class="literal">[]</span> args) &#123;</span><br><span class="line">    Object result;</span><br><span class="line">    switch (command.get<span class="constructor">Type()</span>) &#123;</span><br><span class="line">      case INSERT: &#123;</span><br><span class="line">      Object param = <span class="keyword">method</span>.convert<span class="constructor">ArgsToSqlCommandParam(<span class="params">args</span>)</span>;</span><br><span class="line">        result = row<span class="constructor">CountResult(<span class="params">sqlSession</span>.<span class="params">insert</span>(<span class="params">command</span>.<span class="params">getName</span>()</span>, param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case UPDATE: &#123;</span><br><span class="line">        Object param = <span class="keyword">method</span>.convert<span class="constructor">ArgsToSqlCommandParam(<span class="params">args</span>)</span>;</span><br><span class="line">        result = row<span class="constructor">CountResult(<span class="params">sqlSession</span>.<span class="params">update</span>(<span class="params">command</span>.<span class="params">getName</span>()</span>, param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case DELETE: &#123;</span><br><span class="line">        Object param = <span class="keyword">method</span>.convert<span class="constructor">ArgsToSqlCommandParam(<span class="params">args</span>)</span>;</span><br><span class="line">        result = row<span class="constructor">CountResult(<span class="params">sqlSession</span>.<span class="params">delete</span>(<span class="params">command</span>.<span class="params">getName</span>()</span>, param));</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      case SELECT:</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">method</span>.returns<span class="constructor">Void()</span><span class="operator"> &amp;&amp; </span><span class="keyword">method</span>.has<span class="constructor">ResultHandler()</span>) &#123;</span><br><span class="line">          execute<span class="constructor">WithResultHandler(<span class="params">sqlSession</span>, <span class="params">args</span>)</span>;</span><br><span class="line">          result = null;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">method</span>.returns<span class="constructor">Many()</span>) &#123;</span><br><span class="line">          result = execute<span class="constructor">ForMany(<span class="params">sqlSession</span>, <span class="params">args</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">method</span>.returns<span class="constructor">Map()</span>) &#123;</span><br><span class="line">          result = execute<span class="constructor">ForMap(<span class="params">sqlSession</span>, <span class="params">args</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">method</span>.returns<span class="constructor">Cursor()</span>) &#123;</span><br><span class="line">          result = execute<span class="constructor">ForCursor(<span class="params">sqlSession</span>, <span class="params">args</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Object param = <span class="keyword">method</span>.convert<span class="constructor">ArgsToSqlCommandParam(<span class="params">args</span>)</span>;</span><br><span class="line">          result = sqlSession.select<span class="constructor">One(<span class="params">command</span>.<span class="params">getName</span>()</span>, param);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      case FLUSH:</span><br><span class="line">        result = sqlSession.flush<span class="constructor">Statements()</span>;</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">BindingException(<span class="string">"Unknown execution method for: "</span> + <span class="params">command</span>.<span class="params">getName</span>()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result<span class="operator"> == </span>null<span class="operator"> &amp;&amp; </span><span class="keyword">method</span>.get<span class="constructor">ReturnType()</span>.is<span class="constructor">Primitive()</span><span class="operator"> &amp;&amp; </span>!<span class="keyword">method</span>.returns<span class="constructor">Void()</span>) &#123;</span><br><span class="line">      throw <span class="keyword">new</span> <span class="constructor">BindingException(<span class="string">"Mapper method '"</span> + <span class="params">command</span>.<span class="params">getName</span>()</span> </span><br><span class="line">          + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + <span class="keyword">method</span>.get<span class="constructor">ReturnType()</span> + <span class="string">")."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，mybatis原理，真相大白。在execute方法中，判断需要执行的sql是insert、update、select，做对应的处理，通过sqlSession执行对应的sql语句。</p><p>这也就解释了为什么xml中的命名空间要和接口全名对应，sql的id要和方法名对应。因为mybatis是在这里通过类名+方法名，定位到某一条sql的。</p><h3 id="dubbo基础原理"><a href="#dubbo基础原理" class="headerlink" title="dubbo基础原理"></a>dubbo基础原理</h3><p>本节本来想借助上面mybatis的原理，我们写一个类似dubbo的rpc框架，但是篇幅内容过长，解释不清，下一次我们一起写一个rpc了解dubbo执行原理。<a href="https://www.ofcoder.com/2019/06/26/java/%E6%89%8B%E5%86%99dubbo%201-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">点击查看 - 手写dubbo</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> dubbo </tag>
            
            <tag> 动态代理 </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈mysql索引实现-B+ Tree</title>
      <link href="/2019/04/01/theory/%E8%B0%88%E8%B0%88mysql%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0-B+Tree/"/>
      <url>/2019/04/01/theory/%E8%B0%88%E8%B0%88mysql%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0-B+Tree/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;本文记录学习mysql索引时，了解到一系列知识点。先从二叉树，到平衡二叉树，再到多路平衡树(B-Tree)，最后到加强版多路平衡查找树(B+Tree)，也就是Mysql默认使用的索引结构。分别解析各自的优缺点。以及最后为什么Mysql选择B+Tree。最后总结对日常开发的影响。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;树，这种数据结构诞生的原因，想必都说腻了。也就是，当你在一堆数据中要查询某个值的时候，你是不是得去遍历所有数据，找到你要的那一个，对不对。当你数据量很大的时候，遍历的成本是非常高。假如你要从一百万个数值中查找你要的值，你有可能就得比较一百万次。那么这个时候树的结构就诞生了。它按照一定规则存储数据，当你查询的时候，按照一定的规则查找数据。它的时间复杂度比你直接遍历要降低数倍。</p><h4 id="二叉查找树-Binary-Search-Tree"><a href="#二叉查找树-Binary-Search-Tree" class="headerlink" title="二叉查找树(Binary Search Tree)"></a>二叉查找树(Binary Search Tree)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;二叉查找树，它将比当前节点小的值全部放在它的左边，当作左子树。将比当前节点大的值放在它的右边，当作右子树。那么它具有以下特性</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;以下为一个标准的二叉查找树。<br><img src="/images/sql/mysql_tree/binary_search_tree_1.png" alt="binary_search_tree"><br>&nbsp;&nbsp;&nbsp;&nbsp;当你要查询某个节点时，二叉查找树的优势就显示出来了。比如你要查询节点<code>14</code>.那么查询的步骤如下：</p><ol><li>跟根节点10比较，14&gt;10，那么向10的右子树查询</li><li>跟节点16比较，14&lt;16，那么向16的左子树查询</li><li>跟节点13比较，14&gt;13，那么向13的右子树查询</li><li>跟节点14比较，14=14，查得结果</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;你以二叉查找树存储数据，查询节点14时，你只需比较4次，而你要是以链表的形式存储，那么你要比较总共进行10比较才可以查询到。当数据量大的时候，这种优势体现的淋漓尽致。但是二叉查找树也有它的缺点。比如当大部分数据都大于或者小于当前节点时，二叉树就夭折了。如下<br><img src="/images/sql/mysql_tree/binary_search_tree_2.png" alt="binary_search_tree"><br>&nbsp;&nbsp;&nbsp;&nbsp;那么这种情况来看，就跟遍历所有数据没有什么区别了，放在数据中，就跟全表遍历没有任何区别。</p><h4 id="平衡二叉查找树-AVL-Tree"><a href="#平衡二叉查找树-AVL-Tree" class="headerlink" title="平衡二叉查找树(AVL Tree)"></a>平衡二叉查找树(AVL Tree)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;上面小节讲到二叉查找树的诞生和致命的缺点，那么本小节介绍的另一种数据结构就是专门解决二叉查找树的缺点的。<br>&nbsp;&nbsp;&nbsp;&nbsp;平衡二叉查找树，是一种结构平衡的二叉搜索树，即叶节点高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。通常都会讲到AVL树、红黑树。它们在增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。<br><img src="/images/sql/mysql_tree/avl_tree_1.png" alt="AVL Tree"><br>&nbsp;&nbsp;&nbsp;&nbsp;当该平衡二叉查找树，增加节点<code>0007</code>的时候，会进行以下步骤</p><ol><li>从根节点查询，找到7应该插入的位置。也就是当作6的右子树<br><img src="/images/sql/mysql_tree/avl_tree_2.png" alt="AVL Tree"></li><li>根据旋转规则，这里以5为中心，6进行左旋。重新恢复平衡。<br><img src="/images/sql/mysql_tree/avl_tree_3.png" alt="AVL Tree"></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;这个时候，我们可以大大的松一口气，我们解决了二叉树致命的缺点，也减少了检索的时间复杂度，那么为什么mysql不使用这种数据结构呢？因为使用AVL树作为索引的数据结构还存在两个问题</p><ol><li>搜索时磁盘IO次数过多</li><li>节点中存放的数据太少</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;第一个问题，是因为数据库中的数据，包括索引一定是存放在硬盘上的，因为数据库中数据少则几个G，多则几个T，这么大的数据不可能存放在内存中，所以存在硬盘中。那么问题就出来了，比较的操作，不可能在硬盘上进行，只能在内存中计算，那么当你要找到节点<code>0003</code>的时候，是不是最少要进行三次IO读取。当总共7个节点的时候，就需要3次的IO读写。当你的数据达到700W的时候，IO次数就很恐怖，而IO读取的效率是非常低效的。<br>&nbsp;&nbsp;&nbsp;&nbsp;第二问题，怎么理解。先要普及另一个知识点，当你的操作系统去读取数据时候，一定是以页为单位去读取的。它不可能根据你要读多少就读多少。一页的大小是4K，当然你可以一次读取4页就是16K的数据。那么回到正题，你觉得每个节点存放了两个子树的地址、自己本身的值、以及其他列的数据所在的地址。足以填满4K的大小吗？肯定是不行的。那么我辛辛苦苦加载一页的数据到内存中，只得到了几十byte的数据。特别是在mysql中，页大小定义是16K。那么肯定是不合适的。</p><h4 id="多路平衡查找树-Balanced-Tree、B-Tree"><a href="#多路平衡查找树-Balanced-Tree、B-Tree" class="headerlink" title="多路平衡查找树(Balanced Tree、B Tree)"></a>多路平衡查找树(Balanced Tree、B Tree)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;B树是一种绝对平衡的树，它从当前节点，到它所有的叶子节点，深度都是相等的。B树，概括来说是一个一般化的二叉查找树（binary search tree），可以拥有多于2个子节点。与自平衡二叉查找树不同，B树为系统大块数据的读写操作做了优化。B树这种数据结构非常适合用来描述外部存储。<br>&nbsp;&nbsp;&nbsp;&nbsp;先感受以下的多路平衡查找树<br><img src="/images/sql/mysql_tree/balance_tree_1.png" alt="Balanced Tree"><br>&nbsp;&nbsp;&nbsp;&nbsp;多路平衡查找树，怎么理解这个路字。回到上一小节把<code>平衡二叉查找树</code>的<code>叉</code>字换成<code>路</code>字，就可以很明了的理解多路平衡查找树了。<br>&nbsp;&nbsp;&nbsp;&nbsp;多路平衡查找树，它的每个节点都存储多个关键字。它每两个相邻的关键字表示的是一个区间，最末端的两个关键字，表示到无穷的区间。那么可以推测，当前节点的路数=它的关键字+1.<br>&nbsp;&nbsp;&nbsp;&nbsp;在以上多路平衡查找树中，当需要查找id为<code>9</code>对应的数据，它的查询步骤则是</p><ol><li>将根节点加载到内存中并比较，9比8大，则向8的右边查找</li><li>将节点10加载到内存中并比较，9比10小，则向左边查找</li><li>这时找到节点9，找到节点9对应数据区。完成查询。</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;那么关键字的个数怎么确定，在mysql中，有一个参数去设置它的页大小的。假如你就设置的是16K，那么一起计算以下，id为int类型（4byte）+关键字对应的子节点引用（假设4byte）+对应存放的数据区（假设8byte）。那么一个关键字是不是就占用16byte的位置，从理论上来说16K就可以存储1000个关键字，这其中不包括磁盘碎片，乱七八糟的因素。<strong>这里又引发另一个思考，也就是说为什么定义字段长度的时候，应该定义它合适的长度就行了。不要过大。</strong>当你定义过大的长度，也就是以上公式的除数变大，那么树的深度就变高。<br>&nbsp;&nbsp;&nbsp;&nbsp;回看平衡二叉查找树的两个缺点是不是都得到了解决。磁盘IO次数过多，是否因为树的深度变矮使得次数降低。每个节点存储的数据太少，是不是通过多关键字得到了解决，每加载一页数据，我都能到我理想的一个数据。所以数据库级别都使用它来作为索引数据结构，它对磁盘的索引是有天然的优势的。<br>&nbsp;&nbsp;&nbsp;&nbsp;回过头来看，我们有说它是一个绝对平衡的树，那么它是怎么保证的呢？以以下树来举例（路数最多为3），插入节点<code>13</code><br><img src="/images/sql/mysql_tree/balance_tree_2.png" alt="Balanced Tree"></p><ol><li>它会找到13可以插入的位置，也就是12的右边<br><img src="/images/sql/mysql_tree/balance_tree_3.png" alt="Balanced Tree"></li><li>但是此时，它违背了上面说的约定，最后的节点它的路数会有4条，这时他会分裂，将12分裂到父节点。完成插入。<br><img src="/images/sql/mysql_tree/balance_tree_4.png" alt="Balanced Tree"></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;从上面步骤来，当分裂到父节点，使得父节点也不满足的时候，就会再往上分裂，那么在你插入时候就会使索引结构发生巨大的变化，<strong>这也就是为什么有的架构师会对你说，某些经常修改的字段、不常使用的字段不建议使用索引。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;重新思考一下，上面的结构update怎么操作。update是分解成delete+insert操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;多路平衡查找树，我们已经讲清楚了，那么mysql还不使用它，还要自己搞一个B+ Tree呢？</p><h4 id="加强版多路平衡查找树-B-Tree"><a href="#加强版多路平衡查找树-B-Tree" class="headerlink" title="加强版多路平衡查找树(B+ Tree)"></a>加强版多路平衡查找树(B+ Tree)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;B+ Tree属于B Tree的一个变种结构，它拥有以下特征</p><ol><li>节点关键字搜索采用闭合区间，关键字=路数</li><li>非叶子节点，不保存数据相关信息，只保存关键字和子节点的引用</li><li>关键字对应的数据保存在叶子节点中</li><li>叶子节点是顺序排列的，并且相邻节点具有顺序引用的关系。形成一个天然有序的链表</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;感受一下它的结构<br><img src="/images/sql/mysql_tree/balance+_tree_1.png" alt="Balanced+ Tree"><br>&nbsp;&nbsp;&nbsp;&nbsp;当他查询数据1时，执行的步骤是</p><ol><li>加载根节点，匹配到1，此时它不会停留</li><li>继续加载下一节点，匹配到1，也不会停留</li><li>一直到叶子节点，因为它的数据保存在叶子节点</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;那么为什么要这样设计呢？它会带来什么好处呢？</p><ol><li>B+ Tree是B Tree的变种，它拥有B Tree的优势</li><li>B+ Tree的扫库、扫表的能力更强</li><li>B+ Tree的磁盘读写能力更强</li><li>B+ Tree排序能力更强</li><li>B+ Tree查询效率更稳定</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;第一点，就是都能解决磁盘IO次数过多，存储的数据太少。<br>&nbsp;&nbsp;&nbsp;&nbsp;第二点，那B Tree来说，当你要基于索引的全表查询，是不是得遍历整棵树，因为数据区散落在各个节点。而B+ Tree，只需要遍历叶子节点。<br>&nbsp;&nbsp;&nbsp;&nbsp;第三点，怎么理解，之前算B Tree每一个节点能保存多少个关键字的时候。算到每一节点都要保存8byte的数据区。而B+ Tree的节点不用保存数据区，是不是每个节点能保存的关键字也就却多。<br>&nbsp;&nbsp;&nbsp;&nbsp;第四点，是因为叶子节点形成了一个天然的有序链表<br>&nbsp;&nbsp;&nbsp;&nbsp;第五点，每次查询都会查询叶子节点，所以它的搜索时间复杂度是一样的。但是有人说，这样的话，那么B Tree的查询效率应该要比B+ Tree快，因为B Tree在第一个节点搜索到了就直接返回了。查询效率这就要看各位的理解了，上面的说法没错，但是B+ Tree不用保存数据区，IO的次数减少了，也会节省效率。</p><h4 id="mysql的B-Tree-具体落地"><a href="#mysql的B-Tree-具体落地" class="headerlink" title="mysql的B+ Tree 具体落地"></a>mysql的B+ Tree 具体落地</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;登陆mysql服务，查询数据保存位置</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="emphasis">'datadir'</span>;</span><br><span class="line"></span><br><span class="line"><span class="code">+---------------+</span>-----------------------------------------+</span><br><span class="line">| Variable<span class="emphasis">_name | Value                                   |</span></span><br><span class="line"><span class="emphasis">+---------------+-----------------------------------------+</span></span><br><span class="line"><span class="emphasis">| datadir       | D:\Program Files (x86)\MySQL\Data\Data\ |</span></span><br><span class="line"><span class="emphasis">+---------------+-----------------------------------------+</span></span><br><span class="line"><span class="emphasis">1 row in set, 1 warning (0.37 sec)</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;在这个目录下，以你的数据名字命名的文件夹。进去看到有以表名字开头文件。</p><ul><li>innodb，以frm或ibd结尾的文件，frm保存表的结构，每一个字段结构等信息。idb保存是数据和索引文件</li><li>myisam，以frm、MYI、MYD，frm保存表的结构，MYI保存索引，MYD保存数据。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;在myisam引擎中，当这个表有多个索引，比如id列和name列都有索引，那么它就是维护了同级别的两颗B+树，每个树的叶子节点的数据区都保存磁盘地址指向MYD中的记录。<br>&nbsp;&nbsp;&nbsp;&nbsp;而在innodb中，由于索引和数据保存在一个文件，所以我们猜测它的数据和索引放在一起。那么多个索引结构的时候，它到底怎么把数据和索引放在一起呢？这是引入一个新概念，<strong>innodb是以主键索引来组织数据的存储。</strong>，如下图所示<br><img src="/images/sql/mysql_tree/mysql_data_1.png" alt="mysq balanced+ Tree"><br>&nbsp;&nbsp;&nbsp;&nbsp;此时我再建一个name字段的索引，这个name字段的叶子节点中保存的是对应的主键的值。也就是说在innodb中，分主索引和辅助索引，主索引组织数据存储，辅助索引引用主索引。也就是我们常说的聚集索引，数据库表行中数据的物理顺序与逻辑（索引）顺序相同。<br>&nbsp;&nbsp;&nbsp;&nbsp;innodb这样设计有什么好处？为什么不直接保存数据的地址？因为保存主键，在主键索引发生结构变化（分裂、合并）时，他的值是不变，但是它的磁盘地址是会变的，如果保存地址的话，那么还得去维护辅助索引的引用地址。</p><h4 id="索引的几大原则"><a href="#索引的几大原则" class="headerlink" title="索引的几大原则"></a>索引的几大原则</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在百度上，或者是一些大佬总结的经验，他们有的是对的，有的是不那么准确的，那么本节我们希望可以在原理上得到验证。</p><h5 id="列的离散型"><a href="#列的离散型" class="headerlink" title="列的离散型"></a>列的离散型</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;离散型计算公式：count(distinct col)/count(col)，就是某一列去重后的数量除以它的总数，就是离散型，这个值越大，离散性越好，选择性就越好。<br>&nbsp;&nbsp;&nbsp;&nbsp;举个例子，用性别这一列作为索引，这一列离散型差，1表示男，2表示女。有以下树结构<br><img src="/images/sql/mysql_tree/mysql_data_2.png" alt="mysq balanced+ Tree"><br>&nbsp;&nbsp;&nbsp;&nbsp;在查询数据1时，和根节点比较，往左查询，到了第二节点的时候，懵逼了，它是不是得把所有得路数都得遍历一次。所以说它选择性差。而且在以前得老师有说过，当列的离散型小于0.15，就会强制全表扫描。</p><h5 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;对索引的关键字做比较时，一定是从左往右进行比较的，且不可跳过。比如果当前节点为’abc’，要比较的字符为’adc’，当匹配到第二个字符时，d大于b，那么走右边。</p><h5 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;联合索引就是由多个列组成的索引，把单列索引理解成特殊的联合索引。相当于说，联合索引的树的每个节点的关键字，是由两个列拼接在一起的。比如果name和phone组成联合索引，那么它存储的关键字就是，<code>jack,13838387438</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;基于最左匹配原则和联合索引原理，我们有得出一个结论，<strong>区别度大的列要放在联合索引前面</strong>，是不是都听过这样一句话，那么现在是不是可以理解了。</p><h5 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果查询的列，通过索引项的信息就可以直接返回，那么该索引称为该查询sql的覆盖索引。<br>&nbsp;&nbsp;&nbsp;&nbsp;为什么会有这个概念，是因为它如果在索引的结构树上就有你要查询的列，那么它就不需要去数据区扫描，大大的减少查询效率。这就是老程序员为什么跟你念，<strong>尽量不要使用<code>select *</code></strong>。</p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ol><li>where条件中，like ‘abc%’、like ‘%9999%’、like ‘%999’ 三种都用不到索引？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一中可以，后面两种用不到，归根结底是最左匹配原则。</span><br><span class="line">但是第一种如果离散性太低，也不会使用索引。</span><br></pre></td></tr></table></figure></li><li>where条件中，not in 和&lt;&gt;无法使用索引，对吗？</li><li>select * from user where concat(name, ‘1’) = ‘far1’<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数的结果无法预料，则不会使用索引</span><br></pre></td></tr></table></figure></li></ol><p><strong>考虑一下下面情况，是否属于正确操作？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 经常查询的sql</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = ?;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = ? <span class="keyword">and</span> phone = ?;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 那么建以下索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> IDX_NAME_IN_USER <span class="keyword">on</span> <span class="keyword">user</span>(<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> IDX_NAME_PHONE_IN_USER <span class="keyword">on</span> <span class="keyword">user</span>(<span class="keyword">name</span>, phone);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;基于最左匹配原则，第一条索引属于冗余索引，如果用其他的扫描工具也会给你报出警告的。</p>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> B-Tree </tag>
            
            <tag> 索引 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式17-可怜人的搜索引擎</title>
      <link href="/2018/11/21/sql/antipatterns/17-%E5%8F%AF%E6%80%9C%E4%BA%BA%E7%9A%84%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
      <url>/2018/11/21/sql/antipatterns/17-%E5%8F%AF%E6%80%9C%E4%BA%BA%E7%9A%84%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="目标：全文搜索"><a href="#目标：全文搜索" class="headerlink" title="目标：全文搜索"></a>目标：全文搜索</h3><p>任何存储文本的应用都有针对某个字段进行查找的需求，随着数据增长，性能成为必经的瓶颈。<br>SQL的一个基本原理就是一列中的单个数据是原子性的，也就是说，你能对两个值进行比较，但通常是把两个值当成两个整体来比较。而你要在SQL中比较子字符串意味着低效和不准确。那么我们该如何高效的查找一个字符的子字符串呢？</p><h3 id="反模式：模式匹配断言"><a href="#反模式：模式匹配断言" class="headerlink" title="反模式：模式匹配断言"></a>反模式：模式匹配断言</h3><p>SQL提供了模式匹配断言来比较字符串，通常是程序员用来搜索关键字的第一选择，最广泛的就是LIKE断言。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> description <span class="keyword">like</span> <span class="string">'%crash%'</span>;</span><br></pre></td></tr></table></figure><p>还有正则表达式也被多数数据库支持，如MYSQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> description REGEXP <span class="string">'crash'</span>;</span><br></pre></td></tr></table></figure><p>模式匹配虽然能实现我们大部分需求，但是最大缺点就是性能问题，它无法从索引上受益，因此必须全表扫描，这是非常恐怖的。</p><p>模式匹配还有一个缺点就是，它会返回莫名奇妙的结果集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> description <span class="keyword">like</span> <span class="string">'%one%'</span>;</span><br></pre></td></tr></table></figure><p>上面模式匹配则会返回money、prone、lonely等单词，即使在两端加上空格也不能避免。虽然mysql对此提出单词匹配的解决方案，但是它仍然是不高效的，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> description REGEXP <span class="string">'[[:&lt;:]]one[[:&gt;:]]'</span>;</span><br></pre></td></tr></table></figure><h3 id="如何识别反模式：当出现以下情况时，可能是反模式"><a href="#如何识别反模式：当出现以下情况时，可能是反模式" class="headerlink" title="如何识别反模式：当出现以下情况时，可能是反模式"></a>如何识别反模式：当出现以下情况时，可能是反模式</h3><ol><li>如何在like表达式的2个通配符之间插入一个变量？</li><li>如何写一个正则表达式来检查一个字符串是否包含多个单词、不包含一个特定的单词，或者包含给定单词的任意形式？</li><li>网站的搜索功能在增加了很多文档进去之后慢的不可理喻。</li></ol><h3 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h3><ol><li>性能是非常重要的，如果一些查询过程很少执行，就不必要花很多功夫去对它进行优化</li><li>使用模式匹配操作进行很复杂的查询是很困难的，但是如果你为了一些简单的需求设计这样的模式匹配，它们能帮助你用最少的工作量获得正确的结果。</li></ol><h3 id="解决方案：使用正确的工具"><a href="#解决方案：使用正确的工具" class="headerlink" title="解决方案：使用正确的工具"></a>解决方案：使用正确的工具</h3><p>最好的解决方案不是优化你的SQL，而是使用搜索引擎。或者另一个可选的方案是将结果保存起来从而减少重复的搜索开销。</p><h4 id="数据库扩展"><a href="#数据库扩展" class="headerlink" title="数据库扩展"></a>数据库扩展</h4><h5 id="MySQL的全文索引"><a href="#MySQL的全文索引" class="headerlink" title="MySQL的全文索引"></a>MySQL的全文索引</h5><p>MySQL在MyISAM存储引擎上提供了一个简单的全文索引类型，你可以在char、varchar、text类型的列上定义一个全文索引。下面的例子在summary和description列上定义全文索引。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> bug <span class="keyword">add</span> fulltext <span class="keyword">index</span> bugfts(<span class="keyword">summary</span>, description);</span><br></pre></td></tr></table></figure><p>可以使用MATCH()函数对索引内容进行搜索。必须在匹配时指定需要全文索引的列（因而你可以在同一张表中对其他列使用不同类型的索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> <span class="keyword">match</span>(summary, description) against(<span class="string">'crash'</span>);</span><br></pre></td></tr></table></figure><h5 id="Oracle的文本索引"><a href="#Oracle的文本索引" class="headerlink" title="Oracle的文本索引"></a>Oracle的文本索引</h5><p>从Oracle8开始，就支持文本索引特性，它的索引非常强大且复杂，这里只是简单介绍</p><ul><li><p>CONTEXT<br>为单个文本列建立这样的索引类型，使用CONTAINS()操作符进行搜索，<strong>索引和数据不同步，所以你每次都得手动重建索引或定期重建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> BugText <span class="keyword">on</span> bug(summary) <span class="keyword">INDEXTYPE</span> <span class="keyword">IS</span> CTSSYS.CONTEXT;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> CONTAINS(summary, <span class="string">'crash'</span>) &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>CTXCAT<br>这样类型的索引是针对短文本设计的，比如用在程序的分类目录上，和同一张表的其他结构化列在一起。这样的索引会保持数据的同步。</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CTX_DDL.CREATE_INDEX_SET(<span class="string">'BugsCatalogSet'</span>);</span><br><span class="line">CTX_DDL.<span class="meta">ADD</span><span class="meta">_INDEX(</span><span class="string">'BugsCatalogSet'</span>, <span class="string">'status'</span>);</span><br><span class="line">CTX_DDL.<span class="meta">ADD</span><span class="meta">_INDEX(</span><span class="string">'BugsCatalogSet'</span>, <span class="string">'priority'</span>);</span><br><span class="line"><span class="meta">CREATE</span> <span class="meta">INDEX</span> BugsCatalog <span class="meta">ON</span> Bug(summary) INDEXTYPE IS CTSSYS.CTXCAT PARAMETERS(<span class="string">'BugsCatalogSet'</span>);</span><br></pre></td></tr></table></figure><p>CATSEARCH()操作符能分别接受两个参数来搜索索引列和结构化的集合。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="function"><span class="keyword">from</span> bug <span class="keyword">where</span> <span class="title">CATSEARCH</span>(<span class="params">summary, <span class="string">'(crash save)'</span>, <span class="string">'status = "NEW"'</span></span>) &gt; 0</span>;</span><br></pre></td></tr></table></figure></li><li><p>CTXXPATH<br>这中索引是针对XML搜索而设计的。使用existsNode()操作符。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> BugTestXml <span class="keyword">ON</span> bug(testoutput) <span class="keyword">INDEXTYPE</span> <span class="keyword">IS</span> CTSSYS.CTXXPATH;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> testoutput.existsNode(<span class="string">'/testsuite/test[@status="fail"]'</span>) &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>CTXRULE<br>假设在数据库中存在大量的文档，然后需要根据文档内容进行分类。使用CTXRULE索引，你可以设计分析文档的规则并返回文档的分类信息。同时，你可以提供一些示例文档以及对应的分类概念，然后让Oracle去分析这个规则并应用到其它文档上。</p></li></ul><h5 id="其他数据库全文索引"><a href="#其他数据库全文索引" class="headerlink" title="其他数据库全文索引"></a>其他数据库全文索引</h5><p>书中还提到SQLServer、PostgreSQL、SQLite。个人没有用到，不是很熟悉，请自行查看。</p><h4 id="第三方搜索引擎"><a href="#第三方搜索引擎" class="headerlink" title="第三方搜索引擎"></a>第三方搜索引擎</h4><p>如果需要搜索功能的代码对不同数据库都通用，那么就需要一个独立于数据库的搜索引擎，这一节介绍两个产品Sphinx Search和Apache Lucene。</p><ul><li><p>Sphinx Search<br>Sphinx Search是一个开源引擎，用于和mysql、postgreSQL配套使用，它构建索引和搜索都很快，而且它还支持分布式查询。对数据不常更新且要求高可扩展性的程序来说，是一个很好的选择。<br>你可以使用Sphinx来索引存在于mysql中的数据，通过修改sphinx.conf中的几个字段，你需要写一个sql查询脚本为构建索引的操作获取数据。这个查询第一列要求为一个整形主键。最后通过sql查询脚本通过给定的主键代码$id，从数据库中获取完整的记录。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- sphinx.conf</span><br><span class="line"><span class="symbol">source</span> <span class="keyword">bugsrc&#123;</span></span><br><span class="line"><span class="keyword"></span>type = mysql</span><br><span class="line">sql_user = <span class="keyword">buguser</span></span><br><span class="line"><span class="keyword"></span>sql_pass = <span class="keyword">bugpass</span></span><br><span class="line"><span class="keyword"></span>sql_db = <span class="keyword">bug</span></span><br><span class="line"><span class="keyword"></span>sql_query = <span class="keyword">select </span><span class="keyword">bug_id, </span>status, date_reported, summary, description from <span class="keyword">bug</span></span><br><span class="line"><span class="keyword"></span>sql_attr_timestamp = date_reported</span><br><span class="line">sql_attr_str2ordinal = status</span><br><span class="line">sql_query_info = <span class="keyword">select </span>* from <span class="keyword">bug </span>where <span class="keyword">bug_id </span>= $id</span><br><span class="line">&#125;</span><br><span class="line"><span class="symbol">index</span> <span class="keyword">bug&#123;</span></span><br><span class="line"><span class="keyword"></span>source = <span class="keyword">bugsrc</span></span><br><span class="line"><span class="keyword"></span>path = /<span class="meta">opt</span>/local/var/db/sphinx/<span class="keyword">bug</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>完成配置后，你可以在shell中使用indexer命令创建索引：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">indexer</span> <span class="selector-tag">-c</span> <span class="selector-tag">sphinx</span><span class="selector-class">.conf</span> <span class="selector-tag">bug</span></span><br></pre></td></tr></table></figure><p>你可以使用search进行搜索</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">search</span> -<span class="keyword">b </span><span class="string">"crash -save"</span></span><br></pre></td></tr></table></figure><p>sphinx 也有对应的API供常用的语言(php、perl、Ruby)调用。sphinx当前的问题是，目前索引算法不支持高效的增量更新。在一个经常更新的数据源上使用sphinx需要一些折中的处理方式。比如，可将搜索的数据拆成两张表 ，第一张存储不变的主体历史数据，第二张存储较小大的当前数据集合，当数据慢慢增长时，就需要重建索引。然后你的程序必须对两个sphinx索引进行搜索。</p></li><li><p>Apache Lucene<br>lucene是一个针对java的成熟搜索引擎，它使用其独特的格式为文本文档创建索引，lucene索引不和元数据保持同步。如果你插入、删除、更新，必须也对lucene索引进行对应的操作。<br>apache提供一个项目叫做solr，solr是lucene索引的网关服务，你可以向solr添加文档或者使用rest风格的接口提交查询请求，这样你可以使用任意语言调用lucene了。<br>你也可以将solr配置成直接连接到数据库，执行一个查询操作，然后使用data-importHandler工具对结果进行索引。</p></li><li><p>实现自己的搜索引擎<br>本节使用一个称为反向索引的方案来实现独立搜索引擎。反向索引就是一个所有可能被搜索的单词列表。在多对多的关系中，索引将这些单词和包含这个单词的文本关联起来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> keyword(</span><br><span class="line">keyword_id <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">keyword <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">unique</span> <span class="keyword">key</span>(keyword)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_keyword(</span><br><span class="line">keyword_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span>(keyword_id, bug_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(keyword_id) <span class="keyword">reference</span> keyword(keyword_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(bug_id) <span class="keyword">reference</span> bug(bug_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>接下来，我们将每个关键字和所匹配到bug添加到bug_keyword中，我们可以使用like查询，获取我们所需要的匹配记录。对于单个单词来说，使用这个查询只有一次，接下来每一次都从索引中获取对应的记录。我们可以使用存储过成完成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> bug_search(keyword <span class="built_in">varchar</span>(<span class="number">40</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">set</span> @keyword = keyword;</span><br><span class="line"><span class="keyword">prepare</span> s1 <span class="keyword">from</span> <span class="string">'select max(keyword_id) into @k from keyword where keyword = ?'</span>;</span><br><span class="line"><span class="keyword">execute</span> s1 <span class="keyword">using</span> @keyword;</span><br><span class="line"><span class="keyword">deallocate</span> <span class="keyword">prepare</span> s1;</span><br><span class="line">if (@k is null) then</span><br><span class="line"><span class="keyword">prepare</span> s2 <span class="keyword">from</span> <span class="string">'insert into keyword(keyword) value (?)'</span>;</span><br><span class="line"><span class="keyword">execute</span> s2 <span class="keyword">using</span> @keyword;</span><br><span class="line"><span class="keyword">deallocate</span> <span class="keyword">prepare</span> s2;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">last_insert_id</span>() <span class="keyword">into</span> @k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">prepare</span> s3 <span class="keyword">from</span> <span class="string">'insert bug_keyword(bug_id, keyword_id) </span></span><br><span class="line"><span class="string">select bug_id, ? from bug </span></span><br><span class="line"><span class="string">where summary regexp concat(''[[:&lt;:]]'', ?, ''[[:&gt;:]]'')</span></span><br><span class="line"><span class="string">or description regexp concat(''[[:&lt;:]]'', ?, ''[[:&gt;:]]'')'</span>;</span><br><span class="line"><span class="keyword">execute</span> s3 <span class="keyword">using</span> @k, @keyword, @keyword;</span><br><span class="line"><span class="keyword">deallocate</span> <span class="keyword">prepare</span> s3;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">prepare</span> s4 <span class="keyword">from</span> <span class="string">'select b.* from bug b</span></span><br><span class="line"><span class="string">join bug_keyword k using(bug_id)</span></span><br><span class="line"><span class="string">where k.keyword_id = ?'</span>;</span><br><span class="line"><span class="keyword">execute</span> s4 <span class="keyword">using</span> @k;</span><br><span class="line"><span class="keyword">deallocate</span> <span class="keyword">prepare</span> s4;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>使用这个存储过程，你需要维护一个触发器，当你插入或删除时，你需要维护bug_keyword的记录</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> bug_insert <span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> bug <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug_keyword(bug_id, keyword_id) </span><br><span class="line"><span class="keyword">select</span> <span class="built_in">new</span>.bug_id, k.keyword_id <span class="keyword">from</span> keyword k</span><br><span class="line"><span class="keyword">where</span> <span class="built_in">new</span>.description regexp concat(<span class="string">'[[:&lt;:]]'</span>, k.keyword, <span class="string">'[[:&gt;:]]'</span>)</span><br><span class="line"><span class="keyword">or</span> <span class="built_in">new</span>.<span class="keyword">summary</span> regexp concat(<span class="string">'[[:&lt;:]]'</span>, k.keyword, <span class="string">'[[:&gt;:]]'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个关键词列表会随着用户不断搜索而自动增长，因此我们不必将知识库中找到的单词都追加到列表中。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>你不必使用sql来解决所有问题</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式16-随机选择</title>
      <link href="/2018/11/03/sql/antipatterns/16-%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9/"/>
      <url>/2018/11/03/sql/antipatterns/16-%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="目的：获取随机样本记录"><a href="#目的：获取随机样本记录" class="headerlink" title="目的：获取随机样本记录"></a>目的：获取随机样本记录</h3><p>从一组数据中随机取几条。这样的需求太太平常了。我们通常把所有的数据读到程序中，由程序再取出随机的样例数据集。其实我们可以直接通过数据库查询拿出这样随机的样例数据。</p><p>本章的目的就是要写出一个仅返回随机数据样本的高效SQL。</p><h3 id="反模式：随机排序"><a href="#反模式：随机排序" class="headerlink" title="反模式：随机排序"></a>反模式：随机排序</h3><p>获取随机记录最常见的SQL语句，就是对查询结果随机排序，然后取第一行。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">rand</span>() <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这样的方式很方便，也很容易理解。但是它的弱点很明显，它意味着整个排序过程无法使用索引，不得不由数据库“手动的”重新排序，也就是全表遍历，它的性能会随着数据量的增长变得越来越慢。</p><h3 id="如何识别反模式：当出现以下情况时，可能是反模式"><a href="#如何识别反模式：当出现以下情况时，可能是反模式" class="headerlink" title="如何识别反模式：当出现以下情况时，可能是反模式"></a>如何识别反模式：当出现以下情况时，可能是反模式</h3><ol><li>在SQL中，返回一个随机行速度非常慢；</li><li>要获取所有的记录然后随机一个。要如何增加程序可使用的内存大小？</li><li>有些列出现的频率比别的列要高一些，这个随机算法不是很随机。</li></ol><h3 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h3><p>这个反模式的特征很明显，它不能使用索引，当数据量大的时候很慢，所以在数据量小的时候，你使用它完全没有问题。</p><h3 id="解决方案：没有具体的顺序…"><a href="#解决方案：没有具体的顺序…" class="headerlink" title="解决方案：没有具体的顺序…"></a>解决方案：没有具体的顺序…</h3><p>随机选择是需要全表遍历并且耗时的进行手动排序的一个典型案例。你预期想办法优化一个不可能被优化的查询，还不如考虑一下别的实现方案。</p><h4 id="从1到最大值之间随机选择"><a href="#从1到最大值之间随机选择" class="headerlink" title="从1到最大值之间随机选择"></a>从1到最大值之间随机选择</h4><p>一种避免对所有数据排序的方法，就是在1到最大主键之间随机选择一个。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b1.* <span class="keyword">from</span> bug b1</span><br><span class="line"><span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">ceil</span>(<span class="keyword">rand</span>() * (<span class="keyword">select</span> <span class="keyword">MAX</span>(bug_id) <span class="keyword">from</span> bug)) <span class="keyword">as</span> rand_id) <span class="keyword">as</span> b2 </span><br><span class="line">  <span class="keyword">on</span> b1.bug_id = b2.rand_id</span><br></pre></td></tr></table></figure><p>这个方案要求主键是连续的，如果主键在中间断了，有可能取到空值。</p><h4 id="选择下一个最大值"><a href="#选择下一个最大值" class="headerlink" title="选择下一个最大值"></a>选择下一个最大值</h4><p>这个方案实在前一个方案上进行修改，解决主键不连续的问题。这个查询会返回它随机找到第一个有效值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b1.* <span class="keyword">from</span> bug b1</span><br><span class="line"><span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">ceil</span>(<span class="keyword">rand</span>() * (<span class="keyword">select</span> <span class="keyword">max</span>(bug_id) <span class="keyword">from</span> bug)) <span class="keyword">as</span> bug_id) <span class="keyword">as</span> b2</span><br><span class="line"><span class="keyword">where</span> b1.bug_id &gt;= b2.bug_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> b1.bug.id</span><br><span class="line"><span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这个方案虽然解决了主键有缝隙的情况，但是当主键缝隙比较大时，它的下一条被选中的概率也会随之增加。</p><h4 id="获取所有键值，随机取一个"><a href="#获取所有键值，随机取一个" class="headerlink" title="获取所有键值，随机取一个"></a>获取所有键值，随机取一个</h4><p>你可以将所有主键读到内存中，然后从内存中随机选一个，再然后根据主键查询对应的记录。这个方案虽然避免了全表遍历，但是它有以下缺点</p><ol><li>你会获取到一个过长列表，有可能超出程序内存极限，导致整个系统瘫痪</li><li>你必须查询两次，如果查询太复杂或太耗时。这也会成为问题所在</li></ol><h4 id="专有的解决方案"><a href="#专有的解决方案" class="headerlink" title="专有的解决方案"></a>专有的解决方案</h4><p>每个数据库都可能正对这个需求提供独有的解决方案，如SQL Server 2005 增加一个TABLE-SAMPLE的子句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">TABLESAMPLE</span>(<span class="number">1</span>, <span class="keyword">ROWS</span>);</span><br></pre></td></tr></table></figure><p>Oracle提供了一个类似的SAMPLE，比如返回表中1%的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">SAMPLE</span>(<span class="number">1</span>) <span class="keyword">order</span> <span class="keyword">by</span> dbms_random.value) <span class="keyword">where</span> <span class="keyword">ROWNUM</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有些查询是无法优化的，换种方法试试看。</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义注解3-组合注解</title>
      <link href="/2018/10/20/java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A33-%E7%BB%84%E5%90%88%E6%B3%A8%E8%A7%A3/"/>
      <url>/2018/10/20/java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A33-%E7%BB%84%E5%90%88%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;组合注解用处很多，只是我们有时没注意而已，比如RestController，PostMapping，GetMapping等。他们的意义在于将多个注解组合在一起，写一个注解就够了。</p><h4 id="定义组合注解"><a href="#定义组合注解" class="headerlink" title="定义组合注解"></a>定义组合注解</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;本节目的在于，组合Cacheable注解，将它的cacheNames写成默认的default（想想第一节最后的讨论）。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Cacheable</span>(cacheNames = <span class="string">"default"</span>)</span><br><span class="line">public <span class="variable">@interface</span> Interest &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">String</span> <span class="selector-tag">key</span>();</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">String</span> <span class="selector-tag">unless</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;其实以上代码就完成了注解组合，你在一个方法上夹Interest注解就相当于加了Cacheable注解。</p><h4 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;以上代码虽然完成了组合，但是你会发现你用spel写key或者unless时。没有提示，也没有高光。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Cacheable</span>(cacheNames = <span class="string">"default"</span>)</span><br><span class="line">public <span class="variable">@interface</span> Interest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@AliasFor</span>(annotation = Cacheable.class)</span><br><span class="line">    String key();</span><br><span class="line"></span><br><span class="line">    <span class="variable">@AliasFor</span>(annotation = Cacheable.class)</span><br><span class="line">    String unless();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;那么现在快去试试吧。你还可以装逼的加上注释。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="variable">@see</span> Cacheable<span class="comment">#key</span></span><br><span class="line"> * <span class="variable">@return</span></span><br><span class="line"> *<span class="regexp">/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> API设计 </tag>
            
            <tag> 注解 </tag>
            
            <tag> 组合注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义注解2-动态修改注解的属性值</title>
      <link href="/2018/10/20/java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A32-%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC/"/>
      <url>/2018/10/20/java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A32-%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;经过上一节的，我们可以自己解析spel表达式。那么我现在的想法是，在注解的第一层aop中解析spel，然后将解析后的值设置到属性中，那么在之后的aop中就不用解析了。</p><h4 id="找出注解中值存放位置"><a href="#找出注解中值存放位置" class="headerlink" title="找出注解中值存放位置"></a>找出注解中值存放位置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;继续上一节的代码，在上一节的AOP中添加注解@Order(0)，再新增一个注解，添加@Order(1)。注意order这个注解有坑的，最好先百度完再使用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterestResolveELAspect</span> </span>&#123;</span><br><span class="line"><span class="comment">// resolve spel... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterestHandleAspect</span> </span>&#123;</span><br><span class="line"><span class="meta">@Around(<span class="meta-string">"@annotation(anno)"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object invoked(ProceedingJoinPoint pjp, Interest anno) throws Throwable &#123;</span><br><span class="line">String key = anno.key();</span><br><span class="line">String unless = anno.unless();</span><br><span class="line">logger.info(<span class="string">"call InterestHandleAspect.invoked, resolvedKey:[&#123;&#125;], resolvedUnless:[&#123;&#125;]"</span></span><br><span class="line">                , key, unless);</span><br><span class="line"><span class="keyword">return</span> pjp.proceed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;我们在上一节代码中的String keySpel = anno.key()打下断点。查看当前栈的变量。<br><img src="/images/java/costom-anno-1.png" alt="操作流程图"><br>&nbsp;&nbsp;&nbsp;&nbsp;发现注解的对象是一个Proxy的实例，Proxy的作用就是为java类生一个代理对象，有这个代理对象去调用真实方法，就像这样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="built_in">String</span> func1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> B <span class="keyword">implements</span> A &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> func1() &#123; <span class="comment">//do something ... &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> func2() &#123; <span class="comment">//do something ... &#125;;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span> ...args) &#123;</span><br><span class="line">    B bInstance = <span class="keyword">new</span> B();</span><br><span class="line">    </span><br><span class="line">    B bProxy = Proxy.newProxyInstance(</span><br><span class="line">        B.class.getClassLoader(),    <span class="comment">// B 类的类加载器</span></span><br><span class="line">        B.class.getInterfaces(), <span class="comment">// B 类所实现的接口，如果你想拦截B类的某个方法，必须让这个方法在某个接口中声明并让B类实现该接口</span></span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123; <span class="comment">// 调用处理器，任何对 B类所实现的接口方法的调用都会触发此处理器</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">Object</span> invoke (<span class="built_in">Object</span> proxy, <span class="comment">// 这个是代理的实例，method.invoke时不能使用这个，否则会死循环</span></span><br><span class="line">                                  Method method, <span class="comment">// 触发的接口方法</span></span><br><span class="line">                                  <span class="built_in">Object</span>[] args <span class="comment">// 此次调用该方法的参数</span></span><br><span class="line">                                  ) throws Throwable &#123;</span><br><span class="line">                System.out.println(<span class="built_in">String</span>.format(<span class="string">"调用 %s 之前"</span>, method.getName()));</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 这里必须使用B类的某个具体实现类的实例，因为触发时这里的method只是一个接口方法的引用，</span></span><br><span class="line"><span class="comment">                 * 也就是说它是空的，你需要为它指定具有逻辑的上下文(bInstance)。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="built_in">Object</span> obj = method.invoke(bInstance, args); </span><br><span class="line">                System.out.println(<span class="built_in">String</span>.format(<span class="string">"调用 %s 之后"</span>, method.getName()));</span><br><span class="line">                <span class="keyword">return</span> obj; <span class="comment">//返回调用结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;再回想注解实质上是一个接口，它本身没有逻辑，那么它的值存在什么地方呢？那么答案就是Proxy实例中了。<br>&nbsp;&nbsp;&nbsp;&nbsp;这个Proxy实例有一个类型为AnnotationInvocationHandler的变量h，我回到上面创建Proxy对象的代码中，Proxy.newProxyInstance()的第三个参数就是InvocationHandler，而这个变量h就是它的实现类。<br>&nbsp;&nbsp;&nbsp;&nbsp;继续往变量h里看，它有一个字段memberValues，是一个map，而在这个map中，我发现了注解值存放的位置。key为注解的属性名，value就是属性值。</p><h4 id="修改注解值"><a href="#修改注解值" class="headerlink" title="修改注解值"></a>修改注解值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;找到了注解值存放位置，那么修改就简单了</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">0</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">InterestResolveELAspect</span> </span>&#123;</span><br><span class="line"> <span class="meta">@Around</span>(<span class="string">"@annotation(anno)"</span>)</span><br><span class="line">    public <span class="built_in">Object</span> invoked(ProceedingJoinPoint pjp, Interest anno) throws Throwable &#123;</span><br><span class="line"><span class="comment">// resolve spel</span></span><br><span class="line">        <span class="built_in">String</span> key = resolve spel;</span><br><span class="line">        Boolean unless = resolve spel;</span><br><span class="line"></span><br><span class="line">InvocationHandler h = Proxy.getInvocationHandler(anno);</span><br><span class="line">        Field hField = h.getClass().getDeclaredField(<span class="string">"memberValues"</span>);</span><br><span class="line">        hField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; memberValues = (<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;) hField.<span class="keyword">get</span>(h);</span><br><span class="line">        memberValues.put(<span class="string">"key"</span>, key);</span><br><span class="line">        memberValues.put(<span class="string">"unless"</span>, unless.toString());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pjp.proceed();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;赶紧测试一下，看看InterestHandleAspect打印的内容是不是你想要的。。。。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> API设计 </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义注解1-实现spel表达式</title>
      <link href="/2018/10/19/java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A31-%E5%AE%9E%E7%8E%B0spel%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/10/19/java/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A31-%E5%AE%9E%E7%8E%B0spel%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;开发中多多少少会使用spel，spel是Spring3引入了Spring表达式语言（Spring Expression Language,SpEL），在一些配置中，注解中经常用到，可谓是神器。比如说spring中的@Cacheable注解，其中key、unless等属性都支持Spel。举个例子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="constructor">Cacheable(<span class="params">key</span>=<span class="string">"#user.name + '_' + #user_phone"</span>, <span class="params">unless</span>=<span class="string">"#user.age &gt; 18"</span>)</span></span><br><span class="line">public Product get<span class="constructor">Product(User <span class="params">user</span>)</span>&#123;</span><br><span class="line"><span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;上面spel表达的意思就是，缓存使用的key由入参属性name和phone组成，当用户的年纪大于18岁时，不进入缓存。<br>&nbsp;&nbsp;&nbsp;&nbsp;但是@Cacheable其中cacheNames这个属性不支持Spel，很痛苦。所以我准备“重复造一次轮子”（解决cacheNames的问题还是有别的方法解决的，所以本文纯属技术交流）</p><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;目的很明确，定义一个支持spel的注解</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> Interest&#123;</span><br><span class="line"><span class="selector-tag">String</span> <span class="selector-tag">key</span>();</span><br><span class="line"><span class="selector-tag">String</span> <span class="selector-tag">unless</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">Interest</span>(key = <span class="string">"#user.name + #user.phone"</span>, unless = <span class="string">"#user.age &gt; 18"</span>)</span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">interest</span>(User user)&#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现Spel"><a href="#实现Spel" class="headerlink" title="实现Spel"></a>实现Spel</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yzker.interest.core.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.LocalVariableTableParameterNameDiscoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.EvaluationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.Expression;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.ExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.standard.SpelExpressionParser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.expression.spel.support.StandardEvaluationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> far.liu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterestResolveELAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(InterestResolveELAspect<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">    LocalVariableTableParameterNameDiscoverer discoverer = <span class="keyword">new</span> LocalVariableTableParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"@annotation(anno)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoked</span><span class="params">(ProceedingJoinPoint pjp, Interest anno)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        Method method = ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line">        String[] params = discoverer.getParameterNames(method);</span><br><span class="line">        EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">0</span>; len &lt; params.length; len++) &#123;</span><br><span class="line">            context.setVariable(params[len], args[len]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String keySpel = anno.key();</span><br><span class="line">        Expression keyExpression = parser.parseExpression(keySpel);</span><br><span class="line">        String key = keyExpression.getValue(context, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String unlessSpel = anno.unless();</span><br><span class="line">        Expression unlessExpression = parser.parseExpression(unlessSpel);</span><br><span class="line">        Boolean unless = unlessExpression.getValue(context, Boolean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"call InterestResolveELAspect.invoked, keySpel:[&#123;&#125;], resolvedKey:[&#123;&#125;], unlessSpel:[&#123;&#125;], resolvedUnless:[&#123;&#125;]"</span></span><br><span class="line">                , keySpel, key, unlessSpel, unless);</span><br><span class="line">        <span class="comment">// todo cache ...</span></span><br><span class="line">        <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上代码是由aop解析spel，缓存处理逻辑未实现，本文重点在解析spel，不在于造轮子，如果不到万不得已不要尝试自己造轮子。<br>&nbsp;&nbsp;&nbsp;&nbsp;说一下关于cacheNames不支持spel。首先得明白cacheNames是干嘛的，在这个注解中，它主要用来配置每一类型的缓存数据过期时间。其实你可以定义一个全局默认的cacheName，所有缓存都使用它，而过期时间你在别的地方修改。不管你是用redis缓存，还是guava缓存，它总的有一个put进缓存的方法，其实你重写它本身的put方法，这里面一般会有过期时间的，你可以在这里根据你的业务场景修改过期时间。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> API设计 </tag>
            
            <tag> 注解 </tag>
            
            <tag> SpEL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式15-模棱两可的分组</title>
      <link href="/2018/10/08/sql/antipatterns/15-%E6%A8%A1%E6%A3%B1%E4%B8%A4%E5%8F%AF%E7%9A%84%E5%88%86%E7%BB%84/"/>
      <url>/2018/10/08/sql/antipatterns/15-%E6%A8%A1%E6%A3%B1%E4%B8%A4%E5%8F%AF%E7%9A%84%E5%88%86%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;假如你的老板想知道哪些项目还处于活跃状态，哪些项目已经停止了。他让你生成一个每个项目最后一个bug提交日期的报表。你查询根据product分组的dete_report的最大值，如下：</p><table><thead><tr><th>product</th><th>latest</th><th>bug_id</th></tr></thead><tbody><tr><td>USQL</td><td>2010-06-01</td><td>1234</td></tr><tr><td>Open RoundFile</td><td>2010-02-16</td><td>3456</td></tr><tr><td>ReConsider</td><td>2010-01-01</td><td>5678</td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;但是你对比全量数据，发现这个结果并不准确。</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>product</th><th>latest</th><th>bug_id</th><th>memo</th></tr></thead><tbody><tr><td>USQL</td><td>2009-12-19</td><td>1234</td><td>这个bug_id…</td></tr><tr><td>USQL</td><td>2010-06-01</td><td>2248</td><td>与这个日期不匹配</td></tr><tr><td>Open RoundFile</td><td>2010-02-16</td><td>3456</td><td>这里又正确</td></tr><tr><td>ReConsider</td><td>2010-01-01</td><td>5678</td><td>这里又正确</td></tr></tbody></table><h4 id="目的：获取每组的最大值"><a href="#目的：获取每组的最大值" class="headerlink" title="目的：获取每组的最大值"></a>目的：获取每组的最大值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;group by 确实很强大，他将复杂的报表生成过程简化到只用一个关键字解决。但是我们要认清group by什么能做，什么不能做。我们分析造成上面的原因。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果我们只需要获取每一个项目和最后一个bug提交的时间。那么可以使用以下语句，他会返回正确的结果。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select product_id, max(date_report) as latest</span><br><span class="line"><span class="keyword">from</span> bug join bug_product using (bug_id)</span><br><span class="line">group by product_id;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;接下来我们对以上语句，进行扩展，让它返回最后一个提交bug的id。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select product_id, max(date_report) as latest, bug_id</span><br><span class="line"><span class="keyword">from</span> bug join bug_product using (bug_id)</span><br><span class="line">group by product_id;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;然而这个查询在不同的数据库中，要么返回一个错误的结果，要么是一个错误的语法。<strong>那么我们本章的目的就是要执行一个不仅返回每组最大值的查询，同时也要返回这个值的其他字段。</strong></p><h4 id="反模式：引用非分组列"><a href="#反模式：引用非分组列" class="headerlink" title="反模式：引用非分组列"></a>反模式：引用非分组列</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;造成这个反模式的根本原因就是程序员对于SQL中分组查询逻辑的普遍误解。</p><h5 id="单值规则"><a href="#单值规则" class="headerlink" title="单值规则"></a>单值规则</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;属于一个组的所有行，他们group by关键字所指的那个字段都是一样的。对于以下查询，<strong>每一组都会返回一条且仅返回一条</strong>，这就是单值规则。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select product_id, max(date_report) as latest</span><br><span class="line"><span class="keyword">from</span> bug join bug_product using (bug_id)</span><br><span class="line">group by product_id;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;跟在select之后的每一列，对于每一组来说都必须返回且仅返回一个值，无论这一组匹配多少行。在这个查询中max()返回每一组最大date_report，它也是遵守单值规则的，所以这个查询返回的结果是正确的。但是你想在这个sql中返回其他的字段，如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select product_id, max(date_report) as latest, bug_id</span><br><span class="line"><span class="keyword">from</span> bug join bug_product using (bug_id)</span><br><span class="line">group by product_id;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，在根据product进行的分组中，每一组将有多个bug_id，也是就是说一个product有多个bug_id，那么它不符合单值规则，数据库就不知道它显示哪一个值是正确的。大多数数据库在这样情况下则会抛出错误，或者给出一个错误的值。</p><h5 id="我想要的查询"><a href="#我想要的查询" class="headerlink" title="我想要的查询"></a>我想要的查询</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;常见的误解就是程序员任务SQL会猜测你需要在报表中显示哪个bug_id，大多数人认为如果查询得到最大值，那么查询返回结果的其他列就会是对应的最大值所在的行的那些值。不幸的是，SQL并没有那么智能，原因如下：</p><ol><li>如果两个bug的date_report值相同并且这两个值就是这一组中的最大值，那么哪个bug_id应该显示到报表中呢？</li><li>如果聚合函数没有匹配到任意一行，那么将显示哪个bug_id，如sum(), count(), avg()。</li><li>如果使用了两个聚合函数，那么SQL该显示哪个bug_id。<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> product_id, <span class="built_in">max</span>(date_report) <span class="keyword">as</span> latest, <span class="built_in">min</span>(date_report) <span class="keyword">as</span> earliest, bug_id</span><br><span class="line"><span class="keyword">from</span> bug <span class="keyword">join</span> bug_product <span class="keyword">using</span> (bug_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> product_id;</span><br></pre></td></tr></table></figure></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;这就是为什么单值规则为何如此重要。所以如果没有单值规则，数据库可靠性会降低，这意味着同样的查询可能是合理的，也可能是不合理的，而唯一的标准竟然是数据的状态！！！</p><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;对于大多数数据库，当你违背了单值原则，会立刻返回一个错误。<br><img src="/images/sql/antipatterns/15/01_error.png" alt="USQL"><br>&nbsp;&nbsp;&nbsp;&nbsp;对于mysql和sqlite，有所不同，mysql在有歧义的列上会返回第一行，而sqlite会返回最后一行，其排序规则是实际的物理存储顺序来决定的。</p><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;如上一小节提到mysql和sqlite不严谨之处，有时我们也可以利用它得到一些便利。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select b.report_by, a.account_name </span><br><span class="line"><span class="keyword">from</span> bug b join account a on b.report_by = a.account_name</span><br><span class="line">group by b.report_by;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上查询虽然违背了单值原则，但是它返回的结果确是正确的，因为report_by 和 account_name 是一对一的关系。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;解决这个反模式的方法就是写不带歧义的SQL，下面将一一说明。</p><h5 id="只查询功能所依赖的列"><a href="#只查询功能所依赖的列" class="headerlink" title="只查询功能所依赖的列"></a>只查询功能所依赖的列</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;最直接的解决办法就是将有歧义的列排除在外。很多时候那些额外的列，我们并不见得用得到。</p><h5 id="使用关联子查询"><a href="#使用关联子查询" class="headerlink" title="使用关联子查询"></a>使用关联子查询</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select </span><span class="keyword">bp1.product_id, </span><span class="keyword">b1.date_report </span>as latest, <span class="keyword">b1.bug_id</span></span><br><span class="line"><span class="keyword">from </span><span class="keyword">bug </span><span class="keyword">b1 </span>join <span class="keyword">bug_product </span><span class="keyword">bp1 </span>using (<span class="keyword">bug_id)</span></span><br><span class="line"><span class="keyword">where </span>not exists(</span><br><span class="line"><span class="keyword">select </span>* from <span class="keyword">bug </span><span class="keyword">b2 </span>join <span class="keyword">bug_product </span><span class="keyword">bp2 </span>using (<span class="keyword">bug_id)</span></span><br><span class="line"><span class="keyword"></span>where <span class="keyword">bp1.product_id </span>on <span class="keyword">bp2.product_id</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">and </span><span class="keyword">b1.date_report </span>&lt; <span class="keyword">b2.date_report</span></span><br><span class="line"><span class="keyword">);</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这个查询简单易懂，但是它的效率是很低的。</p><h5 id="使用衍生表"><a href="#使用衍生表" class="headerlink" title="使用衍生表"></a>使用衍生表</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;使用衍生表比使用关联子查询效率要更高，就是先group by得到一个临时表，然后关联这个临时表</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select m.product_id, m.latest, max(<span class="keyword">b1.bug_id) </span>as latest_bug_id</span><br><span class="line">from <span class="keyword">bug </span><span class="keyword">b1 </span><span class="keyword">join </span><span class="keyword">bug_product </span><span class="keyword">bp1 </span>using(<span class="keyword">bug_id)</span></span><br><span class="line"><span class="keyword">join </span>(</span><br><span class="line">select <span class="keyword">bp2.product_id, </span>max(<span class="keyword">b2.date_report) </span>as latest</span><br><span class="line">from <span class="keyword">bug </span><span class="keyword">b2 </span><span class="keyword">join </span><span class="keyword">bug_product </span><span class="keyword">bp2 </span>using(<span class="keyword">bug_id)</span></span><br><span class="line"><span class="keyword"></span>group <span class="keyword">by </span><span class="keyword">bp2.product_id</span></span><br><span class="line"><span class="keyword">) </span>m on <span class="keyword">bp1.product_id </span>= m.product_id <span class="keyword">and </span><span class="keyword">b1.date_report </span>= m.latest</span><br><span class="line">group <span class="keyword">by </span>m.product_id, m.latest;</span><br></pre></td></tr></table></figure><h5 id="使用join"><a href="#使用join" class="headerlink" title="使用join"></a>使用join</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你可以创建一个外联结查询去匹配那些不存在的记录。如果匹配不存在就会返回NULL，因此，如果查询结果返回了NULL，就知道没有找到相应的记录</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select <span class="keyword">bp1.product_id, </span><span class="keyword">b1.date_report </span>as latest, <span class="keyword">b1.bug_id</span></span><br><span class="line"><span class="keyword">from </span><span class="keyword">bug </span><span class="keyword">b1 </span><span class="keyword">join </span><span class="keyword">bug_product </span><span class="keyword">bp1 </span>on <span class="keyword">b1.bug_id </span>= <span class="keyword">bp1.bug_id</span></span><br><span class="line"><span class="keyword">left </span>outer <span class="keyword">join </span>(</span><br><span class="line"><span class="keyword">bug </span>as <span class="keyword">b2 </span><span class="keyword">join </span><span class="keyword">bug_product </span>as <span class="keyword">bp2 </span>on <span class="keyword">b2.bug_id </span>= <span class="keyword">bp2.bug_id</span></span><br><span class="line"><span class="keyword">) </span>on (</span><br><span class="line"><span class="keyword">bp1.product_id </span>= <span class="keyword">bp2.product_id </span><span class="keyword">and </span><span class="keyword">b1.date_report </span>&lt; <span class="keyword">b2.date_report </span></span><br><span class="line"><span class="keyword">or </span><span class="keyword">b1.date_report </span>= <span class="keyword">b2.data_report </span><span class="keyword">and </span><span class="keyword">b1.bug_id </span>&lt; <span class="keyword">b2.bug_id</span></span><br><span class="line"><span class="keyword">)</span></span><br><span class="line"><span class="keyword">where </span><span class="keyword">b2.bug_id </span>is null;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;你理解这个sql需要花点时间，但是它是一个很重要的工具，它适用于大量数据查询并且可伸缩性比较关键时。</p><h5 id="对额外的列使用聚合函数"><a href="#对额外的列使用聚合函数" class="headerlink" title="对额外的列使用聚合函数"></a>对额外的列使用聚合函数</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你可以使用另一个聚合函数，从而让它遵守单值规则</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> product_id, <span class="built_in">max</span>(date_report) <span class="keyword">as</span> latest,</span><br><span class="line"><span class="built_in">max</span>(bug_id) <span class="keyword">as</span> latest_bug_id</span><br><span class="line"><span class="keyword">from</span> bug <span class="keyword">join</span> bug_product <span class="keyword">using</span>(bug_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> product_id;</span><br></pre></td></tr></table></figure><h5 id="连接同组所有值"><a href="#连接同组所有值" class="headerlink" title="连接同组所有值"></a>连接同组所有值</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;最后还有一个聚合函数可以用来处理bug_id并避免单值规则。mysql和sqlite提出一个叫做group_concat()的函数，它能将这一组中所有值连在一起作为单值返回。默认情况下使用逗号分割。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select product_id, max(date_report), group_concat(bug_id)</span><br><span class="line"><span class="keyword">from</span> bug join bug_product using(bug_id)</span><br><span class="line">group by product_id;</span><br></pre></td></tr></table></figure><table><thead><tr><th>product</th><th>latest</th><th>bug_id</th></tr></thead><tbody><tr><td>USQL</td><td>2010-06-01</td><td>1234,2248</td></tr><tr><td>Open RoundFile</td><td>2010-02-16</td><td>3456,4077,5150</td></tr><tr><td>ReConsider</td><td>2010-01-01</td><td>5678,8063</td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;但是它不会告诉你哪个bug_id对应最新bug，他还有一个缺点，它并非SQL标准函数。其他数据库并不支持这个函数。有些数据库支持自定义函数，如postgreSQL你可以这样写：</td><td></td><td></td></tr><tr><td><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">AGGREGATE</span> GROUP_ARRAY(</span><br><span class="line">BASETYPE = <span class="type">ANYELEMENT</span>,</span><br><span class="line">SFUNC = ARRAY_APPEND,</span><br><span class="line">STYPE = <span class="type">ANYARRAY</span>,</span><br><span class="line">INITCOND = <span class="string">'&#123;&#125;'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> product_id, max(date_report) <span class="keyword">as</span> latest,</span><br><span class="line">ARRAY_TO_STRING(GROUP_ARRAY(BUG_ID), <span class="string">','</span>) <span class="keyword">as</span> bug_id_list</span><br><span class="line"><span class="keyword">from</span> bug <span class="keyword">join</span> bug_product <span class="keyword">using</span>(bug_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> product;</span><br></pre></td></tr></table></figure></td><td></td><td></td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;另一些数据库不支持自定义函数，那么你只能写存储过程遍历一个非分组的查询结果，手动将每个值连在一起。</td><td></td><td></td></tr></tbody></table><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;牢记单值规则，避免模棱两可的查询。</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式14-对未知的恐惧</title>
      <link href="/2018/09/10/sql/antipatterns/14-%E5%AF%B9%E6%9C%AA%E7%9F%A5%E7%9A%84%E6%81%90%E6%83%A7/"/>
      <url>/2018/09/10/sql/antipatterns/14-%E5%AF%B9%E6%9C%AA%E7%9F%A5%E7%9A%84%E6%81%90%E6%83%A7/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;你的account表中有first_name, last_name两个字段，现在有需求要你显示一个完整名字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(first_name, last_name)</span><br><span class="line"> <span class="keyword">as</span> <span class="string">'full_name'</span> <span class="keyword">from</span> <span class="keyword">account</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但是你发现大部分人的名字都不显示了，你查到这些人的first_name都为null，concat出来的结果也为null。</p><h4 id="目的：辨别悬空值"><a href="#目的：辨别悬空值" class="headerlink" title="目的：辨别悬空值"></a>目的：辨别悬空值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;不可避免，数据库中总有些字段是没有值的。SQL支持一个特殊的值，那就是NULL。本章的目的就是要弄清楚如何编写那些包含NULL的查询。</p><h4 id="反模式：将NULL作为普通的值，反之亦然"><a href="#反模式：将NULL作为普通的值，反之亦然" class="headerlink" title="反模式：将NULL作为普通的值，反之亦然"></a>反模式：将NULL作为普通的值，反之亦然</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;开发者都对SQL中的NULL的行为感到茫然无措。SQL将NULL当作一个特殊值，不同于0、false或空字符串。但在Oracle的Sybase中，NULL的意义是长度为0的空字符串。</p><h5 id="在表达式中使用NULL"><a href="#在表达式中使用NULL" class="headerlink" title="在表达式中使用NULL"></a>在表达式中使用NULL</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;在值为NULL的列上进行计算所得的结果也是NULL，NULL和0是不同的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">hour</span> + <span class="number">10</span> <span class="keyword">from</span> bug;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上语句你可能期待，当值为NULL时返回10，但是实际上它返回的NULL<br>&nbsp;&nbsp;&nbsp;&nbsp;NULL和false也是不同的，and、or和not这三个布尔操作如果涉及NULL，其结果也让人感到困惑。</p><h5 id="搜索允许为空的列"><a href="#搜索允许为空的列" class="headerlink" title="搜索允许为空的列"></a>搜索允许为空的列</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果以下查询返回assigned_to为123的行，不包含别的值和NULL：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>你可能觉得以下查询会返回上个查询的补集，也就是所有之前查询没有返回的行：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="function"><span class="keyword">from</span> bug <span class="keyword">where</span> <span class="title">not</span> (<span class="params">assigned_to = <span class="number">123</span></span>)</span></span><br></pre></td></tr></table></figure><p>然而，这个查询都不会返回为NULL的记录。任何和NULL比较都返回“未知”，既不是TRUE，也不是FALSE。如下都得不到你需要的结果</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to &lt;&gt; <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h5 id="在查询参数中使用NULL"><a href="#在查询参数中使用NULL" class="headerlink" title="在查询参数中使用NULL"></a>在查询参数中使用NULL</h5><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select </span>* from <span class="keyword">bug </span>assigned_to = ?</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;你传入一个整型时，会返回你期望的值，但是你不能传入一个NULL。这永远得不到为NULL的行。</p><h5 id="避免上述问题"><a href="#避免上述问题" class="headerlink" title="避免上述问题"></a>避免上述问题</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;为了避免上述问题，很多程序员会定义一个固定的值来取代NULL值。但是这样又会造成以下问题。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table bug(</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">assigned_to <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">hour numeric(9,2) <span class="keyword">not</span> <span class="literal">null</span><span class="built_in"> default </span>-1</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;假如定义hour的悬空值为-1，但是你有没有想过当你SUM，AVG这一列时，会有什么后果。因而你又必须添加一个额外的条件去除这个值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SUM</span>(<span class="keyword">hours</span>) <span class="keyword">from</span> bug <span class="keyword">where</span> <span class="keyword">hours</span> &lt;&gt; <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;接着来看assigned_to，这个外键指向account，当一个bug提交了，还没有人处理，assigned_to应该怎么填写呢？如果你因此去创建一个没有意义的账号，这看起来多么可笑。</p><h4 id="如何识别反模式："><a href="#如何识别反模式：" class="headerlink" title="如何识别反模式："></a>如何识别反模式：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当出现以下情况时，可能是反模式</p><ol><li>我如何将没有值（Null）的列取出来？</li><li>将字符串与Null进行拼接操作，结果返回Null</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;反模式不是使用NULL，反模式是将NULL作为一个普通值处理或者使用一个普通的值来代替NULL。<br>&nbsp;&nbsp;&nbsp;&nbsp;有一种情况可以将NULL视为普通值，那就是导入或者导出数据的时候。</p><h4 id="解决方案：将NULL作为特殊值"><a href="#解决方案：将NULL作为特殊值" class="headerlink" title="解决方案：将NULL作为特殊值"></a>解决方案：将NULL作为特殊值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;你需要理解SQL的三值逻辑。true、false和NULL。</p><h5 id="在标量表达式中使用NULL"><a href="#在标量表达式中使用NULL" class="headerlink" title="在标量表达式中使用NULL"></a>在标量表达式中使用NULL</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;假如Bob的年龄未知，Alice的年龄也未知，我问你，他两谁的年纪大，你肯定回答不知道。那么这就是NULL = NULL的结果是NULL。<br>&nbsp;&nbsp;&nbsp;&nbsp;下表列举一些程序员期望得到某种结果，但是不如人意的情况。<br><img src="/images/sql/antipatterns/14/null_1.png" alt="USQL"></p><h5 id="在布尔表达式中使用NULL"><a href="#在布尔表达式中使用NULL" class="headerlink" title="在布尔表达式中使用NULL"></a>在布尔表达式中使用NULL</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;下表列举一些程序员期望得到某种结果，但是不如人意的情况。<br><img src="/images/sql/antipatterns/14/null_2.png" alt="USQL"></p><h5 id="检索NULL值"><a href="#检索NULL值" class="headerlink" title="检索NULL值"></a>检索NULL值</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你需要使用is null等语句</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;在SQL-99标准中，定义了一个比较断言 is distinct from，它在操作NULL时，会返回true或者false。以下两个查询等价</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">or</span> assigned_to &lt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to <span class="keyword">is</span> <span class="keyword">distinct</span> <span class="keyword">from</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;你也可以将NULL做为参数传入</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> assigned_to <span class="keyword">is</span> <span class="keyword">distinct</span> <span class="keyword">from</span> ?;</span><br></pre></td></tr></table></figure><h5 id="声明NOT-NULL的列"><a href="#声明NOT-NULL的列" class="headerlink" title="声明NOT NULL的列"></a>声明NOT NULL的列</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果NUll会破坏程序逻辑或NULL本身就是毫无意义的，那么使用NOT NULL吧。比如bug表中的date_report, report_by, status。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果有人建议你使用default值，这并不是通用的，比如report_by应该总是非NULL的，如果要定义默认值，那么定义什么默认值。</p><h5 id="动态默认值"><a href="#动态默认值" class="headerlink" title="动态默认值"></a>动态默认值</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你只是某一请求需要使用默认值，那么你就在查询时使用COALESCE()，或者IFNULL()</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="keyword">IFNULL</span>(first_name, <span class="string">''</span>), <span class="keyword">IFNULL</span>(last_name, <span class="string">''</span>)) <span class="keyword">as</span> <span class="string">'full_name'</span> <span class="keyword">from</span> <span class="keyword">account</span>;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;接受NULL来表示任意类型的悬空值</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式13-乱用索引</title>
      <link href="/2018/09/02/sql/antipatterns/13-%E4%B9%B1%E7%94%A8%E7%B4%A2%E5%BC%95/"/>
      <url>/2018/09/02/sql/antipatterns/13-%E4%B9%B1%E7%94%A8%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h4 id="目的：优化性能"><a href="#目的：优化性能" class="headerlink" title="目的：优化性能"></a>目的：优化性能</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;改善性能最好的技术就是合理使用数据库中的索引。索引也是数据结构，他可以帮助快速定位到相应的行，而不需要野蛮的自上而下全表遍历。</p><h4 id="反模式：无规划的使用索引"><a href="#反模式：无规划的使用索引" class="headerlink" title="反模式：无规划的使用索引"></a>反模式：无规划的使用索引</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;软件开发人员通常猜测的来选择索引，那么就不可避免的犯一些错误</p><ol><li>不使用索引或索引不足</li><li>使用了太多索引或者使用了一些无效的索引</li><li>执行一些让索引无能为力的查询</li></ol><h5 id="无索引"><a href="#无索引" class="headerlink" title="无索引"></a>无索引</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;通常我们知道数据库为了保持同步索引会增加额外的开销。每一次insert，update，数据库不得不更新索引的数据结构来保证数据一致。<br>&nbsp;&nbsp;&nbsp;&nbsp;我们已经习惯额外的开销都是浪费的。但却忽略了一个事实，索引能够带给你的好处远远大于它的开销。除了在你select的时候能够快速定位数据。在你update，delete时，索引也能帮你快速找到你要更新的数据。如下SQL，bug_id的索引能有效的提升效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> bug <span class="keyword">set</span> <span class="keyword">status</span> = <span class="string">'FIXED'</span> <span class="keyword">where</span> bug_id = <span class="number">1234</span></span><br></pre></td></tr></table></figure><h5 id="索引太多"><a href="#索引太多" class="headerlink" title="索引太多"></a>索引太多</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你只有在使用索引查询时才能收益。对于那些你不使用的索引，你没有任何好处。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line">bug_id <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">date_report <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">summary varcahr(<span class="number">80</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">hour</span> <span class="built_in">numeric</span>(<span class="number">9</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">index</span>(bug_id),</span><br><span class="line"><span class="keyword">index</span>(summary),</span><br><span class="line"><span class="keyword">index</span>(<span class="keyword">hour</span>),</span><br><span class="line"><span class="keyword">index</span>(bug_id, date_report, <span class="keyword">status</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这个例子中，有几个无用的索引：</p><ul><li>bug_id：为主键，数据库会自动为主键创建索引，因此再定义一个索引就是冗余的操作，这个索引没有任何好处。</li><li>summary：对于长字符串，比如varchar(80)这种类型的索引要比更为紧凑数据类型的索引大很多。而且你好像不可能使用summary进行全匹配查找。</li><li>hour：你不太可能按照特定的值去搜索的列</li><li>bug_id, date_report, status：使用组合查询是一个很好的选择，但大多数人创建的组合索引通常都是冗余索引或很少使用。同样的，组合索引的列的顺序也是很重要的：<strong>你需要在查询条件，联合条件或者排序规则上使用定义索引时的从左到右的顺序。</strong></li></ul><h5 id="索引也无能为力"><a href="#索引也无能为力" class="headerlink" title="索引也无能为力"></a>索引也无能为力</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;接下来常犯的错误就是进行一个无法使用索引的查询。<br>&nbsp;&nbsp;&nbsp;&nbsp;比如电话簿是按照先姓后名的方式对联系人排序的，就像一个按照last_name,first_name顺序创建的联合索引一样，这种索引不能帮你按照名来进行快速查找。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> telephone_book <span class="keyword">on</span> <span class="keyword">account</span>(last_name, first_name);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;那么以下查询无法使用索引</p><ul><li>select * from telephone_book order by first_name, last_name;<br>这个查询就是上面说的，如果你创建了一种先last_name再first_name顺序的索引，那么它是不会帮你先按照first_name进行排序的。</li><li>select * from bug where MONTH(date_report) = 4;<br>即使你为date_report创建了索引，因为在索引中是按照完整的日期来进行排序的，所以你想单独使用它的月份查询是不行的。</li><li>select * from telephone_book where last_name = ‘Charles’ or first_name = ‘Charles’;<br>你定义的是联合索引，那么索引是根据两列进行排序的，所以你无法按照其中某一项来使用索引查询。</li><li>select * from bug where description lisk ‘%crash%’<br>即使你为description定义了索引，由于这个查询断言的匹配字串可能出现在该字段的任何部分，因此索引结构也帮不上忙。</li></ul><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当出现以下情况时，可能是反模式</p><ol><li>这是我的查询语句，怎样使它更快？</li><li>我在每个字段上都定义了索引，为什么它没有变的更？</li><li>我听说索引会使数据库变慢，所以我不使用它。</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你需要设计一个普通的数据库，不了解那些查询时需要重点优化的，你就不能确定哪些索引是最好的。你需要大胆的猜测，你可能创建一些无用的索引，但是你必须去尝试。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>分离率</strong>是衡量索引的一个指标，它是一张表中，所有不重复的数量和总记录条数之比：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">status</span>) / <span class="keyword">count</span>(<span class="keyword">status</span>) <span class="keyword">from</span> bug;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>分离率越低，索引效率就越低</strong>，你需要时刻关注，并抛弃哪些低效的索引。</p><h4 id="解决方案：MENTOR你的索引"><a href="#解决方案：MENTOR你的索引" class="headerlink" title="解决方案：MENTOR你的索引"></a>解决方案：MENTOR你的索引</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;MENTOR：测量(Measure)，解释(Explain)，挑选(Nominate)，测试(Test)，优化(Optimize)，重建(Rebuild)</p><h5 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;大多数据库都提供一些方法来记录执行SQL查询的时效，那么就可以定位到哪些SQL最耗时，并优化。</p><ul><li>Oracle 和 SQL Server都有SQL跟踪功能和工具来生成分析相应报表，SQLServer 称之为 SQL Server Profiler，Oracle称之为TKProf。</li><li>MySQL 和 PostgreSQL 会记录耗时超过一个特定值的查询请求。MySQL称之为慢查询日志，其配置文件中long_query_time项默认为10秒。PostgreSQL有一个类似的配置叫做log_min_duration_statement。</li><li>postgreSQL还有一个配套的工具叫做pgFouine，它能帮助你对查询日志进行分析，并且定位出哪些需要格外注意的查询请求</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;你在做以上操作进行优化时，记得禁止所有缓存，他会影响数值。分析完后记得关闭profiler，或降低profiler运行的频率。</p><h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;找到了最耗时的SQL，接下来就是要找出它之所以慢的原因。每个数据都使用一种优化工具为每次查询选择合适索引。你可以让数据库生成一份它所作做分析的报表。<br>&nbsp;&nbsp;&nbsp;&nbsp;每种数据库的语法不尽相同。</p><table><thead><tr><th>数据库</th><th>QEP报表方案</th></tr></thead><tbody><tr><td>IBM DB2</td><td>EXPLAIN, db2expln命令, Visual Explain</td></tr><tr><td>SQL Server</td><td>SET SHOWPLAN_XML, Display Execution plan</td></tr><tr><td>MySQL</td><td>EXPLAIN</td></tr><tr><td>Oracle</td><td>EXPLAIN PLAN</td></tr><tr><td>PostgreSQL</td><td>EXPLAIN</td></tr><tr><td>SQLite</td><td>EXPLAIN</td></tr></tbody></table><p>&nbsp;&nbsp;&nbsp;&nbsp;看一个简单QEP报表(MySQL)。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">select</span> bug.* <span class="keyword">from</span> bug</span><br><span class="line"><span class="keyword">join</span> (bug_product <span class="keyword">join</span> product <span class="keyword">using</span>(product_id)) <span class="keyword">using</span>(bug_id)</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">summary</span> <span class="keyword">like</span> <span class="string">'%crash%'</span></span><br><span class="line"><span class="keyword">and</span> product_name = <span class="string">'Open RoundFile'</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> date_report <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/sql/antipatterns/13/explain_result.png" alt="QEP报表结果"><br>&nbsp;&nbsp;&nbsp;&nbsp;结果中的key这一列表明这个查询使用的索引。<br>&nbsp;&nbsp;&nbsp;&nbsp;like表达式，强制bug表中进行全表遍历。<br>&nbsp;&nbsp;&nbsp;&nbsp;product.product_name列上没有索引，我们可以建立索引增加效率。</p><h5 id="挑选"><a href="#挑选" class="headerlink" title="挑选"></a>挑选</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;有了报表，你应该挑选出哪些被你漏掉的但能起到比较好效果的索引。数据库都有提供一些工具，你可以详细了解一下，如:</p><ul><li>IBM DB2 Design Advisor</li><li>SQL Server Database Engine Tuning Advisor</li><li>MySQL Enterprise Query Advisor</li><li>Oracle Automatic SQL Tuning Advisor</li></ul><h6 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;这是一个额外的话题，但是他能极大提升效率。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果一个索引包含我们所需要的所有列，那么就不需要再从表中获取数据了。<br>&nbsp;&nbsp;&nbsp;&nbsp;想象一下，如果电话簿中的条目只包含一个页码，在你找到一个名字后，你不得不翻到对应的页码才能获取所需要的号码。如果将这两步整和成一步是不是会更合理，由于电话簿是排序的，所以找到一个名字很快的，然后在一个条目中可以包含一个字段存储电话号码，甚至地址。<br>&nbsp;&nbsp;&nbsp;&nbsp;这就是索引覆盖的作用，你可以定义一个索引包含额外的列，即使这些列对于这个索引来说并不是必须包含的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> bug_convering <span class="keyword">on</span> bug (<span class="keyword">status</span>, bug_id, date_report, report_by, summary)</span><br><span class="line"><span class="comment">-- 2</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">status</span>, bug_id, date_report, report_by, summary <span class="keyword">from</span> bug <span class="keyword">where</span> <span class="keyword">status</span> = <span class="string">'OPEN'</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你定义的索引是1，那么查询语句2就不用去表中查询了，直接在索引的数据结构中就能获取结果，因为查询语句2所查询的所有的列都包含在索引中。</p><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;这一步很重要，在创建完索引后，并不是万事大吉，你需要跟踪那些查询，需要确认你的改动确实提升了性能，然后才能确定工作完成。</p><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;索引是小型的、频繁使用的数据结构，因此很适合常驻内存，毕竟内存操作比磁盘IO要快很多倍。<br>&nbsp;&nbsp;&nbsp;&nbsp;数据库服务允许你配置缓存所需要的系统内存大小，大多数默认配置都是最小的。所以你需要调整这个值。<br>&nbsp;&nbsp;&nbsp;&nbsp;使用索引预加载方法可能要比通过数据库活动本身将最频繁使用的数据与索引放入缓存更有效一点。比如MySQL中，使用LOAD INDEX INTO CACHE 语句。</p><h5 id="重建"><a href="#重建" class="headerlink" title="重建"></a>重建</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;索引在平衡的时候效率是最高的，当你更新或删除时，索引就会不平衡，就如文件系统中随着时间推移产生很多磁盘碎片一样。所以你想最大限度的使用索引，就必须定期对索引进行维护。<br>&nbsp;&nbsp;&nbsp;&nbsp;每个数据库维护索引的语句都有区别</p><table><thead><tr><th>数据库</th><th>索引维护命令</th></tr></thead><tbody><tr><td>DB2</td><td>REBUILD INDEX</td></tr><tr><td>SQL Server</td><td>ALTER INDEX … REORGANIZE, ALTER INDEX … REBUILD, or DBCC DBREINDEX</td></tr><tr><td>MySQL</td><td>ANALYZE TABLE or OPTIMIZE TABLE</td></tr><tr><td>Oracle</td><td>ALTER INDEX … REBUILD</td></tr><tr><td>PostgreSQL</td><td>VACUUM or ANALYZE</td></tr></tbody></table><p>&nbsp;&nbsp;&nbsp;&nbsp;那么多久重建一次索引？这个需要你自己定夺。至于花上一小时时间来重构一个使用很少的索引，获得1%的性能提升，这个也没有必要。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>了解你的数据，了解你的查询请求，然后MENTOR你的索引。</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式12-幽灵文件</title>
      <link href="/2018/08/30/sql/antipatterns/12-%E5%B9%BD%E7%81%B5%E6%96%87%E4%BB%B6/"/>
      <url>/2018/08/30/sql/antipatterns/12-%E5%B9%BD%E7%81%B5%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;在一次灾难中，你的服务器硬件机架整个倾倒，导致大量硬盘损坏，庆幸的是IT部分灾备做的比较好，你们有一份和上次备份一样的完整副本。但是在冒烟测试中你们发现所有的图片都不能加载，这是才想起来所有的文件都存在/var目录下。</p><h4 id="目的：存储图片或其他媒体大文件"><a href="#目的：存储图片或其他媒体大文件" class="headerlink" title="目的：存储图片或其他媒体大文件"></a>目的：存储图片或其他媒体大文件</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;本章的目标就是要存储这些图片并且将其和数据库实体管理起来，当查询这些实体时，我们需要确保同时能获取与其关联的图片。</p><h4 id="反模式：假设你必须使用文件系统"><a href="#反模式：假设你必须使用文件系统" class="headerlink" title="反模式：假设你必须使用文件系统"></a>反模式：假设你必须使用文件系统</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;理论上来说，图片是一个字段，在account表中可能有一个portrait_image列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">account</span>(</span><br><span class="line"><span class="comment">-- some columns</span></span><br><span class="line">portrait_image <span class="built_in">BLOB</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你需要一条记录对应多个文件，比如bug表对应多个截图，你可以建立从属表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> screenshot(</span><br><span class="line">image_id <span class="built_in">serial</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">screenshot_image <span class="built_in">blob</span>,</span><br><span class="line">caption <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">primary <span class="keyword">key</span> (image_id, bug_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(bug_id) <span class="keyword">references</span> bug(bug_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这些都不难理解，最纠结的在于，应该使用将二进制格式存储在blob类型中，还是将文件保存在文件系统中，然后用一个varchar类型来保存路径。这两种方式都有其存在的道理，一般程序员会选择第二种，接下来的几节就是要指明这样设计面临的风险。</p><h5 id="文件不支持delete"><a href="#文件不支持delete" class="headerlink" title="文件不支持delete"></a>文件不支持delete</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;第一个问题就是垃圾回收，如果文件在数据库之外，你想删除包含这个路劲的记录，没有什么办法能自动的删除文件，除非你新写一个脚本程序来监视其“无人领养”的图片。</p><h5 id="文件不支持事务隔离"><a href="#文件不支持事务隔离" class="headerlink" title="文件不支持事务隔离"></a>文件不支持事务隔离</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;通常，当更新或删除数据，在commit之前，所有的更改对其他客户端不可见。然而数据库之外的操作并非如此，当你删除一个文件，对于其他的客户端来说就立刻无法访问该图片，同时你修改文件，其他客户端也可以立即看到，而不是看到在事务提交之前的文件状态。</p><h5 id="文件不支持回滚操作"><a href="#文件不支持回滚操作" class="headerlink" title="文件不支持回滚操作"></a>文件不支持回滚操作</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;出错情况下，或者程序逻辑要求取消变更时，事务回滚再正常不过了。但是当你执行一句delete语句来删除一条记录并同时移除对应的截屏文件，然后你回滚了这个操作，被删除的数据回来了，但是文件没了。</p><h5 id="文件不支持数据库备份工具"><a href="#文件不支持数据库备份工具" class="headerlink" title="文件不支持数据库备份工具"></a>文件不支持数据库备份工具</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;多数数据库都提供了备份工具，如，mysql提供了mysqldump，Oracle提供了rman，postgreSQL提供了pg_dump等。这些工具都不知道如何将路劲引用的那些文件包含在备份操作中。所以你需要记住执行两步来备份：使用数据库备份工具，然后使用文件系统备份工具手机外部文件。即使如此，你也不能保证外部文件和数据库备份是否一致</p><h5 id="文件不支持SQL的访问权限设置"><a href="#文件不支持SQL的访问权限设置" class="headerlink" title="文件不支持SQL的访问权限设置"></a>文件不支持SQL的访问权限设置</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;外部文件会绕开grant 和 revoke SQL语句设定的访问权限，SQL权限管理着对表和列的访问，但他们不能应用到外部文件。</p><h5 id="文件不是sql数据类型"><a href="#文件不是sql数据类型" class="headerlink" title="文件不是sql数据类型"></a>文件不是sql数据类型</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;screenshot_image保存的是路径，数据无法保证这个路劲是否正确，当你修改、移动文件时，数据库也不会更新该字段，这些都依赖于你程序的逻辑。</p><h4 id="如何识别反模式："><a href="#如何识别反模式：" class="headerlink" title="如何识别反模式："></a>如何识别反模式：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;典型的使用反模式的项目通常没有考虑以下几个或者全部问题</p><ol><li>数据备份和恢复的过程是怎样的？怎么对一个备份进行验证？你有没有在一个干净的系统或者别的系统上对备份回复的数据进行测试？</li><li>图片文件堆积在那里，还是当他们孤立的时候就从系统中移除？移除他们的过程是怎么样的？这是一个自动的还是手动的过程？</li><li>系统中的哪些用户有权限查看这些图片？进入权限是怎么限制的？当用户请求查看他们无权查看的图片时会发生什么？</li><li>我能撤销对图片的变更吗？如果能，是应用程序来恢复图片之前的状态吗？</li></ol><h4 id="合理使用反模式："><a href="#合理使用反模式：" class="headerlink" title="合理使用反模式："></a>合理使用反模式：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;如下是将图片或者大文件存储在数据库之外的好理由</p><ol><li>这个数据库在没有图片的时候能精艺很多，因为图片相比于简单的数据类型来说大很多；</li><li>当不包含图片时备份数据库会更快并且备份的文件更小。你必须额外的执行一次文件备份，但这些比备份一个大型数据库要更容易管理；</li><li>如果图片是存储在数据库之外的文件系统中，对图片的预览或者编辑就能够使用更简单直接的处理方式。如果这些图片存在文件系统中的好处是重要的，那么可以将大文件存储在数据库之外。</li><li>一些数据库产品提供了特殊的SQL数据类型，Oracle里面的BFile，SQL Server2008里面的FileStream。</li></ol><h4 id="解决方案：在需要的时候使用BLOB类型。"><a href="#解决方案：在需要的时候使用BLOB类型。" class="headerlink" title="解决方案：在需要的时候使用BLOB类型。"></a>解决方案：在需要的时候使用BLOB类型。</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;如果在以上反模式所描述的问题对你的程序有影响，你需要考虑将文件保存到数据库中。如果你将文件保存到数据库中，以上反模式的风险都将迎刃而解。而且几乎所有的数据库产品都支持BLOB类型，支持你存储任何二进制数据。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你考虑到大文件blob存储不了，大多数据库都帮你考虑到了这一点，比如mysql的mediumblob类型最大存储16M，Oracle的longraw或blob最大支持2GB或4GB的长度。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你的数据库一开始是以文件的形式保存的，一些数据库也提供了加载外部文件的函数，如mysql的load_file()</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> screenshot <span class="keyword">set</span> screenshot_image = <span class="keyword">load_file</span>(<span class="string">"image/usql.png) where image_id = 123;</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;你还可以将二进制直接从blob中提取并显示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> screenshot_image <span class="keyword">into</span> <span class="keyword">dumpfile</span> <span class="string">'image/usql.png'</span> <span class="keyword">from</span> screenshot <span class="keyword">where</span> image_id = <span class="number">123</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;存储在数据库之外的数据不由数据库管理</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式11-每日新花样(限定列的有效值)</title>
      <link href="/2018/08/22/sql/antipatterns/11-%E6%AF%8F%E6%97%A5%E6%96%B0%E8%8A%B1%E6%A0%B7(%E9%99%90%E5%AE%9A%E5%88%97%E7%9A%84%E6%9C%89%E6%95%88%E5%80%BC)/"/>
      <url>/2018/08/22/sql/antipatterns/11-%E6%AF%8F%E6%97%A5%E6%96%B0%E8%8A%B1%E6%A0%B7(%E9%99%90%E5%AE%9A%E5%88%97%E7%9A%84%E6%9C%89%E6%95%88%E5%80%BC)/</url>
      
        <content type="html"><![CDATA[<h4 id="目标：限定列的有效值"><a href="#目标：限定列的有效值" class="headerlink" title="目标：限定列的有效值"></a>目标：限定列的有效值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;限定列的有效值是非常有用的，比如bug表的status，我们定义check约束，让它只允许保存(“NEW”,”IN PROGRESS”,”FIXED”)，那么它就会拒绝所有不存在以上集合中的无效值。但是定义check约束，我们日后改如何修改限定有效值呢？这就是本章所讲的反模式。</p><h4 id="反模式：在列定义上指定可选值-约束"><a href="#反模式：在列定义上指定可选值-约束" class="headerlink" title="反模式：在列定义上指定可选值(约束)"></a>反模式：在列定义上指定可选值(约束)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;很多数据库设计人员趋向于在定义列的时候指定所有可选的有效值。如下DDL：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- check 约束</span><br><span class="line">create table bug(</span><br><span class="line">-- other columns</span><br><span class="line">status varchar(<span class="number">20</span>) check (status in (<span class="string">'NEW'</span>,<span class="string">'IN PROGRESS'</span>,<span class="string">'FIXED'</span>))</span><br><span class="line">);</span><br><span class="line">-- 或者使用mysql支持的<span class="class"><span class="keyword">enum</span>约束</span></span><br><span class="line">create table bug(</span><br><span class="line">-- other columns</span><br><span class="line">status <span class="class"><span class="keyword">enum</span>('<span class="title">NEW</span>','<span class="title">IN</span> <span class="title">PROGRESS</span>','<span class="title">FIXED</span>')</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="中间的是哪个"><a href="#中间的是哪个" class="headerlink" title="中间的是哪个"></a>中间的是哪个</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;假设你开发用户界面，有一个下拉框显示所有的status。你第一反应可能是查询当前正在被使用的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> <span class="keyword">status</span> <span class="keyword">from</span> bug;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;然而，如果所有的bug都是新建的，那么你只能得到NEW这个值。还有如果你使用这个查询来填充你的下拉框，这就会变成一个先有鸡还是有蛋的问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;当然你还有另一种方式，就是获取元数据的值，也就是定义约束的值。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column_type </span><br><span class="line"><span class="keyword">from</span> information_schema.<span class="keyword">columns</span></span><br><span class="line"><span class="keyword">where</span> table_schema = <span class="string">'bugtracker'</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">table_name</span> = <span class="string">'bug'</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">column_name</span> = <span class="string">'status'</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但是你还是无法简单的获取到有效值。如果mysql，以上会返回一个类型为longtext，内容为enum(‘NEW’,’IN PROGRESS’,’FIXED’)的结果，其中包含括号、逗号、引号。你必须编写一点额外的程序来解析这个字符串。</p><h5 id="添加新口味"><a href="#添加新口味" class="headerlink" title="添加新口味"></a>添加新口味</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;没有什么语法能后从enum或者check约束中，添加或删除一个值，你只能使用一个新的集合定义到这个列。如添加一个DUPLICATE的值。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table bug modify column status <span class="class"><span class="keyword">enum</span>('<span class="title">NEW</span>','<span class="title">IN</span> <span class="title">PROGRESS</span>','<span class="title">FIXED</span>', '<span class="title">DUPLICATE</span>');</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这个操作会重新构建一张使用的表，在生产环境应该是极少的，开销也是巨大的。修改了元数据，意味着你要花更大的力气来测试稳定性。</p><h5 id="老的口味永不消失"><a href="#老的口味永不消失" class="headerlink" title="老的口味永不消失"></a>老的口味永不消失</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你打算废弃一个状态，比如，将FIXED状态拆分成CODE COMPLETE和VERIFIED两个状态：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table bug modify column status <span class="class"><span class="keyword">enum</span>('<span class="title">NEW</span>','<span class="title">IN</span> <span class="title">PROGRESS</span>','<span class="title">CODE</span> <span class="title">COMPLETE</span>', '<span class="title">VERIFIED</span>');</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但是大多数情况下，这条语句会执行错误，因为表数据中存在FIXED的值。</p><h5 id="可移植性低"><a href="#可移植性低" class="headerlink" title="可移植性低"></a>可移植性低</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;check约束、域和UDT在各数据库的支持形式是不一致的。enum更加是mysql独有的。</p><h4 id="如何识别反模式："><a href="#如何识别反模式：" class="headerlink" title="如何识别反模式："></a>如何识别反模式：</h4><p>当出现以下情况时，可能是反模式</p><ol><li>我们不得不将数据库下线，才能在程序中加入一个新的选项。</li><li>这个Status列可以填入这些候选值中的一个。我们不应该改变这个后选值列表。</li><li>程序代码中关于业务规则的选项列表和数据库中的值又不同步了。</li></ol><h4 id="解决方案：在数据中指定值"><a href="#解决方案：在数据中指定值" class="headerlink" title="解决方案：在数据中指定值"></a>解决方案：在数据中指定值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;也就是创建一张检查表bug_status，其中bug中每一行的值为bug_status中的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_status(</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">varchar</span>(<span class="number">20</span>) primary <span class="keyword">key</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug_status(<span class="keyword">status</span>) <span class="keyword">values</span>(<span class="string">'NEW'</span>),(<span class="string">'IN PROGRESS'</span>),(<span class="string">'FIXED'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line"><span class="comment">-- other columns</span></span><br><span class="line"><span class="keyword">status</span> <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (<span class="keyword">status</span>) <span class="keyword">references</span> bug_status(<span class="keyword">status</span>) <span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;该设计能让你有效的更新检查表中的值</p><ol><li>增加一个选项<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug_status(<span class="keyword">status</span>)<span class="keyword">values</span>(<span class="string">'DUPLICATE'</span>);</span><br></pre></td></tr></table></figure></li><li>如果外键使用了on update cascade，重命名一个选项<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> bug_status <span class="keyword">set</span> <span class="keyword">status</span> = <span class="string">'INVALID'</span> <span class="keyword">where</span> <span class="keyword">status</span> = <span class="string">'BOGUS'</span>;</span><br></pre></td></tr></table></figure></li><li>支持废弃的数据<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table bug_status <span class="builtin-name">add</span> column active enum(<span class="string">'INACTIVE'</span>,<span class="string">'ACTIVE'</span>) <span class="keyword">not</span> <span class="literal">null</span><span class="built_in"> default </span><span class="string">'ACTIVE'</span>;</span><br><span class="line">update bug_status <span class="builtin-name">set</span> active = <span class="string">'INACTIVE'</span> where status =<span class="string">'DUPLICATE'</span>;</span><br><span class="line">select * <span class="keyword">from</span> bug_status where active = <span class="string">'ACTIVE'</span>;</span><br></pre></td></tr></table></figure></li></ol><h4 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h4><ol><li>在验证固定集合的候选值时使用元数据；</li><li>在验证可变集合的候选值时使用数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式10-取整错误</title>
      <link href="/2018/08/22/sql/antipatterns/10-%E5%8F%96%E6%95%B4%E9%94%99%E8%AF%AF/"/>
      <url>/2018/08/22/sql/antipatterns/10-%E5%8F%96%E6%95%B4%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="目标：使用小数取代整数"><a href="#目标：使用小数取代整数" class="headerlink" title="目标：使用小数取代整数"></a>目标：使用小数取代整数</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;整数是一个很有用的数据类型，但是只能存出整数，但是它不能表示像“2.5”这样的浮点型。如果数据对精度要求很好，你需要使用另一种数据类型来代替整形。当然还要保证运算结果必须正确。</p><h4 id="反模式：使用FLOAT类型"><a href="#反模式：使用FLOAT类型" class="headerlink" title="反模式：使用FLOAT类型"></a>反模式：使用FLOAT类型</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;SQL中的float类型，和其他大多数编程语言的float一样，根据IEEE754标准使用二进制格式编码实数数据。你需要了解一些浮点数的定义规范，才能有效的使用这个数据类型。</p><h5 id="舍入的必要性"><a href="#舍入的必要性" class="headerlink" title="舍入的必要性"></a>舍入的必要性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;很多程序员并不清楚浮点类型的特性：并不是所有十进制中描述的信息都能使用二进制存储。出于一些必要因素，浮点数通常会舍入到一个非常近似的值。<br>&nbsp;&nbsp;&nbsp;&nbsp;举例来说，1/3用一个无限循环的十进制可以表示为0.333<del>~</del>，其真实值无法完整的写出来，因此折中的方法就是限制精度，选择一个尽可能接近原始值的数据，比如0.333。然而，这个数字却不是我们所希望的值。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>/<span class="number">3</span> + <span class="number">1</span>/<span class="number">3</span> + <span class="number">1</span>/<span class="number">3</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0.333</span> + <span class="number">0.333</span> + <span class="number">0.333</span> = <span class="number">0.999</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;即使提高精度，也无法将这三个值加起来等于1.0.这就是使用有限精度的数表示无限小数的必要妥协。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>/<span class="number">3</span> + <span class="number">1</span>/<span class="number">3</span> + <span class="number">1</span>/<span class="number">3</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0.333333</span> + <span class="number">0.333333</span> + <span class="number">0.333333</span> = <span class="number">0.999999</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;IEEE754使用二进制表示浮点数。十进制中的无限小数在二进制中的表达方式是完全不同的。然后一些十进制有限小数，比如0.1，在二进制中确实无限小数。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> * <span class="number">2</span> = <span class="number">0.2</span>     ----<span class="number">-0</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span>     ----<span class="number">-0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span>     ----<span class="number">-0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span>     ----<span class="number">-1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span>     ----<span class="number">-1</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span>     ----<span class="number">-0</span></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="comment">//你懂的 0.0001100110011001100110011001100110011001100110011001101</span></span><br></pre></td></tr></table></figure><h5 id="在SQL中使用FLOAT"><a href="#在SQL中使用FLOAT" class="headerlink" title="在SQL中使用FLOAT"></a>在SQL中使用FLOAT</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;有些数据库能够通过某种方式来弥补数据的不精准性，输出我们期望的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> hourly_rate <span class="keyword">from</span> <span class="keyword">Account</span> <span class="keyword">where</span> account_id=<span class="number">123</span>   ;</span><br><span class="line"><span class="comment">-- Result:59.95</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但float类型的列中实际存储的数据可能并不等于他的值。如果将这个值方法十亿倍，或者将他作为查询条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> hourly_rate * <span class="number">100000000</span> <span class="keyword">from</span> <span class="keyword">Account</span> <span class="keyword">where</span> account_id=<span class="number">123</span>;</span><br><span class="line"><span class="comment">-- Result:59950000762.939</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> hourly_rate = <span class="number">59.95</span>;</span><br><span class="line"><span class="comment">-- Result:empty set; no rows match</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;所以你需要将查询条件修改成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> <span class="keyword">ABS</span>(hourly_rate - <span class="number">59.95</span>) &lt; <span class="number">0.00001</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;另一个使用合计函数计算很多值的时候，影响比较明显，比如使用sum()计算某一列的所有值。举个例子，如果你用<code>1*1.0</code>，无论你执行多少次，结果都是1。但是你用<code>1*0.999</code>，结果就完全不同，执行一千次你的得到的结果约等于0.3677。</p><h4 id="如何识别反模式："><a href="#如何识别反模式：" class="headerlink" title="如何识别反模式："></a>如何识别反模式：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;任何使用Float、Real或者Double Percent类型的设计都有可能是反模式。</p><h4 id="合理使用反模式："><a href="#合理使用反模式：" class="headerlink" title="合理使用反模式："></a>合理使用反模式：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;如果要存储的值取值范围很大，大于integer、numeric的范围，那只能用float了。科学计算类的程序通常使用float。<br>&nbsp;&nbsp;&nbsp;&nbsp;orale使用的float是精准值，而binary_float使用的是IEEE754标准编码。</p><h4 id="解决方案：使用numeric、decimal类型"><a href="#解决方案：使用numeric、decimal类型" class="headerlink" title="解决方案：使用numeric、decimal类型"></a>解决方案：使用numeric、decimal类型</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;使用的numeric或decimal类型来代替float及其类似的数据类型进行固定精度的小数存储。numeric、decimal，他们不会对存储的有理数进行舍入，所以他保存的值和原始的值是一致的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> bug <span class="keyword">add</span> <span class="keyword">column</span> <span class="keyword">hours</span> <span class="built_in">decimal</span>(<span class="number">9</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;其中9代表你可以存储123456789，而1234567890则为非法值。2表示你可以存储1234567.89，而12345678.91、123456.789都为非法值。<br>&nbsp;&nbsp;&nbsp;&nbsp;你依旧不能存储1/3的值，它应该当作非精度的值来处理。</p><h4 id="结论：尽可能不要使用浮点数"><a href="#结论：尽可能不要使用浮点数" class="headerlink" title="结论：尽可能不要使用浮点数"></a>结论：尽可能不要使用浮点数</h4>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 安装 MySQL 服务</title>
      <link href="/2018/08/21/android/Android%20%E5%AE%89%E8%A3%85%20MySQL%20%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/08/21/android/Android%20%E5%AE%89%E8%A3%85%20MySQL%20%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;由于许多原因USQL移除本地MySQL功能，需要者可以参照以下教程来完成。</p><h4 id="介绍：版本为5-1-57编译而来。"><a href="#介绍：版本为5-1-57编译而来。" class="headerlink" title="介绍：版本为5.1.57编译而来。"></a>介绍：版本为5.1.57编译而来。</h4><ul><li>仅支持Myisam数据类型，不支持事务。</li><li>默认编码utf-8，可以支持gb2312。</li><li>默认root密码为123。</li><li>安装手机需要获取root权限。</li></ul><h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><p>地址：<a href="https://www.lanzous.com/i1pc7ni" target="_blank" rel="noopener">https://www.lanzous.com/i1pc7ni</a><br>密码：fr0r</p><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><ol><li>下载好以上压缩包，并解压</li><li>将<code>wj008.net</code>文件夹拷贝到/data目录下，此时路径应该为/data/wj008.net/mysql/**</li><li>把/data/wj008.net/目录下的mysqlstart，mysqlstop 拷贝到/system/bin/目录下</li><li>打开终端（你需要一个可以执行命令的app，如：Ansole），执行以下命令<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#后面为注释，不用执行。</span></span><br><span class="line">su  <span class="comment">#切换到root用户下</span></span><br><span class="line"><span class="keyword">chmod</span> +<span class="keyword">x</span> /<span class="keyword">system</span>/bin/mysqlstart  <span class="comment">#为mysqlstart增加执行权限</span></span><br><span class="line"><span class="keyword">chmod</span> +<span class="keyword">x</span> /<span class="keyword">system</span>/bin/mysqlstop   <span class="comment">#为mysqlstop增加执行权限</span></span><br><span class="line">/<span class="keyword">system</span>/bin/mysqlstart  <span class="comment">#启动mysql</span></span><br></pre></td></tr></table></figure></li><li>关闭mysql.<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/system/</span>bin<span class="regexp">/mysqlstop</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su</span><br><span class="line"><span class="keyword">cd</span> <span class="string">/data/wj008.net/mysql/bin</span></span><br><span class="line"><span class="string">./mysql</span> -u root -p123   <span class="comment">#登录mysql</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;登录成功后，可以尝试创建数据库。如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;该版本默认已经配置了可以远程登录，你可以使用USQL登录，配置如下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主机名：localhost</span><br><span class="line">数据库：test</span><br><span class="line">端口：<span class="number">3306</span></span><br><span class="line">用户名：root</span><br><span class="line">密码：<span class="number">123</span></span><br></pre></td></tr></table></figure><h4 id="有报错，留言说明"><a href="#有报错，留言说明" class="headerlink" title="有报错，留言说明"></a>有报错，留言说明</h4>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> MySQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven打包不能下载插件(maven-clean-plugin)</title>
      <link href="/2018/08/18/java/maven%E6%89%93%E5%8C%85%E4%B8%8D%E8%83%BD%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6(maven-clean-plugin)/"/>
      <url>/2018/08/18/java/maven%E6%89%93%E5%8C%85%E4%B8%8D%E8%83%BD%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6(maven-clean-plugin)/</url>
      
        <content type="html"><![CDATA[<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在一个新环境(新电脑)，第一次执行<code>mvn package</code>，很有可能出先类似问题，具体报错信息如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Downloading</span> <span class="selector-tag">from</span> <span class="selector-tag">central</span>: <span class="selector-tag">https</span>:<span class="comment">//repo.maven.apache.org/maven2/org/apache/maven/plugins/maven-clean-plugin/2.5/maven-clean-plugin-2.5.pom</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> <span class="selector-tag">------------------------------------------------------------------------</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> <span class="selector-tag">BUILD</span> <span class="selector-tag">FAILURE</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> <span class="selector-tag">------------------------------------------------------------------------</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> <span class="selector-tag">Total</span> <span class="selector-tag">time</span>: <span class="selector-tag">4</span><span class="selector-class">.222</span> <span class="selector-tag">s</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> <span class="selector-tag">Finished</span> <span class="selector-tag">at</span>: <span class="selector-tag">2018-08-18T14</span><span class="selector-pseudo">:54</span><span class="selector-pseudo">:25+08</span><span class="selector-pseudo">:00</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> <span class="selector-tag">Final</span> <span class="selector-tag">Memory</span>: <span class="selector-tag">8M</span>/<span class="selector-tag">27M</span></span><br><span class="line"><span class="selector-attr">[INFO]</span> <span class="selector-tag">------------------------------------------------------------------------</span></span><br><span class="line"><span class="selector-attr">[ERROR]</span> <span class="selector-tag">Plugin</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.maven</span><span class="selector-class">.plugins</span><span class="selector-pseudo">:maven-clean-plugin</span><span class="selector-pseudo">:2.5</span> <span class="selector-tag">or</span> <span class="selector-tag">one</span> <span class="selector-tag">of</span> <span class="selector-tag">its</span> <span class="selector-tag">dependencies</span> <span class="selector-tag">could</span> <span class="selector-tag">not</span> <span class="selector-tag">be</span> <span class="selector-tag">resolved</span>: <span class="selector-tag">Failed</span> <span class="selector-tag">to</span> <span class="selector-tag">read</span> <span class="selector-tag">artifact</span> <span class="selector-tag">descriptor</span> <span class="selector-tag">for</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.maven</span><span class="selector-class">.plugins</span><span class="selector-pseudo">:maven-clean-plugin</span><span class="selector-pseudo">:jar</span><span class="selector-pseudo">:2.5</span>: <span class="selector-tag">Could</span> <span class="selector-tag">not</span> <span class="selector-tag">transfer</span> <span class="selector-tag">artifact</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.maven</span><span class="selector-class">.plugins</span><span class="selector-pseudo">:maven-clean-plugin</span><span class="selector-pseudo">:pom</span><span class="selector-pseudo">:2.5</span> <span class="selector-tag">from</span>/<span class="selector-tag">to</span> <span class="selector-tag">central</span> (<span class="attribute">https</span>:<span class="comment">//repo.maven.apache.org/maven2): Received fatal alert: protocol_version -&gt; [Help 1]</span></span><br><span class="line">[ERROR] </span><br><span class="line">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</span><br><span class="line">[ERROR] Re-run Maven using the -X switch to enable full debug logging.</span><br><span class="line">[ERROR] </span><br><span class="line">[ERROR] For more information about the errors and possible solutions, please read the following <span class="attribute">articles</span>:</span><br><span class="line">[ERROR] [Help <span class="number">1</span>] <span class="attribute">http</span>:<span class="comment">//cwiki.apache.org/confluence/display/MAVEN/PluginResolutionException</span></span><br></pre></td></tr></table></figure><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;这个问题还有另一种表现方式，在你请求国外的https网站的接口时，有可能会抛出以下异常：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">javax</span><span class="selector-class">.net</span><span class="selector-class">.ssl</span><span class="selector-class">.SSLHandshakeException</span>: <span class="selector-tag">Received</span> <span class="selector-tag">fatal</span> <span class="selector-tag">alert</span>: <span class="selector-tag">handshake_failure</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这都是因为你请求的网站不支持较低版本的协议。而你需要做的就是将请求的协议设置成它所支持的。你可以去下面网站查询你请求的网站支持的协议。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//myssl.com</span></span><br></pre></td></tr></table></figure><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="maven打包是抛出这个异常"><a href="#maven打包是抛出这个异常" class="headerlink" title="maven打包是抛出这个异常"></a>maven打包是抛出这个异常</h5><p>** 开发中遇到 **</p><ol><li>在idea的Maven Projects 选项卡里右键 package，选择Create ‘XXXX’ [package]。</li><li>在弹出的窗口中，选择Runner里的VM Options中增加-Dhttps.protocols=TLSv1.2<br><img src="/images/java/maven-package-1.png" alt="操作流程图"></li><li>然后执行它。以后就不用执行了，可以正常的mvn clean package.<br><img src="/images/java/maven-package-2.png" alt="操作流程图"></li></ol><p>** 部署时遇到 **<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你在部署中遇到这个问题，此时你只能使用命令，没有idea帮你做上面的事情，你修改$MAVEN_HOME/bin/mvn文件，在第一行添加MAVEN_OPTS=”-Dhttps.protocols=TLSv1.2”，打包好记得去掉。</p><h5 id="请求https接口时抛出该异常"><a href="#请求https接口时抛出该异常" class="headerlink" title="请求https接口时抛出该异常"></a>请求https接口时抛出该异常</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;去我的csdn看吧，有时间再搬过来。<a href="https://blog.csdn.net/gege87417376/article/details/77936507" target="_blank" rel="noopener">https://blog.csdn.net/gege87417376/article/details/77936507</a></p>]]></content>
      
      
      <categories>
          
          <category> 踩坑日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> maven </tag>
            
            <tag> HTTPS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式09-元数据分裂</title>
      <link href="/2018/08/14/sql/antipatterns/09-%E5%85%83%E6%95%B0%E6%8D%AE%E5%88%86%E8%A3%82/"/>
      <url>/2018/08/14/sql/antipatterns/09-%E5%85%83%E6%95%B0%E6%8D%AE%E5%88%86%E8%A3%82/</url>
      
        <content type="html"><![CDATA[<h4 id="目标：支持可扩展性"><a href="#目标：支持可扩展性" class="headerlink" title="目标：支持可扩展性"></a>目标：支持可扩展性</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;随着数据量增长，数据库的查询性能也会随之下降，哪怕查询结果只是很少的几千行，遍历表中积累的数据也可能使整个查询性能变得极差，即使使用了索引，随着数据量增大，索引的作用也变得非常有限。<br>&nbsp;&nbsp;&nbsp;&nbsp;本章目标就是要优化数据库的结构来提升查询性能以及表的平滑扩展。</p><h4 id="反模式：克隆表与克隆列"><a href="#反模式：克隆表与克隆列" class="headerlink" title="反模式：克隆表与克隆列"></a>反模式：克隆表与克隆列</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;根据经验，我们知道查询一张表的性能和这张表的数据条数有关，越少的记录，查询速度更快。于是我们会想办法将每张表存储的记录尽可能少。这就导致本章反模式的两种表现。</p><ol><li>将一张很长的表拆分成多张较小的表，使用表中某一个特定的数据字段来给这些拆分出来的表命名。（比如按条数拆分表）</li><li>将一个列拆分成多个子列，使用别的列中的不同值给拆分出来的列命名。（比如按年份拆分列）</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;为了减少每张表的记录数，你不得不创建一些有很多列的表，或者创建很多很多表。但在这两个方案中，你会发现数据量的增长，会有越来越多的表或者列，迫使你创建新的schema对象。</p><h5 id="不断产生新表"><a href="#不断产生新表" class="headerlink" title="不断产生新表"></a>不断产生新表</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你按照年份来查分表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_2008(...);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_2009(...);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_2010(...);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;在保存数据时，你要操心，什么时候改插入哪张表。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert <span class="keyword">into</span> bug_2010(<span class="params">...</span>, date_report, <span class="params">...</span>) values(<span class="params">...</span>, <span class="string">'2010-01-01'</span>, <span class="params">...</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;在快进入到2010-01-01时，你的程序还有可能报错，原因是你忘记创建一张叫做bug_2010的表。</p><h5 id="管理数据完整性"><a href="#管理数据完整性" class="headerlink" title="管理数据完整性"></a>管理数据完整性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你统计2010年的bug数量时，发现有一部分数据出现了在bug_2009的表中，导致统计数据不正确。这时你需要在每一张表中都声明一个check约束。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table bug_2009(</span><br><span class="line">...</span><br><span class="line">date_report date<span class="built_in"> check </span>(extract(year from date_report) = 2009)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;某一天，你需要修改bug的日期，在数据库中存储的日期是2010-01-03，但顾客实际是在一周前（2009-12-27），使用传真报告的错误。你必须先修改bug_2010，再插入bug_2009，再删除bug_2010.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> bug_2010 <span class="keyword">set</span> date_report = <span class="string">'2009-12-27'</span> <span class="keyword">where</span> bug_id = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug_2009(..., date_report) <span class="keyword">values</span>(</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug_2010 <span class="keyword">where</span> bug_id = <span class="number">1234</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> bug <span class="keyword">where</span> bug_id = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;使用以上sql，你还可能会遇到，在bug_2010中bug_id已经存在bug_2009中，此时你该怎么选择。</p><h5 id="确保唯一性"><a href="#确保唯一性" class="headerlink" title="确保唯一性"></a>确保唯一性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果同步数据中bug_id重复，难倒你了，你可能会想到创建另外一张表，用来生成bug_id</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_id_generator(</span><br><span class="line">bug_id <span class="built_in">serial</span> primary <span class="keyword">key</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug_id_generator(bug_id) <span class="keyword">value</span>(<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug_2010(bug_id, ....)</span><br><span class="line"><span class="keyword">values</span>(<span class="keyword">last_insert_id</span>(), ....);</span><br></pre></td></tr></table></figure><h5 id="跨表查询"><a href="#跨表查询" class="headerlink" title="跨表查询"></a>跨表查询</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;不可避免，你一定有需求要查询所有的数据。此时你只能选择union 将所有的数据联合起来。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> count(<span class="number">1</span>) from (</span><br><span class="line"><span class="keyword">select</span> * from bug_2008</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">all</span></span></span><br><span class="line"><span class="keyword">select</span> * from bug_2009</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">all</span></span></span><br><span class="line"><span class="keyword">select</span> * from bug_2010</span><br><span class="line">) <span class="keyword">as</span> temp;</span><br></pre></td></tr></table></figure><h5 id="同步元数据"><a href="#同步元数据" class="headerlink" title="同步元数据"></a>同步元数据</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你要添加一列作为每个bug解决的时间，你需要同步之前创建的所有表，不然你在使用union语句会报错，或者你不使用通配符(*)，而是一个一个列出你要查询的列。</p><h5 id="管理引用完整性"><a href="#管理引用完整性" class="headerlink" title="管理引用完整性"></a>管理引用完整性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;使用拆分表，你不能建立一个外键约束，是因为sql是不支持的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">comment</span> (</span><br><span class="line">bug_id <span class="built_in">bigint</span> unsiged <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(bug_id) <span class="keyword">references</span> bug_???(bug_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;同时关联查询也是如此，如果你要统计某一个用户提交的所有bug数</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * from account a </span><br><span class="line">join (</span><br><span class="line"><span class="keyword">select</span> * from bug_2008</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">all</span></span></span><br><span class="line"><span class="keyword">select</span> * from bug_2009</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">all</span></span></span><br><span class="line"><span class="keyword">select</span> * from bug_2010</span><br><span class="line">) t on a.account_id = t.report_id</span><br></pre></td></tr></table></figure><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>当出现以下情况时，可能是反模式</p><ol><li>我们需要每……创建一张表或者列？</li><li>数据库支持的最大数量的表或者列是多少？</li><li>发现程序添加记录失败了：因为王佳伟新的一年添加新表了</li><li>如何查询很多张表？每张表的列都是一样的。<br>【如果你需要查询很多结构一样的表，就应该讲数据全部存储在一个表中，使用一个额外的属性列来分组数据】</li><li>如何将表名称作为一个表里传递？在查询是需要根据辩分动态的生成这些表名称。</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;手动分隔表的一个合理使用场景是“归档数据”—–将历史数据从日常使用的数据库中移除。通常在过期数据的查询变的非常稀少的情况下，才会进行如此的操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你没有同时查询当前数据和历史数据的需求，将老数据从当前活动的表转移到其他地方是很合适的操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;将数据归档到与当前表结构相兼容的新表中，既能支持偶尔做数据分析时的查询，同时能让日常数据查询边的非常高效。</p><h4 id="解决方案：分区并标准化"><a href="#解决方案：分区并标准化" class="headerlink" title="解决方案：分区并标准化"></a>解决方案：分区并标准化</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当一张表的数据量非常巨大时，除了手动拆分这张表，还有比这更好的办法来提升查询性能。这些方法包括了水平分区，垂直分区以及使用关联表。</p><h5 id="水平分区"><a href="#水平分区" class="headerlink" title="水平分区"></a>水平分区</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;水平分区（或者叫分片）：根据数据行来对表进行拆分。同时不用担心那些分隔表所带来的缺陷。仅需要定义一些规则来拆分一张逻辑表，数据库会为你管理余下所有的工作。物理上来说，表的确的被拆分了，但你依旧可以向查询单一表那样执行SQL查询语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mysql 5.1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line">bug_id <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">...</span><br><span class="line">date_report <span class="built_in">date</span></span><br><span class="line">) <span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">hash</span>(<span class="keyword">year</span>(date_report)) </span><br><span class="line"><span class="keyword">partitions</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上分割数据库的方式和这章最开始讲到的方式类似，根据date_report列的年份对数据拆分，但是它不用人工维护。实际存储数据的物理表在本例子中被固定设置为4张，当记录的年份跨度超过4年，某一个分区将用来存储多于一年。年份跨度不断增长，这样的现象也会不断重演。你不必添加新的分区，除非分区里面的数据量变得非常巨大，让你觉得需要重新分区。<br>&nbsp;&nbsp;&nbsp;&nbsp;注意：分区在sql标准中没有定义，每个不用的数据库实现这一功能都是非标准的。</p><h5 id="垂直分区"><a href="#垂直分区" class="headerlink" title="垂直分区"></a>垂直分区</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;鉴于水平分区是根据行来拆分，那么垂直分区就是根据列来拆分，将不经常用到的列或者非常庞大的列拆分出来。<br>&nbsp;&nbsp;&nbsp;&nbsp;BLOB或者TEXT类型的列可能是非常大的，有些数据库默认做了拆分存储，如果你查询不包含BLOB或者TEXT速度是非常快的。<br>&nbsp;&nbsp;&nbsp;&nbsp;我们开发可以创建一张额外的表来保存这些庞大的列，多出一列用来关联之前的表。比如product表，要将安装文件保存到数据库。（例子比较极端）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product_install_image(</span><br><span class="line">product_id bugint unsiged primary <span class="keyword">key</span>,</span><br><span class="line">install_image <span class="built_in">blob</span>,</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> product_id <span class="keyword">references</span> product(product_id);</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;还有值得注意，在mysql的MyISAM引擎中，使用固定长度的列是最高效的，比如说char类型比varchar类型要高效。</p><h5 id="解决元数据分裂"><a href="#解决元数据分裂" class="headerlink" title="解决元数据分裂"></a>解决元数据分裂</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;我们在第8章解决过类似的问题，解决元数据分裂的方案就是创建关联表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product_history(</span><br><span class="line">product_id <span class="built_in">bigint</span>,</span><br><span class="line"><span class="keyword">year</span> <span class="built_in">smallint</span>,</span><br><span class="line">big_fix <span class="built_in">int</span>,</span><br><span class="line">primary <span class="keyword">key</span>(product_id, <span class="keyword">year</span>),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (product_id) <span class="keyword">references</span> product(product_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;使用每一个产品、每一列记录一年的bug修复数量，还不如使用多行、仅用一列记录修复的bug数量。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;别让数据繁衍元数据</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式08-多列属性</title>
      <link href="/2018/08/13/sql/antipatterns/08-%E5%A4%9A%E5%88%97%E5%B1%9E%E6%80%A7/"/>
      <url>/2018/08/13/sql/antipatterns/08-%E5%A4%9A%E5%88%97%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;有时候在我们需求中，一条记录会对应多个<br>相同内容的列，比如电话号码：家庭电话、工作电话、手机号码等。那么就需要分四列来存储，而且后面需求可能还加入出差电话、传真号码这些不可预测的分类。</p><h4 id="目标：存储多列属性"><a href="#目标：存储多列属性" class="headerlink" title="目标：存储多列属性"></a>目标：存储多列属性</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;像第2章一样，解决一个属性看上去只属于一张表，但是同时可能会有多个值。<br>&nbsp;&nbsp;&nbsp;&nbsp;这一章，使用bug数据添加标签来举例。一个bug可以存在多个标签。</p><h4 id="反模式：创建多个列"><a href="#反模式：创建多个列" class="headerlink" title="反模式：创建多个列"></a>反模式：创建多个列</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;第2章，我们解决了一列存储一个列表，这是不合适的。这次反模式采用一列存储一个值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line">bug_id <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">description <span class="built_in">varchar</span>(<span class="number">1000</span>),</span><br><span class="line">tag1 <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">tag2 <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">tag3 <span class="built_in">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;当你要根据给定标签(performance)所有bug时，你必须查询所有的三列，因为他可能存在这三列中任意一列。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug</span><br><span class="line"><span class="keyword">where</span> tag1 = <span class="string">'performance'</span> </span><br><span class="line">or tag2 = <span class="string">'performance'</span></span><br><span class="line">or tag3 = <span class="string">'performance'</span></span><br></pre></td></tr></table></figure><p>或者，使用in 的方式来查询</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> <span class="string">'performance'</span> <span class="keyword">in</span> (tag1, tag2, tag3)</span><br></pre></td></tr></table></figure><h5 id="添加及删除值"><a href="#添加及删除值" class="headerlink" title="添加及删除值"></a>添加及删除值</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;在这个设计中添加以及删除也是有问题的，单纯的使用update语句来更新一列是不安全的。举个例子，假如我们事先知道tag2是为null的，于是我们写出以下语句来更新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> bug <span class="keyword">set</span> tag2 = <span class="string">'performance'</span> <span class="keyword">where</span> bug_id = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这条语句是不安全的，假如同时有两个线程执行这个一条语句，结果就是不正确的。或者你可以使用ifnull来避免这个问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> bug <span class="keyword">set</span> tag2 = <span class="keyword">ifnull</span>(<span class="string">'performance'</span>, tag1)</span><br><span class="line"><span class="keyword">where</span> bug_id = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;或者，你可以写出更复杂的语句，但是它是非常耗时的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> bug</span><br><span class="line"><span class="keyword">set</span> tag2 = <span class="keyword">case</span></span><br><span class="line"><span class="keyword">when</span> <span class="string">'performance'</span> <span class="keyword">in</span> (tag1, tag3) <span class="keyword">then</span> tag2</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">coalesce</span>(tag2, <span class="string">'performance'</span>) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">where</span> bug_id = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><h5 id="确保唯一性"><a href="#确保唯一性" class="headerlink" title="确保唯一性"></a>确保唯一性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;在这个设计中，数据库是无法保证在一条记录中不存在相同的值的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug(..., tag1, tag2, tag3) <span class="keyword">values</span>(..., <span class="string">'performance'</span>, <span class="string">'printing'</span>, <span class="string">'performance'</span>);</span><br></pre></td></tr></table></figure><h5 id="处理不断增长的值"><a href="#处理不断增长的值" class="headerlink" title="处理不断增长的值"></a>处理不断增长的值</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;这个设计的另一个弱点就是三列并不够用，当你需要增加新一列时</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> bug <span class="keyword">add</span> <span class="keyword">column</span> tag4 <span class="built_in">varchar</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;如果频繁使用以上语句会存在以下问题：</p><ul><li>重构一张表会锁住整张表，影响客户端访问。</li><li>有些数据库会定义一张符合需求的新表，将现有的数据从旧表中导入新表，在丢弃旧表的方式来实现重构表结构，如果重构的表多，那么转换是相当耗时的。</li><li>新增一列，你需要检查每一条已存在的sql，以保证这些sql能够支持新增的列。</li></ul><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当出现以下情况时，可能是反模式</p><ol><li>应该支持的动态列的数量是多少？</li><li>如何才能在SQL查询中同时查询多列？</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在默写情况下，一个属性可能有固定数量的候选值，并且他们的存储位置和顺序都是固定的。这样的话，可以使用反模式。</p><h4 id="解决方案：创建从属表"><a href="#解决方案：创建从属表" class="headerlink" title="解决方案：创建从属表"></a>解决方案：创建从属表</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;创建另外一张表，保存tag，其中有一列作为外键关联bug表，以上问题迎刃而解。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tag(</span><br><span class="line">bug_id <span class="built_in">bigint</span> unsiged <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">tag <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">primary <span class="keyword">key</span> (bug_id, tag),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (bug_id) <span class="keyword">references</span> bug(bug_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;将具有同样意义的值存储在同一列中。</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API设计-AOP+log4j2(logId)</title>
      <link href="/2018/08/07/java/API%E8%AE%BE%E8%AE%A1-AOP+log4j2(logId)/"/>
      <url>/2018/08/07/java/API%E8%AE%BE%E8%AE%A1-AOP+log4j2(logId)/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;在生产环境下出现bug，都需要靠日志才能定位到问题的关键，而有效的日志往往能让你事半功倍。在生产并发访问情况下，日志纵横交错，那么如何快速找到你要看的日志呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;本章将介绍通过AOP使打印的每一条日志增加一个与业务相关的logId。</p><h4 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="AOP环绕增强controller"><a href="#AOP环绕增强controller" class="headerlink" title="AOP环绕增强controller"></a>AOP环绕增强controller</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;getUnique();没有给出具体实现，大家可以根据自己的业务需求，选择一个合适的值，比如用户id，流水号，都行。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package club.usql.core.aop;</span><br><span class="line"></span><br><span class="line">import club.usql.core.enums.ResponseEnum;</span><br><span class="line">import club.usql.core.facade.domain.vo.ResponseVO;</span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.springframework.core.annotation.Order;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.context.request.RequestContextHolder;</span><br><span class="line">import org.springframework.web.context.request.ServletRequestAttributes;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author far.liu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">@<span class="constructor">Order(0)</span></span><br><span class="line">public <span class="keyword">class</span> ApiLogAspect &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static final Logger logger = <span class="module-access"><span class="module"><span class="identifier">LoggerFactory</span>.</span></span>get<span class="constructor">Logger(ApiLogAspect.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    @<span class="constructor">Around(<span class="string">"execution(public * club.usql..controller.*.*(..))"</span>)</span></span><br><span class="line">    public Object around<span class="constructor">Api(ProceedingJoinPoint <span class="params">pjp</span>)</span> throws Throwable &#123;</span><br><span class="line">        String uri = StringUtils.EMPTY;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object<span class="literal">[]</span> args = pjp.get<span class="constructor">Args()</span>;</span><br><span class="line">            HttpServletRequest request = get<span class="constructor">RequestObj()</span>;</span><br><span class="line">            uri = request.get<span class="constructor">RequestURI()</span>;</span><br><span class="line"></span><br><span class="line">            String unique = get<span class="constructor">Unique(<span class="params">args</span>)</span>;<span class="comment">// not implemented, user_id or seq_no</span></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">ThreadContext</span>.</span></span>put(<span class="string">"unique"</span>, unique);</span><br><span class="line"></span><br><span class="line">            print<span class="constructor">Request(<span class="params">uri</span>, <span class="params">args</span>)</span>;</span><br><span class="line">            Object result = pjp.proceed(args);</span><br><span class="line">            print<span class="constructor">Response(<span class="params">uri</span>, <span class="params">result</span>)</span>;</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">            ResponseVO responseVO = <span class="keyword">new</span> <span class="constructor">ResponseVO(ResponseEnum.UNAUTHORIZED)</span>;</span><br><span class="line">            print<span class="constructor">Response(<span class="params">uri</span>, <span class="params">responseVO</span>)</span>;</span><br><span class="line">            return responseVO;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="comment">// don't forget it</span></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">ThreadContext</span>.</span></span>clear<span class="constructor">All()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest get<span class="constructor">RequestObj()</span> &#123;</span><br><span class="line">        return ((ServletRequestAttributes) <span class="module-access"><span class="module"><span class="identifier">RequestContextHolder</span>.</span></span>get<span class="constructor">RequestAttributes()</span>).get<span class="constructor">Request()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void print<span class="constructor">Request(String <span class="params">uri</span>, Object[] <span class="params">args</span>)</span> &#123;</span><br><span class="line">        logger.info(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">"call uri:%s begin, reqParam:%s"</span>, uri, args.<span class="keyword">to</span><span class="constructor">String()</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void print<span class="constructor">Response(String <span class="params">uri</span>, Object <span class="params">args</span>)</span> &#123;</span><br><span class="line">        logger.info(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">"call uri:%s end, respParam:%s"</span>, uri, args.<span class="keyword">to</span><span class="constructor">String()</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="log4j2-xml"><a href="#log4j2-xml" class="headerlink" title="log4j2.xml"></a>log4j2.xml</h4><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span>&gt;</span>e:/logs<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d %-5p [%t] [unique:%X</span></span></span><span class="template-variable">&#123;unique&#125;</span><span class="xml"><span class="tag"><span class="string">] %C (%F:%L) %m%n"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-06</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">39</span>,<span class="number">456</span> INFO  [thread<span class="number">-495</span>] [unique:<span class="number">101660</span>] club.usql.core.aop.ApiLogAspect(ApiLogAspect.java:<span class="number">56</span>) call uri:/usql/test begin, reqParam:</span><br><span class="line"><span class="number">2018</span><span class="number">-08</span><span class="number">-06</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">39</span>,<span class="number">457</span> INFO  [thread<span class="number">-495</span>] [unique:<span class="number">101660</span>] club.usql.core.aop.ApiLogAspect(ApiLogAspect.java:<span class="number">56</span>) call uri:/usql/test end, respParam:</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;以上代码，能让你在本此请求中，所有打印的日志，会显示你设置的unique，你可以通过这个值获取到关于本次请求的日志，不用担心在并发的情况下要根据可能重复的线程号去定位。</p><h4 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h4><h5 id="less-usql-log"><a href="#less-usql-log" class="headerlink" title="less usql.log"></a>less usql.log</h5><ol><li>G -&gt; 跳转到日志结尾</li><li>g -&gt; 跳转到日志开始</li><li>/interest -&gt; 从当前位置往下搜索interest</li><li>?interest -&gt; 从当前位置往上搜索interest</li></ol><h5 id="tailf-usql-log"><a href="#tailf-usql-log" class="headerlink" title="tailf usql.log"></a>tailf usql.log</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;监听日志文件，有更新立即输出</p><h5 id="grep-interest-a5b5-usql-log-gt-gt-test-log"><a href="#grep-interest-a5b5-usql-log-gt-gt-test-log" class="headerlink" title="grep interest -a5b5 usql.log &gt;&gt; test.log"></a>grep interest -a5b5 usql.log &gt;&gt; test.log</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;将usql.log中的interes上下5行，输出到test.log 中，grep不适用与已经压缩的日志文件，可以使用以下命令</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -dc usql.<span class="built_in">log</span>.gz <span class="string">| grep interest</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 干货 </tag>
            
            <tag> AOP </tag>
            
            <tag> log4j </tag>
            
            <tag> API设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式07-多态关联</title>
      <link href="/2018/08/04/sql/antipatterns/07-%E5%A4%9A%E6%80%81%E5%85%B3%E8%81%94/"/>
      <url>/2018/08/04/sql/antipatterns/07-%E5%A4%9A%E6%80%81%E5%85%B3%E8%81%94/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;允许用户对bug记录进行评论，我们很容易设计出一个一对多的关系。但是随着需求变更，可以进行评论的可能是多张表，比如bug和feature_request都可以进行评论，就会有类似以下的关系。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误的语句，仅用于表现关系</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">comment</span>(</span><br><span class="line">comment_id <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">.......</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(issue_id)</span><br><span class="line"><span class="keyword">reference</span> bug(issue_id) <span class="keyword">or</span> <span class="keyword">reference</span> feature_request(issue_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="目的：关联多个父表"><a href="#目的：关联多个父表" class="headerlink" title="目的：关联多个父表"></a>目的：关联多个父表</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;本章目的很明确，就是要处理多个父表关联同一子表的情况。</p><h4 id="反模式：使用多用途外键"><a href="#反模式：使用多用途外键" class="headerlink" title="反模式：使用多用途外键"></a>反模式：使用多用途外键</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;这个解决方案已经正式命名了，那就是多态关联，或者叫杂乱关联。</p><h5 id="定义多态关联"><a href="#定义多态关联" class="headerlink" title="定义多态关联"></a>定义多态关联</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;为了使用多态关联，你需要多添加一列issue_type用来标识issue_id属于bug还是feature_request，如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">comment</span>(</span><br><span class="line">comment_id <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">issue_type <span class="built_in">varchar</span>(<span class="number">20</span>), <span class="comment">-- BUG or FEATURE_REQUEST</span></span><br><span class="line">author <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">....</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(author) <span class="keyword">reference</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;你会发现使用该设计，issue_id外键没有了，因此就没有任何保障数据完整性的手段来确保issue_id是否存在其父表中。同样的也没有一个约束来保证issue_type是否为一个有效值。</p><h5 id="使用多态关联进行查询"><a href="#使用多态关联进行查询" class="headerlink" title="使用多态关联进行查询"></a>使用多态关联进行查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">comment</span> c</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> bug b <span class="keyword">on</span> c.issue_id = b.issue_id <span class="keyword">and</span> c.issue_type = <span class="string">'BUG'</span></span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> feature_request f <span class="keyword">on</span> c.issue_id = f.issue_id <span class="keyword">and</span> c.issue_type = <span class="string">'FEATURE_REQUEST'</span></span><br></pre></td></tr></table></figure><h4 id="如何识别反模式：当出现以下情况时，可能是反模式"><a href="#如何识别反模式：当出现以下情况时，可能是反模式" class="headerlink" title="如何识别反模式：当出现以下情况时，可能是反模式"></a>如何识别反模式：当出现以下情况时，可能是反模式</h4><ol><li>这种标记框架可以让你将标记(或者其他属性)和数据库中的任何其他资源联系起来。就想EAV的设计一样，应该怀疑任何生成有无线扩展性的设计。</li><li>不能在数据库中声明外键。</li><li>有一列，用来说明这条记录的其他列是和什么相关的。任何外键都强制一张表中所有的行引用同一张表。</li></ol><h4 id="合理使用反模式："><a href="#合理使用反模式：" class="headerlink" title="合理使用反模式："></a>合理使用反模式：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;应该尽量避免使用多态关联，应该使用外键约束等来确保引用完整性。<br>&nbsp;&nbsp;&nbsp;&nbsp;因为：多态关联通常过度依赖上层程序设计而不是数据库的元数据。</p><h4 id="解决方案：让关系变得简单"><a href="#解决方案：让关系变得简单" class="headerlink" title="解决方案：让关系变得简单"></a>解决方案：让关系变得简单</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;既要避免使用多态关联的缺点，又要支持你需要的数据模型，最好就是重新设计数据库，接下来就是要帮你解决这个难题。</p><h5 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;当你看清本质时，解决方案异常简单：多态关联是一个反向关联。</p><h5 id="创建交叉表"><a href="#创建交叉表" class="headerlink" title="创建交叉表"></a>创建交叉表</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;comment无法创建外键，是因为多个外键引用comment表，那么我们为每个外键创建一张独立的交叉表。如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_comment(</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">comment_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span> (issue_id, comment_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (issue_id) <span class="keyword">references</span> bug(issue_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (comment_id) <span class="keyword">references</span> <span class="keyword">comment</span>(comment_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> feature_comment(</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">comment_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span> (issue_id, comment_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (issue_id) <span class="keyword">references</span> feature_request(issue_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (comment_id) <span class="keyword">references</span> <span class="keyword">comment</span>(comment_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这个设计模式，元数据可以确保数据完整性。<br>&nbsp;&nbsp;&nbsp;&nbsp;缺点：如果有更多的类型，你需要创建更多这样的交叉表。联结查询需要多关联一张表。</p><h5 id="共用超级表"><a href="#共用超级表" class="headerlink" title="共用超级表"></a>共用超级表</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;创建一个基类表，并让所有的父表都继承该基类表，关系图如下<br><img src="/images/sql/antipatterns/07/01.png" alt="关系示意图"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> issue(</span><br><span class="line">issue_id <span class="built_in">serial</span> primary <span class="keyword">key</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (issue_id) <span class="keyword">references</span> issue(issue_id),</span><br><span class="line">....</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> feature_request(</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (issue_id) <span class="keyword">references</span> issue(issue_id),</span><br><span class="line">....</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">comment</span>(</span><br><span class="line">comment_id <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">author <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">comment_date datetime,</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (issue_id) <span class="keyword">references</span> issue(issue_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span> (author) <span class="keyword">references</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;给定一个评论，你可以通过一个相对简单的查询就获取对应的bug记录或者feature记录，而不再需要在查询中包含issue表，除非你将一些属性定义在那张表，同样的，由于bug表的主键和他的祖先issue表中的值时一样的，你可以直接对bug和comment表进行关联查询。也可以对两张没有外键约束直接关联的表进行联结查询，只要对应的列的信息是可比较的即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">as</span> c </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> bug <span class="keyword">as</span> b <span class="keyword">using</span>(issue_id)</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> feature <span class="keyword">as</span> f <span class="keyword">using</span>(issue_id)</span><br><span class="line"><span class="keyword">where</span> c.comment_id = <span class="number">1234</span></span><br></pre></td></tr></table></figure><p>对于一个指定bug，你同样可以轻易的查出他的评论</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">as</span> b</span><br><span class="line"><span class="keyword">join</span> <span class="keyword">comment</span> <span class="keyword">as</span> c <span class="keyword">using</span>(issue_id)</span><br><span class="line"><span class="keyword">where</span> b.issue_id = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure><p>更重要的是如果你是用了像issue这样的祖先表，就可以依赖外键来确保数据完整性。<br>在每一个表与表的关系中，都有一个引用表和一个被引用表。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;看完这章，总感觉有点过度设计，我觉得学习以下作者思考的思路就好了，或者以后也用得上这一章的内容。</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式06-实体-属性-值</title>
      <link href="/2018/07/21/sql/antipatterns/06-%E5%AE%9E%E4%BD%93-%E5%B1%9E%E6%80%A7-%E5%80%BC/"/>
      <url>/2018/07/21/sql/antipatterns/06-%E5%AE%9E%E4%BD%93-%E5%B1%9E%E6%80%A7-%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h4 id="目的：支持可变的属性"><a href="#目的：支持可变的属性" class="headerlink" title="目的：支持可变的属性"></a>目的：支持可变的属性</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;可扩展性是程序员所追求的。通常一张表对应一个实体，但是需求中也可能两个实体他们继承同一个父类实体，他们由相同的属性，也有不同属性。<br>&nbsp;&nbsp;&nbsp;&nbsp;bug和feature_request，有相同的属性，我们抽出一个父类issue。<br><img src="/images/sql/antipatterns/06/01_issue.png" alt="关系示意图"></p><h4 id="反模式：使用泛型属性表-EVA"><a href="#反模式：使用泛型属性表-EVA" class="headerlink" title="反模式：使用泛型属性表(EVA)"></a>反模式：使用泛型属性表(EVA)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;对于程序员来说，需要支持可变的属性时，第一发应就是创建一张表(issue_attributes)，它有三个字段</p><ol><li>实体 ： 指向父表的外键</li><li>属性 ： varchar类型，存储属性名字</li><li>值 ：存储对应属性的值<br><img src="/images/sql/antipatterns/06/02_issue.png" alt="关系示意图"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> issue(</span><br><span class="line">issue_id <span class="built_in">serial</span> primary <span class="keyword">key</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> issue_attribute(</span><br><span class="line">issue_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">attr_name <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">attr_value <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span>(issue_id, attr_name),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(issue_id) <span class="keyword">references</span> issue(issue_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><h5 id="查询某一个属性"><a href="#查询某一个属性" class="headerlink" title="查询某一个属性"></a>查询某一个属性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;假如你要查询bug的描述信息，显得比较啰嗦，还不清晰</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> issue_id, attr_value <span class="keyword">as</span> <span class="string">'description'</span> <span class="keyword">from</span> issue_attribute <span class="keyword">where</span> attr_name = <span class="string">'description'</span></span><br></pre></td></tr></table></figure><h5 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你无法保证attr_value是否是一个有效值</p><h5 id="无法声明属性类型"><a href="#无法声明属性类型" class="headerlink" title="无法声明属性类型"></a>无法声明属性类型</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;无法使用SQL的数据类型，比如对日期、金钱等格式内容都只能保持为字符串类型；</p><h5 id="无法确保引用完整性"><a href="#无法确保引用完整性" class="headerlink" title="无法确保引用完整性"></a>无法确保引用完整性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你不能对attr_value声明外键约束，比如说status，你不能保证status的值一定存在status表中</p><h5 id="无法确定属性名"><a href="#无法确定属性名" class="headerlink" title="无法确定属性名"></a>无法确定属性名</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;假如有两条数据，一条的attr_name是sex，一条attr_name是gender，都是表示性别</p><h5 id="查询结果中有多个属性时，异常困难"><a href="#查询结果中有多个属性时，异常困难" class="headerlink" title="查询结果中有多个属性时，异常困难"></a>查询结果中有多个属性时，异常困难</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> i.issue_id,</span><br><span class="line">i1.attr_value <span class="keyword">as</span> <span class="string">'date_reported'</span>,</span><br><span class="line">i2.attr_value <span class="keyword">as</span> <span class="string">'status'</span></span><br><span class="line"><span class="keyword">from</span> issue i </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> issue_attribute i1 <span class="keyword">on</span> i.issue_id = i1.issue_id <span class="keyword">and</span> attr_name = <span class="string">'date_reported'</span></span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> issue_attribute i2 <span class="keyword">on</span> i.issue_id = i2.issue_id <span class="keyword">and</span> attr_name = <span class="string">'status'</span></span><br></pre></td></tr></table></figure><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>当出现以下情况时，可能是反模式</p><ol><li>数据库不需要修改元数据库（表中的列属性）就可以扩展。还可以在运行时定义新的属性。</li><li>查询是连接数量非常多，且连接的数量可能会达到数据库的限制时，你的数据库的设计可能是有问题的。</li><li>普通的报表查询变的及其复杂甚至不且实际。</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>优点：</p><ol><li>表中的列很少；</li><li>新增属性时，不需要新增列。不会影响现有表的结构；</li><li>存储的字段内容不会为空值。</li></ol><p>缺点：上面列了一大段</p><p>如果真的有非关系数据管理需求，那最好使用nosql数据库</p><h4 id="解决方案：模型化子类型"><a href="#解决方案：模型化子类型" class="headerlink" title="解决方案：模型化子类型"></a>解决方案：模型化子类型</h4><h5 id="单表继承"><a href="#单表继承" class="headerlink" title="单表继承"></a>单表继承</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;所有属性都在一个单表上保存，使用issue_type来标识哪一个子类，子类属性必须支持null。<br>&nbsp;&nbsp;&nbsp;&nbsp;缺点：</p><ol><li>当程序加入新对象时，必须修改数据库来适应这些新对象，而张表的列的数量是有限制的。</li><li>没有任何的元信息来记录哪个属性属于哪个子类型。</li></ol><h5 id="实体表继承"><a href="#实体表继承" class="headerlink" title="实体表继承"></a>实体表继承</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;为每个子类型创建一张独立的表，每个表包含哪些属于基类的共有属性，同时也包含了子类型特殊化的属性。<br>&nbsp;&nbsp;&nbsp;&nbsp;优点：</p><ol><li>你可以像使用普通表那样来使用</li><li>相比于单表继承，新增对象时，你只需要新增表，而不需要修改之前的表结构</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;缺点：</p><ol><li>难将通用属性和子类特有属性区分开来。因此，如果将一个新的属性增加到通用属性中，必须为每个子类表都添加一遍。</li></ol><h5 id="类表继承"><a href="#类表继承" class="headerlink" title="类表继承"></a>类表继承</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;把表当成面向对象里的类，这可能也是最容易想到的吧，创建一张基表存储子类相同的字段，每一个子类创建一张表，添加一列执行基表的外键</p><h5 id="半结构化数据模型"><a href="#半结构化数据模型" class="headerlink" title="半结构化数据模型"></a>半结构化数据模型</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果有很多子类型或者必须经常增加新的属性支持，那么可以用一个BLOB列来存储JSON数据，缺点是，这样的结构中sql无法获取某个指定的属性。你必须或者整个blob字段并通过程序去解释这些属性。<br>&nbsp;&nbsp;&nbsp;&nbsp;当你需要绝对的灵活性时，可以使用这个方案。</p><h5 id="你接手一个EAV项目"><a href="#你接手一个EAV项目" class="headerlink" title="你接手一个EAV项目"></a>你接手一个EAV项目</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你无奈接手一个EAV项目，你需要衡量在数据库中处理数据好还是在程序代码中处理好，比如说查询</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> issue_attribute <span class="keyword">where</span> issue_id = <span class="number">1444</span>;</span><br></pre></td></tr></table></figure><p>查出所有行，在程序代码中遍历，明显要比在数据库中使用无限的联结查询要好。</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ActiveMQ解析-客户端（消息发送端）</title>
      <link href="/2018/07/21/middleware/activemq-producter/"/>
      <url>/2018/07/21/middleware/activemq-producter/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;本篇主要粗略介绍程序在启动时，连接mq做了哪些操作，你可能需要先自己阅读一遍源码，再来看本篇文章，或对照源码看本篇文章</p><h3 id="1-抛开spring，创建一个简单生产者"><a href="#1-抛开spring，创建一个简单生产者" class="headerlink" title="1 抛开spring，创建一个简单生产者"></a>1 抛开spring，创建一个简单生产者</h3><h4 id="1-1-安装windows版activemq"><a href="#1-1-安装windows版activemq" class="headerlink" title="1.1 安装windows版activemq"></a>1.1 安装windows版activemq</h4><ol><li>下载地址：<a href="http://activemq.apache.org/download.html" target="_blank" rel="noopener">http://activemq.apache.org/download.html</a></li><li>解压，启动bin\win64\activemq.bat</li><li>访问：<a href="http://localhost:8161/" target="_blank" rel="noopener">http://localhost:8161/</a></li></ol><h4 id="1-2-生产者"><a href="#1-2-生产者" class="headerlink" title="1.2 生产者"></a>1.2 生产者</h4><ol><li><p><strong>pom.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.15.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Producter</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producter</span> &#123;</span></span><br><span class="line">    <span class="comment">//ActiveMq 的默认用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> USERNAME = ActiveMQConnection.DEFAULT_USER;</span><br><span class="line">    <span class="comment">//ActiveMq 的默认登录密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD;</span><br><span class="line">    <span class="comment">//ActiveMQ 的链接地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> BROKEN_URL = ActiveMQConnection.DEFAULT_BROKER_URL;</span><br><span class="line">    <span class="comment">//链接工厂</span></span><br><span class="line">    ConnectionFactory connectionFactory;</span><br><span class="line">    <span class="comment">//链接对象</span></span><br><span class="line">    Connection connection;</span><br><span class="line">    <span class="comment">//事务管理</span></span><br><span class="line">    Session session;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个链接工厂</span></span><br><span class="line">            connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKEN_URL);</span><br><span class="line">            <span class="comment">//从工厂中创建一个链接</span></span><br><span class="line">            connection = connectionFactory.createConnection();</span><br><span class="line">            <span class="comment">//开启链接</span></span><br><span class="line">            connection.start();</span><br><span class="line">            <span class="comment">//创建一个事务（这里通过参数可以设置事务的级别）</span></span><br><span class="line">            session = connection.createSession(<span class="literal">true</span>, Session.SESSION_TRANSACTED);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">String</span> disname, <span class="keyword">String</span> content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个消息队列</span></span><br><span class="line">            Queue <span class="built_in">queue</span> = session.createQueue(disname);</span><br><span class="line">            <span class="comment">//消息生产者</span></span><br><span class="line">            MessageProducer messageProducer = session.createProducer(<span class="built_in">queue</span>);</span><br><span class="line">            <span class="comment">//创建一条消息</span></span><br><span class="line">            TextMessage msg = session.createTextMessage(content);</span><br><span class="line">            System.out.<span class="built_in">println</span>(content);</span><br><span class="line">            <span class="comment">//发送消息</span></span><br><span class="line">            messageProducer.send(msg);</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            session.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">session.rollback();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>测试</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    Producter producter = <span class="keyword">new</span> Producter();</span><br><span class="line">    producter.init();</span><br><span class="line">    producter.sendMessage(<span class="string">"test"</span>, <span class="string">"interest"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-分析init-方法"><a href="#2-分析init-方法" class="headerlink" title="2 分析init()方法"></a>2 分析init()方法</h3><h4 id="2-1-connectionFactory-new-ActiveMQConnectionFactory-USERNAME-PASSWORD-BROKEN-URL"><a href="#2-1-connectionFactory-new-ActiveMQConnectionFactory-USERNAME-PASSWORD-BROKEN-URL" class="headerlink" title="2.1 connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKEN_URL);"></a>2.1 connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, BROKEN_URL);</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;该语句只是将USERNAME, PASSWORD, BROKEN_URL设置到ActiveMQConnectionFactory的变量里面。</p><h4 id="2-2-connection-connectionFactory-createConnection"><a href="#2-2-connection-connectionFactory-createConnection" class="headerlink" title="2.2 connection = connectionFactory.createConnection();"></a>2.2 connection = connectionFactory.createConnection();</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;createConnection()方法只是单纯调用createActiveMQConnection()方法，createActiveMQConnection的源码如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected ActiveMQConnection create<span class="constructor">ActiveMQConnection(String <span class="params">userName</span>, String <span class="params">password</span>)</span> throws JMSException &#123;</span><br><span class="line">    <span class="keyword">if</span> (brokerURL<span class="operator"> == </span>null) &#123;</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">ConfigurationException(<span class="string">"brokerURL not set."</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ActiveMQConnection connection = null;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.2.1 创建Transport</span></span><br><span class="line">        Transport transport = create<span class="constructor">Transport()</span>;</span><br><span class="line">        <span class="comment">// 2.2.2 由transport和状态管理器创建连接</span></span><br><span class="line">        connection = create<span class="constructor">ActiveMQConnection(<span class="params">transport</span>, <span class="params">factoryStats</span>)</span>;</span><br><span class="line"></span><br><span class="line">        connection.set<span class="constructor">UserName(<span class="params">userName</span>)</span>;</span><br><span class="line">        connection.set<span class="constructor">Password(<span class="params">password</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 看名字就知道配置connection的参数，它也的确只做了这样事，把new ActiveMQConnectionFactory()时处理好的参数set到connection中</span></span><br><span class="line">        configure<span class="constructor">Connection(<span class="params">connection</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一切准备就绪，就可以启动了</span></span><br><span class="line">        transport.start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clientID != null) &#123;</span><br><span class="line">            connection.set<span class="constructor">DefaultClientID(<span class="params">clientID</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return connection;</span><br><span class="line">    &#125; catch (JMSException e) &#123;</span><br><span class="line">        <span class="comment">// Clean up!</span></span><br><span class="line">connection.close<span class="literal">()</span>;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        <span class="comment">// Clean up!</span></span><br><span class="line">        connection.close<span class="literal">()</span>;</span><br><span class="line">        throw <span class="module-access"><span class="module"><span class="identifier">JMSExceptionSupport</span>.</span></span>create(<span class="string">"Could not connect to broker URL: "</span> + brokerURL + <span class="string">". Reason: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-1-创建Transport，createTransport"><a href="#2-2-1-创建Transport，createTransport" class="headerlink" title="2.2.1 创建Transport，createTransport()"></a>2.2.1 创建Transport，createTransport()</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>粗略介绍：</strong>createTransport()，该方法首先从brokerURL中，取出scheme，scheme就是写在brokerUrl中的tcp、auto等关键字，然后根据scheme在一个保存了TransportFactory的ConcurrentMap中查找TransportFactory，没有就新new一个TransportFactory保存到ConcurrentMap中。然后调用TransportFactory.doConnect()，根据brokerUrl中的参数返回一个Transport的对象。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected Transport create<span class="constructor">Transport()</span> throws JMSException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        URI connectBrokerUL = brokerURL;</span><br><span class="line">        <span class="comment">//取出scheme</span></span><br><span class="line">        String scheme = brokerURL.get<span class="constructor">Scheme()</span>;</span><br><span class="line">        <span class="keyword">if</span> (scheme<span class="operator"> == </span>null) &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">IOException(<span class="string">"Transport not scheme specified: ["</span> + <span class="params">brokerURL</span> + <span class="string">"]"</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (scheme.equals(<span class="string">"auto"</span>)) &#123;</span><br><span class="line">            connectBrokerUL = <span class="keyword">new</span> <span class="constructor">URI(<span class="params">brokerURL</span>.<span class="params">toString</span>()</span>.replace(<span class="string">"auto"</span>, <span class="string">"tcp"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheme.equals(<span class="string">"auto+ssl"</span>)) &#123;</span><br><span class="line">            connectBrokerUL = <span class="keyword">new</span> <span class="constructor">URI(<span class="params">brokerURL</span>.<span class="params">toString</span>()</span>.replace(<span class="string">"auto+ssl"</span>, <span class="string">"ssl"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheme.equals(<span class="string">"auto+nio"</span>)) &#123;</span><br><span class="line">            connectBrokerUL = <span class="keyword">new</span> <span class="constructor">URI(<span class="params">brokerURL</span>.<span class="params">toString</span>()</span>.replace(<span class="string">"auto+nio"</span>, <span class="string">"nio"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheme.equals(<span class="string">"auto+nio+ssl"</span>)) &#123;</span><br><span class="line">            connectBrokerUL = <span class="keyword">new</span> <span class="constructor">URI(<span class="params">brokerURL</span>.<span class="params">toString</span>()</span>.replace(<span class="string">"auto+nio+ssl"</span>, <span class="string">"nio+ssl"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2.1.1 根据scheme在Map中取出TransportFactory，获得Transport对象</span></span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">TransportFactory</span>.</span></span>connect(connectBrokerUL);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw <span class="module-access"><span class="module"><span class="identifier">JMSExceptionSupport</span>.</span></span>create(<span class="string">"Could not create Transport. Reason: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2.1.1 根据scheme在Map中取出TransportFactory，获得Transport对象</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Transport <span class="title">connect</span><span class="params">(URI location)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//2.2.1.1.1 从ConcurrentMap中获取TransportFactory</span></span><br><span class="line">    TransportFactory tf = findTransportFactory(location);</span><br><span class="line">    <span class="comment">//2.2.1.1.2 从TransportFactory返回Transport对象</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> tf.<span class="title">doConnect</span><span class="params">(location)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2.1.1.1 从ConcurrentMap中获取TransportFactory</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static TransportFactory find<span class="constructor">TransportFactory(URI <span class="params">location</span>)</span> throws IOException &#123;</span><br><span class="line">    String scheme = location.get<span class="constructor">Scheme()</span>;</span><br><span class="line">    <span class="keyword">if</span> (scheme<span class="operator"> == </span>null) &#123;</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">IOException(<span class="string">"Transport not scheme specified: ["</span> + <span class="params">location</span> + <span class="string">"]"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//TRANSPORT_FACTORYS 保存着 TransportFactory的ConcurrentMap</span></span><br><span class="line">    TransportFactory tf = <span class="module-access"><span class="module"><span class="identifier">TRANSPORT_FACTORYS</span>.</span></span>get(scheme);</span><br><span class="line">    <span class="comment">//没有，则返回一个新对象并保存在map中</span></span><br><span class="line">    <span class="keyword">if</span> (tf<span class="operator"> == </span>null) &#123;</span><br><span class="line">        <span class="comment">// Try to load if from a META-INF property.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            tf = (TransportFactory)<span class="module-access"><span class="module"><span class="identifier">TRANSPORT_FACTORY_FINDER</span>.</span></span><span class="keyword">new</span><span class="constructor">Instance(<span class="params">scheme</span>)</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">TRANSPORT_FACTORYS</span>.</span></span>put(scheme, tf);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw <span class="module-access"><span class="module"><span class="identifier">IOExceptionSupport</span>.</span></span>create(<span class="string">"Transport scheme NOT recognized: ["</span> + scheme + <span class="string">"]"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2.1.1.2 从TransportFactory返回Transport对象</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Transport <span class="keyword">do</span><span class="constructor">Connect(URI <span class="params">location</span>)</span> throws Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; options = <span class="keyword">new</span> HashMap&lt;String, String&gt;(<span class="module-access"><span class="module"><span class="identifier">URISupport</span>.</span></span>parse<span class="constructor">Parameters(<span class="params">location</span>)</span>);</span><br><span class="line">        <span class="keyword">if</span>( !options.contains<span class="constructor">Key(<span class="string">"wireFormat.host"</span>)</span> ) &#123;</span><br><span class="line">            options.put(<span class="string">"wireFormat.host"</span>, location.get<span class="constructor">Host()</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        WireFormat wf = create<span class="constructor">WireFormat(<span class="params">options</span>)</span>;</span><br><span class="line">        <span class="comment">//2.2.1.1.2.1 创建Transport对象</span></span><br><span class="line">        Transport transport = create<span class="constructor">Transport(<span class="params">location</span>, <span class="params">wf</span>)</span>;</span><br><span class="line">        Transport rc = configure(transport, wf, options);</span><br><span class="line">        <span class="comment">//remove auto</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">IntrospectionSupport</span>.</span></span>extract<span class="constructor">Properties(<span class="params">options</span>, <span class="string">"auto."</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!options.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">IllegalArgumentException(<span class="string">"Invalid connect parameters: "</span> + <span class="params">options</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return rc;</span><br><span class="line">    &#125; catch (URISyntaxException e) &#123;</span><br><span class="line">        throw <span class="module-access"><span class="module"><span class="identifier">IOExceptionSupport</span>.</span></span>create(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2.1.1.2.1 创建Transport对象</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由子类实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function">Transport <span class="title">createTransport</span><span class="params">(URI location, WireFormat wf)</span> <span class="keyword">throws</span> MalformedURLException, UnknownHostException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"createTransport() method not implemented!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2.1.1.2.2 createTransport()由子类实现，TcpTransportFactory</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected Transport create<span class="constructor">Transport(URI <span class="params">location</span>, WireFormat <span class="params">wf</span>)</span> throws UnknownHostException, IOException &#123;</span><br><span class="line">    URI localLocation = null;</span><br><span class="line">    String path = location.get<span class="constructor">Path()</span>;</span><br><span class="line">    <span class="comment">// see if the path is a local URI location</span></span><br><span class="line">    <span class="keyword">if</span> (path != null<span class="operator"> &amp;&amp; </span>path.length<span class="literal">()</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> localPortIndex = path.index<span class="constructor">Of(':')</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">path</span>.<span class="params">substring</span>(<span class="params">localPortIndex</span> + 1, <span class="params">path</span>.<span class="params">length</span>()</span>));</span><br><span class="line">            String localString = location.get<span class="constructor">Scheme()</span> + <span class="string">":/"</span> + path;</span><br><span class="line">            localLocation = <span class="keyword">new</span> <span class="constructor">URI(<span class="params">localString</span>)</span>;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">LOG</span>.</span></span>warn(<span class="string">"path isn't a valid local location for TcpTransport to use"</span>, e.get<span class="constructor">Message()</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">LOG</span>.</span></span>is<span class="constructor">DebugEnabled()</span>) &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">LOG</span>.</span></span>debug(<span class="string">"Failure detail"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上算是都在校验url</span></span><br><span class="line">    <span class="comment">//这一句new DefaultSocketFactory()对象返回</span></span><br><span class="line">    SocketFactory socketFactory = create<span class="constructor">SocketFactory()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// new一个TcpTransport对象，将wf，socketFactory放入该对象的变量里面</span></span><br><span class="line">    return create<span class="constructor">TcpTransport(<span class="params">wf</span>, <span class="params">socketFactory</span>, <span class="params">location</span>, <span class="params">localLocation</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-2-由transport和状态管理器创建连接"><a href="#2-2-2-由transport和状态管理器创建连接" class="headerlink" title="2.2.2 由transport和状态管理器创建连接"></a>2.2.2 由transport和状态管理器创建连接</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>粗略介绍：</strong>createActiveMQConnection()字面意思就是创建一个activeMQ的连接。这个连接是根据transport，和一个连接状态管理器JMSStats创建的，源码如下。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected ActiveMQConnection create<span class="constructor">ActiveMQConnection(Transport <span class="params">transport</span>, JMSStatsImpl <span class="params">stats</span>)</span> throws Exception &#123;</span><br><span class="line">    <span class="comment">//getConnectionIdGenerator(), getClientIdGenerator()这是一个同步方法，返回IdGenerator对象</span></span><br><span class="line">    <span class="comment">//transport 上面代码生成的Transport对象</span></span><br><span class="line">    <span class="comment">//stats 是一个JMSStatsImpl对象，有提供set方法，修改连接状态</span></span><br><span class="line"><span class="comment">//2.2.2.2 ActiveMQConnection的构造</span></span><br><span class="line">    ActiveMQConnection connection = <span class="keyword">new</span> <span class="constructor">ActiveMQConnection(<span class="params">transport</span>, <span class="params">getClientIdGenerator</span>()</span>,</span><br><span class="line">            get<span class="constructor">ConnectionIdGenerator()</span>, stats);</span><br><span class="line">    return connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>2.2.2.1 JMSStatsImpl *</em></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMSStatsImpl</span> <span class="title">extends</span> <span class="title">StatsImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span> List connections;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JMSStatsImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="comment">//CopyOnWriteArrayList，一开是所有线程共享内容，当你需要修改时将内容复制出来再修改，然后把旧的地址指向新地址，这样可以达到并发的读，而不需要加锁</span></span><br><span class="line">        connections = <span class="keyword">new</span> CopyOnWriteArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> JMSConnectionStatsImpl[] getConnections()</span><br><span class="line">    &#123;</span><br><span class="line">        Object connectionArray[] = connections.toArray();</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = connectionArray.length;</span><br><span class="line">        JMSConnectionStatsImpl answer[] = <span class="keyword">new</span> JMSConnectionStatsImpl[<span class="built_in">size</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ActiveMQConnection connection = (ActiveMQConnection)connectionArray[i];</span><br><span class="line">            answer[i] = connection.getConnectionStats();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addConnection</span><span class="params">(ActiveMQConnection connection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        connections.add(connection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeConnection</span><span class="params">(ActiveMQConnection connection)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        connections.<span class="built_in">remove</span>(connection);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">(IndentPrinter out)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out.printIndent();</span><br><span class="line">        out.<span class="built_in">println</span>(<span class="string">"factory &#123;"</span>);</span><br><span class="line">        out.incrementIndent();</span><br><span class="line">        JMSConnectionStatsImpl <span class="built_in">array</span>[] = getConnections();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            JMSConnectionStatsImpl connectionStat = <span class="built_in">array</span>[i];</span><br><span class="line">            connectionStat.dump(out);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.decrementIndent();</span><br><span class="line">        out.printIndent();</span><br><span class="line">        out.<span class="built_in">println</span>(<span class="string">"&#125;"</span>);</span><br><span class="line">        out.<span class="built_in">flush</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        super.setEnabled(enabled);</span><br><span class="line">        JMSConnectionStatsImpl stats[] = getConnections();</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = stats.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">            stats[i].setEnabled(enabled);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.2.2.2 ActiveMQConnection的构造</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="constructor">ActiveMQConnection(<span class="params">final</span> Transport <span class="params">transport</span>, IdGenerator <span class="params">clientIdGenerator</span>, IdGenerator <span class="params">connectionIdGenerator</span>, JMSStatsImpl <span class="params">factoryStats</span>)</span> throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    this.transport = transport;</span><br><span class="line">    this.clientIdGenerator = clientIdGenerator;</span><br><span class="line">    this.factoryStats = factoryStats;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure a single threaded executor who's core thread can timeout if</span></span><br><span class="line">    <span class="comment">// idle</span></span><br><span class="line">    executor = <span class="keyword">new</span> <span class="constructor">ThreadPoolExecutor(1, 1, 5, TimeUnit.SECONDS, <span class="params">new</span> LinkedBlockingQueue&lt;Runnable&gt;()</span>, <span class="keyword">new</span> <span class="constructor">ThreadFactory()</span> &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Thread <span class="keyword">new</span><span class="constructor">Thread(Runnable <span class="params">r</span>)</span> &#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> <span class="constructor">Thread(<span class="params">r</span>, <span class="string">"ActiveMQ Connection Executor: "</span> + <span class="params">transport</span>)</span>;</span><br><span class="line">            <span class="comment">//守护线程，用于关闭，检测心跳等 - see https://issues.apache.org/jira/browse/AMQ-796</span></span><br><span class="line">            <span class="comment">//thread.setDaemon(true);</span></span><br><span class="line">            return thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//连接信息，赋值</span></span><br><span class="line">    <span class="comment">// asyncConnectionThread.allowCoreThreadTimeOut(true);</span></span><br><span class="line">    String uniqueId = connectionIdGenerator.generate<span class="constructor">Id()</span>;</span><br><span class="line">    this.info = <span class="keyword">new</span> <span class="constructor">ConnectionInfo(<span class="params">new</span> ConnectionId(<span class="params">uniqueId</span>)</span>);</span><br><span class="line">    this.info.set<span class="constructor">Manageable(<span class="params">true</span>)</span>;</span><br><span class="line">    this.info.set<span class="constructor">FaultTolerant(<span class="params">transport</span>.<span class="params">isFaultTolerant</span>()</span>);</span><br><span class="line">    this.connectionSessionId = <span class="keyword">new</span> <span class="constructor">SessionId(<span class="params">info</span>.<span class="params">getConnectionId</span>()</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    this.transport.set<span class="constructor">TransportListener(<span class="params">this</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sessions 也是一个 CopyOnWriteArrayList，用于保存session，启动时size = 0</span></span><br><span class="line">    this.stats = <span class="keyword">new</span> <span class="constructor">JMSConnectionStatsImpl(<span class="params">sessions</span>, <span class="params">this</span> <span class="params">instanceof</span> XAConnection)</span>;</span><br><span class="line">    this.factoryStats.add<span class="constructor">Connection(<span class="params">this</span>)</span>;</span><br><span class="line">    this.timeCreated = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span>;</span><br><span class="line">    this.connectionAudit.set<span class="constructor">CheckForDuplicates(<span class="params">transport</span>.<span class="params">isFaultTolerant</span>()</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-session-connection-createSession-true-Session-SESSION-TRANSACTED"><a href="#2-3-session-connection-createSession-true-Session-SESSION-TRANSACTED" class="headerlink" title="2.3 session = connection.createSession(true, Session.SESSION_TRANSACTED);"></a>2.3 session = connection.createSession(true, Session.SESSION_TRANSACTED);</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;该方法返回一个seesion，该session用于操作activemq，该方法先做了保护性校验查看连接是否关闭，如果没有，那么将ConnectionInfo发送给broker，没有异常情况下，new 一个 Session对象返回</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">Session <span class="title">createSession</span><span class="params">(<span class="keyword">boolean</span> transacted, <span class="keyword">int</span> acknowledgeMode)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">    checkClosedOrFailed();</span><br><span class="line">    ensureConnectionInfoSent();</span><br><span class="line">    <span class="keyword">if</span> (!transacted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acknowledgeMode == Session.SESSION_TRANSACTED) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JMSException(<span class="string">"acknowledgeMode SESSION_TRANSACTED cannot be used for an non-transacted Session"</span>);</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(acknowledgeMode &lt; Session.SESSION_TRANSACTED || acknowledgeMode &gt; ActiveMQSession.MAX_ACK_CONSTANT)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> JMSException(<span class="string">"invalid acknowledgeMode: "</span> + acknowledgeMode + <span class="string">". Valid values are Session.AUTO_ACKNOWLEDGE (1), "</span> +</span><br><span class="line">                    <span class="string">"Session.CLIENT_ACKNOWLEDGE (2), Session.DUPS_OK_ACKNOWLEDGE (3), ActiveMQSession.INDIVIDUAL_ACKNOWLEDGE (4) or for transacted sessions Session.SESSION_TRANSACTED (0)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveMQSession(<span class="keyword">this</span>, getNextSessionId(), transacted ? Session.SESSION_TRANSACTED : acknowledgeMode, isDispatchAsync(), isAlwaysSessionAsync());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-分析sendMessage-方法"><a href="#3-分析sendMessage-方法" class="headerlink" title="3 分析sendMessage()方法"></a>3 分析sendMessage()方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这个方法基本上就属于业务层了，你需要关心的是Queue，Topic。<br>可参考<a href="http://usql.club/2018/06/17/middleware/activemq-simple/" target="_blank" rel="noopener">点击查看</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
            <tag> 源码解析 </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据安全02-RSA 加密原理</title>
      <link href="/2018/07/17/theory/RSA%20%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"/>
      <url>/2018/07/17/theory/RSA%20%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="粗略介绍"><a href="#粗略介绍" class="headerlink" title="粗略介绍"></a>粗略介绍</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>RSA属于非对称加密</strong>，它使用一对密钥进行加密，加密和解密分别使用不同密钥，所以也号称地球上最安全的加密算法。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>对称加密</strong>，它的加密解密使用同一密钥，所以相对RSA来说没有那么安全，但是效率却要比RSA高。</p><h4 id="转自"><a href="#转自" class="headerlink" title="转自"></a>转自</h4><p><a href="https://blog.csdn.net/dbs1215/article/details/48953589" target="_blank" rel="noopener">查看</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tomcat爱恨情仇</title>
      <link href="/2018/07/14/centos/tomcat/"/>
      <url>/2018/07/14/centos/tomcat/</url>
      
        <content type="html"><![CDATA[<h4 id="tomcat-与-oom-killer"><a href="#tomcat-与-oom-killer" class="headerlink" title="tomcat 与 oom_killer"></a>tomcat 与 oom_killer</h4><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;在一台centos上，我启动了tomcat，运行之后内存剩余500M，但是第二天tomcat已经被停止了。要知道申请JVM内存是成倍申请，申请到了之后不会回收，也就是说，我的tomcat启动成功后，就拥有固定的内存，而我可以保证它的使用不会超出该内存而去申请下一段内存，但是为什么莫名的停止呢？而且没有留下任何日志，说明是系统kill掉的。</p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;那么我们想办法打出日志，加上以下参数，我们期待在下一次出现问题时能及时打印堆栈信息再挂掉。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改$TOMCAT_HOME/bin/catalina.sh</span></span><br><span class="line"><span class="attr">JAVA_OPTS</span>=<span class="string">"-XX:+HeapDumpOnOutOfMemoryError-XX:HeapDumpPath=/usr/local/tomcat/logs"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;第二天起床照样发现已被kill，查看日志，<strong>/var/log/message</strong> </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">03</span> rcmsit kernel: YDService invoked oom-killer: gfp_mask=<span class="number">0x201da</span>, order=<span class="number">0</span>, oom_score_adj=<span class="number">0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: YDService cpuset=/ mems_allowed=<span class="number">0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: CPU: <span class="number">1</span> PID: <span class="number">9434</span> Comm: YDService Not tainted <span class="number">3.10</span><span class="number">.0</span><span class="number">-514.26</span><span class="number">.2</span>.el7.x86_64 #<span class="number">1</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Hardware name: Bochs Bochs, BIOS Bochs <span class="number">01</span>/<span class="number">01</span>/<span class="number">2011</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: ffff880119648000 <span class="number">00000000210107</span>be ffff88005c037938 ffffffff81687133</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: ffff88005c0379c8 ffffffff816820de ffffffff810eb0dc ffff88005c14b980</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: ffff88005c14b998 <span class="number">0000000000000202</span> ffff880119648000 ffff88005c0379b8</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Call Trace:</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81687133&gt;] dump_stack+<span class="number">0x19</span>/<span class="number">0x1b</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff816820de&gt;] dump_header+<span class="number">0x8e</span>/<span class="number">0x225</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff810eb0dc&gt;] ? ktime_get_ts64+<span class="number">0x4c</span>/<span class="number">0xf0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff8113d22f&gt;] ? delayacct_end+<span class="number">0x8f</span>/<span class="number">0xb0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81184d0e&gt;] oom_kill_process+<span class="number">0x24e</span>/<span class="number">0x3c0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff811847ad&gt;] ? oom_unkillable_task+<span class="number">0xcd</span>/<span class="number">0x120</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81184856&gt;] ? find_lock_task_mm+<span class="number">0x56</span>/<span class="number">0xc0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81093c0e&gt;] ? has_capability_noaudit+<span class="number">0x1e</span>/<span class="number">0x30</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81185546&gt;] out_of_memory+<span class="number">0x4b6</span>/<span class="number">0x4f0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81682be7&gt;] __alloc_pages_slowpath+<span class="number">0x5d7</span>/<span class="number">0x725</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff8118b655&gt;] __alloc_pages_nodemask+<span class="number">0x405</span>/<span class="number">0x420</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff811cf9ca&gt;] alloc_pages_current+<span class="number">0xaa</span>/<span class="number">0x170</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81180be7&gt;] __page_cache_alloc+<span class="number">0x97</span>/<span class="number">0xb0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81183760&gt;] filemap_fault+<span class="number">0x170</span>/<span class="number">0x410</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffffa01b7016&gt;] ext4_filemap_fault+<span class="number">0x36</span>/<span class="number">0x50</span> [ext4]</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff811ac83c&gt;] __do_fault+<span class="number">0x4c</span>/<span class="number">0xc0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff811accd3&gt;] do_read_fault.isra<span class="number">.42</span>+<span class="number">0x43</span>/<span class="number">0x130</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff811b1461&gt;] handle_mm_fault+<span class="number">0x6b1</span>/<span class="number">0x1000</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81692cc4&gt;] __do_page_fault+<span class="number">0x154</span>/<span class="number">0x450</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff81692ff5&gt;] do_page_fault+<span class="number">0x35</span>/<span class="number">0x90</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [&lt;ffffffff8168f208&gt;] page_fault+<span class="number">0x28</span>/<span class="number">0x30</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Mem-Info:</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: active_anon:<span class="number">625329</span> inactive_anon:<span class="number">205647</span> isolated_anon:<span class="number">0</span>#<span class="number">012</span> active_file:<span class="number">2142</span> inactive_file:<span class="number">3816</span> isolated_file:<span class="number">0</span>#<span class="number">012</span> unevictable:<span class="number">0</span> dirty:<span class="number">0</span> writeback:<span class="number">0</span> unstable:<span class="number">0</span>#<span class="number">012</span> slab_reclaimable:<span class="number">26535</span> slab_unreclaimable:<span class="number">52499</span>#<span class="number">012</span> mapped:<span class="number">615</span> shmem:<span class="number">12902</span></span><br><span class="line"><span class="number">0</span> pagetables:<span class="number">3722</span> bounce:<span class="number">0</span>#<span class="number">012</span> free:<span class="number">33074</span> free_pcp:<span class="number">192</span> free_cma:<span class="number">0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Node <span class="number">0</span> DMA free:<span class="number">15400</span>kB min:<span class="number">276</span>kB low:<span class="number">344</span>kB high:<span class="number">412</span>kB active_anon:<span class="number">108</span>kB inactive_anon:<span class="number">192</span>kB active_file:<span class="number">0</span>kB inactive_file:<span class="number">0</span>kB unevictable:<span class="number">0</span>kB isolated(anon):<span class="number">0</span>kB isolated(file):<span class="number">0</span>kB present:<span class="number">15992</span>kB managed:<span class="number">15908</span>kB mlocked:<span class="number">0</span>kB dirty:<span class="number">0</span>kB writ</span><br><span class="line">eback:<span class="number">0</span>kB mapped:<span class="number">0</span>kB shmem:<span class="number">44</span>kB slab_reclaimable:<span class="number">68</span>kB slab_unreclaimable:<span class="number">36</span>kB kernel_stack:<span class="number">0</span>kB pagetables:<span class="number">20</span>kB unstable:<span class="number">0</span>kB bounce:<span class="number">0</span>kB free_pcp:<span class="number">0</span>kB local_pcp:<span class="number">0</span>kB free_cma:<span class="number">0</span>kB writeback_tmp:<span class="number">0</span>kB pages_scanned:<span class="number">0</span> all_unreclaimable? yes</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: lowmem_reserve[]: <span class="number">0</span> <span class="number">3327</span> <span class="number">3773</span> <span class="number">3773</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Node <span class="number">0</span> DMA32 free:<span class="number">108368</span>kB min:<span class="number">59340</span>kB low:<span class="number">74172</span>kB high:<span class="number">89008</span>kB active_anon:<span class="number">2321152</span>kB inactive_anon:<span class="number">634816</span>kB active_file:<span class="number">7216</span>kB inactive_file:<span class="number">13476</span>kB unevictable:<span class="number">0</span>kB isolated(anon):<span class="number">0</span>kB isolated(file):<span class="number">0</span>kB present:<span class="number">3653624</span>kB managed:<span class="number">3408868</span>kB</span><br><span class="line"> mlocked:<span class="number">0</span>kB dirty:<span class="number">0</span>kB writeback:<span class="number">0</span>kB mapped:<span class="number">2328</span>kB shmem:<span class="number">500612</span>kB slab_reclaimable:<span class="number">91688</span>kB slab_unreclaimable:<span class="number">184240</span>kB kernel_stack:<span class="number">12304</span>kB pagetables:<span class="number">12780</span>kB unstable:<span class="number">0</span>kB bounce:<span class="number">0</span>kB free_pcp:<span class="number">696</span>kB local_pcp:<span class="number">0</span>kB free_cma:<span class="number">0</span>kB writeback_tmp:<span class="number">0</span>kB pages_scanned:<span class="number">0</span> all_unrecla</span><br><span class="line">imable? no</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: lowmem_reserve[]: <span class="number">0</span> <span class="number">0</span> <span class="number">446</span> <span class="number">446</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Node <span class="number">0</span> Normal free:<span class="number">9892</span>kB min:<span class="number">7964</span>kB low:<span class="number">9952</span>kB high:<span class="number">11944</span>kB active_anon:<span class="number">180056</span>kB inactive_anon:<span class="number">187580</span>kB active_file:<span class="number">1904</span>kB inactive_file:<span class="number">4676</span>kB unevictable:<span class="number">0</span>kB isolated(anon):<span class="number">0</span>kB isolated(file):<span class="number">0</span>kB present:<span class="number">524288</span>kB managed:<span class="number">457256</span>kB mlocke</span><br><span class="line">d:<span class="number">0</span>kB dirty:<span class="number">0</span>kB writeback:<span class="number">0</span>kB mapped:<span class="number">132</span>kB shmem:<span class="number">15424</span>kB slab_reclaimable:<span class="number">14384</span>kB slab_unreclaimable:<span class="number">25720</span>kB kernel_stack:<span class="number">2208</span>kB pagetables:<span class="number">2088</span>kB unstable:<span class="number">0</span>kB bounce:<span class="number">0</span>kB free_pcp:<span class="number">296</span>kB local_pcp:<span class="number">0</span>kB free_cma:<span class="number">0</span>kB writeback_tmp:<span class="number">0</span>kB pages_scanned:<span class="number">96</span> all_unreclaimable? no</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: lowmem_reserve[]: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Node <span class="number">0</span> DMA: <span class="number">17</span>*<span class="number">4</span>kB (UEM) <span class="number">1</span>*<span class="number">8</span>kB (E) <span class="number">2</span>*<span class="number">16</span>kB (UE) <span class="number">2</span>*<span class="number">32</span>kB (EM) <span class="number">2</span>*<span class="number">64</span>kB (UM) <span class="number">2</span>*<span class="number">128</span>kB (UE) <span class="number">2</span>*<span class="number">256</span>kB (UE) <span class="number">2</span>*<span class="number">512</span>kB (EM) <span class="number">3</span>*<span class="number">1024</span>kB (UEM) <span class="number">1</span>*<span class="number">2048</span>kB (E) <span class="number">2</span>*<span class="number">4096</span>kB (M) = <span class="number">15404</span>kB</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Node <span class="number">0</span> DMA32: <span class="number">6745</span>*<span class="number">4</span>kB (UEM) <span class="number">1058</span>*<span class="number">8</span>kB (UEM) <span class="number">922</span>*<span class="number">16</span>kB (UEM) <span class="number">546</span>*<span class="number">32</span>kB (UEM) <span class="number">208</span>*<span class="number">64</span>kB (UEM) <span class="number">83</span>*<span class="number">128</span>kB (UEM) <span class="number">24</span>*<span class="number">256</span>kB (UEM) <span class="number">13</span>*<span class="number">512</span>kB (UEM) <span class="number">4</span>*<span class="number">1024</span>kB (U) <span class="number">0</span>*<span class="number">2048</span>kB <span class="number">0</span>*<span class="number">4096</span>kB = <span class="number">108500</span>kB</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Node <span class="number">0</span> Normal: <span class="number">682</span>*<span class="number">4</span>kB (UEM) <span class="number">180</span>*<span class="number">8</span>kB (UEM) <span class="number">151</span>*<span class="number">16</span>kB (UEM) <span class="number">39</span>*<span class="number">32</span>kB (UEM) <span class="number">18</span>*<span class="number">64</span>kB (UEM) <span class="number">9</span>*<span class="number">128</span>kB (UEM) <span class="number">3</span>*<span class="number">256</span>kB (UEM) <span class="number">2</span>*<span class="number">512</span>kB (EM) <span class="number">0</span>*<span class="number">1024</span>kB <span class="number">0</span>*<span class="number">2048</span>kB <span class="number">0</span>*<span class="number">4096</span>kB = <span class="number">11928</span>kB</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Node <span class="number">0</span> hugepages_total=<span class="number">0</span> hugepages_free=<span class="number">0</span> hugepages_surp=<span class="number">0</span> hugepages_size=<span class="number">2048</span>kB</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: <span class="number">143267</span> total pagecache pages</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: <span class="number">7945</span> pages <span class="keyword">in</span> swap cache</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Swap cache stats: add <span class="number">284622</span>, delete <span class="number">276677</span>, find <span class="number">2373345</span>/<span class="number">2374779</span></span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Free swap  = <span class="number">0</span>kB</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Total swap = <span class="number">1023996</span>kB</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: <span class="number">1048476</span> pages RAM</span><br><span class="line">....</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [ pid ]   uid  tgid total_vm      rss nr_ptes swapents oom_score_adj name</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [  <span class="number">553</span>]     <span class="number">0</span>   <span class="number">553</span>    <span class="number">26364</span>       <span class="number">23</span>      <span class="number">51</span>      <span class="number">223</span>         <span class="number">-1000</span> sshd</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [<span class="number">10530</span>]    <span class="number">27</span> <span class="number">10530</span>   <span class="number">452707</span>    <span class="number">79498</span>     <span class="number">396</span>    <span class="number">91599</span>         <span class="number">-1000</span> mysqld</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [<span class="number">30398</span>]     <span class="number">0</span> <span class="number">30398</span>   <span class="number">582767</span>    <span class="number">20612</span>     <span class="number">109</span>       <span class="number">62</span>             <span class="number">0</span> java</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [  <span class="number">515</span>]     <span class="number">0</span>   <span class="number">515</span>    <span class="number">35253</span>     <span class="number">2031</span>      <span class="number">17</span>        <span class="number">4</span>             <span class="number">0</span> redis-server</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [  <span class="number">520</span>]     <span class="number">0</span>   <span class="number">520</span>    <span class="number">35253</span>     <span class="number">1816</span>      <span class="number">17</span>        <span class="number">1</span>             <span class="number">0</span> redis-server</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [  <span class="number">524</span>]     <span class="number">0</span>   <span class="number">524</span>    <span class="number">35253</span>     <span class="number">1878</span>      <span class="number">17</span>        <span class="number">1</span>             <span class="number">0</span> redis-server</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [ <span class="number">5404</span>]     <span class="number">0</span>  <span class="number">5404</span>   <span class="number">612065</span>    <span class="number">43032</span>     <span class="number">228</span>        <span class="number">0</span>             <span class="number">0</span> java</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [<span class="number">16265</span>]     <span class="number">0</span> <span class="number">16265</span>   <span class="number">520357</span>    <span class="number">65939</span>     <span class="number">261</span>        <span class="number">0</span>         <span class="number">-1000</span> java</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [ <span class="number">3251</span>]     <span class="number">0</span>  <span class="number">3251</span>  <span class="number">1005500</span>   <span class="number">235844</span>     <span class="number">563</span>        <span class="number">0</span>         <span class="number">-1000</span> java</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [ <span class="number">5709</span>]  <span class="number">1000</span>  <span class="number">5709</span>  <span class="number">1007769</span>   <span class="number">134443</span>     <span class="number">358</span>        <span class="number">0</span>             <span class="number">0</span> java</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: [ <span class="number">9434</span>]     <span class="number">0</span>  <span class="number">9434</span>   <span class="number">142807</span>      <span class="number">793</span>      <span class="number">38</span>        <span class="number">0</span>             <span class="number">0</span> YDService</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Out of memory: Kill process <span class="number">5709</span> (java) score <span class="number">109</span> <span class="keyword">or</span> sacrifice child</span><br><span class="line">Jul  <span class="number">3</span> <span class="number">03</span>:<span class="number">53</span>:<span class="number">04</span> rcmsit kernel: Killed process <span class="number">5709</span> (java) total-vm:<span class="number">4031076</span>kB, anon-rss:<span class="number">537772</span>kB, file-rss:<span class="number">0</span>kB, shmem-rss:<span class="number">0</span>kB</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;在03:53的时候，看到oom_killer被唤醒。oom_killer会选择占用内存最高的，然后kill 掉 oom_score_adj 值高的进程。<br>&nbsp;&nbsp;&nbsp;&nbsp;日志显示，oom_killer 杀的进程号为5709，而5709是一个java进程，所以也可以断定就被是kill掉的tomcat ，它占用的内存为612065，oom_score_adj为0，所以oom_killer选择kill掉它。</p><h5 id="插播-oom-killer介绍"><a href="#插播-oom-killer介绍" class="headerlink" title="插播 oom_killer介绍"></a>插播 oom_killer介绍</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;Linux下允许程序申请比系统可用内存更多的内存，这个特性叫Overcommit。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Overcommit原理</strong>：优化，申请内存不一定马上使用，可能申请后，如果你在使用的时候有资源释放了，那么就说明 你的申请是有效的<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>容易出现的问题：</strong> 如果使用的时候，还是没有释放出足够的内存，当你用到这个Overcommit给你的内存的时候，系统还没有资源的话，OOM killer就跳出来了。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>oom_killer：策略：</strong>Linux下有3种Overcommit的策略（参考内核文档：vm/overcommit-accounting），可以在/proc/sys/vm/overcommit_memory配置（取0,1和2三个值，默认是0）。</p><ol><li><strong>0：</strong>启发式策略，比较严重的Overcommit将不能得逞，比如你突然申请了128TB的内存。而轻微的overcommit将被允许。另外，root能Overcommit的值比普通用户要稍微多些。</li><li><strong>1：</strong>永远允许overcommit，这种策略适合那些不能承受内存分配失败的应用，比如某些支付模块应用。</li><li><strong>2：</strong>永远禁止overcommit，在这个情况下，系统所能分配的内存不会超过swap+RAM*系数（/proc/sys/vm/overcmmit_ratio，默认50%，你可以调整），如果这么多资源已经用光，那么后面任何尝试申请内存的行为都会返回错误，这通常意味着此时没法运行任何新程序</li></ol><h5 id="继续分析"><a href="#继续分析" class="headerlink" title="继续分析"></a>继续分析</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>关闭进程选择策略：</strong>没用的且耗内存多的程序被枪，作为用户，我们可以通过<strong>设置一些值来影响OOM killer做出决策</strong>。Linux下每个进程都有个OOM权重，在/proc/pid/oom_adj里面，取值是-17到+15，<strong>取值越高，越容易被干掉</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;最终OOM killer是通过/proc/pid/oom_score这个值来决定哪个进程被干掉的。这个值是系统综合进程的内存消耗量、CPU时间(utime + stime)、存活时间(uptime - start time)和oom_adj计算出的，消耗内存越多分越高，存活时间越长分越低。总之，总的策略是：损失最少的工作，释放最大的内存同时不伤及无辜的用了很大内存的进程，并且杀掉的进程数尽量少。<br>具体参考：<a href="http://blog.csdn.net/fjssharpsword/article/details/9341563" target="_blank" rel="noopener">http://blog.csdn.net/fjssharpsword/article/details/9341563</a></p><h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><ol><li>加内存，享受价格成倍增长的乐趣</li><li>修改/proc/pid/oom_adj，取值-17~15，默认0，越小越不容易选中</li><li>根据项目情况修改堆栈配置。（下文tomcat 调优）</li><li>修改代码，比如说大批量处理，不应该一开始把数据全加载到内存中。</li><li><strong>多说一句：</strong>我发现每天固定有个时间点，内存会莫名升高，估计是腾讯云在跑批，所以内存不要用得太紧，多留一点。</li></ol><h4 id="tomcat启动慢"><a href="#tomcat启动慢" class="headerlink" title="tomcat启动慢"></a>tomcat启动慢</h4><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;Tomcat 7/8使用org.apache.catalina.util.SessionIdGeneratorBase.createSecureRandom类产生安全随机类SecureRandom的实例作为会话ID，这个操作巨慢。</p><h5 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h5><ol><li>在Tomcat环境中解决，可以通过配置JRE使用非阻塞的Entropy Source。在catalina.sh中加入这么一行：<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.security.egd=<span class="keyword">file</span>:<span class="regexp">/dev/</span>.<span class="regexp">/urandom</span></span><br></pre></td></tr></table></figure></li><li>在JVM环境中解决，打开$JAVA_PATH/jre/lib/security/java.security这个文件<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">securerandom.<span class="keyword">source</span>=<span class="keyword">file</span>:<span class="regexp">/dev/u</span>random</span><br><span class="line">替换成</span><br><span class="line">securerandom.<span class="keyword">source</span>=<span class="keyword">file</span>:<span class="regexp">/dev/</span>.<span class="regexp">/urandom</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="dev-urandom-和-dev-random"><a href="#dev-urandom-和-dev-random" class="headerlink" title="/dev/urandom 和 /dev/random"></a>/dev/urandom 和 /dev/random</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;/dev/random和/dev/urandom是Linux系统中提供的随机伪设备，这两个设备的任务，是提供永不为空的随机字节数据流。很多解密程序与安全应用程序（如SSH Keys,SSL Keys等）需要它们提供的随机数据流。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>这两个设备的差异在于：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;/dev/random的random pool依赖于系统中断，因此在系统的中断数不足时，/dev/random设备会一直封锁，尝试读取的进程就会进入等待状态，直到系统的中断数充分够用.<br>&nbsp;&nbsp;&nbsp;&nbsp;/dev/random设备可以保证数据的随机性。<br>&nbsp;&nbsp;&nbsp;&nbsp;/dev/urandom不依赖系统的中断，也就不会造成进程忙等待，但是数据的随机性也不高。</p><h4 id="tomcat-调优"><a href="#tomcat-调优" class="headerlink" title="tomcat 调优"></a>tomcat 调优</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">JAVA_OPTS="-Xms512m</span> -Xmx2048m -XX:<span class="attr">PermSize=256M</span> -XX:<span class="attr">MaxPermSize=512m</span> -Ddubbo.shutdown.<span class="attr">hook=true</span> -XX:+HeapDumpOnOutOfMemoryError -XX:<span class="attr">HeapDumpPath=/home/administrator/software/server/tomcat-rcm/dump/oom.hprof"</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上为2核4G的配置，<strong>只做参考，根据自己项目修改</strong>，在catalina.sh加上。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Xmx：</strong>用来设置你的应用程序能够使用的最大内存数,如果程序要花很大内存的话，那就需要修改增加此数的值。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Xms：</strong>用它来设置程序初始化的时候内存栈的大小，增加这个值的话你的程序的启动性能会得到提高。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>XX:PermSize：</strong>表示非堆区初始内存分配大小，其缩写为permanent size（持久化内存）<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>XX:MaxPermSize：</strong>表示对非堆区分配的内存的最大上限<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>XX:+HeapDumpOnOutOfMemoryError：</strong>JVM会在遇到OutOfMemoryError时拍摄一个“堆转储快照”，并将其保存在一个文件中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;JAVA_OPTS这个变量会在tomcat启动时应用，但是也会在执行shutdown.sh时应用。当你关闭tomcat时如果告诉你内存不够，不要惊慌，这只是在执行shutdown.sh会启动另一个程序，而这时申请不到像启动时那么大的内存，就会报错，你可以忽略该异常，执行kill来关闭tomcat。</p><h4 id="tomcat访问项目时不需要加项目名称"><a href="#tomcat访问项目时不需要加项目名称" class="headerlink" title="tomcat访问项目时不需要加项目名称"></a>tomcat访问项目时不需要加项目名称</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;修改conf目录下的server.xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">appBase</span>=<span class="string">"webapps"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span> <span class="attr">name</span>=<span class="string">"localhost"</span> <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">xmlNamespaceAware</span>=<span class="string">"false"</span> <span class="attr">xmlValidation</span>=<span class="string">"false"</span>&gt;</span>  </span><br><span class="line">     <span class="comment">&lt;!-- path留空代表访问域名后面不需要带项目的名称 --&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">""</span> <span class="attr">docBase</span>=<span class="string">"F:\temp"</span> <span class="attr">reloadable</span>=<span class="string">"false"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式05-无视约束</title>
      <link href="/2018/07/08/sql/antipatterns/05-%E6%97%A0%E8%A7%86%E7%BA%A6%E6%9D%9F/"/>
      <url>/2018/07/08/sql/antipatterns/05-%E6%97%A0%E8%A7%86%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="目的：简化数据库架构"><a href="#目的：简化数据库架构" class="headerlink" title="目的：简化数据库架构"></a>目的：简化数据库架构</h4><p>&nbsp;&nbsp;&nbsp;&nbsp; 一些开发人员为了简化数据库架构，不推荐使用引用完整性约束，原因有一下几点：</p><ol><li>数据更新有可能和约束冲突;</li><li>当前的数据库设计如此灵活，以至于不支持引用完整性约束;</li><li>数据库为外键建立的索引会影响性能;</li><li>当前使用的数据库不支持外键。比如MySQL的MyISAM存储引擎，或者比SQLite3.6.19早的版本;</li><li>定义外键的语法并不简单，还需要查阅;</li></ol><h4 id="反模式：无视约束"><a href="#反模式：无视约束" class="headerlink" title="反模式：无视约束"></a>反模式：无视约束</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;不使用外键约束能使数据库设计更加简单、灵活，或者执行更加高效，但是不得不在其他方面付出相应的代价–增加额外的代码来手动维护引用完整性</p><h5 id="假设无暇代码"><a href="#假设无暇代码" class="headerlink" title="假设无暇代码"></a>假设无暇代码</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;要避免在没有外键约束的情况下产生引用的不完整状态，需要再任何改变生效前执行额外的Select查询，以此来确保这些改变不会导致引用错误。比如插入一条bug</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询account_id是否存在</span></span><br><span class="line"><span class="keyword">select</span> account_id <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> account_id = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 才能执行插入</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug(reported_by) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h5 id="检查错误"><a href="#检查错误" class="headerlink" title="检查错误"></a>检查错误</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;开发人员使用额外的脚本来查询是否有错误的数据。</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b.bug_id, b.status <span class="keyword">from</span> bug b</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> bug_status s <span class="keyword">on</span> b.status = s.status</span><br><span class="line"><span class="keyword">where</span> s.status <span class="keyword">is</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;试想一下，每天手动执行成百上千个这样对整表联结查询的sql是多么恐怖的事情。</p><h5 id="修改代码、数据"><a href="#修改代码、数据" class="headerlink" title="修改代码、数据"></a>修改代码、数据</h5><ol><li>你可以在开发时写几个简单查询来保证引用完整性，但是当修改代码，如何能保证会同时修改所有的地方。</li><li>可能有的用户直接了当的修改或删除了被引用的数据，会导致其他表引用发生未知错误。</li><li>当你Update更新一条被其他记录依赖的记录时，在没有更新父记录前，你不能更新子记录，也不能在更新父记录前更新子记录。你需要同步执行两边的更新，但是使用2个独立的更新语句是不现实的。</li></ol><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>当出现以下情况时，可能是反模式</p><ol><li>我要怎么写这个查询来检查一个值是否没有被同时存在2张表中？（通常这样的需求是为了查找那些孤立的行数据）</li><li>有没有一种简单的方法来判断在一张表中的数据是否也在第二张表中存在？（这么做是用来确认父记录切实存在。外键会自动完成这些，并且外键会使用这父表的索引尽可能的高效完成）</li><li>有人说不要用外键，外键影响数据库效率。</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;如果数据库产品(mysql的MyISAM存储引擎，SQLite 3.6.19 之前的版本)不支持外键约束功能，则不得不使用别的方法来保持引用完整性，比如使用监控脚本。<br>&nbsp;&nbsp;&nbsp;&nbsp;同样也存在一些极度灵活的数据库设计，外键无法用来表示其对应的关系。</p><h4 id="解决方案：声名约束"><a href="#解决方案：声名约束" class="headerlink" title="解决方案：声名约束"></a>解决方案：声名约束</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;声明外键约束，无疑可以保证数据完整性，但是更新，删除时会变的困难，下面会给你解答这个难题</p><h5 id="支持同步修改"><a href="#支持同步修改" class="headerlink" title="支持同步修改"></a>支持同步修改</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;外键有另一个在应用程序中无法模拟的特性：级联更新。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bus(</span><br><span class="line">reported_by <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">'NEW'</span>,</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(reported_by) <span class="keyword">references</span> <span class="keyword">account</span>(account_id)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span>,</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> restrict, <span class="comment">-- 无法删除bug中被引用的账号</span></span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(<span class="keyword">status</span>) <span class="keyword">references</span> bug_stastus(<span class="keyword">status</span>)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">update</span> <span class="keyword">cascade</span>,</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">set</span> <span class="keyword">default</span> <span class="comment">-- 删除status会设置成默认值</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这个方案允许你更新或删除父记录，数据库会帮你处理子记录，不会出现上面先更新父记录还是先更新子记录的问题</p><h5 id="系统开销过度？"><a href="#系统开销过度？" class="headerlink" title="系统开销过度？"></a>系统开销过度？</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;外键约束需要那么多一点的系统开销，但是相比其他的选择，外键确实高效一点</p><ol><li>不需要在更新或删除记录前执行Select检查；</li><li>在同步修改时不需要再锁住整张表；</li><li>不再需要执行定期监控脚本来修正不可避免的孤立数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式04-需要ID</title>
      <link href="/2018/07/07/sql/antipatterns/04-%E9%9C%80%E8%A6%81ID/"/>
      <url>/2018/07/07/sql/antipatterns/04-%E9%9C%80%E8%A6%81ID/</url>
      
        <content type="html"><![CDATA[<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;这章目的就是要确认哪些使用了主键，却混淆了主键的本质而造成的一种反模式。</p><h4 id="反模式（每个数据库表都需要一个伪主键）"><a href="#反模式（每个数据库表都需要一个伪主键）" class="headerlink" title="反模式（每个数据库表都需要一个伪主键）"></a>反模式（每个数据库表都需要一个伪主键）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在表中，加入一个对于表的域模型无实际意义的列，叫做ID，用它来定位表中的某一条记录。</p><h5 id="冗余键值"><a href="#冗余键值" class="headerlink" title="冗余键值"></a>冗余键值</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">bug_id <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">unique</span>,</span><br><span class="line">description <span class="built_in">varchar</span>(<span class="number">1000</span>),</span><br><span class="line">...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上设计中，bug_id也用来定位到表中某一条数据，它和id有这相同的作用。</p><h5 id="允许重复项"><a href="#允许重复项" class="headerlink" title="允许重复项"></a>允许重复项</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_product(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">product_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(bug_id) <span class="keyword">references</span> bug(bug_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(product_id) <span class="keyword">references</span> bug(product_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;上面设置使用id做为主键，但是它并不能约束bug_id,product_id的组合存在重复，那么你必须再添加unique约束，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_product(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">product_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">unique</span> <span class="keyword">key</span>(bug_id, product_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(bug_id) <span class="keyword">references</span> bug(bug_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(product_id) <span class="keyword">references</span> bug(product_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但是，当你在bug_id, product_id这两列上应用唯一约束，此时id这一列就会变成多余的。</p><h5 id="意义不明的关键字"><a href="#意义不明的关键字" class="headerlink" title="意义不明的关键字"></a>意义不明的关键字</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;单词code有很多意思，其一用于简化或加密消息，其二还有写代码的意思。而ID这个词，如此普通，完全无法表达更深层次的意思，特别是你在做两张表联结查询的时候</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> b.id, a.id </span><br><span class="line"><span class="keyword">from</span> bug b </span><br><span class="line"><span class="keyword">join</span> <span class="keyword">account</span> a <span class="keyword">on</span> b.assigned_to = a.id</span><br><span class="line"><span class="keyword">where</span> b.status = <span class="string">'OPEN'</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;列名ID并不会是查询变得清晰，而使用bug_id或者account_id，事请就会变更加简单。</p><h5 id="使用USING关键字"><a href="#使用USING关键字" class="headerlink" title="使用USING关键字"></a>使用USING关键字</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你可能很熟悉联结查询</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">as</span> b <span class="keyword">join</span> bus_product <span class="keyword">as</span> bp <span class="keyword">on</span> b.bug_id=bp.bug_id;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;SQL其实还支持另一种更见简洁的联结查询</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">join</span> bus_product <span class="keyword">USING</span>(bug_id);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;然而，如果所有的表都是ID作为伪主键，那么只能使用ON做联结查询</p><h5 id="使用组合键之难"><a href="#使用组合键之难" class="headerlink" title="使用组合键之难"></a>使用组合键之难</h5><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>当出现以下情况时，可能是反模式</p><ol><li>我觉得这张表不需要主键；</li><li>我怎么能在多对多的表中存储重复的项；</li><li>我学过《数据库设计理论》，里面说我应该把数据移动到一张查询表中，然后通过ID查找。但是我不想这么做，因为每次我想要获得真是的数据，都不得不做一次连接查询。（这在数据库设计中是一个常见的误区，称为“正规化”，然而实际中对于伪主键并没有什么需要做的）</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;使用伪主键，或者通过自动增长的整形的机制本身没有什么错误，但不是每张表都需要一个伪主键，更没有必要将每个伪主键都定义为ID。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;主键是约束而非数据类型，你可以定义任意多的列为主键，只要其数据类型支持索引。你还可以将一个列定义为自增长的整形而不设定其为主键，这两者完全没有关系，<strong>别被既有的惯例限制住设计。</strong></p><h5 id="直接了当的描述设计"><a href="#直接了当的描述设计" class="headerlink" title="直接了当的描述设计"></a>直接了当的描述设计</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;为主键设置一个更有意义的名称，比如，bug表的主键应该叫bug_id。<br>&nbsp;&nbsp;&nbsp;&nbsp;外键应该尽可能和所引用的列使用相同的名称，这通常意味这：一个主键的名称在整个数据库中的设计是唯一的。任意两张表都不应该使用相同的名称来定义主键，除非其中之一引用了另一个作为主键，但是有时也需要和其所引用的主键区分开，从而使他们之间引用关系表现的更加清晰。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line">  ....</span><br><span class="line">  reported_by <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">  <span class="keyword">foreign</span> <span class="keyword">key</span>(reported_by) <span class="keyword">references</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="拥抱自然键和组合键"><a href="#拥抱自然键和组合键" class="headerlink" title="拥抱自然键和组合键"></a>拥抱自然键和组合键</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你的表中包含一列能确认唯一、非空以及能够用来定位一条记录，就别仅仅因为传统而觉得有必要加上一个伪主键</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;以下都是我个人想法，看完本章我觉得我还是会继续使用id作为主键，另外就算有一列可能作为唯一标识，我也还是会加上id。<br>&nbsp;&nbsp;&nbsp;&nbsp;举个栗子，假如现在有一张表，存在一列可以唯一的标识一条记录，我因此没有加上id列，产品上线之后，业务方变更需求说，当初那个可以唯一标识一条记录的列变成可以重复的了，那么你该怎么办，此时再加上id列，还来得及吗？</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据安全02-Base64 算法原理</title>
      <link href="/2018/06/30/theory/BASE64%20%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"/>
      <url>/2018/06/30/theory/BASE64%20%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol><li>表示二进制数据，可用于传输二进制数据，如文件、缩略图等</li><li>对数据起一定加密效果</li></ol><h4 id="转换原理"><a href="#转换原理" class="headerlink" title="转换原理"></a>转换原理</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Base64算法，是用64个可打印字符表示二进制所有数据方法。Base64字符成包含A—Z，a—z，0—9，+，/ ，他们编码对应表如下。<br><img src="/images/encrypt/base64_1.png" alt="编码表"><br>&nbsp;&nbsp;&nbsp;&nbsp;一个Base64字符编码转换成二进制都是8个bit位，而前两位都00，有效数字只有6个bit位，也就是说<strong>只需要6个bit位就能表示1个Base64字符</strong>，而正常的字符是使用8个bit位表示， 8和6的最小公倍数是24，所以4个Base64字符可以表示3个标准的ascii字符。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;按照以上原理，我们将要加密的明文对应的ascii值转换成二进制并拼接在一起，将其分为<strong>每6个bit为一份，每4份为一组</strong>。不够6个bit位的用0补充，不够4份的用=补充。根据base64编码表将每一份转成对应的Base64字符，得到的也就是密文。</p><h4 id="转换过程"><a href="#转换过程" class="headerlink" title="转换过程"></a>转换过程</h4><ol><li>得到明文每一个字符对应的ascii码</li><li>将ascii码转换成二进制，并拼接在一起</li><li>将拼接在一起的二进制，分为6个bit位为一份，4份为一组</li><li>将每一份根据base64编码表转换成base64字符</li><li>最后不够6个bit位的用0补充，不够一组的用=补充为4份</li></ol><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><h5 id="不需要补充0或-（明文：Man）"><a href="#不需要补充0或-（明文：Man）" class="headerlink" title="不需要补充0或=（明文：Man）"></a>不需要补充0或=（明文：Man）</h5><ol><li><strong>将明文每一个字符对应的ascii码</strong><br>M 对应ascii码 ：77<br>a 对应ascii码 ：97<br>n 对应ascii码 ：110</li><li><strong>将ascii码转换成二进制，并拼接在一起</strong><br>77 二进制 ： 01001101<br>97 二进制 ： 01100001<br>110 二进制 ： 01101110<br>拼接 : 010011010110000101101110</li><li><strong>分为6个bit位为一份，4份为一组</strong><br>010011<br>010110<br>000101<br>101110</li><li><strong>每一份根据base64编码表转换成base64字符</strong><br>010011 十进制 : 19 : base64字符 : T<br>010110 十进制 : 22 : base64字符 : W<br>000101 十进制 : 5 : base64字符 : F<br>101110 十进制 : 46 : base64字符 : u</li><li><strong>详解图</strong><br><img src="/images/encrypt/base64_2.png" alt="详解图"></li></ol><h5 id="需要补充0或-（明文：BC）"><a href="#需要补充0或-（明文：BC）" class="headerlink" title="需要补充0或=（明文：BC）"></a>需要补充0或=（明文：BC）</h5><ol><li><strong>将明文每一个字符对应的ascii码</strong><br>B 对应ascii码 ：66<br>C 对应ascii码 ：67</li><li><strong>将ascii码转换成二进制，并拼接在一起</strong><br>66 二进制 ： 01000010<br>67 二进制 ： 01000011<br>拼接 : 0100001001000011</li><li><strong>分为6个bit位为一份，4份为一组，补充0和=</strong><br>010000<br>100100<br>0011<strong>00</strong></li></ol><p><strong>xxxxxx</strong><br>4. <strong>每一份根据base64编码表转换成base64字符</strong><br>010000 十进制 : 16 : base64字符 : Q<br>100100 十进制 : 36 : base64字符 : k<br>0011<strong>00</strong> 十进制 : 12 : base64字符 : M<br><strong>xxxxxx</strong> : base64字符 : =<br>5. <strong>详解图</strong><br><img src="/images/encrypt/base64_3.png" alt="详解图"></p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;java中早已提供以上算法的jar包，不用自己去实现以上算法，个人倾向使用apache提供的</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.codec.<span class="built_in">binary</span>.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> ENCODING_UTF8 = <span class="string">"UTF-8"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二进制数据编码为BASE64字符串,根据isChunked是否输出换行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> encodeBase64(<span class="built_in">byte</span>[] bytes, <span class="built_in">boolean</span> isChunked) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">String</span>(Base64.encodeBase64(bytes, isChunked), ENCODING_UTF8);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BASE64解码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] decodeBase64(<span class="keyword">String</span> encodedStr) &#123;</span><br><span class="line">    <span class="built_in">byte</span>[] result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = Base64.decodeBase64(encodedStr);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;ASCII码总共128个，用来表示英文字母、数字以及英文标点符号。而简体中文、繁体中文、日文以及韩文等都是用多字节来存储的，通常称之为多字节字符。因为Base编码的输入是字符串的编码，<strong>不同编码的字符串的Base64结果是不同的</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;个人觉得用base64传输缩略图，非常合适，客户端收到base64字符后，就可以显示图片，而不用依赖网络了。这样至少可以保证缩略图一定能显示出来。但是通过以上算法，可以发现<strong>base64后的字符串大小是原来的4/3</strong>.</p>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 加密 </tag>
            
            <tag> Base64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据安全01-HTTPS 加密原理</title>
      <link href="/2018/06/29/theory/HTTPS%20%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"/>
      <url>/2018/06/29/theory/HTTPS%20%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;前后端分离的开发模式中，一般由后端提供给接口给前端调用。如果接口中包含用户身份证、银行卡等敏感信息，我们必须要考虑数据安全性，因为网络传输，本身就没有安全保障。所以容不得马虎。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;众所周知，Https比Http要安全，因为传输中Https会对数据进行加密，那么到底如何加密的呢？而Https比Http要慢，也是因为要进行加密过程</p><h4 id="Https-加密简介"><a href="#Https-加密简介" class="headerlink" title="Https 加密简介"></a>Https 加密简介</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;该过程使用RSA加密算法，和AES加密算法.</p><ol><li><strong>AES(对称加密)</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;加密、解密过程中使用同一个密钥，效率快</li><li><strong>RSA(非对称加密)</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;加密、解密分别使用不同的密钥，此密钥是成对的，分为公钥和私钥。公钥允许泄露，私钥只能一方拥有，所以<strong>一般用公钥对数据加密，私钥对数据解密。</strong></li><li><strong>Https加密详情</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;使用RSA的公钥对AES的密钥加密，传输给另一端，另一端使用私钥解密密文得到AES密钥，有了AES密钥了，就可以进行加密操作了。</li></ol><h4 id="Https-加密过程"><a href="#Https-加密过程" class="headerlink" title="Https 加密过程"></a>Https 加密过程</h4><ol><li>客户端启动，发送请求到服务端，服务端用RSA算法生成一对公钥和私钥，我们简称为pubkey1,prikey1，将公钥pubkey1返回给客户端。</li><li>客户端拿到服务端返回的公钥pubkey1后，自己用RSA算法生成一对公钥和私钥，我们简称为pubkey2,prikey2，并将公钥pubkey2通过公钥pubkey1加密，加密之后传输给服务端。</li><li>此时服务端收到客户端传输的密文，用私钥prikey1进行解密，因为数据是用公钥pubkey1加密的，通过解密就可以得到客户端生成的公钥pubkey2。</li><li>然后自己在生成对称加密，也就是我们的AES的密钥，生成了这个key之后我们就用公钥pubkey2进行加密，返回给客户端。</li><li>客户端收到密文后，使用pubkey2对应的私钥prikey2，对密文解密得到AES的密钥。</li><li>最后就用加密key进行数据传输的加密，至此整个流程结束。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
            <tag> 加密 </tag>
            
            <tag> RSA </tag>
            
            <tag> AES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP两种代理JDK和CGLIB</title>
      <link href="/2018/06/25/java/AOP%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86JDK%E5%92%8CCGLIB/"/>
      <url>/2018/06/25/java/AOP%E4%B8%A4%E7%A7%8D%E4%BB%A3%E7%90%86JDK%E5%92%8CCGLIB/</url>
      
        <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/u013126379/article/details/52121096" target="_blank" rel="noopener">https://blog.csdn.net/u013126379/article/details/52121096</a></p><h4 id="一、原理区别："><a href="#一、原理区别：" class="headerlink" title="一、原理区别："></a>一、原理区别：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p><p>1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP<br>2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP<br>3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</p><p>如何强制使用CGLIB实现AOP？<br> （1）添加CGLIB库，SPRING_HOME/cglib/*.jar<br> （2）在spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class=”true”/&gt;</p><p>JDK动态代理和CGLIB字节码生成的区别？<br> （1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类<br> （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法<br>   因为是继承，所以该类或方法最好不要声明成final </p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
            <tag> CGLIB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式03-单纯的树</title>
      <link href="/2018/06/23/sql/antipatterns/03-%E5%8D%95%E7%BA%AF%E7%9A%84%E6%A0%91/"/>
      <url>/2018/06/23/sql/antipatterns/03-%E5%8D%95%E7%BA%AF%E7%9A%84%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;设想你正在开发一个新闻网站，读者可以对文章评论，甚至相互回复，这样一来这个树就会<strong>延伸出很多分支</strong>，其<strong>深度也会大大增加</strong>，你选择一个简单的方案来实现需求：每条评论引用它所回复的评论。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> comments(</span><br><span class="line">comment_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">parent_id <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span>,</span><br><span class="line"><span class="keyword">comment</span> <span class="built_in">text</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (parent_id) <span class="keyword">REFERENCES</span> comments(comment_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这样一来，程序逻辑变得清晰明了，<strong>但是它并不能完成一棵树最基本的功能，就是遍历一整棵树</strong></p><h4 id="目的（分成存储与查询）"><a href="#目的（分成存储与查询）" class="headerlink" title="目的（分成存储与查询）"></a>目的（分成存储与查询）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;递归关系的数据很常见，数据会像树或以层级方式组织，比如：</p><ul><li><strong>组织机构图</strong>：职员与经理关系，每个职员有一个经理，同时经理也是一个职员</li><li><strong>线程化讨论</strong>：像引言中介绍的评论链。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;本篇对树结构定义：</p><ul><li>最上层的节点叫做<strong>根（root）节点</strong>，它没有父节点</li><li>最底层的没有子节点的节点叫做<strong>叶（leaf）</strong></li><li>中间的节点简单地称为<strong>非叶节点（nonleaf）</strong></li></ul><h4 id="反模式（总是依赖父节点，邻接表）"><a href="#反模式（总是依赖父节点，邻接表）" class="headerlink" title="反模式（总是依赖父节点，邻接表）"></a>反模式（总是依赖父节点，邻接表）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;最简单的方式就是添加parent_id，引用同一张表的其他条目，这样的设计也叫做<strong>邻接表</strong>，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">comment</span>(</span><br><span class="line">comment_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">parent_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span>,</span><br><span class="line">bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">author <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">comment_date datetime <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">comment</span> <span class="built_in">text</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (parent_id) <span class="keyword">REFERENCES</span> <span class="keyword">comment</span>(comment_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (author) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>以下展示一个树结构</strong><br><img src="/images/sql/antipatterns/03/comment_1.png" alt="评论示意图"></p><h5 id="1-使用邻接表查询树"><a href="#1-使用邻接表查询树" class="headerlink" title="1.使用邻接表查询树"></a>1.使用邻接表查询树</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;在引言中提到，邻接表不能完成一棵树最基本的查询：虽然你可以使用关联查询出某一个节点的子节点，如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select </span><span class="built_in">c1</span>.*, <span class="built_in">c2</span>.* from comment <span class="built_in">c1</span></span><br><span class="line"><span class="symbol">left</span> join comment <span class="built_in">c2</span> on <span class="built_in">c2</span>.parent_id = <span class="built_in">c1</span>.comment_id</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但是，这个查询只能获取两层，如果要继续查询某个节点的孙子，就的再关联一层。但是树的深度是无止境的。<br>&nbsp;&nbsp;&nbsp;&nbsp;另外还有一种办法，查询出所有的评论，然后再Java中重新构造这个树，但是大量的数据赋值，这是非常低效的。</p><h5 id="2-使用邻接表维护树"><a href="#2-使用邻接表维护树" class="headerlink" title="2.使用邻接表维护树"></a>2.使用邻接表维护树</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>插入修改节点：</strong>使用邻接表，是非常简单</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">comment</span>(parent_id, bug_id, author, <span class="keyword">comment</span>)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">7</span>, <span class="number">1234</span>, <span class="string">'Kukla'</span>, <span class="string">'Thanks!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">comment</span> <span class="keyword">SET</span> parent_id = <span class="number">4</span> <span class="keyword">WHERE</span> comment_id = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>删除节点：</strong>但是删除节点会变得复杂，你必须从该节点下最低级子节点开始删除，以保证外键完整性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> comment_id <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> parent_id = <span class="number">4</span> <span class="comment">-- return 5 and 6</span></span><br><span class="line"><span class="keyword">select</span> comment_id <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> parent_id = <span class="number">5</span> <span class="comment">-- return none</span></span><br><span class="line"><span class="keyword">select</span> comment_id <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> parent_id = <span class="number">6</span> <span class="comment">-- return 7</span></span><br><span class="line"><span class="keyword">select</span> comment_id <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> parent_id = <span class="number">7</span> <span class="comment">-- return none</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> comment_id <span class="keyword">in</span> (<span class="number">7</span>);</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> comment_id <span class="keyword">in</span> (<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> comment_id = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;这里虽然可以使用带 <strong>ON DELETE CASCADE</strong> 来修改外键，来使它自动完成以上操作。但是，如果需求是删除一个非叶子节点，并提升它的子节点，或将它子节点移动到另一个节点，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查出自己的父节点</span></span><br><span class="line"><span class="keyword">select</span> parent_id <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> comment_id = <span class="number">6</span>; <span class="comment">-- return 4</span></span><br><span class="line"><span class="comment">-- 修改自己所有的子节点的父节点为要删除节点的父节点</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">comment</span> <span class="keyword">set</span> parent_id = <span class="number">4</span> <span class="keyword">where</span> parent_id = <span class="number">6</span>;</span><br><span class="line"><span class="comment">-- 删除自己</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> comment_id = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp; 当你说过以下话，你可能正在使用“反模式”</p><ol><li>我们的数结构要支持多少层</li><li>我们总是很害怕接触那些管理树结构的代码</li><li>我需要一个脚本来定期的清理树中的孤立节点数据</li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><ol><li>邻接表设计的优势在与能快速地获取一个给定节点的直接父子节点，也很容易插入新节点、维护节点、删除节点。如果树的<strong>分层结构不是很深，可以使用这种模式</strong>。</li><li>某些数据库提供了<strong>递归查询</strong>，可是使用WITH关键字来查询，<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL Server 2005, Oracle 11g, IBM DB2, PostgreSQL 8.4</span></span><br><span class="line"><span class="keyword">with</span> CommentTree(comment_id, parent_id, bug_id, author, comment_date, <span class="keyword">comment</span>)</span><br><span class="line"><span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> * <span class="number">0</span> <span class="keyword">as</span> <span class="keyword">depth</span> <span class="keyword">from</span> <span class="keyword">comment</span></span><br><span class="line"><span class="keyword">where</span> parent_id <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> c.*, ct.depth+<span class="number">1</span> <span class="keyword">as</span> <span class="keyword">depth</span> <span class="keyword">from</span> CommentTree ct </span><br><span class="line"><span class="keyword">join</span> <span class="keyword">comment</span> c <span class="keyword">on</span> ct.comment_id = c.parent_id</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> CommentTree <span class="keyword">where</span> bug_id = <span class="number">1234</span>;</span><br><span class="line"><span class="comment">-- Oracle 9i 和 10g 递归查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">comment</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> comment_id = <span class="number">9876</span></span><br><span class="line"><span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">prior</span> parent_id = comment_id</span><br></pre></td></tr></table></figure></li></ol><h4 id="解决办法-使用其他树模型"><a href="#解决办法-使用其他树模型" class="headerlink" title="解决办法:使用其他树模型"></a>解决办法:使用其他树模型</h4><h5 id="1-路径枚举："><a href="#1-路径枚举：" class="headerlink" title="1.路径枚举："></a>1.路径枚举：</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;用一个path字段保存当前节点的最顶层的祖先到自己的序列(路径)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">comment</span>(</span><br><span class="line">comment_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line"><span class="keyword">path</span> <span class="built_in">varchar</span>(<span class="number">1000</span>),</span><br><span class="line">bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">author <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">comment_date datetime <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">comment</span> <span class="built_in">text</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (author) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="/images/sql/antipatterns/03/comment_2.png" alt="评论示意图"></p><h6 id="查询评论-7（路径是1-4-6-7），的祖先"><a href="#查询评论-7（路径是1-4-6-7），的祖先" class="headerlink" title="查询评论#7（路径是1/4/6/7），的祖先"></a>查询评论#7（路径是1/4/6/7），的祖先</h6><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from comment where '<span class="number">1</span>/<span class="number">4</span>/<span class="number">6</span>/<span class="number">7</span>' like path || '%';</span><br><span class="line">-- 它会匹配到 <span class="number">1</span>/<span class="number">4</span>/<span class="number">6</span>/%，<span class="number">1</span>/<span class="number">4</span>/%，<span class="number">1</span>/%的节点，而他们就是#<span class="number">7</span>祖先</span><br></pre></td></tr></table></figure><h6 id="查询评论-4（路径是1-4），的子孙"><a href="#查询评论-4（路径是1-4），的子孙" class="headerlink" title="查询评论#4（路径是1/4），的子孙"></a>查询评论#4（路径是1/4），的子孙</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">where</span> <span class="keyword">path</span> <span class="keyword">like</span> <span class="string">'1/4/'</span> || <span class="string">'%'</span>;</span><br><span class="line"><span class="comment">-- 它会匹配到 1/4/% 的节点，而他们就是#4子孙</span></span><br></pre></td></tr></table></figure><h6 id="查询评论-4，每个用户的评论数"><a href="#查询评论-4，每个用户的评论数" class="headerlink" title="查询评论#4，每个用户的评论数"></a>查询评论#4，每个用户的评论数</h6><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select count(1) <span class="keyword">from</span> comment where path like <span class="string">'1/4'</span> || <span class="string">'%'</span></span><br><span class="line">group by author</span><br></pre></td></tr></table></figure><h6 id="插入也简单"><a href="#插入也简单" class="headerlink" title="插入也简单"></a>插入也简单</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;只需要将父节点的path查出来，再追加自己的id就行了，但是一般id是自增，你需要先insert子节点，再select父节点，再update子节点</p><h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><ol><li>优点：查询方便</li><li>缺点：</li></ol><ul><li>存在“乱穿马路”，不能保证存储的值的有效性。</li><li>修改节点，比较麻烦，所有子节点的path也要修改</li></ul><h5 id="2-嵌套集："><a href="#2-嵌套集：" class="headerlink" title="2.嵌套集："></a>2.嵌套集：</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;存储子孙节点的相关信息，而不是节点的直接祖先。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">comment</span>(</span><br><span class="line">comment_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">nsleft <span class="built_in">integer</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">nsright <span class="built_in">integer</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">author <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">comment_date datetime <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">comment</span> <span class="built_in">text</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (author) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>要求：nsleft的数值小于该节点所有后代的id，nsright的数值大于所有后代的id。</strong><br><img src="/images/sql/antipatterns/03/comment_3.png" alt="评论示意图"></p><h6 id="查询评论-4及其所有后代"><a href="#查询评论-4及其所有后代" class="headerlink" title="查询评论#4及其所有后代"></a>查询评论#4及其所有后代</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c2.* <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">as</span> c1</span><br><span class="line"><span class="keyword">join</span> <span class="keyword">comment</span> <span class="keyword">as</span> c2 <span class="keyword">on</span> c2.nsleft <span class="keyword">between</span> c1.nsleft <span class="keyword">and</span> c1.nsright</span><br><span class="line"><span class="keyword">where</span> c1.comment_id=<span class="number">4</span>;</span><br></pre></td></tr></table></figure><h6 id="查询评论-6的祖先"><a href="#查询评论-6的祖先" class="headerlink" title="查询评论#6的祖先"></a>查询评论#6的祖先</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c2.* <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">as</span> c1</span><br><span class="line"><span class="keyword">join</span> <span class="keyword">comment</span> <span class="keyword">as</span> c2 <span class="keyword">on</span> c1.nsleft <span class="keyword">between</span> c2.nsleft <span class="keyword">and</span> c2.nsright</span><br><span class="line"><span class="keyword">where</span> c1.comment_id=<span class="number">4</span>;</span><br></pre></td></tr></table></figure><h6 id="删除指定节点"><a href="#删除指定节点" class="headerlink" title="删除指定节点"></a>删除指定节点</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;可以直接删除，虽然再示例图中，左右两个值时有序的，而每个节点也是和它相邻的父兄节点进行比较，但是嵌套集设计并不必须保证分层关系。并且在你删除某节点后，该节点所有子节点自动上移</p><h6 id="查询评论-6的直接父亲"><a href="#查询评论-6的直接父亲" class="headerlink" title="查询评论#6的直接父亲"></a>查询评论#6的直接父亲</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> parent.* <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">as</span> c </span><br><span class="line"><span class="keyword">join</span> <span class="keyword">comment</span> <span class="keyword">as</span> <span class="keyword">parent</span> </span><br><span class="line"><span class="keyword">on</span> c.nsleft <span class="keyword">between</span> parent.nsleft <span class="keyword">and</span> parent.nsright</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">comment</span> <span class="keyword">as</span> in_between </span><br><span class="line"><span class="keyword">on</span> c.nsleft <span class="keyword">between</span> in_between.nsleft <span class="keyword">and</span> in_between.nsright</span><br><span class="line"><span class="keyword">and</span> in_between.nsleft <span class="keyword">between</span> parent.nsleft <span class="keyword">and</span> parent.nsright</span><br><span class="line"><span class="keyword">where</span> c.comment_id = <span class="number">6</span></span><br><span class="line"><span class="keyword">and</span> in_between.comment_id <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h6 id="增加，移动节点"><a href="#增加，移动节点" class="headerlink" title="增加，移动节点"></a>增加，移动节点</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;这个对于嵌套集要复杂的多，你需要重新计算插入节点的相邻兄弟的节点、祖先节点和祖先节点的兄弟，来确保它们左右值都比这个新节点的左右值大，如果这个节点不是非叶节点，你还需要计算它的子孙节点。<br>&nbsp;&nbsp;&nbsp;&nbsp;插入一个叶子节点，以下语句将更新每个需要更新的地方</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- make space for NS values 8 and 9</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">comment</span></span><br><span class="line"><span class="keyword">set</span> nsleft = <span class="keyword">case</span> </span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">nsleft &gt;= <span class="number">8</span> </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">nsleft + <span class="number">2</span> </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">nsleft </span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line">nsright = nsright + <span class="number">2</span></span><br><span class="line"><span class="keyword">where</span> nsright &gt;= <span class="number">7</span>;</span><br><span class="line"><span class="comment">-- create new child of comment #5 occupying NS values 8 and 9</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">comment</span>(nsleft, nsright, author, <span class="keyword">comment</span>)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">8</span>, <span class="number">9</span>, <span class="string">'Fran'</span>, <span class="string">'Me too!'</span>);</span><br></pre></td></tr></table></figure><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>优点：查询，简单快速。删除时，原来子节点的关系自动上移。<br>缺点：</p><ol><li>查询一个节点的直接上级或下级，很困难。</li><li>增、改，困难。</li></ol><h5 id="3-闭包表："><a href="#3-闭包表：" class="headerlink" title="3.闭包表："></a>3.闭包表：</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;闭包表是解决分级存储一个简单而优雅的解决办法。<br>&nbsp;&nbsp;&nbsp;&nbsp;创建另一张叫做tree_path，他包含两列，每一列都是一个指向comment中的comment_id</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">comment</span>(</span><br><span class="line">comment_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">author <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">comment_date datetime <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">comment</span> <span class="built_in">text</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (author) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tree_path(</span><br><span class="line">ancestor <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">descendant <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">primary <span class="keyword">key</span>(ancestor,descendant),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(ancestor) <span class="keyword">references</span> <span class="keyword">comment</span>(comment_id),</span><br><span class="line"><span class="keyword">foreign</span> <span class="keyword">key</span>(descendant) <span class="keyword">references</span> <span class="keyword">comment</span>(comment_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;将树中任何一对具有祖先-后代关系的节点对都存储在tree_path的一行中，即使他们不是直接的父子关系，同时还增加一行指向自己。<br><img src="/images/sql/antipatterns/03/comment_4.png" alt="评论示意图"></p><h6 id="查询评论-4的后代"><a href="#查询评论-4的后代" class="headerlink" title="查询评论#4的后代"></a>查询评论#4的后代</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.* <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">join</span> tree_path <span class="keyword">as</span> t <span class="keyword">on</span> c.comment_id = t.descendant</span><br><span class="line"><span class="keyword">where</span> t.ancestor = <span class="number">4</span></span><br></pre></td></tr></table></figure><h6 id="查询评论-6的祖先-1"><a href="#查询评论-6的祖先-1" class="headerlink" title="查询评论#6的祖先"></a>查询评论#6的祖先</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.* <span class="keyword">from</span> <span class="keyword">comment</span> <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">join</span> tree_path <span class="keyword">as</span> t <span class="keyword">on</span> c.comment_id = t.ancestor</span><br><span class="line"><span class="keyword">where</span> t.descendant = <span class="number">6</span></span><br></pre></td></tr></table></figure><h6 id="插入-5下的子节点-8"><a href="#插入-5下的子节点-8" class="headerlink" title="插入#5下的子节点#8"></a>插入#5下的子节点#8</h6><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insert into tree_path（ancestor,descendant）</span><br><span class="line"><span class="keyword">select</span> t.ancestor, <span class="number">8</span></span><br><span class="line">from tree_path <span class="keyword">as</span> t</span><br><span class="line">where t.descendant = <span class="number">5</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">all</span></span></span><br><span class="line"><span class="keyword">select</span> <span class="number">8</span>, <span class="number">8</span>;</span><br></pre></td></tr></table></figure><h6 id="删除评论-4"><a href="#删除评论-4" class="headerlink" title="删除评论#4"></a>删除评论#4</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除直接后代</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tree_path <span class="keyword">where</span> descendant = <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 删除所有后代 </span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tree_path </span><br><span class="line"><span class="keyword">where</span> descendant <span class="keyword">in</span> (<span class="keyword">select</span> descendant <span class="keyword">from</span> tree_path <span class="keyword">where</span> ancestor = <span class="number">4</span>);</span><br></pre></td></tr></table></figure><h6 id="移动，-6从现在的位置-4的孩子-移动到-3下"><a href="#移动，-6从现在的位置-4的孩子-移动到-3下" class="headerlink" title="移动，#6从现在的位置(#4的孩子)移动到#3下"></a>移动，#6从现在的位置(#4的孩子)移动到#3下</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除所有子节点跟他祖先的关系</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tree_path </span><br><span class="line"><span class="keyword">where</span> descendant <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> descendant <span class="keyword">from</span> tree_path</span><br><span class="line"><span class="keyword">where</span> ancestor = <span class="number">6</span></span><br><span class="line">) <span class="keyword">and</span> ancestor <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> ancestor <span class="keyword">from</span> tree_path</span><br><span class="line"><span class="keyword">where</span> descendant = <span class="number">6</span></span><br><span class="line"><span class="keyword">and</span> ancestor != descendant</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 建立新节点的关系</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tree_path (ancestor,descendant) </span><br><span class="line"><span class="keyword">select</span> supertree.ancestor,supertree.descendant <span class="keyword">from</span> tree_path <span class="keyword">as</span> supertree</span><br><span class="line"><span class="keyword">cross</span> <span class="keyword">join</span> tree_path <span class="keyword">as</span> subtree</span><br><span class="line"><span class="keyword">where</span> supertree.descendant = <span class="number">3</span> <span class="keyword">and</span> subtree.ancestor = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h4 id="你改使用哪种设计"><a href="#你改使用哪种设计" class="headerlink" title="你改使用哪种设计"></a>你改使用哪种设计</h4><ul><li><p>邻接表<br>&nbsp;&nbsp;&nbsp;&nbsp;简单高效，如果你的数据库支持WITH或者CONNECT BY PRIOR的递归查询，那么邻接表是最高效的</p></li><li><p>路劲枚举<br>&nbsp;&nbsp;&nbsp;&nbsp;直观的看到祖先到后代关系，但无法保证引用完整性</p></li><li><p>嵌套集<br>&nbsp;&nbsp;&nbsp;&nbsp;无法保证引用完整性，太复杂。适用于查询小于非常高场景</p></li><li><p>闭包表<br>&nbsp;&nbsp;&nbsp;&nbsp;以空间换时间，通用的设计</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql批量插入数据量过大报错</title>
      <link href="/2018/06/20/sql/mysql%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E9%87%8F%E8%BF%87%E5%A4%A7%E6%8A%A5%E9%94%99/"/>
      <url>/2018/06/20/sql/mysql%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E9%87%8F%E8%BF%87%E5%A4%A7%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h4 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Packet <span class="keyword">for</span> query is too large (6071393 &gt; 4194304). You can change this value on the<span class="built_in"> server </span>by setting the max_allowed_packet<span class="string">' variable.</span></span><br></pre></td></tr></table></figure><h4 id="报错SQL"><a href="#报错SQL" class="headerlink" title="报错SQL"></a>报错SQL</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert <span class="built_in">int</span>o table_name(col1，col2) </span><br><span class="line">values (<span class="number">1</span>, <span class="number">2</span>),(<span class="number">1</span>, <span class="number">3</span>) ....;</span><br></pre></td></tr></table></figure><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;批量插入数据时，以上SQL肯定是首选，在java中使用for循环插入，效率肯定要低。但是数据量超大时，以上sql会报错，是因为msql默认限制了。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="修改mysql配置"><a href="#修改mysql配置" class="headerlink" title="修改mysql配置"></a>修改mysql配置</h5><ol><li>修改 my.ini, 添加以下配置。67108864则是大小，单位为字节。需要根据自己项目需求修改大小。需要重启mysql服务<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">max_allowed_packet</span> =<span class="number">67108864</span></span><br></pre></td></tr></table></figure></li><li>也可以登录mysql使用以下命令<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> global <span class="comment">max_allowed_packet = 67108864</span>;</span><br></pre></td></tr></table></figure></li><li>查看是否生效<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">VARIABLES</span> <span class="keyword">like</span> <span class="string">'%max_allowed_packet%'</span>;</span><br></pre></td></tr></table></figure></li></ol><h5 id="java中控制插入条数（推荐）"><a href="#java中控制插入条数（推荐）" class="headerlink" title="java中控制插入条数（推荐）"></a>java中控制插入条数（推荐）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;以上方法虽然能解燃眉之急，但是如何保证以后不会超过你设置的值？当达到一定量时，JVM也会内存溢出，数据库压力也扛不住。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; data = dosomething();</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt;&gt; temp = Lists.partition(data, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">List</span>&lt;<span class="built_in">Object</span>&gt; item : temp)&#123;</span><br><span class="line">    insert(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上代码为，将要修改数据分隔成多份，每一份的大小为1000(不要写魔法值哦)个。每一份插入一次。</p>]]></content>
      
      
      <categories>
          
          <category> 踩坑日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初说 - ActiveMQ</title>
      <link href="/2018/06/17/middleware/activemq-simple/"/>
      <url>/2018/06/17/middleware/activemq-simple/</url>
      
        <content type="html"><![CDATA[<h4 id="一、AvticeMQ"><a href="#一、AvticeMQ" class="headerlink" title="一、AvticeMQ"></a>一、AvticeMQ</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;ActiveMQ 是Apache出品的开源消息总线。完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现</p><h4 id="二、JMS"><a href="#二、JMS" class="headerlink" title="二、JMS"></a>二、JMS</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p><h4 id="三、JMS支持的两种消息传递模型"><a href="#三、JMS支持的两种消息传递模型" class="headerlink" title="三、JMS支持的两种消息传递模型"></a>三、JMS支持的两种消息传递模型</h4><h5 id="1-Queue（点对点-point-to-point，简称PTP）"><a href="#1-Queue（点对点-point-to-point，简称PTP）" class="headerlink" title="1. Queue（点对点 point-to-point，简称PTP）"></a>1. Queue（点对点 point-to-point，简称PTP）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;通过该消息传递模型，一个应用程序（即消息生产者）可以向另外一个应用程序（即消息消费者）发送消息。消息目的地类型是队列（即由Session接口实现类实例通过调用其createQueue方法并传入队列名称而创建）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;消息首先被传送至消息服务器端特定的队列中，然后从此对列中将消息传送至对此队列进行监听的某个消费者。同一个队列可以关联多个消息生产者和消息消费者，但<strong>一条消息仅能传递给一个消息消费者</strong>。如果多个消息消费者正在监听队列上的消息，JMS消息服务器将根据“先来者优先”的原则确定由哪个消息消费者接收下一条消息。如果没有消息消费者在监听队列，消息将保留在队列中，直至消息消费者连接到队列为止。这种消息传递模型是传统意义上的懒模型或轮询模型。在此模型中，<strong>消息不是自动推动给消息消费者的，而是要由消息消费者从队列中请求获得</strong>。 </p><h5 id="2-Topic（发布-订阅-publish-subscribe，简称pub-sub）"><a href="#2-Topic（发布-订阅-publish-subscribe，简称pub-sub）" class="headerlink" title="2. Topic（发布/订阅 publish/subscribe，简称pub/sub）"></a>2. Topic（发布/订阅 publish/subscribe，简称pub/sub）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;通过该消息传递模型，应用程序能够将一条消息发送给多个消息消费者。消息目的地类型是主题（即Destination接口实现类实例由Session接口实现类实例通过调用其createTopic方法并传入主题名称而创建）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;消息首先由消息生产者发布至消息服务器中特定的主题中，然后由消息服务器将消息传送至所有已订阅此主题的消费者。与PTP消息传递模型不同，<strong>pub/sub消息传递模型允许多个主题订阅者接收同一条消息</strong>。在该模型中，消息会自动广播，<strong>消息消费者无须通过主动请求或轮询主题的方法来获得新的消息</strong>。</p><h5 id="3-Queue-和-Topic-具体区别"><a href="#3-Queue-和-Topic-具体区别" class="headerlink" title="3. Queue 和 Topic 具体区别"></a>3. Queue 和 Topic 具体区别</h5><table><thead><tr><th>Tables</th><th>Topic</th><th>Queue</th></tr></thead><tbody><tr><td>概要</td><td>Publish Subscribe messaging 发布订阅消息</td><td>Point-to-Point 点对点</td></tr><tr><td>有无状态</td><td>topic数据默认不落地，是无状态的。</td><td>Queue数据默认会在mq服务器上以文件形式保存，比如Active MQ一般保存在$AMQ_HOME\data\kr-store\data下面。也可以配置成DB存储。</td></tr><tr><td>完整性保障</td><td>并不保证publisher发布的每条数据，Subscriber都能接受到。</td><td>Queue保证每条数据都能被receiver接收。</td></tr><tr><td>消息是否会丢失</td><td>一般来说publisher发布消息到某一个topic时，只有正在监听该topic地址的sub能够接收到消息；如果没有sub在监听，该topic就丢失了。</td><td>Sender发送消息到目标Queue，receiver可以异步接收这个Queue上的消息。Queue上的消息如果暂时没有receiver来取，也不会丢失。</td></tr><tr><td>消息发布接收策略</td><td>一对多的消息发布接收策略，监听同一个topic地址的多个sub都能收到publisher发送的消息。Sub接收完通知mq服务器</td><td>一对一的消息发布接收策略，一个sender发送的消息，只能有一个receiver接收。receiver接收完后，通知mq服务器已接收，mq服务器对queue里的消息采取删除或其他操作。</td></tr></tbody></table><h4 id="四、AvticeMQ-配置"><a href="#四、AvticeMQ-配置" class="headerlink" title="四、AvticeMQ 配置"></a>四、AvticeMQ 配置</h4><h5 id="failover"><a href="#failover" class="headerlink" title="failover"></a>failover</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">failover:(tcp:<span class="comment">//192.168.1.118:61616?connectionTimeout=3000)</span></span><br><span class="line">?timeout=<span class="number">5000</span></span><br><span class="line">&amp;initialReconnectDelay=<span class="number">1000</span></span><br><span class="line">&amp;maxReconnectDelay=<span class="number">1000</span></span><br><span class="line">&amp;nested.wireFormat.maxInactivityDuration=<span class="number">30000</span></span><br></pre></td></tr></table></figure><p><strong>initialReconnectDelay：</strong>默认为10，单位毫秒，表示第一次尝试重连之前等待的时间。<br><strong>maxReconnectDelay：</strong>默认30000，单位毫秒，表示两次重连之间的最大时间间隔。<br><strong>nested.wireFormat.maxInactivityDuration</strong> 检测死连接时间<br><strong><a href="http://manzhizhen.iteye.com/blog/2105572" target="_blank" rel="noopener">其它相关配置</a></strong></p><h4 id="五、ActiveMQ-使用"><a href="#五、ActiveMQ-使用" class="headerlink" title="五、ActiveMQ 使用"></a>五、ActiveMQ 使用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;一种典型的JMS 程序需要经过下列几个步骤:</p><ol><li>通过 JNDI 查找 ConnectionFactory。</li><li>用 ConnectionFactory 创建一个 Connection。</li><li>用 Connection 创建一个或多个 Session。 </li><li>用 Session 和 Destination 创建所需的 MessageProducer 和 MessageConsumer。 </li><li>启动 Connection。 (下面是对应的截图说明)</li></ol><h5 id="1-连接工厂-ConnectionFactory"><a href="#1-连接工厂-ConnectionFactory" class="headerlink" title="1. 连接工厂 (ConnectionFactory)"></a>1. 连接工厂 (ConnectionFactory)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;连接工厂是客户用来创建连接的对象.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;例如: ActiveMQ 提供的ActiveMQConnectionFactory。注意（要初始化 JMS，则需要使用连接工厂。客户端通过创建ConnectionFactory建立到 ActveMQ的连接，一个连接工厂封装了一组连接配置参数，这组参数在配置ActiveMQ时已经定义，例如brokerURL参数，此参数传入的是ActiveMQ服务地址和端口，支持openwire协议的默认连接为 tcp://localhost:61616，支持 stomp协议的默认连接为tcp://localhost:61613。</p><h6 id="ActiveMQConnectionFactory构造方法："><a href="#ActiveMQConnectionFactory构造方法：" class="headerlink" title="ActiveMQConnectionFactory构造方法："></a>ActiveMQConnectionFactory构造方法：</h6><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">ActiveMQConnectionFactory()</span>;</span><br><span class="line"><span class="constructor">ActiveMQConnectionFactory(String <span class="params">brokerURL</span>)</span>;</span><br><span class="line"><span class="constructor">ActiveMQConnectionFactory(String <span class="params">userName</span>, String <span class="params">password</span>, String <span class="params">b</span> <span class="params">rokerURL</span>)</span> ; </span><br><span class="line"><span class="constructor">ActiveMQConnectionFactory(String <span class="params">userName</span>, String <span class="params">password</span>, URI <span class="params">brok</span> <span class="params">erURL</span>)</span> ; </span><br><span class="line"><span class="constructor">ActiveMQConnectionFactory(URI <span class="params">brokerURL</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中 brokerURL为ActiveMQ服务地址和端口。</p><h6 id="spring封装的："><a href="#spring封装的：" class="headerlink" title="spring封装的："></a>spring封装的：</h6><ul><li><p><strong>SingleConnectionFactory</strong>：对于建立JMS服务器链接的请求会一直返回同一个链接，并且会忽略Connection的close方法调用。(<br>org.springframework.jms.connection.SingleConnectionFactory)</p></li><li><p><strong>CachingConnectionFactory</strong>：继承了SingleConnectionFactory，所以它拥有SingleConnectionFactory的所有功能，同时它还新增了缓存功能，它可以缓存Session、MessageProducer和MessageConsumer。我们使用CachingConnectionFactory来作为示例。(<br>org.springframework.jms.connection.CachingConnectionFactory)</p></li><li><p><strong>PooledConnectionFactory</strong>：线程池(org.apache.activemq.pool.PooledConnectionFactory)</p></li></ul><h5 id="2-连接-Connection"><a href="#2-连接-Connection" class="headerlink" title="2. 连接 (Connection)"></a>2. 连接 (Connection)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;Connection 封装了客户与 JMS 提供者之间的一个虚拟的连接。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;当一个Connection被创建时，它的传输默认是关闭的，必须使用start方法开启。一个Connection可以建立一个或多个的Session。当一个程序执行完成后，必须关闭之前创建的Connection，否则 ActiveMQ不能释放资源，关闭一个Connection同样也关闭了 Session，MessageProducer和MessageConsumer。</p><h5 id="3-会话-Seesion"><a href="#3-会话-Seesion" class="headerlink" title="3. 会话(Seesion)"></a>3. 会话(Seesion)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;Session 是生产和消费消息的一个单线程上下文。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;会话用于创建消息生产者（producer）、消息消费者（consumer）和消息（message）等。会话提供了一个事务性的上下文，在这个上下文中，一组发送和接收被组合到了一个原子操作中。</p><h4 id="六、ActiveMQ的多种部署方式"><a href="#六、ActiveMQ的多种部署方式" class="headerlink" title="六、ActiveMQ的多种部署方式"></a>六、ActiveMQ的多种部署方式</h4><p>具体介绍请查看文章后面部分：<a href="http://manzhizhen.iteye.com/blog/2105572" target="_blank" rel="noopener">查看</a></p><h5 id="1-Master-Slave部署方式"><a href="#1-Master-Slave部署方式" class="headerlink" title="1. Master-Slave部署方式"></a>1. Master-Slave部署方式</h5><h6 id="shared-filesystem-Master-Slave部署方式"><a href="#shared-filesystem-Master-Slave部署方式" class="headerlink" title="shared filesystem Master-Slave部署方式"></a>shared filesystem Master-Slave部署方式</h6><h6 id="shared-database-Master-Slave方式"><a href="#shared-database-Master-Slave方式" class="headerlink" title="shared database Master-Slave方式"></a>shared database Master-Slave方式</h6><h6 id="Replicated-LevelDB-Store方式"><a href="#Replicated-LevelDB-Store方式" class="headerlink" title="Replicated LevelDB Store方式"></a>Replicated LevelDB Store方式</h6><h5 id="2-Broker-Cluster部署方式"><a href="#2-Broker-Cluster部署方式" class="headerlink" title="2. Broker-Cluster部署方式"></a>2. Broker-Cluster部署方式</h5><h6 id="static-Broker-Cluster部署"><a href="#static-Broker-Cluster部署" class="headerlink" title="static Broker-Cluster部署"></a>static Broker-Cluster部署</h6><h6 id="Dynamic-Broker-Cluster部署"><a href="#Dynamic-Broker-Cluster部署" class="headerlink" title="Dynamic Broker-Cluster部署"></a>Dynamic Broker-Cluster部署</h6><h5 id="3-Master-Slave与Broker-Cluster相结合的部署方式"><a href="#3-Master-Slave与Broker-Cluster相结合的部署方式" class="headerlink" title="3. Master-Slave与Broker-Cluster相结合的部署方式"></a>3. Master-Slave与Broker-Cluster相结合的部署方式</h5>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ActiveMQ </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式02-乱穿马路</title>
      <link href="/2018/06/12/sql/antipatterns/02-%E4%B9%B1%E7%A9%BF%E9%A9%AC%E8%B7%AF/"/>
      <url>/2018/06/12/sql/antipatterns/02-%E4%B9%B1%E7%A9%BF%E9%A9%AC%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是“乱穿马路”"><a href="#什么是“乱穿马路”" class="headerlink" title="什么是“乱穿马路”"></a>什么是“乱穿马路”</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在数据库设计中，多对多的情况经常成为我们的需求，比如一个产品有多个负责人，一个人可以负责多个产品。<strong>程序员通常使用逗号分隔的列表来避免在多对多的关系中创建交叉表</strong>，书中将这种设计模式叫做<strong>“乱穿马路”</strong></p><h4 id="目的（存储多值属性）"><a href="#目的（存储多值属性）" class="headerlink" title="目的（存储多值属性）"></a>目的（存储多值属性）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;背景：每个产品对应一个联系人，一个联系人可能对应多个产品，因此我们在产品和账号之间是一个多对一的关系。我们设计product表如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">product_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">product_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">account_id <span class="built_in">BIGINT</span> UNSIGEND,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (account_id) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但是随着需求变更，一个产品需要对应多个联系人，此时product表的一行数据必须存储多个联系人</p><h4 id="反模式（格式化数据，用逗号分隔列表）"><a href="#反模式（格式化数据，用逗号分隔列表）" class="headerlink" title="反模式（格式化数据，用逗号分隔列表）"></a>反模式（格式化数据，用逗号分隔列表）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;为了将数据库表结构改动控制到最小，你决定将account_id的类型改成VARCHAR，每个账号id之间用逗号分隔，这样就可以存储多个联系人</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">product_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">product_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">account_id <span class="built_in">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这样看似可行，但是<strong>你要承受以下伴随的问题</strong></p><h5 id="1-查询指定账号的产品"><a href="#1-查询指定账号的产品" class="headerlink" title="1.查询指定账号的产品"></a>1.查询指定账号的产品</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;不能使用SQL语法中的等号操作符，只能使用like 或者正则表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> PRODUCT <span class="keyword">WHERE</span> account_id REGEXP <span class="string">'[[:&lt;:]]12[[:&gt;:]]'</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;模式匹配可能<strong>会返回错误的结果</strong>，而且，此时<strong>索引将不可用</strong>，查询效率不能保证。</p><h5 id="2-查询指定产品的账号"><a href="#2-查询指定产品的账号" class="headerlink" title="2.查询指定产品的账号"></a>2.查询指定产品的账号</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你想使用关联查询account表，也是<strong>极其耗时</strong>的，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> PRODUCT <span class="keyword">AS</span> p </span><br><span class="line"><span class="keyword">JOIN</span> <span class="keyword">ACCOUNT</span> <span class="keyword">AS</span> a </span><br><span class="line"><span class="keyword">ON</span> a.account_id REGEXP <span class="string">'[[:&lt;:]]'</span>+a.account_id+<span class="string">'[[:&gt;:]]'</span></span><br><span class="line"><span class="keyword">WHERE</span> p.product_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;以上语句必须扫描两种表，创建一个交叉结果集，然后使用正则匹配每一行联合的数据，而它不能使用任何索引</p><h5 id="3-执行聚合查询"><a href="#3-执行聚合查询" class="headerlink" title="3.执行聚合查询"></a>3.执行聚合查询</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;使用COUNT(),SUM(),AVG()等函数时也极其困难，你不得不间接的得出结果，比如实现COUNT()</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> product_id,<span class="keyword">LENGTH</span>(account_id)-<span class="keyword">LENGTH</span>(<span class="keyword">REPLACE</span>(account_id,<span class="string">','</span>,<span class="string">''</span>))+<span class="number">1</span> <span class="keyword">as</span> contacts_per_product </span><br><span class="line"><span class="keyword">FROM</span> product;</span><br></pre></td></tr></table></figure><p>这类办法看起来很帅（使用它的长度减去替换后’,’的长度，得到’,’的个数。），但是有些<strong>聚合函数根本不能使用这些技巧来完成</strong>，何况这类解决办法需要花费大量时间</p><h5 id="4-更新产品的账号"><a href="#4-更新产品的账号" class="headerlink" title="4.更新产品的账号"></a>4.更新产品的账号</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;更新产品的联系人，使用追加的方式，也不能保证按顺序存储</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE product <span class="builtin-name">SET</span> <span class="attribute">account_id</span>=account_id+','+3</span><br><span class="line">WHERE <span class="attribute">product_id</span>=1;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;删除产品某个联系人，你必须先查出老的列表，然后使用java等语言删除联系人后，才能将更新后的列表存储</p><h5 id="5-选择合适的分隔符"><a href="#5-选择合适的分隔符" class="headerlink" title="5.选择合适的分隔符"></a>5.选择合适的分隔符</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果存储一个字符串列表而不是数字列表，条目中可能会包含分隔符，那么你该如何选择分隔符，你能确保你选择的分隔符永远不会出现在条目中吗？</p><h5 id="6-列表长度限制"><a href="#6-列表长度限制" class="headerlink" title="6.列表长度限制"></a>6.列表长度限制</h5><p>&nbsp;&nbsp;&nbsp;&nbsp; 你能在一个VARCHAR(30)的结构存储多少数据？用mysql举例，如果每个条目长度为6，你只能存储4个条目，你能确定到底多少的长度够用吗？</p><h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><h5 id="如果你在开发中说过下面这些话，那么很有可能在使用“乱穿马路”"><a href="#如果你在开发中说过下面这些话，那么很有可能在使用“乱穿马路”" class="headerlink" title="如果你在开发中说过下面这些话，那么很有可能在使用“乱穿马路”"></a>如果你在开发中说过下面这些话，那么很有可能在使用“乱穿马路”</h5><ol><li><strong>列表最多支持存放多少数据？</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;这个问题在选择Varchar列的最大长度时被提及</li><li><strong>你知道怎么使用正则提取数据吗？</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;需要使用正则表达式来提取数据，这可能是一种提示，意味着你应该把这些数据分开存储。</li><li><strong>哪些字符按不会出现在任何一个条目中？</strong></li></ol><h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><ol><li>如果应用程序接收的源数据是有逗号分隔的格式，而你只需要存储和使用它们并且不对其做任何修改，完全没有必要分开其中的值。</li><li>个人补充：如果这个要存储的列表，你只是保存和单纯的查询出来，不做修改，不需要关联查询的话，我觉得完全可以这样做。你甚至还可以保存一个json数组</li></ol><h4 id="解决办法-创建一张交叉表"><a href="#解决办法-创建一张交叉表" class="headerlink" title="解决办法(创建一张交叉表)"></a>解决办法(创建一张交叉表)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;创建一张交叉表，使用规范性设计数据，能使你的代码更加灵活，以上所说的，不能使用索引，不能使用聚合函数等，都能得到解决</p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL反模式01-引子</title>
      <link href="/2018/06/10/sql/antipatterns/01-%E5%BC%95%E5%AD%90/"/>
      <url>/2018/06/10/sql/antipatterns/01-%E5%BC%95%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>像普通书籍一样，本系列博客也有引子，它将笼统介绍本系列博客内容。</p><p>本博客，是因为我读到一本<strong>《SQL反模式》</strong>的书，发现它介绍了日常开发中我经常遇到的问题，受益匪浅，所以决定写下博客，<strong>画出本书的重点，以及尽可能的将书中sql语句翻译成mysql</strong>，一来帮我记忆，二来分享和大家一起学习</p><h4 id="什么是“反模式”"><a href="#什么是“反模式”" class="headerlink" title="什么是“反模式”"></a>什么是“反模式”</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;本书介绍到的“反模式”，定义为：“反模式是一种<strong>试图</strong>解决需求的“不合常规”方法。”<br>&nbsp;&nbsp;&nbsp;&nbsp;注意：是<strong>试图</strong>，指我们在遇到需求时，想到某个“不合常规”的解决办法，引发的系列问题，但不是说这样的解决办法不好，我们要合理使用</p><h4 id="反模式分类"><a href="#反模式分类" class="headerlink" title="反模式分类"></a>反模式分类</h4><ol><li>逻辑数据库设计反模式</li><li>物理数据库设计反模式</li><li>查询反模式</li><li>应用程序开发反模式</li></ol><h4 id="本书每章结构，我也尽量按照这个结构记录"><a href="#本书每章结构，我也尽量按照这个结构记录" class="headerlink" title="本书每章结构，我也尽量按照这个结构记录"></a>本书每章结构，我也尽量按照这个结构记录</h4><ul><li><strong>目的</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;这是你可能要去尝试解决的任务。意图使用反模式提供解决方案，但通常会以引起更多问题而告终。</li><li><strong>反模式</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;这一部分表述了通常使用的解决方案的本质，并且展示了那些没有预知到的后果，正是这些使得这些方案成为反模式。</li><li><strong>如何识别反模式</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;一些固定的方式会有助于你辨识在项目中使用的反模式。你遇到的特殊障碍，或是你自己和别人说的一些话，都能使你提前识别出反模式。</li><li><strong>合理使用反模式</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;规则总有例外。在某些情况下，本来认为是反模式的设计却可能是合理的，或者说至少是所有的方案中最合理的。</li><li><strong>解决办法</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;描述了首选的最佳解决方案，他们不仅能够解决原有的问题，同时也不至于引起由反模式导致的新问题。</li></ul><h4 id="示例数据库"><a href="#示例数据库" class="headerlink" title="示例数据库"></a>示例数据库</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;以下sql跟书中不一致，我修改有些命名规则，如下。<br>&nbsp;&nbsp;&nbsp;&nbsp;我不喜欢表名存在复数，因为这样会让我生成java类也是复数。<br>&nbsp;&nbsp;&nbsp;&nbsp;我不喜欢表名用驼峰的规则，这貌似也不符合sql的规范。<br>&nbsp;&nbsp;&nbsp;&nbsp;这两点出现在书中，感觉有点怪，也可能是我认知错了</p><h5 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">account</span>(</span><br><span class="line">account_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">account_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">first_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">last_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">email <span class="built_in">VARCHAR</span>(<span class="number">1000</span>),</span><br><span class="line">password_hash <span class="built_in">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">protrait_image <span class="built_in">BLOB</span>,</span><br><span class="line">hourly_rate <span class="built_in">NUMERIC</span>(<span class="number">9</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_stastus(</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) PRIMARY <span class="keyword">KEY</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line">bug_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">date_reported <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">summary <span class="built_in">VARCHAR</span>(<span class="number">80</span>),</span><br><span class="line">description <span class="built_in">VARCHAR</span>(<span class="number">1000</span>),</span><br><span class="line">resolution <span class="built_in">VARCHAR</span>(<span class="number">1000</span>),</span><br><span class="line">reported_by <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">assigned_to <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span>,</span><br><span class="line">verified_by <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span>,</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'NEW'</span>,</span><br><span class="line"><span class="keyword">priority</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">hours</span> <span class="built_in">NUMERIC</span>(<span class="number">9</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (reported_by) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (assigned_to) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (verified_by) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="keyword">status</span>) <span class="keyword">REFERENCES</span> bug_stastus(<span class="keyword">status</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> comments(</span><br><span class="line">comment_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">bug_id <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">author <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">comment_date DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">comment</span> <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (author) <span class="keyword">REFERENCES</span> <span class="keyword">account</span>(account_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> screenshot(</span><br><span class="line">bug_id <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">image_id <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">screenshot_image <span class="built_in">BLOB</span>,</span><br><span class="line">caption <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (bug_id,image_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tag(</span><br><span class="line">bug_id <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">tag <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (bug_id,tag),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">product_id <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">product_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_product(</span><br><span class="line">bug_id <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">product_id <span class="built_in">BIGINT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (bug_id,product_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (bug_id) <span class="keyword">REFERENCES</span> bug(bug_id),</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (product_id) <span class="keyword">REFERENCES</span> product(product_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="ERD图"><a href="#ERD图" class="headerlink" title="ERD图"></a>ERD图</h5><p><img src="/images/sql/antipatterns/01/database_erd.png" alt="ERD图"></p>]]></content>
      
      
      <categories>
          
          <category> SQL反模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【干货】java集成paypal，含android代码，服务端代码</title>
      <link href="/2018/06/09/integrate/paypal/"/>
      <url>/2018/06/09/integrate/paypal/</url>
      
        <content type="html"><![CDATA[<h3 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h3><blockquote><p><strong>1. 前端选择商品，调用paypal支付</strong></p></blockquote><blockquote><p><strong>2. 支付完成，paypal会返回payment信息，将payment的id返回给自己服务端</strong></p></blockquote><blockquote><p><strong>3. 服务端根据paymentId,调paypal，查询支付是否完成</strong></p></blockquote><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li><p>前往<code>https://www.paypal.com/</code>注册商家账号</p></li><li><p>前往<code>https://developer.paypal.com/</code>，使用刚注册的商家账号登录</p></li><li><p>点击右上角名字，选择Dashboard</p></li><li><p>在左边的导航栏中点击 Sandbox 下的 Accounts</p></li><li><p>进入Acccouts界面后，可以看到系统有两个已经生成好的测试账号，但是我们不要用系统给的测试账号，自己创建两个，一个是商家账号，一个是个人账号</p><blockquote><ol><li>点击右上角的“Create Account”，创建测试用户 </li><li>先创建一个“ PERSONAL”类型的用户，国家一定要选“China”，账户余额自己填写（邮箱地址可以随便写，自己好记就行）</li><li>接着创建一个“BUSINESS”类型的用户，国家一定要选“China”，账户余额自己填写 （邮箱地址可以随便写，自己好记就行）</li><li>创建好之后可以点击测试账号下的”Profile“，可以查看信息，如果没加载出来，刷新</li><li>用测试账号登录测试网站查看，注意！这跟paypal官网不同！不是同一个地址，在浏览器输入：<code>https://www.sandbox.paypal.com</code> 在这里登陆测试账户</li></ol></blockquote></li><li><p>创建应用，生成用于测试的clientID 和 密钥 </p><blockquote><ol><li>点击左边导航栏Dashboard下的My Apps &amp; Credentials，创建一个Live账号</li><li>然后再到下边创建App</li><li>点击刚刚创建好的App，注意看到”ClientID“ 和”Secret“(Secret如果没显示，点击下面的show就会看到，点击后show变为hide) </li></ol></blockquote></li></ul><h3 id="start-coding"><a href="#start-coding" class="headerlink" title="start coding"></a>start coding</h3><h4 id="Android"><a href="#Android" class="headerlink" title="Android`"></a>Android`</h4><ul><li><p>添加依赖</p><pre><code>`compile(&apos;com.paypal.sdk:paypal-android-sdk:2.15.1&apos;) { exclude group: &apos;io.card&apos; }//禁止通过信用卡直接支付，如果不禁止可以直接去掉这一句`</code></pre></li><li><p>强制在你的编译版本上执行编译操作（编译不过的时候才建议添加）</p><pre><code>`&lt;uses-sdk    android:minSdkVersion=&quot;这里填写你需要的编译版本&quot;    tools:overrideLibrary=&quot;com.paypal.android.sdk.payments&quot; /&gt;`</code></pre></li><li><p>封装好的工具类</p><pre><code>`    import android.app.Activity;    import android.content.Context;    import android.content.Intent;    import android.util.Log;    import com.globalegrow.app.gearbest.network.HttpCallBack;    import com.globalegrow.app.gearbest.widget.CustomToast;    import com.paypal.android.sdk.payments.PayPalAuthorization;    import com.paypal.android.sdk.payments.PayPalConfiguration;    import com.paypal.android.sdk.payments.PayPalFuturePaymentActivity;    import com.paypal.android.sdk.payments.PayPalItem;    import com.paypal.android.sdk.payments.PayPalPayment;    import com.paypal.android.sdk.payments.PayPalPaymentDetails;    import com.paypal.android.sdk.payments.PayPalProfileSharingActivity;    import com.paypal.android.sdk.payments.PayPalService;    import com.paypal.android.sdk.payments.PaymentActivity;    import com.paypal.android.sdk.payments.PaymentConfirmation;    import org.json.JSONException;    import org.json.JSONObject;    import java.io.IOException;    import java.math.BigDecimal;    /**     * Create by Moosen on 09/11/2016     */    public class PayPalHelper {        private static final String TAG = &quot;PayPalHelper&quot;;        //配置何种支付环境，一般沙盒，正式        private static final String CONFIG_ENVIRONMENT = PayPalConfiguration.ENVIRONMENT_SANDBOX;        // note that these credentials will differ between live &amp; sandbox environments.        //你所注册的APP Id        private static final String CONFIG_CLIENT_ID = &quot;&quot;;        private static final int REQUEST_CODE_PAYMENT = 1;        private static final int REQUEST_CODE_FUTURE_PAYMENT = 2;        private static final int REQUEST_CODE_PROFILE_SHARING = 3;        private static PayPalConfiguration config = new PayPalConfiguration()                .environment(CONFIG_ENVIRONMENT)                .clientId(CONFIG_CLIENT_ID);        //以下配置是授权支付的时候用到的    //            .merchantName(&quot;Example Merchant&quot;)    //            .merchantPrivacyPolicyUri(Uri.parse(&quot;https://www.example.com/privacy&quot;))    //            .merchantUserAgreementUri(Uri.parse(&quot;https://www.example.com/legal&quot;));        private static PayPalHelper payPalHelper;        private PayPalHelper() {        }        public static PayPalHelper getInstance() {            if (payPalHelper == null) {                synchronized (PayPalHelper.class) {                    payPalHelper = new PayPalHelper();                }            }            return payPalHelper;        }        /**         * 启动PayPal服务         *         * @param context         */        public void startPayPalService(Context context) {            Intent intent = new Intent(context, PayPalService.class);            intent.putExtra(PayPalService.EXTRA_PAYPAL_CONFIGURATION, config);            context.startService(intent);        }        /**         * 停止PayPal服务  sdfsdfsdssaaass         *         * @param context         */        public void stopPayPalService(Context context) {            context.stopService(new Intent(context, PayPalService.class));        }        /**         * 开始执行支付操作         *         * @param context         */        public void doPayPalPay(Context context) {            /*             * PAYMENT_INTENT_SALE will cause the payment to complete immediately.             * Change PAYMENT_INTENT_SALE to             *   - PAYMENT_INTENT_AUTHORIZE to only authorize payment and capture funds later.             *   - PAYMENT_INTENT_ORDER to create a payment for authorization and capture             *     later via calls from your server.             *             * Also, to include additional payment details and an item list, see getStuffToBuy() below.             */            PayPalPayment thingToBuy = getStuffToBuy(PayPalPayment.PAYMENT_INTENT_SALE);            /*             * See getStuffToBuy(..) for examples of some available payment options.             */            Intent intent = new Intent(context, PaymentActivity.class);            // send the same configuration for restart resiliency            intent.putExtra(PayPalService.EXTRA_PAYPAL_CONFIGURATION, config);            intent.putExtra(PaymentActivity.EXTRA_PAYMENT, thingToBuy);            ((Activity) context).startActivityForResult(intent, REQUEST_CODE_PAYMENT);        }        /*             * This method shows use of optional payment details and item list.             *             * 直接给PP创建支付的信息，支付对象实体信息             */        private PayPalPayment getStuffToBuy(String paymentIntent) {            //--- include an item list, payment amount details            //具体的产品信息列表            PayPalItem[] items =                    {                            new PayPalItem(&quot;sample item #1&quot;, 2, new BigDecimal(&quot;0.50&quot;), &quot;USD&quot;,                                    &quot;sku-12345678&quot;),                            new PayPalItem(&quot;free sample item #2&quot;, 1, new BigDecimal(&quot;0.00&quot;),                                    &quot;USD&quot;, &quot;sku-zero-price&quot;),                            new PayPalItem(&quot;sample item #3 with a longer name&quot;, 6, new BigDecimal(&quot;0.99&quot;),                                    &quot;USD&quot;, &quot;sku-33333&quot;)                    };            BigDecimal subtotal = PayPalItem.getItemTotal(items);            BigDecimal shipping = new BigDecimal(&quot;0.21&quot;);            BigDecimal tax = new BigDecimal(&quot;0.67&quot;);            PayPalPaymentDetails paymentDetails = new PayPalPaymentDetails(shipping, subtotal, tax);            BigDecimal amount = subtotal.add(shipping).add(tax);            PayPalPayment payment = new PayPalPayment(amount, &quot;USD&quot;, &quot;sample item&quot;, paymentIntent);            payment.items(items).paymentDetails(paymentDetails);            //--- set other optional fields like invoice_number, custom field, and soft_descriptor            payment.custom(&quot;This is text that will be associated with the payment that the app can use.&quot;);            return payment;        }        /**         * 处理支付之后的结果         *         * @param context         * @param requestCode         * @param resultCode         * @param data         */        public void confirmPayResult(final Context context, int requestCode, int resultCode, Intent data, final DoResult doResult) {            if (requestCode == REQUEST_CODE_PAYMENT) {                if (resultCode == Activity.RESULT_OK) {                    PaymentConfirmation confirm =                            data.getParcelableExtra(PaymentActivity.EXTRA_RESULT_CONFIRMATION);                    if (confirm != null) {                        try {                            Log.i(TAG, confirm.toJSONObject().toString(4));                            Log.i(TAG, confirm.getPayment().toJSONObject().toString(4));                            /**                             *  TODO: send &apos;confirm&apos; (and possibly confirm.getPayment() to your server for verification                             * or consent completion.                             * See https://developer.paypal.com/webapps/developer/docs/integration/mobile/verify-mobile-payment/                             * for more details.                             *                             * For sample mobile backend interactions, see                             * https://github.com/paypal/rest-api-sdk-python/tree/master/samples/mobile_backend                             */    //                        displayResultText(&quot;PaymentConfirmation info received from PayPal&quot;);                            // 这里直接跟服务器确认支付结果，支付结果确认后回调处理结果                            JSONObject jsonObject = confirm.toJSONObject();                            if (jsonObject != null) {                                JSONObject response = jsonObject.optJSONObject(&quot;response&quot;);                                if (response != null) {                                    String id = response.optString(&quot;id&quot;);                                    try {                                        CartManager.getInstance().confirmPayPalPayPrice(context, id, new HttpCallBack&lt;String&gt;() {                                            @Override                                            public void onSuccess(String responseString) {                                                if (responseString != null) {                                                    try {                                                        JSONObject jsonObject = new JSONObject(responseString);                                                        if (jsonObject != null) {                                                            int resultcode = jsonObject.optInt(&quot;_resultcode&quot;);                                                            String msg = jsonObject.optString(&quot;_msg&quot;);                                                            if (200 == resultcode) {                                                                doResult.confirmSuccess();                                                                Log.i(TAG, &quot;dddddddd&quot;);                                                            } else {                                                                Log.i(TAG, &quot;ssssssss&quot;);                                                                CustomToast.getInstance(context).showToast(msg);                                                                doResult.confirmNetWorkError();                                                            }                                                            CustomToast.getInstance(context).showToast(msg);                                                        }                                                    } catch (JSONException e) {                                                        e.printStackTrace();                                                        doResult.confirmNetWorkError();                                                    }                                                }                                            }                                            @Override                                            public void onFailure(IOException e) {                                                Log.i(TAG, &quot;aaaaaaaa&quot;);                                                doResult.confirmNetWorkError();                                            }                                        });                                    } catch (Exception e) {                                        e.printStackTrace();                                        doResult.confirmNetWorkError();                                    }                                }                            }                        } catch (JSONException e) {                            Log.e(TAG, &quot;an extremely unlikely failure occurred: &quot;, e);                            doResult.confirmNetWorkError();                        }                    }                } else if (resultCode == Activity.RESULT_CANCELED) {                    Log.i(TAG, &quot;The user canceled.&quot;);                    doResult.customerCanceled();                } else if (resultCode == PaymentActivity.RESULT_EXTRAS_INVALID) {                    doResult.invalidPaymentConfiguration();                    Log.i(                            TAG,                            &quot;An invalid Payment or PayPalConfiguration was submitted. Please see the docs.&quot;);                }            } else if (requestCode == REQUEST_CODE_FUTURE_PAYMENT) {                if (resultCode == Activity.RESULT_OK) {                    PayPalAuthorization auth =                            data.getParcelableExtra(PayPalFuturePaymentActivity.EXTRA_RESULT_AUTHORIZATION);                    if (auth != null) {                        try {                            doResult.confirmFuturePayment();                            Log.i(&quot;FuturePaymentExample&quot;, auth.toJSONObject().toString(4));                            String authorization_code = auth.getAuthorizationCode();                            Log.i(&quot;FuturePaymentExample&quot;, authorization_code);    //                        sendAuthorizationToServer(auth);    //                        displayResultText(&quot;Future Payment code received from PayPal&quot;);                        } catch (JSONException e) {                            doResult.confirmNetWorkError();                            Log.e(&quot;FuturePaymentExample&quot;, &quot;an extremely unlikely failure occurred: &quot;, e);                        }                    }                } else if (resultCode == Activity.RESULT_CANCELED) {                    Log.i(&quot;FuturePaymentExample&quot;, &quot;The user canceled.&quot;);                    doResult.customerCanceled();                } else if (resultCode == PayPalFuturePaymentActivity.RESULT_EXTRAS_INVALID) {                    doResult.invalidPaymentConfiguration();                    Log.i(                            &quot;FuturePaymentExample&quot;,                            &quot;Probably the attempt to previously start the PayPalService had an invalid PayPalConfiguration. Please see the docs.&quot;);                }            } else if (requestCode == REQUEST_CODE_PROFILE_SHARING) {                if (resultCode == Activity.RESULT_OK) {                    PayPalAuthorization auth =                            data.getParcelableExtra(PayPalProfileSharingActivity.EXTRA_RESULT_AUTHORIZATION);                    if (auth != null) {                        try {                            Log.i(&quot;ProfileSharingExample&quot;, auth.toJSONObject().toString(4));                            String authorization_code = auth.getAuthorizationCode();                            Log.i(&quot;ProfileSharingExample&quot;, authorization_code);    //                        sendAuthorizationToServer(auth);    //                        displayResultText(&quot;Profile Sharing code received from PayPal&quot;);                        } catch (JSONException e) {                            Log.e(&quot;ProfileSharingExample&quot;, &quot;an extremely unlikely failure occurred: &quot;, e);                        }                    }                } else if (resultCode == Activity.RESULT_CANCELED) {                    Log.i(&quot;ProfileSharingExample&quot;, &quot;The user canceled.&quot;);                } else if (resultCode == PayPalFuturePaymentActivity.RESULT_EXTRAS_INVALID) {                    Log.i(                            &quot;ProfileSharingExample&quot;,                            &quot;Probably the attempt to previously start the PayPalService had an invalid PayPalConfiguration. Please see the docs.&quot;);                }            }        }        /**         * c处理完结果之后回调         */        public interface DoResult {            //与服务确认支付成功            void confirmSuccess();            //网络异常或者json返回有问题            void confirmNetWorkError();            //用户取消支付            void customerCanceled();            //授权支付            void confirmFuturePayment();            //订单支付验证无效            void invalidPaymentConfiguration();        }    }`</code></pre></li><li><p>在你需要调起支付的页面配置支付环境（或者在基类配置相应的支付环境）</p><pre><code>`    //配置何种支付环境，一般沙盒，正式        private static final String CONFIG_ENVIRONMENT = PayPalConfiguration.ENVIRONMENT_SANDBOX;        // note that these credentials will differ between live &amp; sandbox environments.        //你所注册的APP Id    private static final String CONFIG_CLIENT_ID = &quot;你所注册的CLient Id&quot;;       private static final int REQUEST_CODE_PAYMENT = 1;        private static final int REQUEST_CODE_FUTURE_PAYMENT = 2;        private static final int REQUEST_CODE_PROFILE_SHARING = 3;        private static PayPalConfiguration config = new PayPalConfiguration()            .environment(CONFIG_ENVIRONMENT)                .clientId(CONFIG_CLIENT_ID);        //以下配置是授权支付的时候用到的    //.merchantName(&quot;Example Merchant&quot;)    // .merchantPrivacyPolicyUri(Uri.parse(&quot;https://www.example.com/privacy&quot;))    //.merchantUserAgreementUri(Uri.parse(&quot;https://www.example.com/legal&quot;));`</code></pre></li><li><p>在类的onCreate方法里面调起支付服务</p><pre><code>`    Intent intent = new Intent(this, PayPalService.class);    intent.putExtra(PayPalService.EXTRA_PAYPAL_CONFIGURATION, config);    startService(intent);`</code></pre></li><li><p>创建支付实体，在需要调起支付的地方调起支付</p><pre><code>`    public void onBuyPressed(View pressed) {    //创建支付对象，用于传过去给PayPal服务器进行收款    PayPalPayment thingToBuy = getThingToBuy(PayPalPayment.PAYMENT_INTENT_SALE);    Intent intent = new Intent(SampleActivity.this, PaymentActivity.class);    intent.putExtra(PayPalService.EXTRA_PAYPAL_CONFIGURATION, config);    intent.putExtra(PaymentActivity.EXTRA_PAYMENT, thingToBuy);    //这里直接调起PayPal的sdk进行付款操作    startActivityForResult(intent, REQUEST_CODE_PAYMENT);    }    //这里只传一个总价格或者单个产品的信息收款情况    private PayPalPayment getThingToBuy(String paymentIntent) {    return new PayPalPayment(new BigDecimal(&quot;0.01&quot;), &quot;USD&quot;, &quot;sample item&quot;,    paymentIntent);    }    //这里是购买一系列产品创建购买对象    private PayPalPayment getStuffToBuy(String paymentIntent) {    PayPalItem[] items =    {    new PayPalItem(&quot;sample item #1&quot;, 2, new BigDecimal(&quot;87.50&quot;), &quot;USD&quot;,    &quot;sku-12345678&quot;),    new PayPalItem(&quot;free sample item #2&quot;, 1, new BigDecimal(&quot;0.00&quot;),    &quot;USD&quot;, &quot;sku-zero-price&quot;),    new PayPalItem(&quot;sample item #3 with a longer name&quot;, 6, new BigDecimal(&quot;37.99&quot;),    &quot;USD&quot;, &quot;sku-33333&quot;)    };    BigDecimal subtotal = PayPalItem.getItemTotal(items);    BigDecimal shipping = new BigDecimal(&quot;7.21&quot;);    BigDecimal tax = new BigDecimal(&quot;4.67&quot;);    PayPalPaymentDetails paymentDetails = new PayPalPaymentDetails(shipping, subtotal, tax);    BigDecimal amount = subtotal.add(shipping).add(tax);    PayPalPayment payment = new PayPalPayment(amount, &quot;USD&quot;, &quot;sample item&quot;, paymentIntent);    payment.items(items).paymentDetails(paymentDetails);    //--- set other optional fields like invoice_number, custom field, and soft_descriptor    payment.custom(&quot;This is text that will be associated with the payment that the app can use.&quot;);    return payment;    }`</code></pre></li><li><p>在类的onActivityResult 里进行回调结果的处理</p><pre><code>`if (resultCode == Activity.RESULT_OK) {    PaymentConfirmation confirm =    data.getParcelableExtra(PaymentActivity.EXTRA_RESULT_CONFIRMATION);    if (confirm != null) {    try {    Log.i(TAG, confirm.toJSONObject().toString(4));    Log.i(TAG, confirm.getPayment().toJSONObject().toString(4));    //这里可以把PayPal带回来的json数据传给服务器以确认你的款项是否收到或者收全    //可以直接把 confirm.toJSONObject() 这个带给服务器，    //得到服务器返回的结果，你就可以跳转成功页面或者做相应的处理了    } catch (JSONException e) {    Log.e(TAG, &quot;an extremely unlikely failure occurred: &quot;, e);    }    }    } else if (resultCode == Activity.RESULT_CANCELED) {    Log.i(TAG, &quot;The user canceled.&quot;);    } else if (resultCode == PaymentActivity.RESULT_EXTRAS_INVALID) {    Log.i(    TAG,    &quot;An invalid Payment or PayPalConfiguration was submitted. Please see the docs.&quot;);    }    }</code></pre><p>  `</p></li><li><p>在类的onDestroy 注销服务</p><pre><code>`stopService(new Intent(this, PayPalService.class));`</code></pre></li></ul><h4 id="服务端，根据前端给的paymentId，判断是否完成付款"><a href="#服务端，根据前端给的paymentId，判断是否完成付款" class="headerlink" title="服务端，根据前端给的paymentId，判断是否完成付款"></a>服务端，根据前端给的paymentId，判断是否完成付款</h4><pre><code>`    package com.net.pay.paypal.service;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import net.sf.json.JSONArray;import net.sf.json.JSONObject;import org.apache.commons.codec.binary.Base64;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.net.crud.dao.RechargeMapper;@Servicepublic class PayPalVerifyPayment {    private static final String TOKEN_URL = &quot;https://api.sandbox.paypal.com/v1/oauth2/token&quot;;    private static final String PAYMENT_DETAIL = &quot;https://api.sandbox.paypal.com/v1/payments/payment/&quot;;    private static final String clientId = &quot;clientId&quot;;    private static final String secret = &quot;secret&quot;;    /**     * 获取token     * 了解更多：https://developer.paypal.com/webapps/developer/docs/integration/mobile/verify-mobile-payment/     * @return     */    private String getAccessToken(){        try{            URL url = new URL(TOKEN_URL);            String authorization = clientId+&quot;:&quot;+secret;            authorization = Base64.encodeBase64String(authorization.getBytes());            HttpURLConnection conn = (HttpURLConnection) url.openConnection();            conn.setRequestMethod(&quot;POST&quot;);// 提交模式            //设置请求头header            conn.setRequestProperty(&quot;Accept&quot;, &quot;application/json&quot;);            conn.setRequestProperty(&quot;Accept-Language&quot;, &quot;en_US&quot;);            conn.setRequestProperty(&quot;Authorization&quot;, &quot;Basic &quot;+authorization);            // conn.setConnectTimeout(10000);//连接超时 单位毫秒            // conn.setReadTimeout(2000);//读取超时 单位毫秒            conn.setDoOutput(true);// 是否输入参数            String params = &quot;grant_type=client_credentials&quot;;            conn.getOutputStream().write(params.getBytes());// 输入参数            InputStreamReader inStream = new InputStreamReader(conn.getInputStream());            BufferedReader reader = new BufferedReader(inStream);            StringBuilder result = new StringBuilder();            String lineTxt = null;            while((lineTxt = reader.readLine()) != null){                result.append(lineTxt);            }            reader.close();            String accessTokey = JSONObject.fromObject(result.toString()).optString(&quot;access_token&quot;);            System.out.println(&quot;getAccessToken:&quot;+accessTokey);            return accessTokey;        }catch(Exception err){            err.printStackTrace();        }        return null;    }    /**     * 获取支付详情     * 了解更多：https://developer.paypal.com/webapps/developer/docs/integration/mobile/verify-mobile-payment/     * @param paymentId 支付ID，来自于用户客户端     * @return     */    public String getPaymentDetails(String paymentId){        try{            URL url = new URL(PAYMENT_DETAIL+paymentId);            HttpURLConnection conn = (HttpURLConnection) url.openConnection();            conn.setRequestMethod(&quot;GET&quot;);// 提交模式            //设置请求头header            conn.setRequestProperty(&quot;Accept&quot;, &quot;application/json&quot;);            conn.setRequestProperty(&quot;Authorization&quot;, &quot;Bearer &quot;+getAccessToken());            // conn.setConnectTimeout(10000);//连接超时 单位毫秒            // conn.setReadTimeout(2000);//读取超时 单位毫秒            InputStreamReader inStream = new InputStreamReader(conn.getInputStream());            BufferedReader reader = new BufferedReader(inStream);            StringBuilder result = new StringBuilder();            String lineTxt = null;            while((lineTxt = reader.readLine()) != null){                result.append(lineTxt);            }            reader.close();            return result.toString();        }catch(Exception err){            err.printStackTrace();        }        return null;    }    /**     * 获取支付详情     * 了解更多：https://developer.paypal.com/webapps/developer/docs/integration/mobile/verify-mobile-payment/     * @param paymentId 支付ID，来自于用户客户端     * @return     */    public boolean verifyPayment(String paymentId) throws Exception {        String str = getPaymentDetails(paymentId);        System.out.println(str);        JSONObject detail = JSONObject.fromObject(str);        //校验订单是否完成        if(&quot;approved&quot;.equals(detail.optString(&quot;state&quot;))){            JSONObject transactions = detail.optJSONArray(&quot;transactions&quot;).optJSONObject(0);            JSONObject amount = transactions.optJSONObject(&quot;amount&quot;);            JSONArray relatedResources = transactions.optJSONArray(&quot;related_resources&quot;);            //从数据库查询支付总金额与Paypal校验支付总金额            double total = 0;            System.out.println(&quot;amount.optDouble(&apos;total&apos;):&quot;+amount.optDouble(&quot;total&quot;));            if( total != amount.optDouble(&quot;total&quot;) ){                return false;            }            //校验交易货币类型            String currency = &quot;USD&quot;;            if( !currency.equals(amount.optString(&quot;currency&quot;)) ){                return false;            }            //校验每个子订单是否完成            for (int i = 0,j = relatedResources.size(); i &lt; j; i++) {                JSONObject sale = relatedResources.optJSONObject(i).optJSONObject(&quot;sale&quot;);                if(sale!=null){                    if( !&quot;completed&quot;.equals(sale.optString(&quot;state&quot;)) ){                        System.out.println(&quot;子订单未完成,订单状态:&quot;+sale.optString(&quot;state&quot;));                    }                }            }            return true;        }        return false;    }    public static void main(String[] args) {        PayPalVerifyPayment payment = new PayPalVerifyPayment();        boolean success = false;        try {            success = payment.verifyPayment(&quot;PAY-9MTXXXXXXXXXXXXXXXXXMI&quot;);        } catch (Exception e) {            e.printStackTrace();        }        System.out.println(success ? &quot;支付完成&quot; : &quot;支付校验失败&quot;);    }}`</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paypal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx负载均衡</title>
      <link href="/2018/06/08/centos/nginx/"/>
      <url>/2018/06/08/centos/nginx/</url>
      
        <content type="html"><![CDATA[<h3 id="nginx用处"><a href="#nginx用处" class="headerlink" title="nginx用处"></a>nginx用处</h3><blockquote><ul><li>直接作为http server(代替tomcat，apache等服务器)；</li><li>另外一个最主要的功能就是作为反向代理服务器实现负载均衡</li></ul></blockquote><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><blockquote><ol><li>nginx部署在windows上，另外两台tomcat,地址为<code>localhost:80</code></li><li>nginx下载地址<code>http://nginx.org/en/download.html</code></li><li>两个tomcat分布部署在虚拟机上，假设他们的ip是<code>192.168.155.1:80</code>和<code>192.168.155.2:80</code>，分别有路劲<code>service1\index.html</code>和<code>service2\index.html</code>，里面的内容只要好鉴别是哪个tomcat下的资源就行了</li><li>先可以启动tomcat，访问相应的地址试试，能不能访问</li></ol></blockquote><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="针对不同请求-负载均衡"><a href="#针对不同请求-负载均衡" class="headerlink" title="针对不同请求 负载均衡"></a>针对不同请求 负载均衡</h4><blockquote><p><strong>下载好nginx之后，修改<code>conf\nginx.conf</code></strong></p></blockquote><pre><code>`    # ~表示根据正则匹配url，以下的效果是，当url包含service1，nginx会将请求给192.168.155.1:80处理    location ~ /service1/ {        proxy_pass    http://192.168.155.1:80;    }            #当url包含service2，nginx会将请求给192.168.155.2:80处理    location ~ /service2/ {        proxy_pass    http://192.168.155.2:80;    }`</code></pre><blockquote><p>启动nginx，这也就实现了最简单的负载均衡</p></blockquote><blockquote><p><strong>例如：</strong>请求<code>http://localhost/service1/index.html</code>，在nginx容器下没有<code>service1/index.html</code>的路劲，nginx就是根据上面的配置，将请求交给<code>http://192.168.155.1:80</code>处理</p></blockquote><h4 id="访问同一请求-负载均衡"><a href="#访问同一请求-负载均衡" class="headerlink" title="访问同一请求 负载均衡"></a>访问同一请求 负载均衡</h4><blockquote><p>即用户访问同一请求时,配置多台tomcat,由nginx随机将请求分给某一个tomcat</p></blockquote><p><strong>在nginx.conf的http模块中添加，服务器集群server cluster</strong></p><pre><code>`    upstream interestCluster {          server 192.168.155.1:80;          server 192.168.155.2:80;    }`</code></pre><p><strong>在server模块中定义，负载均衡</strong></p><pre><code>`    location ~ /service1/ {      proxy_pass http://interestCluster ; #跟上面的集群名字一样      proxy_redirect off;      proxy_set_header Host $host;      proxy_set_header X-Real-IP $remote_addr;      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    }`</code></pre><blockquote><p>以上配置，到达的效果就是，当你访问<code>http://localhost/service1/index.html</code>，在nginx容器下没有<code>service1/index.html</code>的路劲，nginx就是根据上面的配置，将请求交给<code>http://192.168.155.1:80</code>或者时<code>http://192.168.155.2:80</code>处理</p></blockquote><p><strong>以上配置两个tomcat均衡，你可以根据自己服务器硬件配置，来配置权重，继续修改nginx.conf</strong></p><pre><code>`    upstream interestCluster {          server 192.168.155.1:80;          server 192.168.155.2:80 weight=2;    }`</code></pre><blockquote><p>即有三分之二的概率用到192.168.155.2，有三分之一的概率用到192.168.155.1</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>drop, delete, truncate 区别</title>
      <link href="/2018/06/07/sql/drop,delete,truncat/"/>
      <url>/2018/06/07/sql/drop,delete,truncat/</url>
      
        <content type="html"><![CDATA[<h4 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;删除内容和定义，释放空间。<br>&nbsp;&nbsp;&nbsp;&nbsp;将表，数据库，视图等完全删除。删库跑步首选语句。</p><h4 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;删除内容、释放空间但不删除定义，效率高。<br>&nbsp;&nbsp;&nbsp;&nbsp;比如说有一列自增id，当前为5，truncate表之后，id会从1开始。清空表数据首选。</p><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;删除整个表的数据，不删除定义，效率低。<br>&nbsp;&nbsp;&nbsp;&nbsp;系统一行一行地删，效率低，数据量大过程比较痛苦，会保留删除之前id自增的值。</p>]]></content>
      
      
      <categories>
          
          <category> 芝士点心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP失效，事务失效</title>
      <link href="/2018/05/25/java/AOP%E5%A4%B1%E6%95%88%EF%BC%8C%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/"/>
      <url>/2018/05/25/java/AOP%E5%A4%B1%E6%95%88%EF%BC%8C%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h4 id="场景还原（Transaction是由aop实现）"><a href="#场景还原（Transaction是由aop实现）" class="headerlink" title="场景还原（Transaction是由aop实现）"></a>场景还原（Transaction是由aop实现）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transaction</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transaction</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        methodC();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transaction</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AopTest aop;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> test（）&#123;</span><br><span class="line">        aop.methodA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;请求进来，到Controller.test()，该方法调用AopTest.methodA()。此时只有methodA的事务会生效</p><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>aop实现的方式是生成一个动态的代理对象去调用aop方法。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;因为@Transaction是由aop实现的，aop的方法，会生成一个代理对象去调用，Controller注入的AopTest对象是一个代理对象，在controller调用methodA会按照aop的过程执行，所以methodA的事务会生效。但是在mthodA中调用methodB,是由当前对象直接调用，所有methodB的事务不会生效。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public <span class="keyword">class</span> AopTest&#123;</span><br><span class="line"></span><br><span class="line">    @Transaction</span><br><span class="line">    public void <span class="keyword">method</span><span class="constructor">A()</span>&#123;</span><br><span class="line">        <span class="comment">//通过代理对象去调用sendMessage()方法          </span></span><br><span class="line">        (AopTest)<span class="module-access"><span class="module"><span class="identifier">AopContext</span>.</span></span>current<span class="constructor">Proxy()</span>.<span class="keyword">method</span><span class="constructor">B()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Transaction</span><br><span class="line">    public void <span class="keyword">method</span><span class="constructor">B()</span>&#123;</span><br><span class="line">        (AopTest)<span class="module-access"><span class="module"><span class="identifier">AopContext</span>.</span></span>current<span class="constructor">Proxy()</span>.<span class="keyword">method</span><span class="constructor">C()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Transaction</span><br><span class="line">    public void <span class="keyword">method</span><span class="constructor">C()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 踩坑日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
