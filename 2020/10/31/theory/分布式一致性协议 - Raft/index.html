<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>分布式一致性协议 - Raft | 并发笔记 - ofcoder.com</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><!-- 顶部加载进度条 --><script type="text/javascript" src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">分布式一致性协议 - Raft</h1><a id="logo" href="/.">并发笔记 - ofcoder.com</a><p class="description">一位后端开发的养肝历程，护发经验</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/usql/"><i class="fa fa-database"> usql</i></a><a href="/book/"><i class="fa fas fa-book"> book</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">分布式一致性协议 - Raft</h1><div class="post-meta">Oct 31, 2020<span> | </span><span class="category"><a href="/categories/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/">算法理论</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.3k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 11</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/2020/10/31/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Raft/#vcomment"><span class="valine-comment-count" data-xid="/2020/10/31/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Raft/"></span><span> 条评论</span></a><div class="post-content"><p>学习raft之前，给大家推荐一个网站，这个网站动画描述raft运行过程。在看文章时对照该网站，可以帮助更好的理解raft。<br><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p>
<p>相比于paxos，我们更应掌握raft。raft作为现在分布式系统首选的共识算法。zookeeper、cubby、oceanbase等系统都是在raft诞生之前开发的，所以都是使用了paxos或者对其进行改进。而后来的大多系统都选择了raft，比如consul、etcd等。</p>
<p>raft相比paxos的优点是:容易理解，容易实现。之所以说容易，是因为raft流程清晰、关键处给出了伪代码描述。相反，可真正用于工程实现的multi-paxos，lamport宗师只提出了个大概。</p>
<h3 id="Raft术语科普以及总结"><a href="#Raft术语科普以及总结" class="headerlink" title="Raft术语科普以及总结"></a>Raft术语科普以及总结</h3><p>基于前两个篇对paxos和zab的介绍，我们对分布式协议有一定的基础，所以本文先给出总结。</p>
<h4 id="三种成员身份"><a href="#三种成员身份" class="headerlink" title="三种成员身份"></a>三种成员身份</h4><p>raft提供三种成员身份，<strong>领导者（leader）、跟随者（follower）、候选人（candidate）</strong></p>
<ul>
<li>跟随者：相当于paxos中的acceptor，接收和处理leader的消息，当leader故障时，主动推荐自己为候选人</li>
<li>候选人：向其他节点发送请求投票消息（Request Vote），如果获得大多数选票，则晋升为leader</li>
<li>领导者：处理写请求，管理日志复制、发送心跳消息。</li>
</ul>
<h4 id="两种运行阶段"><a href="#两种运行阶段" class="headerlink" title="两种运行阶段"></a>两种运行阶段</h4><p>raft强化了leader的地位，把整个协议可以清楚的分割成两个部分，并利用日志的连续性做了一些简化：</p>
<ul>
<li>leader在时，由leader向follower同步日志。</li>
<li>leader挂掉了，选一个新leader，leader选举算法。</li>
</ul>
<h4 id="两类rpc消息"><a href="#两类rpc消息" class="headerlink" title="两类rpc消息"></a>两类rpc消息</h4><ul>
<li>请求投票消息（request vote），用于选举leader。</li>
<li>追加条目消息（append entry），用于心跳消息或日志复制消息。该包含当前最大的日志项。</li>
</ul>
<h4 id="raft与multi-paxos的区别"><a href="#raft与multi-paxos的区别" class="headerlink" title="raft与multi-paxos的区别"></a>raft与multi-paxos的区别</h4><ul>
<li>不是所有节点都能当选leader<br>只有日志最完整的才能当选leader，而multi-paxos则不需要保证这一点，也意味multi-paxos需要额外的流程从其它节点获取已经被提交的日志。</li>
<li>日志是连续的<br>日志的连续性蕴含了这样一条性质：如果两个不同节点上相同序号的日志，那么这和这之前的日志必然也相同的</li>
<li>简化的二阶段</li>
</ul>
<h3 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h3><p>在节点刚启动状态下，都处于follower状态。同时每个节点会为自己设置一个等待leader心跳消息的随机超时时间。当在超时时间之内没有收到来自leader的心跳信息时，则会推荐自己为candidate。随后增加自己的任期编号，并以candidate的身份发起请求投票消息，推荐自己为leader，当获得大多数选票后，晋升leader，发送心跳消息。</p>
<h4 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h4><p>例如，存在A、B、C三个节点的raft集群刚启动时，都处于follower状态，其中A超时时间为100ms，B超时时间为200ms，C超时时间为300ms。<br><img src="/images/theory/distributed/raft_1.png" alt="节点信息"></p>
<p>由于集群中不存在leader，A、B、C三个节点都不会收到来自leader心跳信息。其中，A节点的超时时间最小，则最先修改自己状态为candidate，并增加自己的任期编号为1，发起请求投票消息。<br><img src="/images/theory/distributed/raft_2.png" alt="节点信息"></p>
<p>节点A的选票会投给自己，而节点B、C收到candidate的请求投票消息。根据投票规则：</p>
<ol>
<li>任期编号大的节点拒绝投票给任期编号的小的请求投票消息</li>
<li>最后一条日志编号大的拒绝投票给最后一条日志编号小的节点</li>
<li>一个任期编号只投出一张选票</li>
<li>先来先获得投票</li>
</ol>
<p>明显，B、C的任期编号小于A的任期，也不存在最大的日志编号，并且任期编号为1的选票还没有投给任何人，则将任期为1的选票投给节点A，并更新自己的任期编号。<br><img src="/images/theory/distributed/raft_3.png" alt="节点信息"><br>节点A获得包括自己在内的3个选票，赢得大多数选票。其中赢得过半选票也是存在随机超时时间的。如果在超时时间内，则晋升为leader，否则发起新的一轮选举。晋升leader后，则向其他节点发送心跳信息，维护自己的leader角色。<br><img src="/images/theory/distributed/raft_4.png" alt="节点信息"></p>
<h4 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h4><p>整个选举过程相对来说，比较简单。具体细节还得挑几个点，单独来说：</p>
<ul>
<li>随机超时时间<br>在basic-paxos中，通常会描述“活性”一词，是指两个提案同时提出，互相争取选票，导致另一个提案在第二阶段获取不到大多数选票。在muilt-paxos中，leader的选举，而会存在瓜分选票的情况。而raft巧妙的通过随机超时时间，避免了两个candidate同时竞选leader。需要注意，随机超时时间包含两个方面：<ul>
<li>follower等待leader心跳信息超时的时间间隔。</li>
<li>candidate在一个随机时间间隔内，没有赢得过半票数，那么选举无效了，需要发起新一轮的选举。</li>
</ul>
</li>
<li>一届任期只投出一张选票，先来先获得投票<br>比如：B节点先后收到A、C任期编号为1的请求投票消息，B节点则将选票投给A节点。至于C节点的请求投票消息，B节点在任期编号为1的已经没有选票可投了。</li>
<li>任期编号大的节点拒绝投票给任期编号的小的请求投票消息<br>实际上，raft协议在leader选举阶段，由于老leader可能也还存活，也会存在不只一个leader的情形，只是不存在任期编号一样的两个leader。因为选举算法要求leader得到同一个任期编号的多数派的同意，同时赞同的成员会承诺不接受任期编号更小的任何消息。这样可以根据任期编号大小来区分谁是合法的leader。</li>
<li>最后一条日志编号（uncommited）大的拒绝投票给最后一条日志编号（uncommited）小的节点<br>这一条则是为了保证，只有日志完整度高的节点才能当选leader。这样则可以节省在当选leader后，与各节点比对日志的时间。</li>
</ul>
<h3 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h3><p>在raft中，数据都是以日志的形式存在的，客户端每一次的写请求，都会封装成一个日志项（log entry）记录在日志中。所以处理客户端的写请求，就是把日志项（log entry）同步给其他节点并应用到各自状态机的过程。日志同步则可以认为就是处理写请求。</p>
<p>一条日志项（log entry）又包含：用户数据、索引值、任期编号。</p>
<ul>
<li>用户数据，指客户端写请求中的数据，一般是对某个值的修改。</li>
<li>索引值，日志项的id，一个连续的单调递增的数字</li>
<li>任期编号，指创建该日志项的leader的任期编号</li>
</ul>
<p>在上面总结中，有提到简化的二阶段协议，则是指日志同步阶段。其实在raft之前lamport宗师也有提到如何优化multi-paxos，其中就有优化为一阶段提交。而raft则在日志同步中做出了实践。</p>
<p>具体实现，在raft中，leader接收到写请求，进入第一阶段。leader将写请求封装为log entry追加到自己的日志中，并发送日志复制消息，将需要同步的log entry复制到集群中其他节点上。如果leader收到大多数节点都成功写入该log entry。那么就将该log entry提交到自己的状态机，同时返回成功给客户端。否则返回错误给客户端。</p>
<p>而follower则是在接收到leader的心跳信息或者新的日志复制消息后，如果follower发现leader已经提交了某条log entry，而自己还没提交，那么follower就将这条log entry提交到自己的状态机中。</p>
<h4 id="算法模拟"><a href="#算法模拟" class="headerlink" title="算法模拟"></a>算法模拟</h4><p>存在3节点的集群，A为leader，B、C为follower。当客户端向leader发送set 5的请求，leader收到后，会将其封装成log entry追加到自己的日志中。然后通过日志复制消息时将更改发送给follower。<br><img src="/images/theory/distributed/raft_5.png" alt="算法模拟"></p>
<p>follower收到消息后，将该log entry追加到自己的日志中，并向leader返回成功响应。当leader收到大多数节点的成功响应后，则在自己的状态机中提交该log entry，并向客户端返回成功。<br><img src="/images/theory/distributed/raft_6.png" alt="算法模拟"></p>
<p>在下一次追加条目消息（心跳消息、日志复制消息）中，会携带leader最新修改的log entry。follower收到后，则会提交之前尚未提交的log entry。<br><img src="/images/theory/distributed/raft_7.png" alt="算法模拟"></p>
<p>follower完成提交后，即达成本次共识。</p>
<h3 id="网络分区、宕机恢复"><a href="#网络分区、宕机恢复" class="headerlink" title="网络分区、宕机恢复"></a>网络分区、宕机恢复</h3><p>当集群中出现网络分区，导致产生了两个小集群时，每个集群都存在自己的leader。或者上一任leader宕机恢复后加入集群时，存在两个leader的情况。raft为此也制定了一些特殊的规定：<strong>根据任期编号大小来区分谁是合法的leader</strong>。例如：当一个candidate或者leader发现自己的任期编号比其他节点小，那么它会立即恢复成follower状态。</p>
<p>存在一个5节点集群，正常运行时，B节点为leader，其余A、C、D、E为follower<br><img src="/images/theory/distributed/raft_8.png" alt="网络分区"></p>
<p>当出现网络分区，出现两个由B, A和C, D, E组成的小集群。并且B继续保持leader状态，C为新晋升的leader。<br><img src="/images/theory/distributed/raft_9.png" alt="网络分区"></p>
<p>当此时，有写请求到B时，由于B不能获得多数票的支持，最终该写请求不会被提交，也不会返回给客户端成功的响应，将一直保持未提交的状态存在日志中。<br><img src="/images/theory/distributed/raft_10.png" alt="网络分区"></p>
<p>而当网络分区恢复后，B, A节点重新加入集群。当它们收到来自C节点的心跳消息时，发现C的任期编号比自己大，则会切换状态，抛弃掉自己有但C节点没有的log entry，并且同步C节点上的log entry。<br><img src="/images/theory/distributed/raft_11.png" alt="网络分区"></p>
<h3 id="思考几个题目吧"><a href="#思考几个题目吧" class="headerlink" title="思考几个题目吧"></a>思考几个题目吧</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">leader选举中，B节点的任期编号为1，日志编号为2。A节点任期编号为2，日志编号为1。</span><br><span class="line">B节点收到A节点的请求投票消息，B会投票给A节点吗？</span><br><span class="line"></span><br><span class="line">不会，B节点的编号大于A节点，说明B节点的日志完整度更高，更适合当选leader。</span><br><span class="line">--------------------------------</span><br><span class="line">当一个节点出现网络分区，它即获取不到大多数节点的选票，当不了leader，也接收不到其他leader的心跳，那么任期则会一直增加。</span><br><span class="line">那它网络恢复加入集群后，因为它存在很大编号，其他节点会不会认它为leader。</span><br><span class="line"></span><br><span class="line">不会，它加入集群后，会拒绝新leader的消息（因为它的任期大），则会修改状态为candidate，并发起请求投票。</span><br><span class="line">其他节点收到它的投票信息后，会将自己的任期编号改成它的，然后判断其他投票条件（最大日志编号），将会拒绝投票给它。</span><br><span class="line">它加入集群的唯一的影响就是一下子增加了任期编号的大小。</span><br><span class="line">--------------------------------</span><br><span class="line">假如客户端发送请求set 1，当leader在第一阶段时将该日志项只复制到了一个节点，没有获得大多数选票，则返回给客户端失败。这时leader宕机。新晋升的leader，将怎么处理set 1的日志项？</span><br><span class="line"></span><br><span class="line">raft一切以领导者为准的原则，是否丢弃掉set 1 的日志项，取决于新晋升的leader是否包含该日志项。</span><br><span class="line">1. 如果新晋升的leader包含set 1，则继续提交该日志项</span><br><span class="line">2. 如果新晋升的leader不包含set 1，当初被复制成功的那个节点，将会以领导者的为准，丢弃掉set 1。</span><br><span class="line"></span><br><span class="line">注释：至于新晋升的leader为什么不确认set 1是否被大多数复制成功再决定是否丢弃。</span><br><span class="line">我查过一些资料，这种情况确实会以leader的日志项为准，leader的日志项不会被删除。</span><br><span class="line">--------------------------------</span><br><span class="line">假如客户端发送请求set 1，当leader在第一阶段时将该日志项只复制到了大多数节点，获得了大多数选票，则返回给客户端成功。这时leader宕机。</span><br><span class="line">新选举的leader，将会如何将set 1日志项进行提交呢？</span><br><span class="line"></span><br><span class="line">按照选举规则，不包含set 1日志项的节点是少数集合，包含set 1日志项不会给不包含set 1日志项的节点投票。</span><br><span class="line">最后晋升的一定是包含set 1日志项的节点。一切以领导者为准的原则，则会完成set 1日志项的提交。</span><br><span class="line">--------------------------------</span><br><span class="line">raft一切依赖leader，所以性能瓶颈集中在leader，写性能仅为单机。如何提升？</span><br><span class="line"></span><br><span class="line">可以裂变分区，将原本一个raft集群裂变成多个互不影响的raft集群。</span><br><span class="line">例如：设计一个数据库，可以将元数据同步和用户数据同步使用两个raft集群。</span><br></pre></td></tr></table></figure></div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=/img/WeChatQR.jpg&amp;GitHub=https://github.com/farawayliu&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>far</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/10/31/theory/分布式一致性协议 - Raft/">https://www.ofcoder.com/2020/10/31/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Raft/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>Copyright © 2021 ofcoder. Author by far.</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://www.ofcoder.com/2020/10/31/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20Raft/" data-id="ckxoviwxt001yycj10dmiety9" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASYAAAEmCAAAAADqr2IGAAAEgElEQVR42u3aS27bQBAFQN3/0g6QVYJE9nvdFKyhiytDps2eooCZ/jwe8fXx+/rz53+v2f3JnflTnkWe3HnBhQkTJkyY3pIpCWu27HxJySL3ZO2LwYQJEyZMd2Jq/137+YZyRp+8kvyvMGHChAnTT2BKEst8+0+IE778qDF7YZgwYcKE6ecwff7J55+3CernrPk9+6MJJkyYMGG6B1O+Sbfl2hZ3lornL/XltXBMmDBhwvRmTLPBnXv8/PL5JkyYMGHC9K1MH+U1Q2zLtdcWfPPt/+mqMWHChAnTsUx5+tqmlO3i98eUnHXW4MSECRMmTKczzTbOPJnM78+HgWbjQW0kmDBhwoTpXKYkoDb0HGXTXNy0J/P0GxMmTJgwnc40K8u2Bd9Z6pujJ6B5Yv9oF4YJEyZMmN6eKb91llvnG3wbVcLXTuBEUWHChAkTpsOZri34zgqyyeJnkcxas5gwYcKE6VymdoBmFlb+SjYHlOQb0RadMWHChAnTuUxJ4XW2mDbcPAXdHEfy1RWNTEyYMGHC9MZMM4i85dk2R6PsPI483/gf+4dhwoQJE6Y3Zrp2U89HdmbQOVlbtsaECRMmTHdlykdY8lA2W3Ke1uZHluSlFqkvJkyYMGE6imk/spNs/xusNv1uEevxHUyYMGHCdBRTvp23oe8T7Fm5eX8geDrfhAkTJkyYDmSaFX83zcu2zNqmyvtnYcKECROm+zHNxlk2ozbtX7Vp7f4pmDBhwoTp3kyz0ZlZY3J25yumazBhwoQJ052YkmR1U/Btl9eO4CQL3qzxgn+BCRMmTJjejCnfpPMjQk6z2cI35eYvosWECRMmTDdlmpVr2+GbzRMT1vyJT+PEhAkTJkzHMrVNvnxb3QSUb/+b48smfkyYMGHCdCJTG1yyJX/+4Nnwa17wzY8pwzQYEyZMmDC9PVO+cbZF4XyTzolnryT5pnzBigkTJkyYDmfKc+J8XGYzBtSy7ou2XxxfMGHChAnTsUztdr4ZrLkqeZ4R50/EhAkTJkz3Y8of0BK3jdL8lVzb1MSECRMmTHdlykuimwXP0tfXkSUv5mk7ExMmTJgwHcW0H9yZpbXtwM2MLI+2+IpgwoQJE6ZjmWbJZDtek6PkDci8nTkbRcKECRMmTOcybVxnW3Jbfm2PCPuk/XHt1w8TJkyYMH0r06w8OoPbtDPzI0KbGGPChAkTpnsz5WXZj9HVNiZnZeJZazMvQGPChAkTpnsw5UMz+dabL2k21tPGnCf5f/0WEyZMmDAdy3RVArlphSYcbTK8L/jWYWHChAkTprdkmqWys5GazSEjSY/b0nNRwsaECRMmTMcy5VfbINyksvkA0H5AJ0+JMWHChAnTuUyb9HLz3zYHgmvT6QQUEyZMmDCdzpRsolc1Bfdty/ZVtYee//wVJkyYMGH6AUx54XWWc8+26iSG5CV98QkmTJgwYfoxTLMm6H4EJ4/nJYcJTJgwYcJ0ONNmkW2zM08+Z/fn8ReJPSZMmDBhOpZpNriTL6w9OuxDv/blYcKECROmY5l+Abfm3j/r7cGrAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/">分布式事务</a><a href="/tags/Raft/">Raft</a></div><div class="post-nav"><a class="pre" href="/2020/11/07/theory/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%20-%20CAP%E3%80%81BASE%E3%80%81NWR/">分布式一致性协议 - CAP、BASE、NWR</a><a class="next" href="/2020/09/22/java/jvm/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm03%20-%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">深入理解jvm03 - 垃圾收集器与内存分配策略</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'s8pJruGkXvi5Skd0e6EaMQ5X-gzGzoHsz',
  appKey:'K3NjnXxqhPNwUw5pmqOzoO4i',
  placeholder:'说出你的故事...',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-blind"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Raft术语科普以及总结"><span class="toc-number">1.</span> <span class="toc-text">Raft术语科普以及总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#三种成员身份"><span class="toc-number">1.1.</span> <span class="toc-text">三种成员身份</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两种运行阶段"><span class="toc-number">1.2.</span> <span class="toc-text">两种运行阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两类rpc消息"><span class="toc-number">1.3.</span> <span class="toc-text">两类rpc消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#raft与multi-paxos的区别"><span class="toc-number">1.4.</span> <span class="toc-text">raft与multi-paxos的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leader选举"><span class="toc-number">2.</span> <span class="toc-text">Leader选举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#选举过程"><span class="toc-number">2.1.</span> <span class="toc-text">选举过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选举规则"><span class="toc-number">2.2.</span> <span class="toc-text">选举规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#日志同步"><span class="toc-number">3.</span> <span class="toc-text">日志同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#算法模拟"><span class="toc-number">3.1.</span> <span class="toc-text">算法模拟</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络分区、宕机恢复"><span class="toc-number">4.</span> <span class="toc-text">网络分区、宕机恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#思考几个题目吧"><span class="toc-number">5.</span> <span class="toc-text">思考几个题目吧</span></a></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">并发笔记 - ofcoder.com | </a><a href="https://beian.miit.gov.cn/" rel="nofollow" target="_blank">粤ICP备18053760号</a><div>本站访客 <span id="busuanzi_value_site_uv"></span>人次 | 总访问 <span id="busuanzi_value_site_pv"></span>次<img src="https://s04.flagcounter.com/count/MnzJ/bg_FFFFFF/txt_000000/border_726EE0/columns_2/maxflags_10/viewers_0/labels_1/pageviews_1/flags_0/percent_0/" style="display: none;"/></div></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.7" zIndex="-1" count="5" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html><script type="text/javascript" src="/js/toc.js?v=0.0.0" async></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>