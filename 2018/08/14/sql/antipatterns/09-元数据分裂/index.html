<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>SQL反模式09-元数据分裂 | 并发笔记 - ofcoder.com</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><!-- 顶部加载进度条 --><script type="text/javascript" src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SQL反模式09-元数据分裂</h1><a id="logo" href="/.">并发笔记 - ofcoder.com</a><p class="description">一位后端开发的养肝历程，护发经验</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/usql/"><i class="fa fa-database"> usql</i></a><a href="/book/"><i class="fa fas fa-book"> book</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">SQL反模式09-元数据分裂</h1><div class="post-meta">Aug 14, 2018<span> | </span><span class="category"><a href="/categories/SQL%E5%8F%8D%E6%A8%A1%E5%BC%8F/">SQL反模式</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.1k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 7</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/2018/08/14/sql/antipatterns/09-%E5%85%83%E6%95%B0%E6%8D%AE%E5%88%86%E8%A3%82/#vcomment"><span class="valine-comment-count" data-xid="/2018/08/14/sql/antipatterns/09-%E5%85%83%E6%95%B0%E6%8D%AE%E5%88%86%E8%A3%82/"></span><span> 条评论</span></a><div class="post-content"><h4 id="目标：支持可扩展性"><a href="#目标：支持可扩展性" class="headerlink" title="目标：支持可扩展性"></a>目标：支持可扩展性</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;随着数据量增长，数据库的查询性能也会随之下降，哪怕查询结果只是很少的几千行，遍历表中积累的数据也可能使整个查询性能变得极差，即使使用了索引，随着数据量增大，索引的作用也变得非常有限。<br>&nbsp;&nbsp;&nbsp;&nbsp;本章目标就是要优化数据库的结构来提升查询性能以及表的平滑扩展。</p>
<h4 id="反模式：克隆表与克隆列"><a href="#反模式：克隆表与克隆列" class="headerlink" title="反模式：克隆表与克隆列"></a>反模式：克隆表与克隆列</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;根据经验，我们知道查询一张表的性能和这张表的数据条数有关，越少的记录，查询速度更快。于是我们会想办法将每张表存储的记录尽可能少。这就导致本章反模式的两种表现。</p>
<ol>
<li>将一张很长的表拆分成多张较小的表，使用表中某一个特定的数据字段来给这些拆分出来的表命名。（比如按条数拆分表）</li>
<li>将一个列拆分成多个子列，使用别的列中的不同值给拆分出来的列命名。（比如按年份拆分列）</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;为了减少每张表的记录数，你不得不创建一些有很多列的表，或者创建很多很多表。但在这两个方案中，你会发现数据量的增长，会有越来越多的表或者列，迫使你创建新的schema对象。</p>
<h5 id="不断产生新表"><a href="#不断产生新表" class="headerlink" title="不断产生新表"></a>不断产生新表</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你按照年份来查分表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_2008(...);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_2009(...);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_2010(...);</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在保存数据时，你要操心，什么时候改插入哪张表。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert <span class="keyword">into</span> bug_2010(<span class="params">...</span>, date_report, <span class="params">...</span>) values(<span class="params">...</span>, <span class="string">'2010-01-01'</span>, <span class="params">...</span>);</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在快进入到2010-01-01时，你的程序还有可能报错，原因是你忘记创建一张叫做bug_2010的表。</p>
<h5 id="管理数据完整性"><a href="#管理数据完整性" class="headerlink" title="管理数据完整性"></a>管理数据完整性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;你统计2010年的bug数量时，发现有一部分数据出现了在bug_2009的表中，导致统计数据不正确。这时你需要在每一张表中都声明一个check约束。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table bug_2009(</span><br><span class="line">	...</span><br><span class="line">	date_report date<span class="built_in"> check </span>(extract(year from date_report) = 2009)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;某一天，你需要修改bug的日期，在数据库中存储的日期是2010-01-03，但顾客实际是在一周前（2009-12-27），使用传真报告的错误。你必须先修改bug_2010，再插入bug_2009，再删除bug_2010.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> bug_2010 <span class="keyword">set</span> date_report = <span class="string">'2009-12-27'</span> <span class="keyword">where</span> bug_id = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug_2009(..., date_report) <span class="keyword">values</span>(</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> bug_2010 <span class="keyword">where</span> bug_id = <span class="number">1234</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> bug <span class="keyword">where</span> bug_id = <span class="number">1234</span>;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;使用以上sql，你还可能会遇到，在bug_2010中bug_id已经存在bug_2009中，此时你该怎么选择。</p>
<h5 id="确保唯一性"><a href="#确保唯一性" class="headerlink" title="确保唯一性"></a>确保唯一性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果同步数据中bug_id重复，难倒你了，你可能会想到创建另外一张表，用来生成bug_id</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_id_generator(</span><br><span class="line">	bug_id <span class="built_in">serial</span> primary <span class="keyword">key</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug_id_generator(bug_id) <span class="keyword">value</span>(<span class="keyword">default</span>);</span><br><span class="line"><span class="keyword">rollback</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bug_2010(bug_id, ....)</span><br><span class="line"><span class="keyword">values</span>(<span class="keyword">last_insert_id</span>(), ....);</span><br></pre></td></tr></table></figure>

<h5 id="跨表查询"><a href="#跨表查询" class="headerlink" title="跨表查询"></a>跨表查询</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;不可避免，你一定有需求要查询所有的数据。此时你只能选择union 将所有的数据联合起来。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> count(<span class="number">1</span>) from (</span><br><span class="line">	<span class="keyword">select</span> * from bug_2008</span><br><span class="line">		<span class="class"><span class="keyword">union</span> <span class="title">all</span></span></span><br><span class="line">	<span class="keyword">select</span> * from bug_2009</span><br><span class="line">		<span class="class"><span class="keyword">union</span> <span class="title">all</span></span></span><br><span class="line">	<span class="keyword">select</span> * from bug_2010</span><br><span class="line">) <span class="keyword">as</span> temp;</span><br></pre></td></tr></table></figure>

<h5 id="同步元数据"><a href="#同步元数据" class="headerlink" title="同步元数据"></a>同步元数据</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你要添加一列作为每个bug解决的时间，你需要同步之前创建的所有表，不然你在使用union语句会报错，或者你不使用通配符(*)，而是一个一个列出你要查询的列。</p>
<h5 id="管理引用完整性"><a href="#管理引用完整性" class="headerlink" title="管理引用完整性"></a>管理引用完整性</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;使用拆分表，你不能建立一个外键约束，是因为sql是不支持的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">comment</span> (</span><br><span class="line">	bug_id <span class="built_in">bigint</span> unsiged <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">	<span class="keyword">foreign</span> <span class="keyword">key</span>(bug_id) <span class="keyword">references</span> bug_???(bug_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;同时关联查询也是如此，如果你要统计某一个用户提交的所有bug数</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * from account a </span><br><span class="line">join (</span><br><span class="line">	<span class="keyword">select</span> * from bug_2008</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">all</span></span></span><br><span class="line">	<span class="keyword">select</span> * from bug_2009</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">all</span></span></span><br><span class="line">	<span class="keyword">select</span> * from bug_2010</span><br><span class="line">) t on a.account_id = t.report_id</span><br></pre></td></tr></table></figure>
<h4 id="如何识别反模式"><a href="#如何识别反模式" class="headerlink" title="如何识别反模式"></a>如何识别反模式</h4><p>当出现以下情况时，可能是反模式</p>
<ol>
<li>我们需要每……创建一张表或者列？</li>
<li>数据库支持的最大数量的表或者列是多少？</li>
<li>发现程序添加记录失败了：因为王佳伟新的一年添加新表了</li>
<li>如何查询很多张表？每张表的列都是一样的。<br>【如果你需要查询很多结构一样的表，就应该讲数据全部存储在一个表中，使用一个额外的属性列来分组数据】</li>
<li>如何将表名称作为一个表里传递？在查询是需要根据辩分动态的生成这些表名称。</li>
</ol>
<h4 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;手动分隔表的一个合理使用场景是“归档数据”—–将历史数据从日常使用的数据库中移除。通常在过期数据的查询变的非常稀少的情况下，才会进行如此的操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;如果你没有同时查询当前数据和历史数据的需求，将老数据从当前活动的表转移到其他地方是很合适的操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;将数据归档到与当前表结构相兼容的新表中，既能支持偶尔做数据分析时的查询，同时能让日常数据查询边的非常高效。</p>
<h4 id="解决方案：分区并标准化"><a href="#解决方案：分区并标准化" class="headerlink" title="解决方案：分区并标准化"></a>解决方案：分区并标准化</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;当一张表的数据量非常巨大时，除了手动拆分这张表，还有比这更好的办法来提升查询性能。这些方法包括了水平分区，垂直分区以及使用关联表。</p>
<h5 id="水平分区"><a href="#水平分区" class="headerlink" title="水平分区"></a>水平分区</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;水平分区（或者叫分片）：根据数据行来对表进行拆分。同时不用担心那些分隔表所带来的缺陷。仅需要定义一些规则来拆分一张逻辑表，数据库会为你管理余下所有的工作。物理上来说，表的确的被拆分了，但你依旧可以向查询单一表那样执行SQL查询语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- mysql 5.1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug(</span><br><span class="line">	bug_id <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">	...</span><br><span class="line">	date_report <span class="built_in">date</span></span><br><span class="line">) <span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">hash</span>(<span class="keyword">year</span>(date_report)) </span><br><span class="line"><span class="keyword">partitions</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;以上分割数据库的方式和这章最开始讲到的方式类似，根据date_report列的年份对数据拆分，但是它不用人工维护。实际存储数据的物理表在本例子中被固定设置为4张，当记录的年份跨度超过4年，某一个分区将用来存储多于一年。年份跨度不断增长，这样的现象也会不断重演。你不必添加新的分区，除非分区里面的数据量变得非常巨大，让你觉得需要重新分区。<br>&nbsp;&nbsp;&nbsp;&nbsp;注意：分区在sql标准中没有定义，每个不用的数据库实现这一功能都是非标准的。</p>
<h5 id="垂直分区"><a href="#垂直分区" class="headerlink" title="垂直分区"></a>垂直分区</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;鉴于水平分区是根据行来拆分，那么垂直分区就是根据列来拆分，将不经常用到的列或者非常庞大的列拆分出来。<br>&nbsp;&nbsp;&nbsp;&nbsp;BLOB或者TEXT类型的列可能是非常大的，有些数据库默认做了拆分存储，如果你查询不包含BLOB或者TEXT速度是非常快的。<br>&nbsp;&nbsp;&nbsp;&nbsp;我们开发可以创建一张额外的表来保存这些庞大的列，多出一列用来关联之前的表。比如product表，要将安装文件保存到数据库。（例子比较极端）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product_install_image(</span><br><span class="line">	product_id bugint unsiged primary <span class="keyword">key</span>,</span><br><span class="line">	install_image <span class="built_in">blob</span>,</span><br><span class="line">	<span class="keyword">foreign</span> <span class="keyword">key</span> product_id <span class="keyword">references</span> product(product_id);</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;还有值得注意，在mysql的MyISAM引擎中，使用固定长度的列是最高效的，比如说char类型比varchar类型要高效。</p>
<h5 id="解决元数据分裂"><a href="#解决元数据分裂" class="headerlink" title="解决元数据分裂"></a>解决元数据分裂</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;我们在第8章解决过类似的问题，解决元数据分裂的方案就是创建关联表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product_history(</span><br><span class="line">	product_id <span class="built_in">bigint</span>,</span><br><span class="line">	<span class="keyword">year</span> <span class="built_in">smallint</span>,</span><br><span class="line">	big_fix <span class="built_in">int</span>,</span><br><span class="line">	primary <span class="keyword">key</span>(product_id, <span class="keyword">year</span>),</span><br><span class="line">	<span class="keyword">foreign</span> <span class="keyword">key</span> (product_id) <span class="keyword">references</span> product(product_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;使用每一个产品、每一列记录一年的bug修复数量，还不如使用多行、仅用一列记录修复的bug数量。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;别让数据繁衍元数据</p>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=/img/WeChatQR.jpg&amp;GitHub=https://github.com/farawayliu&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>far</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2018/08/14/sql/antipatterns/09-元数据分裂/">https://www.ofcoder.com/2018/08/14/sql/antipatterns/09-%E5%85%83%E6%95%B0%E6%8D%AE%E5%88%86%E8%A3%82/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>Copyright © 2021 ofcoder. Author by far.</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://www.ofcoder.com/2018/08/14/sql/antipatterns/09-%E5%85%83%E6%95%B0%E6%8D%AE%E5%88%86%E8%A3%82/" data-id="ckxovix3q00isycj1e0wb9qmt" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADLklEQVR42u3a0Y7iQAwEwP3/n+ZeV1oB3TacyFB5OrFokgrSWXb75ye+br+uv5/8ve6dcO+0x3e8d35yzurCxsbGvgh7doO/N3uMzz/PX/HjF/rkx8DGxsY+jp2UnASQf6d9fTn7sQUbGxsbe/Y69mWpfTZsbGxs7Pa4pF2ZzXnawomNjY39nezN4CYvOck1CyreOEvDxsbG/nh2Xlo+/99vybexsbGxP5h9K6+kYWgXdGZB70qBjY2NfRA7LwAt7/GZbcOQRwXF82NjY2MfxM5HNrMhTj5+ystY2zI9eUHY2NjYl2XPwtS2eOTn5KfNVoWwsbGxz2PvA4B2lWc2Esp5SduDjY2NfRK7HfrnnU0+6GkLZ7tIdLcVwcbGxj6O/fg2s0HSrOWYDaSKVR5sbGzso9n5Q+ffSR50FvfOPsHGxsY+jz2LWvPhTnvmZlAVjaiwsbGxD2LPxkD7diV5oNlYqo6NsbGxsQ9iJ0ViH/rO7rLnPfkONjY29mXZ+dg9H8HPGo9ZKzIMDLCxsbEPYq/i0sXg/lXxQLvEg42NjX0eO1+IyYOBTQHbLxJFQQU2Njb2Qew2pm1HRa8KFeqlnHaKho2NjX1ZdjuaaUfzbambLYC2rQ42Njb2SexZ+dkUmPz8vB3KGyRsbGzsU9l5E5IXpKThSUKI9qUXPwA2Njb2F7Dzwc0e9n+GStjY2Nhns9vR/74UtQudm/jhbgHDxsbGvjj7VdFpu8qTj/tngXGUimBjY2Mfwc7/3BaY2aho/832CbGxsbFPYrerM21sMHs1beHMT8PGxsY+ib1Ztdks2dRbRYuSGaUi2NjY2Bdnt21JEhjkqzxtA5P/MHXQi42NjX1ZdhsSbELftvFoX9zL6jY2Njb2x7Nv5fWOeGAzZpqVW2xsbOyT2O1//fkN2qKYNzCzEHpYCLGxsbEvwm6LVh4nvKoIzUIIbGxs7G9j57fJg962VWjPzIsuNjY2Nvas8WjXaNqX0q4QFbUUGxsb+2h2Uk7alZq2CWkj5LvZCDY2NvZB7Hy4vwl6Z8UyAb9xloaNjY398ey8DOSj+bZ1yQdDrwqesbGxsY9g/wOx1yFMTew5agAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/SQL/">SQL</a></div><div class="post-nav"><a class="pre" href="/2018/08/18/java/maven%E6%89%93%E5%8C%85%E4%B8%8D%E8%83%BD%E4%B8%8B%E8%BD%BD%E6%8F%92%E4%BB%B6(maven-clean-plugin)/">maven打包不能下载插件(maven-clean-plugin)</a><a class="next" href="/2018/08/13/sql/antipatterns/08-%E5%A4%9A%E5%88%97%E5%B1%9E%E6%80%A7/">SQL反模式08-多列属性</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'s8pJruGkXvi5Skd0e6EaMQ5X-gzGzoHsz',
  appKey:'K3NjnXxqhPNwUw5pmqOzoO4i',
  placeholder:'说出你的故事...',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-blind"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#目标：支持可扩展性"><span class="toc-number">1.</span> <span class="toc-text">目标：支持可扩展性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#反模式：克隆表与克隆列"><span class="toc-number">2.</span> <span class="toc-text">反模式：克隆表与克隆列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#不断产生新表"><span class="toc-number">2.1.</span> <span class="toc-text">不断产生新表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#管理数据完整性"><span class="toc-number">2.2.</span> <span class="toc-text">管理数据完整性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#同步数据"><span class="toc-number">2.3.</span> <span class="toc-text">同步数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#确保唯一性"><span class="toc-number">2.4.</span> <span class="toc-text">确保唯一性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#跨表查询"><span class="toc-number">2.5.</span> <span class="toc-text">跨表查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#同步元数据"><span class="toc-number">2.6.</span> <span class="toc-text">同步元数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#管理引用完整性"><span class="toc-number">2.7.</span> <span class="toc-text">管理引用完整性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何识别反模式"><span class="toc-number">3.</span> <span class="toc-text">如何识别反模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#合理使用反模式"><span class="toc-number">4.</span> <span class="toc-text">合理使用反模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决方案：分区并标准化"><span class="toc-number">5.</span> <span class="toc-text">解决方案：分区并标准化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#水平分区"><span class="toc-number">5.1.</span> <span class="toc-text">水平分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#垂直分区"><span class="toc-number">5.2.</span> <span class="toc-text">垂直分区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#解决元数据分裂"><span class="toc-number">5.3.</span> <span class="toc-text">解决元数据分裂</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结论"><span class="toc-number">6.</span> <span class="toc-text">结论</span></a></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">并发笔记 - ofcoder.com | </a><a href="https://beian.miit.gov.cn/" rel="nofollow" target="_blank">粤ICP备18053760号</a><div>本站访客 <span id="busuanzi_value_site_uv"></span>人次 | 总访问 <span id="busuanzi_value_site_pv"></span>次<img src="https://s04.flagcounter.com/count/MnzJ/bg_FFFFFF/txt_000000/border_726EE0/columns_2/maxflags_10/viewers_0/labels_1/pageviews_1/flags_0/percent_0/" style="display: none;"/></div></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="100,99,98" opacity="0.7" zIndex="-1" count="5" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html><script type="text/javascript" src="/js/toc.js?v=0.0.0" async></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>