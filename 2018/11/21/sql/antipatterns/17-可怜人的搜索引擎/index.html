<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>SQL反模式17-可怜人的搜索引擎 | 并发笔记 - ofcoder.com</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><!-- 顶部加载进度条 --><script type="text/javascript" src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SQL反模式17-可怜人的搜索引擎</h1><a id="logo" href="/.">并发笔记 - ofcoder.com</a><p class="description">一位后端开发的养肝历程，护发经验</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/usql/"><i class="fa fa-database"> usql</i></a><a href="/book/"><i class="fa fas fa-book"> book</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">SQL反模式17-可怜人的搜索引擎</h1><div class="post-meta">Nov 21, 2018<span> | </span><span class="category"><a href="/categories/SQL%E5%8F%8D%E6%A8%A1%E5%BC%8F/">SQL反模式</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.3k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 8</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/2018/11/21/sql/antipatterns/17-%E5%8F%AF%E6%80%9C%E4%BA%BA%E7%9A%84%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/#vcomment"><span class="valine-comment-count" data-xid="/2018/11/21/sql/antipatterns/17-%E5%8F%AF%E6%80%9C%E4%BA%BA%E7%9A%84%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"></span><span> 条评论</span></a><div class="post-content"><h3 id="目标：全文搜索"><a href="#目标：全文搜索" class="headerlink" title="目标：全文搜索"></a>目标：全文搜索</h3><p>任何存储文本的应用都有针对某个字段进行查找的需求，随着数据增长，性能成为必经的瓶颈。<br>SQL的一个基本原理就是一列中的单个数据是原子性的，也就是说，你能对两个值进行比较，但通常是把两个值当成两个整体来比较。而你要在SQL中比较子字符串意味着低效和不准确。那么我们该如何高效的查找一个字符的子字符串呢？</p>
<h3 id="反模式：模式匹配断言"><a href="#反模式：模式匹配断言" class="headerlink" title="反模式：模式匹配断言"></a>反模式：模式匹配断言</h3><p>SQL提供了模式匹配断言来比较字符串，通常是程序员用来搜索关键字的第一选择，最广泛的就是LIKE断言。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> description <span class="keyword">like</span> <span class="string">'%crash%'</span>;</span><br></pre></td></tr></table></figure>

<p>还有正则表达式也被多数数据库支持，如MYSQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> description REGEXP <span class="string">'crash'</span>;</span><br></pre></td></tr></table></figure>
<p>模式匹配虽然能实现我们大部分需求，但是最大缺点就是性能问题，它无法从索引上受益，因此必须全表扫描，这是非常恐怖的。</p>
<p>模式匹配还有一个缺点就是，它会返回莫名奇妙的结果集</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> description <span class="keyword">like</span> <span class="string">'%one%'</span>;</span><br></pre></td></tr></table></figure>

<p>上面模式匹配则会返回money、prone、lonely等单词，即使在两端加上空格也不能避免。虽然mysql对此提出单词匹配的解决方案，但是它仍然是不高效的，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> description REGEXP <span class="string">'[[:&lt;:]]one[[:&gt;:]]'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="如何识别反模式：当出现以下情况时，可能是反模式"><a href="#如何识别反模式：当出现以下情况时，可能是反模式" class="headerlink" title="如何识别反模式：当出现以下情况时，可能是反模式"></a>如何识别反模式：当出现以下情况时，可能是反模式</h3><ol>
<li>如何在like表达式的2个通配符之间插入一个变量？</li>
<li>如何写一个正则表达式来检查一个字符串是否包含多个单词、不包含一个特定的单词，或者包含给定单词的任意形式？</li>
<li>网站的搜索功能在增加了很多文档进去之后慢的不可理喻。</li>
</ol>
<h3 id="合理使用反模式"><a href="#合理使用反模式" class="headerlink" title="合理使用反模式"></a>合理使用反模式</h3><ol>
<li>性能是非常重要的，如果一些查询过程很少执行，就不必要花很多功夫去对它进行优化</li>
<li>使用模式匹配操作进行很复杂的查询是很困难的，但是如果你为了一些简单的需求设计这样的模式匹配，它们能帮助你用最少的工作量获得正确的结果。</li>
</ol>
<h3 id="解决方案：使用正确的工具"><a href="#解决方案：使用正确的工具" class="headerlink" title="解决方案：使用正确的工具"></a>解决方案：使用正确的工具</h3><p>最好的解决方案不是优化你的SQL，而是使用搜索引擎。或者另一个可选的方案是将结果保存起来从而减少重复的搜索开销。</p>
<h4 id="数据库扩展"><a href="#数据库扩展" class="headerlink" title="数据库扩展"></a>数据库扩展</h4><h5 id="MySQL的全文索引"><a href="#MySQL的全文索引" class="headerlink" title="MySQL的全文索引"></a>MySQL的全文索引</h5><p>MySQL在MyISAM存储引擎上提供了一个简单的全文索引类型，你可以在char、varchar、text类型的列上定义一个全文索引。下面的例子在summary和description列上定义全文索引。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> bug <span class="keyword">add</span> fulltext <span class="keyword">index</span> bugfts(<span class="keyword">summary</span>, description);</span><br></pre></td></tr></table></figure>

<p>可以使用MATCH()函数对索引内容进行搜索。必须在匹配时指定需要全文索引的列（因而你可以在同一张表中对其他列使用不同类型的索引）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> <span class="keyword">match</span>(summary, description) against(<span class="string">'crash'</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Oracle的文本索引"><a href="#Oracle的文本索引" class="headerlink" title="Oracle的文本索引"></a>Oracle的文本索引</h5><p>从Oracle8开始，就支持文本索引特性，它的索引非常强大且复杂，这里只是简单介绍</p>
<ul>
<li><p>CONTEXT<br>为单个文本列建立这样的索引类型，使用CONTAINS()操作符进行搜索，<strong>索引和数据不同步，所以你每次都得手动重建索引或定期重建</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> BugText <span class="keyword">on</span> bug(summary) <span class="keyword">INDEXTYPE</span> <span class="keyword">IS</span> CTSSYS.CONTEXT;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> CONTAINS(summary, <span class="string">'crash'</span>) &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CTXCAT<br>这样类型的索引是针对短文本设计的，比如用在程序的分类目录上，和同一张表的其他结构化列在一起。这样的索引会保持数据的同步。</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CTX_DDL.CREATE_INDEX_SET(<span class="string">'BugsCatalogSet'</span>);</span><br><span class="line">CTX_DDL.<span class="meta">ADD</span><span class="meta">_INDEX(</span><span class="string">'BugsCatalogSet'</span>, <span class="string">'status'</span>);</span><br><span class="line">CTX_DDL.<span class="meta">ADD</span><span class="meta">_INDEX(</span><span class="string">'BugsCatalogSet'</span>, <span class="string">'priority'</span>);</span><br><span class="line"><span class="meta">CREATE</span> <span class="meta">INDEX</span> BugsCatalog <span class="meta">ON</span> Bug(summary) INDEXTYPE IS CTSSYS.CTXCAT PARAMETERS(<span class="string">'BugsCatalogSet'</span>);</span><br></pre></td></tr></table></figure>
<p>CATSEARCH()操作符能分别接受两个参数来搜索索引列和结构化的集合。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="function"><span class="keyword">from</span> bug <span class="keyword">where</span> <span class="title">CATSEARCH</span>(<span class="params">summary, <span class="string">'(crash save)'</span>, <span class="string">'status = "NEW"'</span></span>) &gt; 0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CTXXPATH<br>这中索引是针对XML搜索而设计的。使用existsNode()操作符。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> BugTestXml <span class="keyword">ON</span> bug(testoutput) <span class="keyword">INDEXTYPE</span> <span class="keyword">IS</span> CTSSYS.CTXXPATH;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> bug <span class="keyword">where</span> testoutput.existsNode(<span class="string">'/testsuite/test[@status="fail"]'</span>) &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CTXRULE<br>假设在数据库中存在大量的文档，然后需要根据文档内容进行分类。使用CTXRULE索引，你可以设计分析文档的规则并返回文档的分类信息。同时，你可以提供一些示例文档以及对应的分类概念，然后让Oracle去分析这个规则并应用到其它文档上。</p>
</li>
</ul>
<h5 id="其他数据库全文索引"><a href="#其他数据库全文索引" class="headerlink" title="其他数据库全文索引"></a>其他数据库全文索引</h5><p>书中还提到SQLServer、PostgreSQL、SQLite。个人没有用到，不是很熟悉，请自行查看。</p>
<h4 id="第三方搜索引擎"><a href="#第三方搜索引擎" class="headerlink" title="第三方搜索引擎"></a>第三方搜索引擎</h4><p>如果需要搜索功能的代码对不同数据库都通用，那么就需要一个独立于数据库的搜索引擎，这一节介绍两个产品Sphinx Search和Apache Lucene。</p>
<ul>
<li><p>Sphinx Search<br>Sphinx Search是一个开源引擎，用于和mysql、postgreSQL配套使用，它构建索引和搜索都很快，而且它还支持分布式查询。对数据不常更新且要求高可扩展性的程序来说，是一个很好的选择。<br>你可以使用Sphinx来索引存在于mysql中的数据，通过修改sphinx.conf中的几个字段，你需要写一个sql查询脚本为构建索引的操作获取数据。这个查询第一列要求为一个整形主键。最后通过sql查询脚本通过给定的主键代码$id，从数据库中获取完整的记录。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- sphinx.conf</span><br><span class="line"><span class="symbol">source</span> <span class="keyword">bugsrc&#123;</span></span><br><span class="line"><span class="keyword">	</span>type = mysql</span><br><span class="line">	sql_user = <span class="keyword">buguser</span></span><br><span class="line"><span class="keyword">	</span>sql_pass = <span class="keyword">bugpass</span></span><br><span class="line"><span class="keyword">	</span>sql_db = <span class="keyword">bug</span></span><br><span class="line"><span class="keyword">	</span>sql_query = <span class="keyword">select </span><span class="keyword">bug_id, </span>status, date_reported, summary, description from <span class="keyword">bug</span></span><br><span class="line"><span class="keyword">	</span>sql_attr_timestamp = date_reported</span><br><span class="line">	sql_attr_str2ordinal = status</span><br><span class="line">	sql_query_info = <span class="keyword">select </span>* from <span class="keyword">bug </span>where <span class="keyword">bug_id </span>= $id</span><br><span class="line">&#125;</span><br><span class="line"><span class="symbol">index</span> <span class="keyword">bug&#123;</span></span><br><span class="line"><span class="keyword">	</span>source = <span class="keyword">bugsrc</span></span><br><span class="line"><span class="keyword">	</span>path = /<span class="meta">opt</span>/local/var/db/sphinx/<span class="keyword">bug</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>
<p>完成配置后，你可以在shell中使用indexer命令创建索引：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">indexer</span> <span class="selector-tag">-c</span> <span class="selector-tag">sphinx</span><span class="selector-class">.conf</span> <span class="selector-tag">bug</span></span><br></pre></td></tr></table></figure>
<p>你可以使用search进行搜索</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">search</span> -<span class="keyword">b </span><span class="string">"crash -save"</span></span><br></pre></td></tr></table></figure>
<p>sphinx 也有对应的API供常用的语言(php、perl、Ruby)调用。sphinx当前的问题是，目前索引算法不支持高效的增量更新。在一个经常更新的数据源上使用sphinx需要一些折中的处理方式。比如，可将搜索的数据拆成两张表 ，第一张存储不变的主体历史数据，第二张存储较小大的当前数据集合，当数据慢慢增长时，就需要重建索引。然后你的程序必须对两个sphinx索引进行搜索。</p>
</li>
<li><p>Apache Lucene<br>lucene是一个针对java的成熟搜索引擎，它使用其独特的格式为文本文档创建索引，lucene索引不和元数据保持同步。如果你插入、删除、更新，必须也对lucene索引进行对应的操作。<br>apache提供一个项目叫做solr，solr是lucene索引的网关服务，你可以向solr添加文档或者使用rest风格的接口提交查询请求，这样你可以使用任意语言调用lucene了。<br>你也可以将solr配置成直接连接到数据库，执行一个查询操作，然后使用data-importHandler工具对结果进行索引。</p>
</li>
<li><p>实现自己的搜索引擎<br>本节使用一个称为反向索引的方案来实现独立搜索引擎。反向索引就是一个所有可能被搜索的单词列表。在多对多的关系中，索引将这些单词和包含这个单词的文本关联起来。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> keyword(</span><br><span class="line">	keyword_id <span class="built_in">serial</span> primary <span class="keyword">key</span>,</span><br><span class="line">	keyword <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">	<span class="keyword">unique</span> <span class="keyword">key</span>(keyword)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bug_keyword(</span><br><span class="line">	keyword_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">	bug_id <span class="built_in">bigint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">	primary <span class="keyword">key</span>(keyword_id, bug_id),</span><br><span class="line">	<span class="keyword">foreign</span> <span class="keyword">key</span>(keyword_id) <span class="keyword">reference</span> keyword(keyword_id),</span><br><span class="line">	<span class="keyword">foreign</span> <span class="keyword">key</span>(bug_id) <span class="keyword">reference</span> bug(bug_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>接下来，我们将每个关键字和所匹配到bug添加到bug_keyword中，我们可以使用like查询，获取我们所需要的匹配记录。对于单个单词来说，使用这个查询只有一次，接下来每一次都从索引中获取对应的记录。我们可以使用存储过成完成</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> bug_search(keyword <span class="built_in">varchar</span>(<span class="number">40</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">set</span> @keyword = keyword;</span><br><span class="line">		<span class="keyword">prepare</span> s1 <span class="keyword">from</span> <span class="string">'select max(keyword_id) into @k from keyword where keyword = ?'</span>;</span><br><span class="line">		<span class="keyword">execute</span> s1 <span class="keyword">using</span> @keyword;</span><br><span class="line">		<span class="keyword">deallocate</span> <span class="keyword">prepare</span> s1;</span><br><span class="line">	if (@k is null) then</span><br><span class="line">		<span class="keyword">prepare</span> s2 <span class="keyword">from</span> <span class="string">'insert into keyword(keyword) value (?)'</span>;</span><br><span class="line">		<span class="keyword">execute</span> s2 <span class="keyword">using</span> @keyword;</span><br><span class="line">		<span class="keyword">deallocate</span> <span class="keyword">prepare</span> s2;</span><br><span class="line">		<span class="keyword">select</span> <span class="keyword">last_insert_id</span>() <span class="keyword">into</span> @k;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">prepare</span> s3 <span class="keyword">from</span> <span class="string">'insert bug_keyword(bug_id, keyword_id) </span></span><br><span class="line"><span class="string">			select bug_id, ? from bug </span></span><br><span class="line"><span class="string">			where summary regexp concat(''[[:&lt;:]]'', ?, ''[[:&gt;:]]'')</span></span><br><span class="line"><span class="string">			or description regexp concat(''[[:&lt;:]]'', ?, ''[[:&gt;:]]'')'</span>;</span><br><span class="line">		<span class="keyword">execute</span> s3 <span class="keyword">using</span> @k, @keyword, @keyword;</span><br><span class="line">		<span class="keyword">deallocate</span> <span class="keyword">prepare</span> s3;</span><br><span class="line">	<span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">prepare</span> s4 <span class="keyword">from</span> <span class="string">'select b.* from bug b</span></span><br><span class="line"><span class="string">		join bug_keyword k using(bug_id)</span></span><br><span class="line"><span class="string">		where k.keyword_id = ?'</span>;</span><br><span class="line">	<span class="keyword">execute</span> s4 <span class="keyword">using</span> @k;</span><br><span class="line">	<span class="keyword">deallocate</span> <span class="keyword">prepare</span> s4;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>使用这个存储过程，你需要维护一个触发器，当你插入或删除时，你需要维护bug_keyword的记录</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> bug_insert <span class="keyword">after</span> <span class="keyword">insert</span> <span class="keyword">on</span> bug <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">insert</span> <span class="keyword">into</span> bug_keyword(bug_id, keyword_id) </span><br><span class="line">		<span class="keyword">select</span> <span class="built_in">new</span>.bug_id, k.keyword_id <span class="keyword">from</span> keyword k</span><br><span class="line">		<span class="keyword">where</span> <span class="built_in">new</span>.description regexp concat(<span class="string">'[[:&lt;:]]'</span>, k.keyword, <span class="string">'[[:&gt;:]]'</span>)</span><br><span class="line">		<span class="keyword">or</span> <span class="built_in">new</span>.<span class="keyword">summary</span> regexp concat(<span class="string">'[[:&lt;:]]'</span>, k.keyword, <span class="string">'[[:&gt;:]]'</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这个关键词列表会随着用户不断搜索而自动增长，因此我们不必将知识库中找到的单词都追加到列表中。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>你不必使用sql来解决所有问题</p>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=/img/WeChatQR.jpg&amp;GitHub=https://github.com/farawayliu&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>far</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2018/11/21/sql/antipatterns/17-可怜人的搜索引擎/">https://www.ofcoder.com/2018/11/21/sql/antipatterns/17-%E5%8F%AF%E6%80%9C%E4%BA%BA%E7%9A%84%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>Copyright © 并发笔记 - ofcoder.com. Author by far.</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://www.ofcoder.com/2018/11/21/sql/antipatterns/17-%E5%8F%AF%E6%80%9C%E4%BA%BA%E7%9A%84%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/" data-id="ckxovix3r00ivycj17mqhfw0i" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASYAAAEmCAAAAADqr2IGAAAEgUlEQVR42u3aS24bOxAF0Ox/0w4QZBAgsHVvFf2e2Dk9MiKJTR4GIOvz40f8fPx6/vz7z2f222Tkr9/12Th/fyf55oEHEyZMmDC9JVMyrdkUvx7/s9Hauc3m046PCRMmTJhuZ5pdAj7iJ1nMZ/+SXzvyMfO1Y8KECROmf4epPexzrH14nKNgwoQJEyZMyQvagHP2/a+3JBm5ZcWECRMmTE9lmh3tyTLOjt++cT83TJgwYcJ0O9OscecZf397fxMmTJgwYfpfmT7K5yzl7Ghvg/PNen+PhgkTJkyYrmXKG2jytptTS0pac2YtRLMCJyZMmDBhupEpX3Z+0OYNNPl7961FSVH2xb0JEyZMmDBdyDQLGhOgPKmaFx3z60v7/eg/ByZMmDBhupxpk3jdBKXJJeD70IsCJyZMmDBheihTe/znk24XXBzeo1W8eC8mTJgwYXoQ0yzBOuNL3pgvqf20mDkmTJgwYbqcaRNwtqXNswniZPFJqvrFdmLChAkTpguZTh32UeNLfC3ID/48gbtpQsKECRMmTLczzY7JWeK1XeTZy0ddwsSECRMmTI9gOtu+01ImV4pkSZvNfvErTJgwYcL0CKZNI057kuYXhTbh29JEApgwYcKE6RFMs+abtsVntiV5Uni/bZgwYcKE6XlMeeNm23bTLm9Pk4+Wl0sxYcKECdOzmdrwdb+Ys8XRTeMOJkyYMGF6BtOsnWUTNm/elUPnpdAXm40JEyZMmK5lyhefFz7bY3vTHpSnkg8TY8KECROmq5jalGgb+u7bbj7Kp03pFjcFTJgwYcJ0FdN/U2hMjuq2jDo74NvLByZMmDBhegbTLBnalgw3b0mWuhn5xZiYMGHChOlypjYk3lwX8jA7b/fJw+BZCI0JEyZMmO5l2rTRzKabp3fb0b5vGzBhwoQJ0+1MpwqByYLzq8a+jJqXOaPNwIQJEyZMj2Bqj9s2QG0D0ZY1n3Ndr8SECRMmTJcztS+YFS/bEfIrQrtVSVL7RUYcEyZMmDBdyzQLKWdJ1VN8LVm9eZgwYcKE6VqmWQCZJ3CTIPYsWXIJSELxouqLCRMmTJjekilJreZLTSYxI052O59/HvD//g4mTJgwYXoEU95wMysK5mXL/JqStNK2G/NpehcTJkyYMF3INHvNLIhtx0yaeGbom4AZEyZMmDA9iWmWfp21Ac0Kn+11ZBa6Y8KECROme5nawmF+GLehbHskb8Ly+iKCCRMmTJgewXQqITt72iA8KkMuQu5hTxMmTJgwYXozpk0A+d3B5wZithlfXyAwYcKECdONTLNje9ayk6Rx8/Rr+81VKhkTJkyYMF3LtClqJpNIAuxZira9ZOTNOkMgTJgwYcL0xkztJaAteebFyM2FIA/U80tJcXvChAkTJkxvzzS7BCS/bT/dp5Vn6V1MmDBhwoRpluQ9G1TPGnHy9qBhlxMmTJgwYXocU/vprIjYkiXvzdPBmDBhwoTpSUzJYjZJ1TYkzhO+yfYc+C0mTJgwYbqW6VSytS1YzhqANjM5xoEJEyZMmO5g+gk7w94/M9+JTgAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/SQL/">SQL</a></div><div class="post-nav"><a class="pre" href="/2019/04/01/theory/%E8%B0%88%E8%B0%88mysql%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0-B+Tree/">谈谈mysql索引实现-B+ Tree</a><a class="next" href="/2018/11/03/sql/antipatterns/16-%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9/">SQL反模式16-随机选择</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'s8pJruGkXvi5Skd0e6EaMQ5X-gzGzoHsz',
  appKey:'K3NjnXxqhPNwUw5pmqOzoO4i',
  placeholder:'说出你的故事...',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-blind"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#目标：全文搜索"><span class="toc-number">1.</span> <span class="toc-text">目标：全文搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反模式：模式匹配断言"><span class="toc-number">2.</span> <span class="toc-text">反模式：模式匹配断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何识别反模式：当出现以下情况时，可能是反模式"><span class="toc-number">3.</span> <span class="toc-text">如何识别反模式：当出现以下情况时，可能是反模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#合理使用反模式"><span class="toc-number">4.</span> <span class="toc-text">合理使用反模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解决方案：使用正确的工具"><span class="toc-number">5.</span> <span class="toc-text">解决方案：使用正确的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数据库扩展"><span class="toc-number">5.1.</span> <span class="toc-text">数据库扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MySQL的全文索引"><span class="toc-number">5.1.1.</span> <span class="toc-text">MySQL的全文索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Oracle的文本索引"><span class="toc-number">5.1.2.</span> <span class="toc-text">Oracle的文本索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#其他数据库全文索引"><span class="toc-number">5.1.3.</span> <span class="toc-text">其他数据库全文索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第三方搜索引擎"><span class="toc-number">5.2.</span> <span class="toc-text">第三方搜索引擎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">并发笔记 - ofcoder.com | </a><a href="https://beian.miit.gov.cn/" rel="nofollow" target="_blank">粤ICP备18053760号</a><div>本站访客 <span id="busuanzi_value_site_uv"></span>人次 | 总访问 <span id="busuanzi_value_site_pv"></span>次<img src="https://s04.flagcounter.com/count/MnzJ/bg_FFFFFF/txt_000000/border_726EE0/columns_2/maxflags_10/viewers_0/labels_1/pageviews_1/flags_0/percent_0/" style="display: none;"/></div></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html><script type="text/javascript" src="/js/toc.js?v=0.0.0" async></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>