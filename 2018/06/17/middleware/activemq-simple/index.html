<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>初说 - ActiveMQ | 并发笔记 - ofcoder.com</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><!-- 顶部加载进度条 --><script type="text/javascript" src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">初说 - ActiveMQ</h1><a id="logo" href="/.">并发笔记 - ofcoder.com</a><p class="description">一位后端开发的养肝历程，护发经验</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/usql/"><i class="fa fa-database"> usql</i></a><a href="/book/"><i class="fa fas fa-book"> book</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">初说 - ActiveMQ</h1><div class="post-meta">Jun 17, 2018<span> | </span><span class="category"><a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1.8k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 6</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/2018/06/17/middleware/activemq-simple/#vcomment"><span class="valine-comment-count" data-xid="/2018/06/17/middleware/activemq-simple/"></span><span> 条评论</span></a><div class="post-content"><h4 id="一、AvticeMQ"><a href="#一、AvticeMQ" class="headerlink" title="一、AvticeMQ"></a>一、AvticeMQ</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;ActiveMQ 是Apache出品的开源消息总线。完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现</p>
<h4 id="二、JMS"><a href="#二、JMS" class="headerlink" title="二、JMS"></a>二、JMS</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p>
<h4 id="三、JMS支持的两种消息传递模型"><a href="#三、JMS支持的两种消息传递模型" class="headerlink" title="三、JMS支持的两种消息传递模型"></a>三、JMS支持的两种消息传递模型</h4><h5 id="1-Queue（点对点-point-to-point，简称PTP）"><a href="#1-Queue（点对点-point-to-point，简称PTP）" class="headerlink" title="1. Queue（点对点 point-to-point，简称PTP）"></a>1. Queue（点对点 point-to-point，简称PTP）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;通过该消息传递模型，一个应用程序（即消息生产者）可以向另外一个应用程序（即消息消费者）发送消息。消息目的地类型是队列（即由Session接口实现类实例通过调用其createQueue方法并传入队列名称而创建）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;消息首先被传送至消息服务器端特定的队列中，然后从此对列中将消息传送至对此队列进行监听的某个消费者。同一个队列可以关联多个消息生产者和消息消费者，但<strong>一条消息仅能传递给一个消息消费者</strong>。如果多个消息消费者正在监听队列上的消息，JMS消息服务器将根据“先来者优先”的原则确定由哪个消息消费者接收下一条消息。如果没有消息消费者在监听队列，消息将保留在队列中，直至消息消费者连接到队列为止。这种消息传递模型是传统意义上的懒模型或轮询模型。在此模型中，<strong>消息不是自动推动给消息消费者的，而是要由消息消费者从队列中请求获得</strong>。 </p>
<h5 id="2-Topic（发布-订阅-publish-subscribe，简称pub-sub）"><a href="#2-Topic（发布-订阅-publish-subscribe，简称pub-sub）" class="headerlink" title="2. Topic（发布/订阅 publish/subscribe，简称pub/sub）"></a>2. Topic（发布/订阅 publish/subscribe，简称pub/sub）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;通过该消息传递模型，应用程序能够将一条消息发送给多个消息消费者。消息目的地类型是主题（即Destination接口实现类实例由Session接口实现类实例通过调用其createTopic方法并传入主题名称而创建）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;消息首先由消息生产者发布至消息服务器中特定的主题中，然后由消息服务器将消息传送至所有已订阅此主题的消费者。与PTP消息传递模型不同，<strong>pub/sub消息传递模型允许多个主题订阅者接收同一条消息</strong>。在该模型中，消息会自动广播，<strong>消息消费者无须通过主动请求或轮询主题的方法来获得新的消息</strong>。</p>
<h5 id="3-Queue-和-Topic-具体区别"><a href="#3-Queue-和-Topic-具体区别" class="headerlink" title="3. Queue 和 Topic 具体区别"></a>3. Queue 和 Topic 具体区别</h5><table>
<thead>
<tr>
<th>Tables</th>
<th>Topic</th>
<th>Queue</th>
</tr>
</thead>
<tbody><tr>
<td>概要</td>
<td>Publish Subscribe messaging 发布订阅消息</td>
<td>Point-to-Point 点对点</td>
</tr>
<tr>
<td>有无状态</td>
<td>topic数据默认不落地，是无状态的。</td>
<td>Queue数据默认会在mq服务器上以文件形式保存，比如Active MQ一般保存在$AMQ_HOME\data\kr-store\data下面。也可以配置成DB存储。</td>
</tr>
<tr>
<td>完整性保障</td>
<td>并不保证publisher发布的每条数据，Subscriber都能接受到。</td>
<td>Queue保证每条数据都能被receiver接收。</td>
</tr>
<tr>
<td>消息是否会丢失</td>
<td>一般来说publisher发布消息到某一个topic时，只有正在监听该topic地址的sub能够接收到消息；如果没有sub在监听，该topic就丢失了。</td>
<td>Sender发送消息到目标Queue，receiver可以异步接收这个Queue上的消息。Queue上的消息如果暂时没有receiver来取，也不会丢失。</td>
</tr>
<tr>
<td>消息发布接收策略</td>
<td>一对多的消息发布接收策略，监听同一个topic地址的多个sub都能收到publisher发送的消息。Sub接收完通知mq服务器</td>
<td>一对一的消息发布接收策略，一个sender发送的消息，只能有一个receiver接收。receiver接收完后，通知mq服务器已接收，mq服务器对queue里的消息采取删除或其他操作。</td>
</tr>
</tbody></table>
<h4 id="四、AvticeMQ-配置"><a href="#四、AvticeMQ-配置" class="headerlink" title="四、AvticeMQ 配置"></a>四、AvticeMQ 配置</h4><h5 id="failover"><a href="#failover" class="headerlink" title="failover"></a>failover</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">failover:(tcp:<span class="comment">//192.168.1.118:61616?connectionTimeout=3000)</span></span><br><span class="line">	?timeout=<span class="number">5000</span></span><br><span class="line">	&amp;initialReconnectDelay=<span class="number">1000</span></span><br><span class="line">	&amp;maxReconnectDelay=<span class="number">1000</span></span><br><span class="line">	&amp;nested.wireFormat.maxInactivityDuration=<span class="number">30000</span></span><br></pre></td></tr></table></figure>
<p><strong>initialReconnectDelay：</strong>默认为10，单位毫秒，表示第一次尝试重连之前等待的时间。<br><strong>maxReconnectDelay：</strong>默认30000，单位毫秒，表示两次重连之间的最大时间间隔。<br><strong>nested.wireFormat.maxInactivityDuration</strong> 检测死连接时间<br><strong><a href="http://manzhizhen.iteye.com/blog/2105572" target="_blank" rel="noopener">其它相关配置</a></strong></p>
<h4 id="五、ActiveMQ-使用"><a href="#五、ActiveMQ-使用" class="headerlink" title="五、ActiveMQ 使用"></a>五、ActiveMQ 使用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;一种典型的JMS 程序需要经过下列几个步骤:</p>
<ol>
<li>通过 JNDI 查找 ConnectionFactory。</li>
<li>用 ConnectionFactory 创建一个 Connection。</li>
<li>用 Connection 创建一个或多个 Session。 </li>
<li>用 Session 和 Destination 创建所需的 MessageProducer 和 MessageConsumer。 </li>
<li>启动 Connection。 (下面是对应的截图说明)</li>
</ol>
<h5 id="1-连接工厂-ConnectionFactory"><a href="#1-连接工厂-ConnectionFactory" class="headerlink" title="1. 连接工厂 (ConnectionFactory)"></a>1. 连接工厂 (ConnectionFactory)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;连接工厂是客户用来创建连接的对象.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;例如: ActiveMQ 提供的ActiveMQConnectionFactory。注意（要初始化 JMS，则需要使用连接工厂。客户端通过创建ConnectionFactory建立到 ActveMQ的连接，一个连接工厂封装了一组连接配置参数，这组参数在配置ActiveMQ时已经定义，例如brokerURL参数，此参数传入的是ActiveMQ服务地址和端口，支持openwire协议的默认连接为 tcp://localhost:61616，支持 stomp协议的默认连接为tcp://localhost:61613。</p>
<h6 id="ActiveMQConnectionFactory构造方法："><a href="#ActiveMQConnectionFactory构造方法：" class="headerlink" title="ActiveMQConnectionFactory构造方法："></a>ActiveMQConnectionFactory构造方法：</h6><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor">ActiveMQConnectionFactory()</span>;</span><br><span class="line"><span class="constructor">ActiveMQConnectionFactory(String <span class="params">brokerURL</span>)</span>;</span><br><span class="line"><span class="constructor">ActiveMQConnectionFactory(String <span class="params">userName</span>, String <span class="params">password</span>, String <span class="params">b</span> <span class="params">rokerURL</span>)</span> ; </span><br><span class="line"><span class="constructor">ActiveMQConnectionFactory(String <span class="params">userName</span>, String <span class="params">password</span>, URI <span class="params">brok</span> <span class="params">erURL</span>)</span> ; </span><br><span class="line"><span class="constructor">ActiveMQConnectionFactory(URI <span class="params">brokerURL</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>其中 brokerURL为ActiveMQ服务地址和端口。</p>
<h6 id="spring封装的："><a href="#spring封装的：" class="headerlink" title="spring封装的："></a>spring封装的：</h6><ul>
<li><p><strong>SingleConnectionFactory</strong>：对于建立JMS服务器链接的请求会一直返回同一个链接，并且会忽略Connection的close方法调用。(<br>org.springframework.jms.connection.SingleConnectionFactory)</p>
</li>
<li><p><strong>CachingConnectionFactory</strong>：继承了SingleConnectionFactory，所以它拥有SingleConnectionFactory的所有功能，同时它还新增了缓存功能，它可以缓存Session、MessageProducer和MessageConsumer。我们使用CachingConnectionFactory来作为示例。(<br>org.springframework.jms.connection.CachingConnectionFactory)</p>
</li>
<li><p><strong>PooledConnectionFactory</strong>：线程池(org.apache.activemq.pool.PooledConnectionFactory)</p>
</li>
</ul>
<h5 id="2-连接-Connection"><a href="#2-连接-Connection" class="headerlink" title="2. 连接 (Connection)"></a>2. 连接 (Connection)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;Connection 封装了客户与 JMS 提供者之间的一个虚拟的连接。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当一个Connection被创建时，它的传输默认是关闭的，必须使用start方法开启。一个Connection可以建立一个或多个的Session。当一个程序执行完成后，必须关闭之前创建的Connection，否则 ActiveMQ不能释放资源，关闭一个Connection同样也关闭了 Session，MessageProducer和MessageConsumer。</p>
<h5 id="3-会话-Seesion"><a href="#3-会话-Seesion" class="headerlink" title="3. 会话(Seesion)"></a>3. 会话(Seesion)</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;Session 是生产和消费消息的一个单线程上下文。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;会话用于创建消息生产者（producer）、消息消费者（consumer）和消息（message）等。会话提供了一个事务性的上下文，在这个上下文中，一组发送和接收被组合到了一个原子操作中。</p>
<h4 id="六、ActiveMQ的多种部署方式"><a href="#六、ActiveMQ的多种部署方式" class="headerlink" title="六、ActiveMQ的多种部署方式"></a>六、ActiveMQ的多种部署方式</h4><p>具体介绍请查看文章后面部分：<a href="http://manzhizhen.iteye.com/blog/2105572" target="_blank" rel="noopener">查看</a></p>
<h5 id="1-Master-Slave部署方式"><a href="#1-Master-Slave部署方式" class="headerlink" title="1. Master-Slave部署方式"></a>1. Master-Slave部署方式</h5><h6 id="shared-filesystem-Master-Slave部署方式"><a href="#shared-filesystem-Master-Slave部署方式" class="headerlink" title="shared filesystem Master-Slave部署方式"></a>shared filesystem Master-Slave部署方式</h6><h6 id="shared-database-Master-Slave方式"><a href="#shared-database-Master-Slave方式" class="headerlink" title="shared database Master-Slave方式"></a>shared database Master-Slave方式</h6><h6 id="Replicated-LevelDB-Store方式"><a href="#Replicated-LevelDB-Store方式" class="headerlink" title="Replicated LevelDB Store方式"></a>Replicated LevelDB Store方式</h6><h5 id="2-Broker-Cluster部署方式"><a href="#2-Broker-Cluster部署方式" class="headerlink" title="2. Broker-Cluster部署方式"></a>2. Broker-Cluster部署方式</h5><h6 id="static-Broker-Cluster部署"><a href="#static-Broker-Cluster部署" class="headerlink" title="static Broker-Cluster部署"></a>static Broker-Cluster部署</h6><h6 id="Dynamic-Broker-Cluster部署"><a href="#Dynamic-Broker-Cluster部署" class="headerlink" title="Dynamic Broker-Cluster部署"></a>Dynamic Broker-Cluster部署</h6><h5 id="3-Master-Slave与Broker-Cluster相结合的部署方式"><a href="#3-Master-Slave与Broker-Cluster相结合的部署方式" class="headerlink" title="3. Master-Slave与Broker-Cluster相结合的部署方式"></a>3. Master-Slave与Broker-Cluster相结合的部署方式</h5></div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=/img/WeChatQR.jpg&amp;GitHub=https://github.com/farawayliu&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>far</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2018/06/17/middleware/activemq-simple/">https://www.ofcoder.com/2018/06/17/middleware/activemq-simple/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>Copyright © 并发笔记 - ofcoder.com. Author by far.</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://www.ofcoder.com/2018/06/17/middleware/activemq-simple/" data-id="ckxoviwxf001fycj177m3hip0" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLUlEQVR42u3aS27DMAxF0ex/0y7QUQtUyn2kXSDU1ahIbUfHA4YfvV54Xd+LX3P9WE/cVVwyZMj4WMa1XSvG6pP9Vvg1fG8yZMg4h5GGQhIc93etnrB/fcvPZciQIQOQ9iGVh04ZMmTI6Adc8nmaRO5figwZMmTwIpYkiGnLLP3eG2pxGTJkfCAjHQz8598PzjdkyJDxIYwrXLzRz6/vLxkyZMxm8PHkPu1LkzY+KuAvSIYMGVMZvBFWG0PyYE1eU3BmTYYMGYMYnVSv35hD7X4c9GXIkDGVkQ4v+ZEI3lbrHPX4VYvLkCFjNCM93MDTwVoxnDbsZMiQMZuRhkt+XIwXq+kBjuXeZMiQMZTBt9tJ+O568vLVyJAhYzSjE3DTFlut0RY072TIkDGUwcvOTvnawQS/GzJkyBjN6ITRTpuMh/IgKZQhQ8YBjH6CmAJq4bhYi8uQIWMEgzfxn9hWsZEnQ4aM0Qx+bJSQUkbtNS33LEOGjAMYwbDw1rElL6Tf7FaGDBlDGdxKqDzt4yEe3SVDhowDGOlggIdRPvLshHIZMmTMZqRBsHbYIm233fbrIUOGjBGMK1z8wNZzQ80//itDhozRjLSM5OOE9PpaASxDhoxzGHwwmT66kzKmxbMMGTJOYNT67elW4kjPQ7YMGTJk4KMStWK19mQZMmTIIKlh2uLvHLZ48xwZMmQcwOg068l208FDXNzKkCFjNKMf8nhjjjfveCNPhgwZoxlf8AjRPy6fCc0AAAAASUVORK5CYII=">分享</a><div class="tags"><a href="/tags/ActiveMQ/">ActiveMQ</a><a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></div><div class="post-nav"><a class="pre" href="/2018/06/20/sql/mysql%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E9%87%8F%E8%BF%87%E5%A4%A7%E6%8A%A5%E9%94%99/">mysql批量插入数据量过大报错</a><a class="next" href="/2018/06/12/sql/antipatterns/02-%E4%B9%B1%E7%A9%BF%E9%A9%AC%E8%B7%AF/">SQL反模式02-乱穿马路</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'s8pJruGkXvi5Skd0e6EaMQ5X-gzGzoHsz',
  appKey:'K3NjnXxqhPNwUw5pmqOzoO4i',
  placeholder:'说出你的故事...',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-blind"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、AvticeMQ"><span class="toc-number">1.</span> <span class="toc-text">一、AvticeMQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、JMS"><span class="toc-number">2.</span> <span class="toc-text">二、JMS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、JMS支持的两种消息传递模型"><span class="toc-number">3.</span> <span class="toc-text">三、JMS支持的两种消息传递模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Queue（点对点-point-to-point，简称PTP）"><span class="toc-number">3.1.</span> <span class="toc-text">1. Queue（点对点 point-to-point，简称PTP）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Topic（发布-订阅-publish-subscribe，简称pub-sub）"><span class="toc-number">3.2.</span> <span class="toc-text">2. Topic（发布&#x2F;订阅 publish&#x2F;subscribe，简称pub&#x2F;sub）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Queue-和-Topic-具体区别"><span class="toc-number">3.3.</span> <span class="toc-text">3. Queue 和 Topic 具体区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四、AvticeMQ-配置"><span class="toc-number">4.</span> <span class="toc-text">四、AvticeMQ 配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#failover"><span class="toc-number">4.1.</span> <span class="toc-text">failover</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#五、ActiveMQ-使用"><span class="toc-number">5.</span> <span class="toc-text">五、ActiveMQ 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-连接工厂-ConnectionFactory"><span class="toc-number">5.1.</span> <span class="toc-text">1. 连接工厂 (ConnectionFactory)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ActiveMQConnectionFactory构造方法："><span class="toc-number">5.1.1.</span> <span class="toc-text">ActiveMQConnectionFactory构造方法：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#spring封装的："><span class="toc-number">5.1.2.</span> <span class="toc-text">spring封装的：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-连接-Connection"><span class="toc-number">5.2.</span> <span class="toc-text">2. 连接 (Connection)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-会话-Seesion"><span class="toc-number">5.3.</span> <span class="toc-text">3. 会话(Seesion)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#六、ActiveMQ的多种部署方式"><span class="toc-number">6.</span> <span class="toc-text">六、ActiveMQ的多种部署方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Master-Slave部署方式"><span class="toc-number">6.1.</span> <span class="toc-text">1. Master-Slave部署方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#shared-filesystem-Master-Slave部署方式"><span class="toc-number">6.1.1.</span> <span class="toc-text">shared filesystem Master-Slave部署方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#shared-database-Master-Slave方式"><span class="toc-number">6.1.2.</span> <span class="toc-text">shared database Master-Slave方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Replicated-LevelDB-Store方式"><span class="toc-number">6.1.3.</span> <span class="toc-text">Replicated LevelDB Store方式</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Broker-Cluster部署方式"><span class="toc-number">6.2.</span> <span class="toc-text">2. Broker-Cluster部署方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#static-Broker-Cluster部署"><span class="toc-number">6.2.1.</span> <span class="toc-text">static Broker-Cluster部署</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Dynamic-Broker-Cluster部署"><span class="toc-number">6.2.2.</span> <span class="toc-text">Dynamic Broker-Cluster部署</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Master-Slave与Broker-Cluster相结合的部署方式"><span class="toc-number">6.3.</span> <span class="toc-text">3. Master-Slave与Broker-Cluster相结合的部署方式</span></a></li></ol></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">并发笔记 - ofcoder.com | </a><a href="https://beian.miit.gov.cn/" rel="nofollow" target="_blank">粤ICP备18053760号</a><div>本站访客 <span id="busuanzi_value_site_uv"></span>人次 | 总访问 <span id="busuanzi_value_site_pv"></span>次<img src="https://s04.flagcounter.com/count/MnzJ/bg_FFFFFF/txt_000000/border_726EE0/columns_2/maxflags_10/viewers_0/labels_1/pageviews_1/flags_0/percent_0/" style="display: none;"/></div></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html><script type="text/javascript" src="/js/toc.js?v=0.0.0" async></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>