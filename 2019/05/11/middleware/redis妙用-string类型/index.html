<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>redis妙用-string类型 | 并发笔记 - ofcoder.com</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><!-- 顶部加载进度条 --><script type="text/javascript" src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">redis妙用-string类型</h1><a id="logo" href="/.">并发笔记 - ofcoder.com</a><p class="description">一位后端开发的养肝历程，护发经验</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/usql/"><i class="fa fa-database"> usql</i></a><a href="/book/"><i class="fa fas fa-book"> book</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">redis妙用-string类型</h1><div class="post-meta">May 11, 2019<span> | </span><span class="category"><a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1.9k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 7</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/2019/05/11/middleware/redis%E5%A6%99%E7%94%A8-string%E7%B1%BB%E5%9E%8B/#vcomment"><span class="valine-comment-count" data-xid="/2019/05/11/middleware/redis%E5%A6%99%E7%94%A8-string%E7%B1%BB%E5%9E%8B/"></span><span> 条评论</span></a><div class="post-content"><p>string类型，是我们最常用的。以及一些特性，我们都比较熟悉，这一节一起回顾一下string的应用场景，以及对<strong>这些场景延申的一些思考</strong>。</p>
<ul>
<li>缓存，如何设计缓存存储，使用spring cache另当别论</li>
<li>分布式锁，锁续期</li>
<li>计数器</li>
<li>分布式全局序列，减少IO交互提高效率</li>
</ul>
<h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><h4 id="针对字符串的操作"><a href="#针对字符串的操作" class="headerlink" title="针对字符串的操作"></a>针对字符串的操作</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SET key value</td>
<td>存储字符串键</td>
</tr>
<tr>
<td>MSET key value[key value …]</td>
<td>批量存储字符串键</td>
</tr>
<tr>
<td>SETNX key value</td>
<td>存入一个存在在的字符串，若存在存储不成功</td>
</tr>
<tr>
<td>GET key</td>
<td>获取一个键的值</td>
</tr>
<tr>
<td>MGET key[key …]</td>
<td>批量获取键的值</td>
</tr>
</tbody></table>
<h4 id="针对数字的操作"><a href="#针对数字的操作" class="headerlink" title="针对数字的操作"></a>针对数字的操作</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>INCRBY key increment</td>
<td>对数字key进行{increment}的增加</td>
</tr>
<tr>
<td>DECRBY key decrement</td>
<td>对数字key进行{decrement}的减少</td>
</tr>
<tr>
<td>INCR key</td>
<td>对数字key自增1</td>
</tr>
<tr>
<td>DECR key</td>
<td>对数字key自减1</td>
</tr>
</tbody></table>
<h4 id="统一的操作"><a href="#统一的操作" class="headerlink" title="统一的操作"></a>统一的操作</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DEL key[key …]</td>
<td>删除一个键</td>
</tr>
<tr>
<td>EXPIRE key seconds</td>
<td>设置key的过期时间（秒）</td>
</tr>
<tr>
<td>PEXPIRE key milliseconds</td>
<td>设置key的过期时间（毫秒）</td>
</tr>
</tbody></table>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>string数据类型，我们常用来做为缓存，一般都是使用spring cache这样的框架来管理缓存。那么考虑一下，在没有使用任何框架情况下，我们使用redis作为缓存，redis中key怎么设计呢？如下表。<br><img src="/images/middleware/redis_user_data.png" alt="user"><br>我们第一个会想到使用json、xml来将user的数据序列化之后保存到redis中，但是这样的话，不便于我们做修改操作，对不对。如果我们要修改的话，需要查询出来进行反序列化，才能做修改。</p>
<p>但是如果进行 这一串操作的话，又会产生第二个问题，就是并发情况下，其他线程会读到修改之前的数据。这里多说一句，我们在实际生产中解决这一问题的方案就是对数据做修改时，直接删除缓存，然后别的线程查询时，再写入缓存。</p>
<p>那么有没有其他的设计方式来解决这一问题呢？我们把解决思路放在缓存的key上，在设计缓存key时，制定一个约定熟成的规定来存储，比如</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 约定key生成规则为</span></span><br><span class="line"><span class="keyword">user</span>::&#123;id&#125;::<span class="type">name</span>、<span class="keyword">user</span>::&#123;id&#125;::age</span><br><span class="line"><span class="comment">-- 写入缓存</span></span><br><span class="line">MSET <span class="keyword">user</span>::<span class="number">1</span>::<span class="type">name</span> ally <span class="keyword">user</span>::<span class="number">1</span>::age <span class="number">18</span></span><br><span class="line"><span class="comment">-- 读取缓存</span></span><br><span class="line">MGET <span class="keyword">user</span>:<span class="number">1</span>::<span class="type">name</span> <span class="keyword">user</span>::<span class="number">1</span>::age</span><br></pre></td></tr></table></figure>

<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>分布式锁，通常会用到SETNX、EXPIRE，SETNX用来获取锁，而EXPIRE设置锁的失效时间，防止死锁。如下</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">SETNX</span><span class="params">(<span class="string">"couponcode::123456"</span>, <span class="number">1</span>)</span></span>     <span class="comment">//return 1，成功获得锁</span></span><br><span class="line"><span class="function"><span class="title">SETNX</span><span class="params">(<span class="string">"couponcode::123456"</span>, <span class="number">1</span>)</span></span>     <span class="comment">//return 0，有人持有该锁，获取失败</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">PEXPIRE</span><span class="params">(<span class="string">"couponcode"</span>, <span class="number">1000</span>)</span></span>      <span class="comment">//设置key的失效时间，防止系统宕机，导致死锁</span></span><br></pre></td></tr></table></figure>

<p>那么这个时候其实又会有另一个问题，SETNX和PEXPIRE是分两步执行，那么可能出现SETNX成功了，在执行PEXPIRE时失败了，就会导致死锁。那么redis给我们还提供了一个原子操作。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET couponcode <span class="number">1</span> EX <span class="number">10</span> NX    <span class="comment">//EX 表示失效时间，NX表示不存在则增加</span></span><br></pre></td></tr></table></figure>
<p>以上命令看似完美的解决了分布式锁的问题，既保证了原子性，又解决了死锁的问题。但是我们还忽略了一点，假如我们设置锁的超时时间为10秒，但是我们应用系统处理需要20秒，那么在多余的10秒内将会有其他的线程获得该锁，那么怎么解决呢？<br>其实对于处理redis的续期，业界比较正确的姿势是采用redisson这个客户端工具，具体可见同性恋交友网站github。</p>
<p><img src="/images/middleware/redis_string_1.png" alt="redisson文档"><br>redisson官方文档中，有明确的提到看门狗每30秒钟会帮我们检查锁的时间，并帮助我们续期。那么这时就问题来了，那么假如锁的时间为10秒，而看门狗的检查时间为30秒，那么不就可以有多个线程同时持有锁了嘛，虽然可以通过Config.lockWatchdogTimeout来指定，但是抱着对技术敬畏的心态，我们一起来看看看门狗是怎么实现的。那么我们写一个demo，跟这源码看看</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> RedissonLock &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        RedissonClient redissonClient = <span class="module-access"><span class="module"><span class="identifier">Redisson</span>.</span></span>create<span class="literal">()</span>;</span><br><span class="line">        RLock lock = redissonClient.get<span class="constructor">Lock(<span class="string">"lock"</span>)</span>;</span><br><span class="line"></span><br><span class="line">        lock.lock<span class="literal">()</span>;  <span class="comment">// 推测，要确认续期的时间，是在加锁时触发看门狗的。所以我们从此进入到RedissonLock.lock();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> void lock(long leaseTime, TimeUnit <span class="built_in">unit</span>, boolean interruptibly) throws InterruptedException &#123;</span><br><span class="line">        long threadId = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>.get<span class="constructor">Id()</span>;</span><br><span class="line">        Long ttl = <span class="keyword">try</span><span class="constructor">Acquire(<span class="params">leaseTime</span>, <span class="params">unit</span>, <span class="params">threadId</span>)</span>;  <span class="comment">// 看名字就知道是我们要找的，尝试获得锁。</span></span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttl<span class="operator"> == </span>null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long <span class="keyword">try</span><span class="constructor">Acquire(<span class="params">long</span> <span class="params">leaseTime</span>, TimeUnit <span class="params">unit</span>, <span class="params">long</span> <span class="params">threadId</span>)</span> &#123;</span><br><span class="line">        return get(<span class="keyword">try</span><span class="constructor">AcquireAsync(<span class="params">leaseTime</span>, <span class="params">unit</span>, <span class="params">threadId</span>)</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="keyword">try</span><span class="constructor">AcquireAsync(<span class="params">long</span> <span class="params">leaseTime</span>, TimeUnit <span class="params">unit</span>, <span class="params">long</span> <span class="params">threadId</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;</span><br><span class="line">            return <span class="keyword">try</span><span class="constructor">LockInnerAsync(<span class="params">leaseTime</span>, <span class="params">unit</span>, <span class="params">threadId</span>, RedisCommands.EVAL_LONG)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//异步获得锁，返回Future对象，这里不明白的，可以补充一下多线程的知识</span></span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture = <span class="keyword">try</span><span class="constructor">LockInnerAsync(<span class="params">commandExecutor</span>.<span class="params">getConnectionManager</span>()</span>.get<span class="constructor">Cfg()</span>.get<span class="constructor">LockWatchdogTimeout()</span>, TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">		</span><br><span class="line">        ttlRemainingFuture.on<span class="constructor">Complete((<span class="params">ttlRemaining</span>, <span class="params">e</span>)</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// lock acquired</span></span><br><span class="line">            <span class="keyword">if</span> (ttlRemaining<span class="operator"> == </span>null) &#123;</span><br><span class="line">				<span class="comment">// 开启调度重新续期</span></span><br><span class="line">                schedule<span class="constructor">ExpirationRenewal(<span class="params">threadId</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return ttlRemainingFuture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新续期</span></span><br><span class="line"><span class="keyword">private</span> void renew<span class="constructor">Expiration()</span> &#123;</span><br><span class="line">        ExpirationEntry ee = <span class="module-access"><span class="module"><span class="identifier">EXPIRATION_RENEWAL_MAP</span>.</span></span>get(get<span class="constructor">EntryName()</span>);</span><br><span class="line">        <span class="keyword">if</span> (ee<span class="operator"> == </span>null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Timeout task = commandExecutor.get<span class="constructor">ConnectionManager()</span>.<span class="keyword">new</span><span class="constructor">Timeout(<span class="params">new</span> TimerTask()</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run(Timeout timeout) throws Exception &#123;</span><br><span class="line">                ExpirationEntry ent = <span class="module-access"><span class="module"><span class="identifier">EXPIRATION_RENEWAL_MAP</span>.</span></span>get(get<span class="constructor">EntryName()</span>);</span><br><span class="line">                <span class="keyword">if</span> (ent<span class="operator"> == </span>null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                Long threadId = ent.get<span class="constructor">FirstThreadId()</span>;</span><br><span class="line">                <span class="keyword">if</span> (threadId<span class="operator"> == </span>null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                RFuture&lt;Boolean&gt; future = renew<span class="constructor">ExpirationAsync(<span class="params">threadId</span>)</span>;</span><br><span class="line">                future.on<span class="constructor">Complete((<span class="params">res</span>, <span class="params">e</span>)</span> -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != null) &#123;</span><br><span class="line">                        log.error(<span class="string">"Can't update lock "</span> + get<span class="constructor">Name()</span> + <span class="string">" expiration"</span>, e);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                        <span class="comment">// reschedule itself</span></span><br><span class="line">                        renew<span class="constructor">Expiration()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, internalLockLeaseTime<span class="operator"> / </span><span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        </span><br><span class="line">        ee.set<span class="constructor">Timeout(<span class="params">task</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，一切明白了，redisson在加锁成功后，开启一个定时任务，也是所谓的看门狗。定时任务每次执行会调用renewExpirationAsync(threadId)检查锁是否释放，没有释放则对锁进行续期 renewExpiration()。而定时任务每次调度时间差为internalLockLeaseTime/3，默认锁时间为30秒，那就是10秒。<br>那么也就是说不会出现我们担心的问题，当我们锁的时间为10秒时，看门狗会在该锁还剩7秒的时候对锁进行续期。</p>
<h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>以下场景，我们要对每一个文章的阅读量进行统计<br><img src="/images/middleware/redis_incrby_1.png" alt="incr"></p>
<p>如果使用数据库要统计的话，我们将面对两个问题，并发修改和数据库压力。处理并发我们可以用cas，那么面对数据库压力我们毫无办法。这是我们可以使用redis提供的incr命令进行统计<br><img src="/images/middleware/redis_incrby_2.png" alt="incr"></p>
<h4 id="分布式全局序列"><a href="#分布式全局序列" class="headerlink" title="分布式全局序列"></a>分布式全局序列</h4><p>在你的业务系统到达一定的体量，特别是进行了分库分表后，分布式唯一键就显得尤为重要，原先的数据库自增id一定是用不了了。常规的解决办法我们多多少少有了解过，雪花算法，UUID。当然这里主要介绍redis生成全局唯一键，使用incr命令生成。<br>那么使用redis的incr就可以实现了啊，为什么还要单独拿出来说呢？其实使用incr命令会存在一个问题，那就是IO交互次数过多，想一想在分布式情况，尽管处于同一内网，还是会存在网络问题，过的IO交互就会影响效率，那么有没有解决办法呢？<br>redis官方其实有考虑到这一点，解决IO交互次数过多的办法就是，一次性获取多个唯一键，那就是incrby，他可以一其增加多个值</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrby read::<span class="number">1001</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>那么这种方案，虽然解决了IO交互次数，那么假如系统宕机了，我们就会丢失已经获取的那一段id值，所以在你的需求要求id连续的情况下，不建议采用这种方式。</p>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=/img/WeChatQR.jpg&amp;GitHub=https://github.com/farawayliu&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>far</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/05/11/middleware/redis妙用-string类型/">https://www.ofcoder.com/2019/05/11/middleware/redis%E5%A6%99%E7%94%A8-string%E7%B1%BB%E5%9E%8B/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>Copyright © 并发笔记 - ofcoder.com. Author by far.</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://www.ofcoder.com/2019/05/11/middleware/redis%E5%A6%99%E7%94%A8-string%E7%B1%BB%E5%9E%8B/" data-id="cl0saphec001jikj13cxj634x" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADLUlEQVR42u3aS2rDQBAFwNz/0s42EOK81y2DNS6tjJFHUyNw05+vr/h6/LjyO3/f/3yF5Lc/v893NbywsbGxb8J+PL1aTLJCcqDP7/y9cm7BxsbGPpX91z/8/nP+rDyAXfBcbGxs7A9mJ2Fmk2AkT0+OABsbGxs7X64tHs3KUrMDwsbGxv4cdlJUmh1NUtx/Xuh/jn95LQ0bGxv77dl5UHn/zy/pb2NjY2O/MftRXrNfbVbL057iudjY2NgHsfMAkCcAz7e4p84KWNjY2NifyW43lx9BG8zy1nKRrmBjY2MfxG6LSu04Tr7FNuzlo0Kr8hM2Njb227PzcLJvtbakPL1pXxg2Njb2SeykBJ+P0eTbykeC8mQjH/3BxsbGPo89K9nnTdy2WZtsOk91huM72NjY2DdhJ49p75kdyqypPFRgY2NjH8TOi+xtozfHt+GtTWP+SZOwsbGxb8veFPHbAlDbrM3ToXpsCBsbG/s49qzs3oaN2Zr5ARU9XGxsbOyD2LPi+yw5yQ933+4tDggbGxv75ux9Qzcvys+CU5LG1MkPNjY29kHsWTDIQ9esTZukLknb+J9UBxsbG/sIdruhPFGZfd82dIfNDGxsbOyD2AkmubMtNuWkq8pPdZMAGxsb+1bsWfKQNFZb3qaFXL9nbGxs7IPYs+HIdlxyNgDUjhDN1sfGxsa+O/uqgZtZCMy3njcSokklbGxs7IPYm2ZA2zaYpQrJmM5mwAgbGxv7DPZjdLWln00Rqm0kFxU1bGxs7NuyNwnDVaGrHRjKR3/+vAcbGxv7IHabcszSiTyFyAPbpnSFjY2NfR57z8i31ZaEilyqbBhjY2Njn8d+9RZnQzkb9j97wMbGxj6OnQeAunscN27bnXzFFzY2Nvap7Gvbuu0hboJlkg5FERsbGxv75uxV3Auavtduri1dzV4DNjY29h3ZeZDID2gfKfLyUDsYhI2NjX0qO08SZkGlbT/MAmfxSrCxsbE/mD0LM+22kiA62xU2NjY2dh5U8uA0G8RpkxxsbGzss9l54WYzfPOKtGfYPMDGxsY+iL1JEvIRn037oV3tqtQIGxsb++3Z34Suz6srLyBAAAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/redis/">redis</a><a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></div><div class="post-nav"><a class="pre" href="/2019/05/13/middleware/redis%E5%A6%99%E7%94%A8-hash%E7%B1%BB%E5%9E%8B/">redis妙用-hash类型</a><a class="next" href="/2019/05/11/middleware/redis%E5%A6%99%E7%94%A8-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/">redis妙用-应用场景</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'s8pJruGkXvi5Skd0e6EaMQ5X-gzGzoHsz',
  appKey:'K3NjnXxqhPNwUw5pmqOzoO4i',
  placeholder:'说出你的故事...',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-blind"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#api"><span class="toc-number">1.</span> <span class="toc-text">api</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#针对字符串的操作"><span class="toc-number">1.1.</span> <span class="toc-text">针对字符串的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#针对数字的操作"><span class="toc-number">1.2.</span> <span class="toc-text">针对数字的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#统一的操作"><span class="toc-number">1.3.</span> <span class="toc-text">统一的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用场景"><span class="toc-number">2.</span> <span class="toc-text">应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存"><span class="toc-number">2.1.</span> <span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分布式锁"><span class="toc-number">2.2.</span> <span class="toc-text">分布式锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#计数器"><span class="toc-number">2.3.</span> <span class="toc-text">计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分布式全局序列"><span class="toc-number">2.4.</span> <span class="toc-text">分布式全局序列</span></a></li></ol></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">并发笔记 - ofcoder.com | </a><a href="https://beian.miit.gov.cn/" rel="nofollow" target="_blank">粤ICP备18053760号</a><div>本站访客 <span id="busuanzi_value_site_uv"></span>人次 | 总访问 <span id="busuanzi_value_site_pv"></span>次<img src="https://s04.flagcounter.com/count/MnzJ/bg_FFFFFF/txt_000000/border_726EE0/columns_2/maxflags_10/viewers_0/labels_1/pageviews_1/flags_0/percent_0/" style="display: none;"/></div></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html><script type="text/javascript" src="/js/toc.js?v=0.0.0" async></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>