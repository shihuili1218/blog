<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>手写dubbo 8-SPI 自适应扩展机制 | 并发笔记 - ofcoder.com</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><!-- 顶部加载进度条 --><script type="text/javascript" src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">手写dubbo 8-SPI 自适应扩展机制</h1><a id="logo" href="/.">并发笔记 - ofcoder.com</a><p class="description">一位后端开发的养肝历程，护发经验</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/book/"><i class="fa fas fa-book"> book</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">手写dubbo 8-SPI 自适应扩展机制</h1><div class="post-meta">Oct 17, 2019<span> | </span><span class="category"><a href="/categories/%E6%BA%90%E7%A0%81%E7%8B%82%E6%83%B3/">源码狂想</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 14</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/2019/10/17/java/%E6%89%8B%E5%86%99dubbo%208-SPI%20%E8%87%AA%E9%80%82%E5%BA%94%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/#vcomment"><span class="valine-comment-count" data-xid="/2019/10/17/java/%E6%89%8B%E5%86%99dubbo%208-SPI%20%E8%87%AA%E9%80%82%E5%BA%94%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/"></span><span> 条评论</span></a><div class="post-content"><p>博客中代码地址：<a href="https://github.com/farliu/farpc.git" target="_blank" rel="noopener">https://github.com/farliu/farpc.git</a><br><img src="/images/java/dubbo/dubbo_implement_1_1.png" alt="dubbo架构"></p>
<p>本章讲解自适应扩展机制，单独将这一块拿出来，是因为这段代码逻辑复杂，处理分支较多。如果不是从上一章看过来的，建议先看看上一章讲的IOC部分。基础不牢地动山摇的情况下无法分析。</p>
<p>自适应扩展机制解决了一个什么问题呢？下面取自dubbo官方的一段话：</p>
<blockquote>
<p>有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。</p>
</blockquote>
<p>这句话意思表达还是很明显，就是在方法被调用的才去选择调用哪个扩展点。但是这时问题来了，“选择”这个动作怎么来做？谁来做？对于这个两个问题，怎么做？是自适应扩展机制的核心。而谁来做？是自适应扩展机制的解决方案。弄清楚这两点，基本差不多了。我们先看一个demo。</p>
<h3 id="自适应扩展机制示例"><a href="#自适应扩展机制示例" class="headerlink" title="自适应扩展机制示例"></a>自适应扩展机制示例</h3><p>取自dubbo的单测（dubbo-common模块）。</p>
<p>org.apache.dubbo.common.extension.ext1.SimpleExt</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment 1</span></span><br><span class="line"><span class="attr">impl1</span>=org.apache.dubbo.common.extension.ext1.impl.SimpleExtImpl1<span class="comment">#Hello World</span></span><br><span class="line"><span class="attr">impl2</span>=org.apache.dubbo.common.extension.ext1.impl.SimpleExtImpl2  <span class="comment"># Comment 2</span></span><br><span class="line"><span class="attr">impl3</span>=org.apache.dubbo.common.extension.ext1.impl.SimpleExtImpl3 <span class="comment"># with head space</span></span><br></pre></td></tr></table></figure>
<p>ExtensionLoader_Adaptive_Test</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test<span class="constructor">_getAdaptiveExtension_defaultAdaptiveKey()</span> throws Exception &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        SimpleExt ext = <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(SimpleExt.<span class="params">class</span>)</span>.get<span class="constructor">AdaptiveExtension()</span>;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;<span class="literal">()</span>;</span><br><span class="line">        URL url = <span class="keyword">new</span> <span class="constructor">URL(<span class="string">"p1"</span>, <span class="string">"1.2.3.4"</span>, 1010, <span class="string">"path1"</span>, <span class="params">map</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String echo = ext.echo(url, <span class="string">"haha"</span>);</span><br><span class="line">        <span class="keyword">assert</span><span class="constructor">Equals(<span class="string">"Ext1Impl1-echo"</span>, <span class="params">echo</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        SimpleExt ext = <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(SimpleExt.<span class="params">class</span>)</span>.get<span class="constructor">AdaptiveExtension()</span>;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;<span class="literal">()</span>;</span><br><span class="line">        map.put(<span class="string">"simple.ext"</span>, <span class="string">"impl2"</span>);</span><br><span class="line">        URL url = <span class="keyword">new</span> <span class="constructor">URL(<span class="string">"p1"</span>, <span class="string">"1.2.3.4"</span>, 1010, <span class="string">"path1"</span>, <span class="params">map</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String echo = ext.echo(url, <span class="string">"haha"</span>);</span><br><span class="line">        <span class="keyword">assert</span><span class="constructor">Equals(<span class="string">"Ext1Impl2-echo"</span>, <span class="params">echo</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test_getAdaptiveExtension_defaultAdaptiveKey中的两个代码块唯一的区别就是，第二个代码块传入的map中保存了simple.ext-&gt;impl2的键值对，就拿到了SimpleExtImpl2的对象。这也正是自适应扩展机制解决的问题。</p>
<h3 id="原理概括"><a href="#原理概括" class="headerlink" title="原理概括"></a>原理概括</h3><p>为了更好的理解，先把原理交个底。我总觉得一步步验证比一步步发掘要更能理解一件事物。至于自适应机制的原理，dubbo会给需要自适应的方法生成一个代理类，通过javassist或jdk编译这段代码，得到Class。而代理类里面的逻辑，就是根据传入的Url对象中的变量取得扩展对象并调用。</p>
<p>SimpleExt接口定义如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">SPI</span>(<span class="string">"impl1"</span>)</span><br><span class="line"><span class="keyword">public</span> interface SimpleExt &#123;</span><br><span class="line">    <span class="comment">// @Adaptive example, do not specify a explicit key.</span></span><br><span class="line">    @Adaptive</span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">echo</span><span class="params">(URL url, <span class="keyword">String</span> s)</span></span>;</span><br><span class="line"></span><br><span class="line">    @Adaptive(&#123;<span class="string">"key1"</span>, <span class="string">"key2"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">yell</span><span class="params">(URL url, <span class="keyword">String</span> s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no @Adaptive</span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">bang</span><span class="params">(URL url, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dubbo为其生成自适应代理类如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.dubbo.common.extension.ext1;</span><br><span class="line"></span><br><span class="line">import org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> SimpleExt$Adaptive implements org.apache.dubbo.common.extension.ext1.SimpleExt &#123;</span><br><span class="line">    public java.lang.String bang(org.apache.dubbo.common.URL arg0, <span class="built_in">int</span> arg1) &#123;</span><br><span class="line">        <span class="comment">// 没有标注@Adaptive，自适应调用直接抛异常</span></span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">UnsupportedOperationException(<span class="string">"The method public abstract java.lang.String org.apache.dubbo.common.extension.ext1.SimpleExt.bang(org.apache.dubbo.common.URL,int) of interface org.apache.dubbo.common.extension.ext1.SimpleExt is not adaptive method!"</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public java.lang.String yell(org.apache.dubbo.common.URL arg0, java.lang.String arg1) &#123;</span><br><span class="line">        <span class="comment">// 判断URL是否空</span></span><br><span class="line">        <span class="keyword">if</span> (arg0<span class="operator"> == </span>null) throw <span class="keyword">new</span> <span class="constructor">IllegalArgumentException(<span class="string">"url == null"</span>)</span>;</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0;</span><br><span class="line">        <span class="comment">// key1和key2，是@Adaptive中所获得的值。根据这两个key从URL中获取值，默认值为impl1，从类上的SPI注解中获取</span></span><br><span class="line">        String extName = url.get<span class="constructor">Parameter(<span class="string">"key1"</span>, <span class="params">url</span>.<span class="params">getParameter</span>(<span class="string">"key2"</span>, <span class="string">"impl1"</span>)</span>);</span><br><span class="line">        <span class="keyword">if</span> (extName<span class="operator"> == </span>null)</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.common.extension.ext1.SimpleExt) name from url ("</span> + <span class="params">url</span>.<span class="params">toString</span>()</span> + <span class="string">") use keys([key1, key2])"</span>);</span><br><span class="line">        <span class="comment">// 普通的SPI扩展对象生成</span></span><br><span class="line">        org.apache.dubbo.common.extension.ext1.SimpleExt extension = (org.apache.dubbo.common.extension.ext1.SimpleExt) <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(<span class="params">org</span>.<span class="params">apache</span>.<span class="params">dubbo</span>.<span class="params">common</span>.<span class="params">extension</span>.<span class="params">ext1</span>.SimpleExt.<span class="params">class</span>)</span>.get<span class="constructor">Extension(<span class="params">extName</span>)</span>;</span><br><span class="line">        <span class="comment">// 调用目标方法</span></span><br><span class="line">        return extension.yell(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public java.lang.String echo(org.apache.dubbo.common.URL arg0, java.lang.String arg1) &#123;</span><br><span class="line">        <span class="comment">// 判断URL是否空</span></span><br><span class="line">        <span class="keyword">if</span> (arg0<span class="operator"> == </span>null) throw <span class="keyword">new</span> <span class="constructor">IllegalArgumentException(<span class="string">"url == null"</span>)</span>;</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0;</span><br><span class="line">        <span class="comment">// 从URL中取出simple.ext的值，默认值为impl1，从类上的SPI注解中获取</span></span><br><span class="line">        String extName = url.get<span class="constructor">Parameter(<span class="string">"simple.ext"</span>, <span class="string">"impl1"</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (extName<span class="operator"> == </span>null)</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">IllegalStateException(<span class="string">"Failed to get extension (org.apache.dubbo.common.extension.ext1.SimpleExt) name from url ("</span> + <span class="params">url</span>.<span class="params">toString</span>()</span> + <span class="string">") use keys([simple.ext])"</span>);</span><br><span class="line">        <span class="comment">// 普通的SPI扩展对象生成</span></span><br><span class="line">        org.apache.dubbo.common.extension.ext1.SimpleExt extension = (org.apache.dubbo.common.extension.ext1.SimpleExt) <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(<span class="params">org</span>.<span class="params">apache</span>.<span class="params">dubbo</span>.<span class="params">common</span>.<span class="params">extension</span>.<span class="params">ext1</span>.SimpleExt.<span class="params">class</span>)</span>.get<span class="constructor">Extension(<span class="params">extName</span>)</span>;</span><br><span class="line">        <span class="comment">// 调用目标方法</span></span><br><span class="line">        return extension.echo(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是dubbo自适应扩展的原理，看到这里是不是觉得自适应扩展也就那么回事。原本看起来如此神奇的功能，原理竟然如此简单。果然早在一百年前，周树人同志就告诫我们：“悲剧,是把美好的东西撕碎了给人看。”</p>
<p>话说回来，这里还有一点值得说。串通整个过程的@Adaptive注解，用起来有讲究。这一点很多博客都直接复制官网内容，一带而过。我想说的是，该注解确实可以标注在类和方法上，标注在方法上，用于自适应扩展机制，也就是本章的重点。而标注在类上，约定这个自适应扩展机制由程序员手动实现，不用dubbo生成扩展类。这里值得注意，dubbo为了这种扩展方式在很多地方都做了兼容。比如：</p>
<ol>
<li>加载配置文件时，loadClass()中对标注了@Adaptive的类做缓存</li>
<li>createAdaptiveExtension()中为标注了@Adaptive的类再做了一次注入</li>
<li>getAdaptiveExtensionClass()在执行loadClass()还不存在已缓存的自适应扩展，也就是不存在标注了@Adaptive的类，才会创建。</li>
</ol>
<p>还有需要注意一点，可以看到，上述所说的原理完全依赖于入参中是否存在URL，那么当入参中不存在URL对象，dubbo会怎么处理呢？直接抛异常？还是有妥善处理方式？</p>
<h3 id="源码验证"><a href="#源码验证" class="headerlink" title="源码验证"></a>源码验证</h3><p>我们以getAdaptiveExtension()为入口，该方法中常规的DCL校验缓存，然后调用createAdaptiveExtension()方法。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T create<span class="constructor">AdaptiveExtension()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        get<span class="constructor">ExtensionClasses()</span>;</span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass != null) &#123;</span><br><span class="line">            return cachedAdaptiveClass;</span><br><span class="line">        &#125;</span><br><span class="line">        cachedAdaptiveClass = create<span class="constructor">AdaptiveExtensionClass()</span>;</span><br><span class="line">        return inject<span class="constructor">Extension((T)</span> cachedAdaptiveClass.<span class="keyword">new</span><span class="constructor">Instance()</span>);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">IllegalStateException(<span class="string">"Can't create adaptive extension "</span> + <span class="params">type</span> + <span class="string">", cause: "</span> + <span class="params">e</span>.<span class="params">getMessage</span>()</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createAdaptiveExtension()是整个自适应扩展机制的全景。主要包含了三个逻辑：</p>
<ol>
<li>调用getExtensionClasses()获取所有扩展实现类</li>
<li>createAdaptiveExtensionClass()自动生成自适应实现类</li>
<li>injectExtension()为标注@Adaptive的类再做了一次注入</li>
</ol>
<h4 id="加载自适应代理类"><a href="#加载自适应代理类" class="headerlink" title="加载自适应代理类"></a>加载自适应代理类</h4><p>getExtensionClasses()在上一章详细讲了，该方法用来加载配置文件中所有的扩展实现类。而需要再次提一下的是，在它调用的loadClass()中，对标注@Adaptive的类进行单独缓存，如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">void</span> loadClass(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, <span class="built_in">String</span> name) throws NoSuchMethodException &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 检测类是否标注Adaptive注解，使用一个变量保存起来</span></span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cachedAdaptiveClass = clazz;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"More than 1 adaptive class found: "</span></span><br><span class="line">                    + cachedAdaptiveClass.getName()</span><br><span class="line">                    + <span class="string">", "</span> + clazz.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getExtensionClasses()在读取配置文件后，一个个加载其中的实现类，会检查该类是否标注@Adaptive，如果标注了则会将其保存在cachedAdaptiveClass变量中。这里也就是加载程序员人工编写自适应扩展类，这里有一个要求，一个接口只允许存在一个自适应扩展类。否则，抛异常。</p>
<h4 id="自动生成自适应实现类"><a href="#自动生成自适应实现类" class="headerlink" title="自动生成自适应实现类"></a>自动生成自适应实现类</h4><p>经过上述加载后，如果不存在人工编写的自适应扩展类，也还没自己创建自适应扩展类，那么开始由dubbo生成。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; create<span class="constructor">AdaptiveExtensionClass()</span> &#123;</span><br><span class="line">    <span class="comment">// 生成自适应扩展类的代码</span></span><br><span class="line">    String code = <span class="keyword">new</span> <span class="constructor">AdaptiveClassCodeGenerator(<span class="params">type</span>, <span class="params">cachedDefaultName</span>)</span>.generate<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">// 这里就想尽办法获得一个非空的ClassLoader</span></span><br><span class="line">    ClassLoader classLoader = find<span class="constructor">ClassLoader()</span>;</span><br><span class="line">    <span class="comment">// 获取Compiler对象，默认使用javassist</span></span><br><span class="line">    org.apache.dubbo.common.compiler.Compiler compiler = <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(<span class="params">org</span>.<span class="params">apache</span>.<span class="params">dubbo</span>.<span class="params">common</span>.<span class="params">compiler</span>.Compiler.<span class="params">class</span>)</span>.get<span class="constructor">AdaptiveExtension()</span>;</span><br><span class="line">    <span class="comment">// 编译，生成class</span></span><br><span class="line">    return compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createAdaptiveExtensionClass()总得来说就是完成两件事，一是生成自适应扩展类的代码，二是编译，生成class。于第二点，不做详细解释，我们主要查看代码生成规则。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public String generate<span class="literal">()</span> &#123;</span><br><span class="line">    <span class="comment">// 校验是否存在有@Adaptive修改的方法，没有则抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (!has<span class="constructor">AdaptiveMethod()</span>) &#123;</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">IllegalStateException(<span class="string">"No adaptive method exist on extension "</span> + <span class="params">type</span>.<span class="params">getName</span>()</span> + <span class="string">", refuse to create the adaptive class!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StringBuilder code = <span class="keyword">new</span> <span class="constructor">StringBuilder()</span>;</span><br><span class="line">	<span class="comment">// 生成包，如：package org.apache.dubbo.common.extension.ext1;</span></span><br><span class="line">    code.append(generate<span class="constructor">PackageInfo()</span>);</span><br><span class="line">    <span class="comment">// 生成import，如：import com.alibaba.dubbo.common.extension.ExtensionLoader;</span></span><br><span class="line">    code.append(generate<span class="constructor">Imports()</span>);</span><br><span class="line">    <span class="comment">// 生成类定义，如：public class SimpleExt$Adaptive implements org.apache.dubbo.common.extension.ext1.SimpleExt &#123;</span></span><br><span class="line">    code.append(generate<span class="constructor">ClassDeclaration()</span>);</span><br><span class="line"></span><br><span class="line">    Method<span class="literal">[]</span> methods = <span class="keyword">type</span>.get<span class="constructor">Methods()</span>;</span><br><span class="line">    for (Method <span class="keyword">method</span> : methods) &#123;</span><br><span class="line">        code.append(generate<span class="constructor">Method(<span class="params">method</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    code.append(<span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.is<span class="constructor">DebugEnabled()</span>) &#123;</span><br><span class="line">        logger.debug(code.<span class="keyword">to</span><span class="constructor">String()</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return code.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>generate()中生成包、import、类定义，这三块代码实现都是通过String.format()，逻辑简单，这里一笔带过。generateMethod()逻辑分为生成方法主体、生成方法参数、生成方法定义异常，然后拼接在一起。而生成方法主体的逻辑分支较多，我先捋出一条思路，再一点点看。</p>
<ol>
<li>分别处理是否有@Adaptive修饰的方法</li>
<li>定位URL对象的值</li>
<li>获取该接口自适应路由的key，用户获取URL中实现类的名字，并非空判断</li>
<li>通过实现类的名字，调用普通的SPI，生成扩展对象</li>
<li>调用目标方法</li>
</ol>
<h5 id="检测-Adaptive修饰"><a href="#检测-Adaptive修饰" class="headerlink" title="检测@Adaptive修饰"></a>检测@Adaptive修饰</h5><p>对于没有Adaptive修饰的方法，以SimpleExt.bang()方法为例。dubbo则不会为该方法生成具体逻辑，而是直接抛出异常，生成逻辑如下：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> String CODE_UNSUPPORTED = <span class="string">"throw new UnsupportedOperationException(\"The method %s of interface %s is not adaptive method!\");\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String generateMethodContent(<span class="function"><span class="keyword">Method</span> <span class="title">method</span>) &#123;</span></span><br><span class="line">    Adaptive adaptiveAnnotation = <span class="function"><span class="keyword">method</span>.<span class="title">getAnnotation</span>(</span>Adaptive<span class="class">.<span class="keyword">class</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(CODE_UNSUPPORTED, <span class="function"><span class="keyword">method</span>, <span class="title">type</span>.<span class="title">getName</span>(</span>));</span><br><span class="line">    &#125; </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="定位URL对象的值"><a href="#定位URL对象的值" class="headerlink" title="定位URL对象的值"></a>定位URL对象的值</h5><p>上文说到，自适应扩展机制，完全依赖URL对象，当不存在URL对象时，无法实现自适应扩展。而不是所有方法都需要URL做为入参的，那么dubbo是怎么处理的呢？</p>
<ol>
<li>对于入参中存在URL对象，获取方式就是直接遍历获得。</li>
<li>对不入参不存在URL对象的方法，dubbo会遍历入参，通过反射调用入参中是否存在以get开头、返回值为URL的方法，并调用。</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static final String CODE_URL_NULL_CHECK = <span class="string">"if (arg%d == null) throw new IllegalArgumentException(\"url == null\");\n%s url = arg%d;\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String generate<span class="constructor">MethodContent(Method <span class="params">method</span>)</span> &#123;</span><br><span class="line">    Adaptive adaptiveAnnotation = <span class="keyword">method</span>.get<span class="constructor">Annotation(Adaptive.<span class="params">class</span>)</span>;</span><br><span class="line">    StringBuilder code = <span class="keyword">new</span> <span class="constructor">StringBuilder(512)</span>;</span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation<span class="operator"> == </span>null) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取URL对象在入参的位置</span></span><br><span class="line">        <span class="built_in">int</span> urlTypeIndex = get<span class="constructor">UrlTypeIndex(<span class="params">method</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (urlTypeIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 存在URL对象，生成代码：判断该对象是否为空并赋值。如：if (arg0 == null) throw new IllegalArgumentException("url == null");org.apache.dubbo.common.URL url = arg0;</span></span><br><span class="line">            code.append(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(CODE_URL_NULL_CHECK, urlTypeIndex, <span class="module-access"><span class="module"><span class="identifier">URL</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">Name()</span>, index));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             Class&lt;?&gt;<span class="literal">[]</span> pts = <span class="keyword">method</span>.get<span class="constructor">ParameterTypes()</span>;</span><br><span class="line">	        <span class="comment">// 遍历所有入参</span></span><br><span class="line">	        for (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; pts.length; ++i) &#123;</span><br><span class="line">                <span class="comment">// 遍历每一个入参中的所有方法</span></span><br><span class="line">	            for (Method m : pts<span class="literal">[<span class="identifier">i</span>]</span>.get<span class="constructor">Methods()</span>) &#123;</span><br><span class="line">	                String name = m.get<span class="constructor">Name()</span>;</span><br><span class="line">	                <span class="keyword">if</span> ((name.starts<span class="constructor">With(<span class="string">"get"</span>)</span><span class="operator"> || </span>name.length<span class="literal">()</span> &gt; <span class="number">3</span>)</span><br><span class="line">                            <span class="comment">// 是否为public方法</span></span><br><span class="line"><span class="operator">	                        &amp;&amp; </span><span class="module-access"><span class="module"><span class="identifier">Modifier</span>.</span></span>is<span class="constructor">Public(<span class="params">m</span>.<span class="params">getModifiers</span>()</span>)</span><br><span class="line">                            <span class="comment">// 不是static方法</span></span><br><span class="line"><span class="operator">	                        &amp;&amp; </span>!<span class="module-access"><span class="module"><span class="identifier">Modifier</span>.</span></span>is<span class="constructor">Static(<span class="params">m</span>.<span class="params">getModifiers</span>()</span>)</span><br><span class="line">                            <span class="comment">// 没有入参</span></span><br><span class="line"><span class="operator">	                        &amp;&amp; </span>m.get<span class="constructor">ParameterTypes()</span>.length<span class="operator"> == </span><span class="number">0</span></span><br><span class="line">                            <span class="comment">// 返回值是URL</span></span><br><span class="line"><span class="operator">	                        &amp;&amp; </span>m.get<span class="constructor">ReturnType()</span><span class="operator"> == </span><span class="module-access"><span class="module"><span class="identifier">URL</span>.</span></span><span class="keyword">class</span>) &#123;</span><br><span class="line">                        <span class="comment">// 生成代码：判断该入参是否为空、判断入参调用get方法返回值是否为空并赋值。</span></span><br><span class="line">	                    return generate<span class="constructor">GetUrlNullCheck(<span class="params">i</span>, <span class="params">pts</span>[<span class="params">i</span>], <span class="params">name</span>)</span>;</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        <span class="comment">// getter method not found, throw</span></span><br><span class="line">	        throw <span class="keyword">new</span> <span class="constructor">IllegalStateException(<span class="string">"Failed to create adaptive class for interface "</span> + <span class="params">type</span>.<span class="params">getName</span>()</span></span><br><span class="line">                        + <span class="string">": not found url parameter or url attribute in parameters of method "</span> + <span class="keyword">method</span>.get<span class="constructor">Name()</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="获取URL中实现类的名字"><a href="#获取URL中实现类的名字" class="headerlink" title="获取URL中实现类的名字"></a>获取URL中实现类的名字</h5><p>获取实现类的名字，需要先获取URL对象中key。获取这个key，dubbo会先从Adaptive注解中取得，倘若注解中没有设置该值，则根据类名生成一个简单的名字当做key。比如SimpleExt，处理后会生成simple.ext当做key。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String generate<span class="constructor">MethodContent(Method <span class="params">method</span>)</span> &#123;</span><br><span class="line">    Adaptive adaptiveAnnotation = <span class="keyword">method</span>.get<span class="constructor">Annotation(Adaptive.<span class="params">class</span>)</span>;</span><br><span class="line">    StringBuilder code = <span class="keyword">new</span> <span class="constructor">StringBuilder(512)</span>;</span><br><span class="line">    <span class="keyword">if</span> (adaptiveAnnotation<span class="operator"> == </span>null) &#123;</span><br><span class="line">...      </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">        String<span class="literal">[]</span> value = adaptiveAnnotation.value<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span> (value.length<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 注解中没有指定key。</span></span><br><span class="line">            String splitName = <span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span>camel<span class="constructor">ToSplitName(<span class="params">type</span>.<span class="params">getSimpleName</span>()</span>, <span class="string">"."</span>);</span><br><span class="line">            value = <span class="keyword">new</span> String<span class="literal">[]</span>&#123;splitName&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，是由上述生成key值，调用generateExtNameAssignment()从URL取得扩展名字。这段代码根据各类情况，分别处理，if判断很长，需要慢慢捋清楚。最终会生成一下代码</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> extName = (<span class="built_in">url</span>.getProtocol() == <span class="literal">null</span> ? <span class="string">"impl1"</span> : <span class="built_in">url</span>.getProtocol());</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line"><span class="built_in">String</span> extName = <span class="built_in">url</span>.getMethodParameter(methodName, <span class="string">"loadbalance"</span>, <span class="string">"random"</span>);</span><br><span class="line"></span><br><span class="line">或者：</span><br><span class="line"><span class="built_in">String</span> extName = <span class="built_in">url</span>.getParameter(<span class="string">"key1"</span>, <span class="built_in">url</span>.getParameter(<span class="string">"key2"</span>, <span class="string">"impl1"</span>));</span><br></pre></td></tr></table></figure>
<h5 id="生成扩展对象、调用目标方法"><a href="#生成扩展对象、调用目标方法" class="headerlink" title="生成扩展对象、调用目标方法"></a>生成扩展对象、调用目标方法</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static final String CODE_EXTENSION_ASSIGNMENT = <span class="string">"%s extension = (%&lt;s)%s.getExtensionLoader(%s.class).getExtension(extName);\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String generate<span class="constructor">MethodContent(Method <span class="params">method</span>)</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 生成调用SPI生成扩展对象的代码</span></span><br><span class="line">        code.append(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(CODE_EXTENSION_ASSIGNMENT, <span class="keyword">type</span>.get<span class="constructor">Name()</span>, <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">SimpleName()</span>, <span class="keyword">type</span>.get<span class="constructor">Name()</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用目标方法，并返回值</span></span><br><span class="line">        code.append(generate<span class="constructor">ReturnAndInvocation(<span class="params">method</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return code.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String generate<span class="constructor">ReturnAndInvocation(Method <span class="params">method</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否void返回类型的方法</span></span><br><span class="line">    String returnStatement = <span class="keyword">method</span>.get<span class="constructor">ReturnType()</span>.equals(void.<span class="keyword">class</span>) ? <span class="string">""</span> : <span class="string">"return "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接入参</span></span><br><span class="line">    String args = <span class="module-access"><span class="module"><span class="identifier">IntStream</span>.</span></span>range(<span class="number">0</span>, <span class="keyword">method</span>.get<span class="constructor">Parameters()</span>.length)</span><br><span class="line">            .map<span class="constructor">ToObj(<span class="params">i</span> -&gt; String.<span class="params">format</span>(CODE_EXTENSION_METHOD_INVOKE_ARGUMENT, <span class="params">i</span>)</span>)</span><br><span class="line">            .collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span>joining(<span class="string">", "</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用目标方法</span></span><br><span class="line">    return returnStatement + <span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">"extension.%s(%s);\n"</span>, <span class="keyword">method</span>.get<span class="constructor">Name()</span>, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，生成代理类代码的逻辑都在上述过程中，后续就是dubbo调用Compiler生成class，然后使用了。SPI到本文，源码讲解就结束了，后面就是我们自己手动实现SPI了。</p>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=/img/WeChatQR.jpg&amp;GitHub=https://github.com/farawayliu&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>far</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/10/17/java/手写dubbo 8-SPI 自适应扩展机制/">https://www.ofcoder.com/2019/10/17/java/%E6%89%8B%E5%86%99dubbo%208-SPI%20%E8%87%AA%E9%80%82%E5%BA%94%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>Copyright © 并发笔记 - ofcoder.com. Author by far.</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://www.ofcoder.com/2019/10/17/java/%E6%89%8B%E5%86%99dubbo%208-SPI%20%E8%87%AA%E9%80%82%E5%BA%94%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/" data-id="cl0saphe50015ikj18s31061r" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASYAAAEmCAAAAADqr2IGAAAEhElEQVR42u3a0W4jIQwF0Pz/T3dfW20mubaJNJCTp1XaMsNhJbg2j0f8+fn1+f3N65/+//3V31791dU4r8fM33zxBxMmTJgw3ZIpf638ka8Rk6lWKavzzeeOCRMmTJjOYEqGy7fYyUZeHTl/ejL+5feYMGHChOlrmJJ4mR8FevG4umDVGIwJEyZMmL6ZKSGrovQWIN/+J9EdEyZMmDCdwZQP1+NLWozJ9zlKHsUX18IxYcKECdPNmHotwDP+/ZH7TZgwYcKE6TZMP8VPtXi6asPuLWr1YHE5a0yYMGHCtC1T/ipVxF5bNC8c95Yqj7WYMGHChOkMpry82/s+aT3mh4Zky08WOG/BYsKECROmM5gmG/CqqzavR86XpNqmja4WYcKECROm45h6Bdm1QTq/PJQfNXqLhAkTJkyY9mWatAOrE56UYqsHl3wur9ExYcKECdN5TJNJ9qLpJLLm0boay99gYcKECROmDZmqHMkDek3HteXa6nJGRwFMmDBhwrQVU3Wq1QjaKwf3Sro5TXRlBxMmTJgwbc6UR9NeXOwR56PNFzJp2WLChAkTpt2Z8lLp5BXz8FzdvPOtPX/6n59iwoQJE6bNmfKImP90EkrL0xiUraNDDCZMmDBhOoIpQZmE0kkpORm518iMDi6YMGHChOlQpur1mjz6rioT936z+m6YMGHChGlfpurW3rtG07tA04vceXG52ljFhAkTJkz7MuXXRquXe+ZHijzirnq36PcxYcKECdMmTNVCbR5Te2XfeTzuNVPf/EfBhAkTJkxHM/UaitUDRzVaJ2G1+u/CSQETJkyYMG3CtKrAmkwvKacmJeYebvVZT/4WEyZMmDAdx9Qr1H6i8Do/fCwoQGPChAkTpm2Z8k26WhTOr+zkRdjPFZejp2PChAkTps2Zkhicv25ePs6PEXk4/8QBBRMmTJgw7cj0iSn1RsgXqXoQ6UXryyIvJkyYMGHaiimPiNWNdjKx6lWbSRm3UD7GhAkTJkwbMlW3zLVXc/K/qhaXc9aoyIsJEyZMmLZl6hV5q03ESTCeBN15nMaECRMmTGcwVe9k9pqLyZh5GJ5E4klpGBMmTJgw7cI02ZirYbV6B6Z6jOiNHLFiwoQJE6YjmKoNzl6pd1IC7oXwSVDHhAkTJkxnMPUagb0tubpIkyLvqkXFhAkTJkxnMOXRNCkKT7b8ahTP25n5YeJJkRcTJkyYMG3LlExjXrpdNflVxd/CEmLChAkTpiOYJnd/VnGXG43xmJN3xoQJEyZM+zIlQL3LMdUxq2/VW8L8WZgwYcKE6QymyePnbc455aT5ml8SwoQJEyZM+zJVt8lk0Elgrl7ZqQb4fMEevQ8mTJgwYbolUzKx/LLLpIBbfe6q98eECRMmTN/A1AuWvVg7L7zmB45qdH9T6sWECRMmTF/AtOoqTHVieWSdNzgxYcKECdM3M/UOBPmzqqXeHCIvBz8ZGRMmTJgwbc6UFEnzyJq8ehJZ5wuWHx3ezBQTJkyYMG3LtHbaScNygpVf36m2YEc3mzBhwoQJ0x2Z/gEf50T1Kq8VRAAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/%E5%B9%B2%E8%B4%A7/">干货</a><a href="/tags/dubbo/">dubbo</a><a href="/tags/%E6%BA%90%E7%A0%81/">源码</a><a href="/tags/SPI/">SPI</a></div><div class="post-nav"><a class="pre" href="/2019/10/20/java/%E6%89%8B%E5%86%99dubbo%209-SPI%E5%AE%9E%E7%8E%B0/">手写dubbo 9-SPI实现</a><a class="next" href="/2019/10/14/java/%E6%89%8B%E5%86%99dubbo%207-SPI(dubbo%E5%92%8Cjdk%E7%9A%84%E5%8C%BA%E5%88%AB)/">手写dubbo 7-SPI(dubbo和jdk的区别)</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'s8pJruGkXvi5Skd0e6EaMQ5X-gzGzoHsz',
  appKey:'K3NjnXxqhPNwUw5pmqOzoO4i',
  placeholder:'说出你的故事...',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-blind"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#自适应扩展机制示例"><span class="toc-number">1.</span> <span class="toc-text">自适应扩展机制示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理概括"><span class="toc-number">2.</span> <span class="toc-text">原理概括</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码验证"><span class="toc-number">3.</span> <span class="toc-text">源码验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#加载自适应代理类"><span class="toc-number">3.1.</span> <span class="toc-text">加载自适应代理类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自动生成自适应实现类"><span class="toc-number">3.2.</span> <span class="toc-text">自动生成自适应实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#检测-Adaptive修饰"><span class="toc-number">3.2.1.</span> <span class="toc-text">检测@Adaptive修饰</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#定位URL对象的值"><span class="toc-number">3.2.2.</span> <span class="toc-text">定位URL对象的值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#获取URL中实现类的名字"><span class="toc-number">3.2.3.</span> <span class="toc-text">获取URL中实现类的名字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#生成扩展对象、调用目标方法"><span class="toc-number">3.2.4.</span> <span class="toc-text">生成扩展对象、调用目标方法</span></a></li></ol></li></ol></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">并发笔记 - ofcoder.com | </a><a href="https://beian.miit.gov.cn/" rel="nofollow" target="_blank">粤ICP备18053760号</a><div>本站访客 <span id="busuanzi_value_site_uv"></span>人次 | 总访问 <span id="busuanzi_value_site_pv"></span>次<img src="https://s04.flagcounter.com/count/MnzJ/bg_FFFFFF/txt_000000/border_726EE0/columns_2/maxflags_10/viewers_0/labels_1/pageviews_1/flags_0/percent_0/" style="display: none;"/></div></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html><script type="text/javascript" src="/js/toc.js?v=0.0.0" async></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>