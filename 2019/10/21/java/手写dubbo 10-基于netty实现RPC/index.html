<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>手写dubbo 10-基于netty实现RPC | 并发笔记 - ofcoder.com</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><!-- 顶部加载进度条 --><script type="text/javascript" src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">手写dubbo 10-基于netty实现RPC</h1><a id="logo" href="/.">并发笔记 - ofcoder.com</a><p class="description">一位后端开发的养肝历程，护发经验</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a><a href="/book/"><i class="fa fas fa-book"> book</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">手写dubbo 10-基于netty实现RPC</h1><div class="post-meta">Oct 21, 2019<span> | </span><span class="category"><a href="/categories/%E6%BA%90%E7%A0%81%E7%8B%82%E6%83%B3/">源码狂想</a></span><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4.2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 19</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" href="/2019/10/21/java/%E6%89%8B%E5%86%99dubbo%2010-%E5%9F%BA%E4%BA%8Enetty%E5%AE%9E%E7%8E%B0RPC/#vcomment"><span class="valine-comment-count" data-xid="/2019/10/21/java/%E6%89%8B%E5%86%99dubbo%2010-%E5%9F%BA%E4%BA%8Enetty%E5%AE%9E%E7%8E%B0RPC/"></span><span> 条评论</span></a><div class="post-content"><p>博客中代码地址：<a href="https://github.com/farliu/farpc.git" target="_blank" rel="noopener">https://github.com/farliu/farpc.git</a><br><img src="/images/java/dubbo/dubbo_implement_1_1.png" alt="dubbo架构"></p>
<p>本文实现的是远程调用，也就是图片中的第4步，dubbo作为一款RPC框架，这是它的核心功能，dubbo提供了很多种方式，如下图：<br><img src="/images/java/dubbo/dubbo_implement_6_1.png" alt="dubbo module"></p>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>首先科普一下RPC三个字母，即Remote Procedure Call。简单来说就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。</p>
<p>回想一下，java本地方法调用。假如在电脑ComputerA上有一个类ClassA，其中有methodA()方法，我们调用的话，就是new一个ClassA的对象classA，然后classA.methodA()来调用。这其中值得深思，凭什么我们能new一个ClassA的对象？我们能不能new一个ComputerB机器上的类ClassB的对象呢？</p>
<p>第二个答案肯定都知道，肯定是不行。第一个问题，我们为什么能在ComputerA上new一个ClassA的对象，是因为在ComputerA上存在ClassA类的class文件，通过JVM加载后，我们可以实现对它的调用。所以为了解决第二个问题，前辈们还真想出了办法。你不是只要class文件就行了嘛，那就给你，ComputerA打个jar包给ComputerB去加载。也就达到了调用的效果。</p>
<p>以上其实就是解决两个应用之间交互的​早期办法。但是当系统依赖复杂后，这种方式极为不妥，每一个系统都得加载子系统的所有class，非常不合适。以及还有敏感代码允许泄露等问题。</p>
<p>为了解决这个问题，我们也就出现RPC服务，就是当ComputerA要调用ComputerB的方法时，ComputerA通过某种方式告诉ComputerB，再由ComputerB执行完之后，将结果告诉ComputerA。这就是RPC最初的设想。我们归纳一下几个步骤</p>
<ol>
<li>ComputerA将自己的需要调用的方法和参数准备封装好。</li>
<li>按照约定的方式，将封装好的参数传给ComputerB</li>
<li>ComputerB收到约定的数据后，解析获得ComputerA需要调用的方法和参数。</li>
<li>ComputerB按照ComputerA给的数据，执行对应的方法。</li>
<li>ComputerB将执行结果按照约定返回ComputerA。</li>
</ol>
<p>可以看到这个过程，极为重要的就是数据传输，为了实现数据传输，我们搞出了很多花样。比较通常的就是，将参数转成xml，通过Http传送给另一台机器，后来发现xml体积太大，我们又将json代替了xml。再后来我们又觉得每次用http协议，都得重新连接，又使用socket实现长连接。再后来觉得socket实现阻塞IO，效率不高，又推送了NIO，以及selector、channel这些专业术语。这都是在优化传输过程，本章采用netty来实现传输。</p>
<p>对于ComputerB执行相应的方法，基于以上的约定，ComputerB拿到所需的参数后，使用java反射就能调用具体的方法了。</p>
<h3 id="项目结构介绍"><a href="#项目结构介绍" class="headerlink" title="项目结构介绍"></a>项目结构介绍</h3><p><img src="/images/java/dubbo/dubbo_implement_2_1.png" alt="项目结构"><br>本节涉及博客中代码的module，farpc-rpc（远程调用）、farpc-demo。</p>
<h3 id="初始化netty"><a href="#初始化netty" class="headerlink" title="初始化netty"></a>初始化netty</h3><p>本章使用netty实现rpc，自然要导入jar包。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.36.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>秉承可扩展设计，提供两个接口。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FarSPI</span>(<span class="string">"netty"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> IProviderServer &#123;</span><br><span class="line">    <span class="built_in">void</span> start(<span class="built_in">String</span> selfAddress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FarSPI</span>(<span class="string">"netty"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> IConsumerServer &#123;</span><br><span class="line">    <span class="built_in">Object</span> execute(<span class="built_in">String</span> address, RequestDTO requestDTO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端就是常规的netty代码，启动服务，然后配置Handler，处理接收的信息。值得一提的是，在服务端启动的时候，我会去扫描所有标注了Provider注解的类，然后将其注入到注册中心，并为一个container保存对应的对象，用于反射执行指定方法。</p>
<p>Provider模拟dubbo中的@Service注解，用于注册服务。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Provider &#123;</span><br><span class="line">    Class interfaceClazz();</span><br><span class="line"></span><br><span class="line">    String name() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Container扫描被Provider修饰的类，然后反射生成对象，将其保存到本地容器供反射执行指定的方法、保存到注册中心供消费端发现服务。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final Logger logger = LoggerFactory.getLogger(Container.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IRegistrar registrar = RegistrarFactory.getRegistrar();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;<span class="keyword">String</span>, Object&gt; providers = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;<span class="keyword">String</span>, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Reflections reflections = <span class="keyword">new</span> <span class="type">Reflections</span>(<span class="keyword">new</span> <span class="type">ConfigurationBuilder</span>()</span><br><span class="line">                .setUrls(ClasspathHelper.forPackage(<span class="string">"com.ofcoder"</span>))</span><br><span class="line">                .setScanners(<span class="keyword">new</span> <span class="type">TypeAnnotationsScanner</span>()));</span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; classes = reflections.getTypesAnnotatedWith(Provider.class, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; clazz : <span class="type">classes</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Provider annotation = clazz.getAnnotation(Provider.class);</span><br><span class="line">                Object provider = clazz.<span class="keyword">new</span><span class="type">Instance</span>();</span><br><span class="line">                <span class="keyword">String</span> canonicalName = annotation.interfaceClazz().getCanonicalName();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 保存到本地容器</span></span><br><span class="line">                providers.put(canonicalName, provider);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void registerSelf(<span class="keyword">String</span> selfAddress)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> service : <span class="type">providers</span>.keySet()) &#123;</span><br><span class="line">            registrar.register(selfAddress, service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;<span class="keyword">String</span>, Object&gt; getProviders() &#123;</span><br><span class="line">        <span class="keyword">return</span> providers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NettyProviderHandler用来处理收到的信息，然后根据收到的数据，从本地容器中取得对象，调用指定的方法，并将执行结果返回给消费端。代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> NettyProviderHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    <span class="keyword">private</span> static final Logger logger = <span class="module-access"><span class="module"><span class="identifier">LoggerFactory</span>.</span></span>get<span class="constructor">Logger(NettyProviderHandler.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channel<span class="constructor">Read(ChannelHandlerContext <span class="params">ctx</span>, Object <span class="params">msg</span>)</span> throws Exception &#123;</span><br><span class="line">        super.channel<span class="constructor">Read(<span class="params">ctx</span>, <span class="params">msg</span>)</span>;</span><br><span class="line">        RequestDTO requestDTO = (RequestDTO) msg;</span><br><span class="line">        Object result = <span class="keyword">new</span> <span class="constructor">Object()</span>;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"receive request.. &#123;&#125;"</span>, requestDTO);</span><br><span class="line">        <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Container</span>.</span></span>get<span class="constructor">Providers()</span>.contains<span class="constructor">Key(<span class="params">requestDTO</span>.<span class="params">getClassName</span>()</span>)) &#123;</span><br><span class="line">            Object provider = <span class="module-access"><span class="module"><span class="identifier">Container</span>.</span></span>get<span class="constructor">Providers()</span>.get(requestDTO.get<span class="constructor">ClassName()</span>);</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; providerClazz = provider.get<span class="constructor">Class()</span>;</span><br><span class="line">            Method <span class="keyword">method</span> = providerClazz.get<span class="constructor">Method(<span class="params">requestDTO</span>.<span class="params">getMethodName</span>()</span>, requestDTO.get<span class="constructor">Types()</span>);</span><br><span class="line">            <span class="comment">// 反射执行指定的方法</span></span><br><span class="line">            result = <span class="keyword">method</span>.invoke(provider, requestDTO.get<span class="constructor">Params()</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将结果输出到消费端</span></span><br><span class="line">        ctx.write(result);</span><br><span class="line">        ctx.flush<span class="literal">()</span>;</span><br><span class="line">        ctx.close<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NettyProviderServer就是监听指定的端口，启动服务。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> NettyProviderServer implements IProviderServer &#123;</span><br><span class="line">    <span class="keyword">private</span> static final Logger logger = <span class="module-access"><span class="module"><span class="identifier">LoggerFactory</span>.</span></span>get<span class="constructor">Logger(NettyProviderServer.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    public void start(String selfAddress) &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Container</span>.</span></span>register<span class="constructor">Self(<span class="params">selfAddress</span>)</span>;</span><br><span class="line"></span><br><span class="line">        String<span class="literal">[]</span> addrs = selfAddress.split(<span class="string">":"</span>);</span><br><span class="line">        String ip = addrs<span class="literal">[<span class="number">0</span>]</span>;</span><br><span class="line">        Integer port = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">addrs</span>[1])</span>;</span><br><span class="line"></span><br><span class="line">        publisher(ip, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void publisher(String ip, Integer port) &#123;</span><br><span class="line">        <span class="comment">// 启动服务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            EventLoopGroup bossGroup = <span class="keyword">new</span> <span class="constructor">NioEventLoopGroup()</span>;</span><br><span class="line">            EventLoopGroup workerGroup = <span class="keyword">new</span> <span class="constructor">NioEventLoopGroup()</span>;</span><br><span class="line"></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> <span class="constructor">ServerBootstrap()</span>;</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(<span class="module-access"><span class="module"><span class="identifier">NioServerSocketChannel</span>.</span></span><span class="keyword">class</span>)</span><br><span class="line">                    .child<span class="constructor">Handler(<span class="params">new</span> ChannelInitializer&lt;Channel&gt;()</span> &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        protected void init<span class="constructor">Channel(Channel <span class="params">channel</span>)</span> throws Exception &#123;</span><br><span class="line">                            ChannelPipeline pipeline = channel.pipeline<span class="literal">()</span>;</span><br><span class="line">                            pipeline.add<span class="constructor">Last(<span class="params">new</span> ObjectEncoder()</span>);</span><br><span class="line">                            pipeline.add<span class="constructor">Last(<span class="params">new</span> ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.<span class="params">cacheDisabled</span>(NettyProviderServer.<span class="params">class</span>.<span class="params">getClassLoader</span>()</span>)));</span><br><span class="line">                            pipeline.add<span class="constructor">Last(<span class="params">new</span> NettyProviderHandler()</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).option(ChannelOption.SO_BACKLOG, <span class="number">128</span>).child<span class="constructor">Option(ChannelOption.SO_KEEPALIVE, <span class="params">true</span>)</span>;</span><br><span class="line"></span><br><span class="line">            ChannelFuture future = bootstrap.bind(ip, port).sync<span class="literal">()</span>;</span><br><span class="line">            logger.info(<span class="string">"netty server is started..."</span>);</span><br><span class="line">            future.channel<span class="literal">()</span>.close<span class="constructor">Future()</span>.sync<span class="literal">()</span>;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><p>NettyConsumerServer用于发送请求，将封装好的参数发给服务提供者。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> NettyConsumerServer implements IConsumerServer &#123;</span><br><span class="line">    <span class="keyword">private</span> static final Logger logger = <span class="module-access"><span class="module"><span class="identifier">LoggerFactory</span>.</span></span>get<span class="constructor">Logger(NettyConsumerServer.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    public Object execute(String serivceAddress, RequestDTO requestDTO) &#123;</span><br><span class="line">        String<span class="literal">[]</span> addrs = serivceAddress.split(<span class="string">":"</span>);</span><br><span class="line">        String host = addrs<span class="literal">[<span class="number">0</span>]</span>;</span><br><span class="line">        Integer port = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">addrs</span>[1])</span>;</span><br><span class="line"></span><br><span class="line">        final NettyConsumerHandler consumerHandler = <span class="keyword">new</span> <span class="constructor">NettyConsumerHandler()</span>;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> <span class="constructor">NioEventLoopGroup()</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> <span class="constructor">Bootstrap()</span>;</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(<span class="module-access"><span class="module"><span class="identifier">NioSocketChannel</span>.</span></span><span class="keyword">class</span>)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;<span class="literal">()</span> &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        protected void init<span class="constructor">Channel(Channel <span class="params">channel</span>)</span> throws Exception &#123;</span><br><span class="line">                            ChannelPipeline pipeline = channel.pipeline<span class="literal">()</span>;</span><br><span class="line">                            pipeline.add<span class="constructor">Last( <span class="params">new</span> ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.<span class="params">cacheDisabled</span>(ConsumerProxy.<span class="params">class</span>.<span class="params">getClassLoader</span>()</span>)));</span><br><span class="line">                            pipeline.add<span class="constructor">Last( <span class="params">new</span> ObjectEncoder()</span>);</span><br><span class="line">                            pipeline.add<span class="constructor">Last(<span class="params">consumerHandler</span>)</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture future = bootstrap.connect(host, port).sync<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">            Channel channel = future.channel<span class="literal">()</span>;</span><br><span class="line">            channel.write<span class="constructor">AndFlush(<span class="params">requestDTO</span>)</span>;</span><br><span class="line">            logger.info(<span class="string">"send request..., &#123;&#125;"</span>, requestDTO);</span><br><span class="line">            channel.close<span class="constructor">Future()</span>.sync<span class="literal">()</span>;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            group.shutdown<span class="constructor">Gracefully()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return consumerHandler.get<span class="constructor">Response()</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NettyConsumerHandler用于处理提供端返回的结果，这里没有做过多处理，直接返回。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NettyConsumerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> response;</span><br><span class="line"></span><br><span class="line">    public <span class="type">Object</span> getResponse() &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void channelRead(<span class="type">ChannelHandlerContext</span> ctx, <span class="type">Object</span> msg) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        response = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用SPI整合"><a href="#使用SPI整合" class="headerlink" title="使用SPI整合"></a>使用SPI整合</h3><p>在上一章，已经把SPI集成的很不错了，这里我们可以按照上一章套路管理RPC服务。我们提供一个Factory，用来替代自适应扩展。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> RpcFactory &#123;</span><br><span class="line">    public static IConsumerServer get<span class="constructor">ConsumerService()</span> &#123;</span><br><span class="line">        String protocol = <span class="module-access"><span class="module"><span class="identifier">Property</span>.</span><span class="module"><span class="identifier">Rpc</span>.</span></span>protocol;</span><br><span class="line">        IConsumerServer extension = <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(IConsumerServer.<span class="params">class</span>)</span>.get<span class="constructor">Extension(<span class="params">protocol</span>)</span>;</span><br><span class="line">        return extension;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static IProviderServer get<span class="constructor">ProviderServer()</span> &#123;</span><br><span class="line">        String protocol = <span class="module-access"><span class="module"><span class="identifier">Property</span>.</span><span class="module"><span class="identifier">Rpc</span>.</span></span>protocol;</span><br><span class="line">        IProviderServer extension = <span class="module-access"><span class="module"><span class="identifier">ExtensionLoader</span>.</span></span>get<span class="constructor">ExtensionLoader(IProviderServer.<span class="params">class</span>)</span>.get<span class="constructor">Extension(<span class="params">protocol</span>)</span>;</span><br><span class="line">        return extension;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">com<span class="selector-class">.ofcoder</span><span class="selector-class">.farpc</span><span class="selector-class">.rpc</span>.IConsumerServer</span><br><span class="line">netty=com<span class="selector-class">.ofcoder</span><span class="selector-class">.farpc</span><span class="selector-class">.rpc</span><span class="selector-class">.netty</span>.NettyConsumerServer</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line"></span><br><span class="line">com<span class="selector-class">.ofcoder</span><span class="selector-class">.farpc</span><span class="selector-class">.rpc</span>.IProviderServer</span><br><span class="line">netty=com<span class="selector-class">.ofcoder</span><span class="selector-class">.farpc</span><span class="selector-class">.rpc</span><span class="selector-class">.netty</span>.NettyProviderServer</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> provider() throws IOException &#123;</span><br><span class="line">    IProviderServer providerServer = RpcFactory.getProviderServer();</span><br><span class="line">    providerServer.<span class="keyword">start</span>("127.0.0.1:20880");</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">in</span>.<span class="keyword">read</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line"><span class="built_in">public</span> <span class="type">void</span> consumer() &#123;</span><br><span class="line">    IConsumerServer consumerService = RpcFactory.getConsumerService();</span><br><span class="line">    <span class="keyword">Object</span> <span class="keyword">execute</span> = consumerService.<span class="keyword">execute</span>("127.0.0.1:20880", <span class="built_in">new</span> RequestDTO());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先启动提供者，然后在执行消费。可以在提供者的控制台看到，相应的日志，也就说明达到我们需要的效果了。如下</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">..</span>.</span><br><span class="line">main  <span class="builtin-name">INFO</span> netty.NettyProviderServer: netty<span class="built_in"> server </span>is started<span class="built_in">..</span>.</span><br><span class="line">nioEventLoopGroup-3-1  <span class="builtin-name">INFO</span> netty.NettyProviderHandler: receive request<span class="built_in">..</span> RequestDTO&#123;<span class="attribute">className</span>=<span class="string">'null'</span>, <span class="attribute">methodName</span>=<span class="string">'null'</span>, <span class="attribute">types</span>=<span class="literal">null</span>, <span class="attribute">params</span>=<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dubbo源码"><a href="#dubbo源码" class="headerlink" title="dubbo源码"></a>dubbo源码</h3><p>这一节，来印证dubbo实现过程，也算是当作源码导读。这一节也分为两段分析，一消费端调用过程，二服务端收到请求处理过程。</p>
<p>整个过程可以总结为：首先服务消费者通过代理对象 Proxy 发起远程调用，接着通过网络客户端 Client 将编码后的请求发送给服务提供方的网络层上，也就是 Server。Server 在收到请求后，首先要做的事情是对数据包进行解码。然后将解码后的请求发送至分发器 Dispatcher，再由分发器将请求派发到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送与接收过程。</p>
<h4 id="消费端-1"><a href="#消费端-1" class="headerlink" title="消费端"></a>消费端</h4><p>消费端调用复杂在于链路太长，由Proxy调用开始，会经过一系列的Invoker，直到DubboInvoker再去真正发起请求</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span>greet</span><br><span class="line">  -&gt; <span class="module-access"><span class="module"><span class="identifier">InvokerInvocationHandler</span>.</span></span>invoke</span><br><span class="line">    -&gt; <span class="module-access"><span class="module"><span class="identifier">MockClusterInvoker</span>.</span></span>invoke</span><br><span class="line">      -&gt; ...</span><br><span class="line">        -&gt; <span class="module-access"><span class="module"><span class="identifier">AbstractInvoker</span>.</span></span>invoke</span><br><span class="line">          -&gt; <span class="module-access"><span class="module"><span class="identifier">DubboInvoker</span>.</span></span>doInvoke</span><br></pre></td></tr></table></figure>

<p>InvokerInvocationHandler用于排除调用toString()、equals()、hashCode()这些方法。MockClusterInvoker主要实现了降级逻辑，在服务调用失败后用于返回默认值。以及后续还有FailoverClusterInvoker，最后会调到DubboInvoker.doInvoke，着重关心这一块，中间那些增强的Invoker逻辑，可以自己了解。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">protected Result <span class="keyword">do</span><span class="constructor">Invoke(<span class="params">final</span> Invocation <span class="params">invocation</span>)</span> throws Throwable &#123;</span><br><span class="line">    RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">    final String methodName = <span class="module-access"><span class="module"><span class="identifier">RpcUtils</span>.</span></span>get<span class="constructor">MethodName(<span class="params">invocation</span>)</span>;</span><br><span class="line">    inv.set<span class="constructor">Attachment(PATH_KEY, <span class="params">getUrl</span>()</span>.get<span class="constructor">Path()</span>);</span><br><span class="line">    inv.set<span class="constructor">Attachment(VERSION_KEY, <span class="params">version</span>)</span>;</span><br><span class="line"></span><br><span class="line">    ExchangeClient currentClient;</span><br><span class="line">    <span class="keyword">if</span> (clients.length<span class="operator"> == </span><span class="number">1</span>) &#123;</span><br><span class="line">        currentClient = clients<span class="literal">[<span class="number">0</span>]</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentClient = clients<span class="literal">[<span class="identifier">index</span>.<span class="identifier">getAndIncrement</span>() % <span class="identifier">clients</span>.<span class="identifier">length</span>]</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 是否有返回值，true表示没有返回值。</span></span><br><span class="line">        boolean isOneway = <span class="module-access"><span class="module"><span class="identifier">RpcUtils</span>.</span></span>is<span class="constructor">Oneway(<span class="params">getUrl</span>()</span>, invocation);</span><br><span class="line">        <span class="built_in">int</span> timeout = get<span class="constructor">Url()</span>.get<span class="constructor">MethodParameter(<span class="params">methodName</span>, TIMEOUT_KEY, DEFAULT_TIMEOUT)</span>;</span><br><span class="line">        <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">            boolean isSent = get<span class="constructor">Url()</span>.get<span class="constructor">MethodParameter(<span class="params">methodName</span>, Constants.SENT_KEY, <span class="params">false</span>)</span>;</span><br><span class="line">            <span class="comment">// 发送请求</span></span><br><span class="line">            currentClient.send(inv, isSent);</span><br><span class="line">            <span class="comment">// 清空future </span></span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">RpcContext</span>.</span></span>get<span class="constructor">Context()</span>.set<span class="constructor">Future(<span class="params">null</span>)</span>;</span><br><span class="line">            <span class="comment">// 不用关注返回值，返回默认RpcResult</span></span><br><span class="line">            return <span class="module-access"><span class="module"><span class="identifier">AsyncRpcResult</span>.</span></span><span class="keyword">new</span><span class="constructor">DefaultAsyncResult(<span class="params">invocation</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//该类实现Future接口，用于实现异步</span></span><br><span class="line">            AsyncRpcResult asyncRpcResult = <span class="keyword">new</span> <span class="constructor">AsyncRpcResult(<span class="params">inv</span>)</span>;</span><br><span class="line">            <span class="comment">// 发起调用，也返回的Future对象</span></span><br><span class="line">            CompletableFuture&lt;Object&gt; responseFuture = currentClient.request(inv, timeout);</span><br><span class="line">            <span class="comment">// 当发起调用的Future完成后，会通知到asyncRpcResult</span></span><br><span class="line">            asyncRpcResult.subscribe<span class="constructor">To(<span class="params">responseFuture</span>)</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">RpcContext</span>.</span></span>get<span class="constructor">Context()</span>.set<span class="constructor">Future(<span class="params">new</span> FutureAdapter(<span class="params">asyncRpcResult</span>)</span>);</span><br><span class="line">            return asyncRpcResult;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (TimeoutException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; catch (RemotingException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费端到此处，应分为第二段，既发送请求。这里dubbo会调用一系列Client，这些Client均是NettyClient的包装增强，对request()的调用都是一直往下传递。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">ReferenceCountExchangeClient</span>.</span></span>request</span><br><span class="line">  -&gt; <span class="module-access"><span class="module"><span class="identifier">HeaderExchangeClient</span>.</span></span>request</span><br><span class="line">    -&gt; <span class="module-access"><span class="module"><span class="identifier">HeaderExchangeChannel</span>.</span></span>request</span><br><span class="line">      -&gt; <span class="module-access"><span class="module"><span class="identifier">AbstractClient</span>.</span></span>send</span><br><span class="line">        -&gt; <span class="module-access"><span class="module"><span class="identifier">NettyChannel</span>.</span></span>send</span><br><span class="line">          -&gt; <span class="module-access"><span class="module"><span class="identifier">NioClientSocketChannel</span>.</span></span>write</span><br></pre></td></tr></table></figure>

<p>ReferenceCountExchangeClient为对象引用增加计数器，当close()调用时，该计数器减1。HeaderExchangeClient增加心跳检测，这里请求会转到Channel对象，并结束request()传递调用。HeaderExchangeChannel对Request的封装，并通过AbstractClient.getChannel()获取到NettyChannel对象并调用其send()方法。完成整个请求的发送。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> throws RemotingException </span>&#123;</span><br><span class="line">    super.send(message, sent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 发送消息(包含请求和响应消息)</span></span><br><span class="line">        ChannelFuture <span class="built_in">future</span> = channel.<span class="built_in">write</span>(message);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// sent 的值源于 &lt;dubbo:method sent="true/false" /&gt; 中 sent 的配置值，有两种配置值：</span></span><br><span class="line">        <span class="comment">//   1. true: 等待消息发出，消息发送失败将抛出异常</span></span><br><span class="line">        <span class="comment">//   2. false: 不等待消息发出，将消息放入 IO 队列，即刻返回</span></span><br><span class="line">        <span class="comment">// 默认情况下 sent = false；</span></span><br><span class="line">        <span class="keyword">if</span> (sent) &#123;</span><br><span class="line">            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">            <span class="comment">// 等待消息发出，若在规定时间没能发出，success 会被置为 false</span></span><br><span class="line">            success = <span class="built_in">future</span>.await(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        Throwable cause = <span class="built_in">future</span>.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause != null) &#123;</span><br><span class="line">            <span class="keyword">throw</span> cause;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若 success 为 false，这里抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">"Failed to send message ..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="提供端"><a href="#提供端" class="headerlink" title="提供端"></a>提供端</h4><p>在服务提供端获取到请求之后，然后交由NettyHandler.messageReceived处理，该方法会进行和消费端相关操作，以此会执行MultiMessageHandlerH、eartbeatHandler，最后由ChannelHandler将操作逻辑封装到Runable对象中，交给线程池进行调用处理，这个过程也成为线程派发，dubbo提供5中派发模式。</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>所有消息都派发到线程池，包括请求，响应，连接事件，断开事件等</td>
</tr>
<tr>
<td>direct</td>
<td>所有消息都不派发到线程池，全部在 IO 线程上直接执行</td>
</tr>
<tr>
<td>message</td>
<td>只有请求和响应消息派发到线程池，其它消息均在 IO 线程上执行</td>
</tr>
<tr>
<td>execution</td>
<td>只有请求消息派发到线程池，不含响应。其它消息均在 IO 线程上执行</td>
</tr>
<tr>
<td>connection</td>
<td>在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池</td>
</tr>
</tbody></table>
<p>dubbo默认选择策略是all，整理上述调用链路如下</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NettyHandler#messageReceived</span><br><span class="line">  -&gt; AbstractPeer#received</span><br><span class="line">    —&gt; MultiMessageHandler#received</span><br><span class="line">      —&gt; HeartbeatHandler#received</span><br><span class="line">        —&gt; ALLChannelHandler#received</span><br><span class="line">          —&gt; ExecutorService#execute</span><br></pre></td></tr></table></figure>

<p>ALLChannelHandler.received会初始化ChannelEventRunnable对象，由该对象真正完成调用，我们看看具体源码</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class ChannelEventRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        // 检测通道状态，对于请求或响应消息，此时 <span class="keyword">state</span> = RECEIVED</span><br><span class="line">        if (<span class="keyword">state</span> == ChannelState.RECEIVED) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                handler.received(channel, message);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"ChannelEventRunnable handle "</span> + <span class="keyword">state</span> + <span class="string">" operation error, channel is "</span> + channel</span><br><span class="line">                        + <span class="string">", message is "</span> + message, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            switch (<span class="keyword">state</span>) &#123;</span><br><span class="line">            case CONNECTED:</span><br><span class="line">                ...</span><br><span class="line">                break;</span><br><span class="line">            case DISCONNECTED:</span><br><span class="line">                ...</span><br><span class="line">                break;</span><br><span class="line">            case SENT:</span><br><span class="line">                ...</span><br><span class="line">                break;</span><br><span class="line">            case CAUGHT:</span><br><span class="line">                ...</span><br><span class="line">                break;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                logger.warn(<span class="string">"unknown state: "</span> + <span class="keyword">state</span> + <span class="string">", message is "</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里多说一句，先用if判断出现频率比较高的消息类型，然后用switch处理其他类型，不用把频率较高的类型和普通类型同级判断，以此提高效率。我们开发过程中也可借鉴这一点。<br>ChannelEventRunnable作用类似于路由，将消息分别交给各自的ChannelHandler去处理，这里的对象为DecodeHandler，该Handler就是对Request或Response进行解码后，继续传递到HeaderExchangeHandler。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> HeaderExchangeHandler implements ChannelHandlerDelegate &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void received(Channel channel, Object message) throws RemotingException &#123;</span><br><span class="line">        channel.set<span class="constructor">Attribute(KEY_READ_TIMESTAMP, System.<span class="params">currentTimeMillis</span>()</span>);</span><br><span class="line">        final ExchangeChannel exchangeChannel = <span class="module-access"><span class="module"><span class="identifier">HeaderExchangeChannel</span>.</span></span>get<span class="constructor">OrAddChannel(<span class="params">channel</span>)</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (message instanceof Request) &#123;</span><br><span class="line">                <span class="comment">// handle request.</span></span><br><span class="line">                Request request = (Request) message;</span><br><span class="line">                <span class="keyword">if</span> (request.is<span class="constructor">Event()</span>) &#123;</span><br><span class="line">                    handler<span class="constructor">Event(<span class="params">channel</span>, <span class="params">request</span>)</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 是否为单/双向调用，判断是否需要接收返回结果</span></span><br><span class="line">                    <span class="keyword">if</span> (request.is<span class="constructor">TwoWay()</span>) &#123;</span><br><span class="line">                        handle<span class="constructor">Request(<span class="params">exchangeChannel</span>, <span class="params">request</span>)</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        handler.received(exchangeChannel, request.get<span class="constructor">Data()</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message instanceof Response) &#123;</span><br><span class="line">                handle<span class="constructor">Response(<span class="params">channel</span>, (Response)</span> message);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message instanceof String) &#123;</span><br><span class="line">                <span class="comment">// telnet 相关</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handler.received(exchangeChannel, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">HeaderExchangeChannel</span>.</span></span>remove<span class="constructor">ChannelIfDisconnected(<span class="params">channel</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response handle<span class="constructor">Request(ExchangeChannel <span class="params">channel</span>, Request <span class="params">req</span>)</span> throws RemotingException &#123;</span><br><span class="line">        Response res = <span class="keyword">new</span> <span class="constructor">Response(<span class="params">req</span>.<span class="params">getId</span>()</span>, req.get<span class="constructor">Version()</span>);</span><br><span class="line">        <span class="comment">// 检测请求是否合法，不合法则返回状态码为 BAD_REQUEST 的响应</span></span><br><span class="line">        <span class="keyword">if</span> (req.is<span class="constructor">Broken()</span>) &#123;</span><br><span class="line">            Object data = req.get<span class="constructor">Data()</span>;</span><br><span class="line"></span><br><span class="line">            String msg;</span><br><span class="line">            <span class="keyword">if</span> (data<span class="operator"> == </span>null)</span><br><span class="line">                msg = null;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span></span><br><span class="line">                (data instanceof Throwable) msg = <span class="module-access"><span class="module"><span class="identifier">StringUtils</span>.</span></span><span class="keyword">to</span><span class="constructor">String((Throwable)</span> data);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                msg = data.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">            res.set<span class="constructor">ErrorMessage(<span class="string">"Fail to decode request due to: "</span> + <span class="params">msg</span>)</span>;</span><br><span class="line">            <span class="comment">// 设置 BAD_REQUEST 状态</span></span><br><span class="line">            res.set<span class="constructor">Status(Response.BAD_REQUEST)</span>;</span><br><span class="line"></span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取 data 字段值，也就是 RpcInvocation 对象</span></span><br><span class="line">        Object msg = req.get<span class="constructor">Data()</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 继续向下调用</span></span><br><span class="line">            Object result = handler.reply(channel, msg);</span><br><span class="line">            <span class="comment">// 设置 OK 状态码</span></span><br><span class="line">            res.set<span class="constructor">Status(Response.OK)</span>;</span><br><span class="line">            <span class="comment">// 设置调用结果</span></span><br><span class="line">            res.set<span class="constructor">Result(<span class="params">result</span>)</span>;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// 若调用过程出现异常，则设置 SERVICE_ERROR，表示服务端异常</span></span><br><span class="line">            res.set<span class="constructor">Status(Response.SERVICE_ERROR)</span>;</span><br><span class="line">            res.set<span class="constructor">ErrorMessage(StringUtils.<span class="params">toString</span>(<span class="params">e</span>)</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来要说的就是定义在DubboProtocol类中匿名对象的reply方法，既ExchangeHandlerAdapter.reply()</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> DubboProtocol extends AbstractProtocol &#123;</span><br><span class="line">    <span class="keyword">private</span> ExchangeHandler requestHandler = <span class="keyword">new</span> <span class="constructor">ExchangeHandlerAdapter()</span> &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Object reply(ExchangeChannel channel, Object message) throws RemotingException &#123;</span><br><span class="line">            <span class="keyword">if</span> (message instanceof Invocation) &#123;</span><br><span class="line">                Invocation inv = (Invocation) message;</span><br><span class="line">                <span class="comment">// 获取 Invoker 实例</span></span><br><span class="line">                Invoker&lt;?&gt; invoker = get<span class="constructor">Invoker(<span class="params">channel</span>, <span class="params">inv</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Boolean</span>.</span><span class="module"><span class="identifier">TRUE</span>.</span></span><span class="keyword">to</span><span class="constructor">String()</span>.equals(inv.get<span class="constructor">Attachments()</span>.get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">                    <span class="comment">// 回调相关，忽略</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">RpcContext</span>.</span></span>get<span class="constructor">Context()</span>.set<span class="constructor">RemoteAddress(<span class="params">channel</span>.<span class="params">getRemoteAddress</span>()</span>);</span><br><span class="line">                <span class="comment">// 通过 Invoker 调用具体的服务</span></span><br><span class="line">                return invoker.invoke(inv);</span><br><span class="line">            &#125;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">RemotingException(<span class="params">channel</span>, <span class="string">"Unsupported request: ..."</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>先通过getInvoker()获取Invoker实例，然后调用invoke方法。getInvoker()方法先从缓存中获取，没命中则调用DubboExporter.getInvoker()继续创建。而Invoker的invoke方法是由AbstractProxyInvoker实现，</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract <span class="keyword">class</span> AbstractProxyInvoker&lt;T&gt; implements Invoker&lt;T&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object value = <span class="keyword">do</span><span class="constructor">Invoke(<span class="params">proxy</span>, <span class="params">invocation</span>.<span class="params">getMethodName</span>()</span>, invocation.get<span class="constructor">ParameterTypes()</span>, invocation.get<span class="constructor">Arguments()</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将结果封装到AsyncRpcResult，然后返回</span></span><br><span class="line">            ...</span><br><span class="line">            return asyncRpcResult;</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">            return <span class="module-access"><span class="module"><span class="identifier">AsyncRpcResult</span>.</span></span><span class="keyword">new</span><span class="constructor">DefaultAsyncResult(<span class="params">null</span>, <span class="params">e</span>.<span class="params">getTargetException</span>()</span>, invocation);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">RpcException(<span class="string">"Failed to invoke remote proxy method "</span> + <span class="params">invocation</span>.<span class="params">getMethodName</span>()</span> + <span class="string">" to "</span> + get<span class="constructor">Url()</span> + <span class="string">", cause: "</span> + e.get<span class="constructor">Message()</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩余的最后一个doInvoke，是一个抽象方法，由子类实现，而Invoker实现类是由JavassistProxyFactory 动态生成，具体可查看JavassistProxyFactory.getInvoker()方法。最后生成的代理类逻辑如下：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Wrapper0 是在运行时生成的，可使用 Arthas 进行反编译 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper0</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Wrapper</span></span> <span class="keyword"><span class="keyword">implements</span> <span class="type">ClassGenerator</span></span>.<span class="title">DC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span>[] pns;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map pts;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span>[] mns;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span>[] dmns;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class[] mts0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object invokeMethod(Object object, <span class="keyword">String</span> string, Class[] arrclass, Object[] arrobject) throws InvocationTargetException &#123;</span><br><span class="line">        DemoService demoService;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 类型转换</span></span><br><span class="line">            demoService = (DemoService)object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据方法名调用指定的方法</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"sayHello"</span>.equals(string) &amp;&amp; arrclass.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> demoService.sayHello((<span class="keyword">String</span>)arrobject[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvocationTargetException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchMethodException</span>(<span class="keyword">new</span> <span class="type">StringBuffer</span>().append(<span class="string">"Not found method \""</span>).append(string).append(<span class="string">"\" in class com.alibaba.dubbo.demo.DemoService."</span>).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到，最后不是通过反射去执行的，而是根据具体方法名路由的，然后调用执行的。所以以后谁要说反射执行，就拿这篇文章呼他的脸。不过话说回来，我们实现的调用还是通过反射，我们也看到了dubbo的实现太复杂了，如果再造一个轮子没必要，主要是弄清楚原理。</p>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=/img/WeChatQR.jpg&amp;GitHub=https://github.com/farawayliu&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>far</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/10/21/java/手写dubbo 10-基于netty实现RPC/">https://www.ofcoder.com/2019/10/21/java/%E6%89%8B%E5%86%99dubbo%2010-%E5%9F%BA%E4%BA%8Enetty%E5%AE%9E%E7%8E%B0RPC/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>Copyright © 并发笔记 - ofcoder.com. Author by far.</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://www.ofcoder.com/2019/10/21/java/%E6%89%8B%E5%86%99dubbo%2010-%E5%9F%BA%E4%BA%8Enetty%E5%AE%9E%E7%8E%B0RPC/" data-id="cl7wxhx6h000wlcj1762z0alh" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAEOCAAAAABd2qZ5AAAD9klEQVR42u3aS07EUAwEwLn/pUFihQQz6bZf+Eg1KwSBvFQWxnY/HvHn7ePz+evP33l2zdfrk2uSMyR/4fVfW31w4MCBA0fwqM8++TWvD9H+/We/276A9vw4cODAgeMUR1Jc26I4w8pL/r7o4sCBAweO3+XYlMb2iHkT2JZhHDhw4MDxNzmSAnnRLMWDyFOlFwcOHDhw/CRHMrzbNGntOiq5+x3DTRw4cODAsefYFL//8vXt+Q4cOHDgwBGUn7Y47a9PWqx8FFg/EQ4cOHDgWHPkbVU7ImwDEDlEG56oV184cODAgWPB0ZbAtlmaDRxni678pQ73Vzhw4MCBYzQNyxunzVpo86o266uL8+DAgQMHjjVHu3OZDfhmrJtlUhtoqFMeOHDgwIEj2LNsVkqzArwJT2xGk9GIEAcOHDhwjDjuLo35aC+f0eXlM389OHDgwIHjPo7k8dqhW5uwyEt+u46KZqU4cODAgWPB0cYOZsXs1DXty8jhLjpaHDhw4MBRcuQNWNu2RTdeBO824Yko0IADBw4cOEqOZAyXFK32WPmiqx7wlUNDHDhw4MBxliOJFOSxg3Y8l9yrbdU2rxAHDhw4cJziaMdtLVlbCGd3zNdUxdoJBw4cOHCsOaI6PApDzBDzB37En2hKigMHDhw4Rhz5+KxthPKRX37ffOHUDihx4MCBA8cpjqTVSR6jLXV70P2yqq7GOHDgwIEjPmEbStgECNrR4azDWoUqcODAgQPHgmNWJtsiN4tK5K1XW/Lr/RsOHDhw4BitnYa/vOiGzi6xkgIfNZ84cODAgWPBsVnw5OPFtknLX0M+pozOgAMHDhw41hz52C451ma5NVt6zSjr/ztw4MCBA8eIIy+07XFb0FmBT2iiF4wDBw4cOBYceeAgeYBTQ8Y2uLB5hVGyAwcOHDhwlGduQwOzEpgct12GbQITxY9x4MCBA0d8TdLYJMO7zcPPRpOzSMTFs+DAgQMHjts4cpq8zcubxs2CarP6woEDBw4cpzjaZc/ZIeBsEdXGF1azUhw4cODAUXLkYbVZbK4N0rUN3ixy8c1v4cCBAweOQxxtyczbvHxR1MYU2uYwGjviwIEDB441x6kb5MV4FpXbhxiGsQYcOHDgwFFyvJWf/TIpf+zZMqwt4Thw4MCB4yzHrCzNYgftcitvvfLh5uPUBwcOHDhwlC3TPqZ2R8s3i+XVDSoOHDhw4DjEsT/KJmC3Hw62Eb2LWSkOHDhw4PgljlkEYRbOm7WL+fdx4MCBA8fPc+SDwpyjLYf7NdJF8caBAwcOHIc4zpa0fSvVFsikSCc/xYEDBw4ce462OG3asNm9kpO0Q8khBA4cOHDgeMXxDvF154KBqNc2AAAAAElFTkSuQmCC">分享</a><div class="tags"><a href="/tags/%E5%B9%B2%E8%B4%A7/">干货</a><a href="/tags/dubbo/">dubbo</a><a href="/tags/%E6%BA%90%E7%A0%81/">源码</a><a href="/tags/netty/">netty</a><a href="/tags/RPC/">RPC</a></div><div class="post-nav"><a class="pre" href="/2019/10/24/java/%E6%89%8B%E5%86%99dubbo%2011-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8/">手写dubbo 11-动态代理的应用</a><a class="next" href="/2019/10/20/java/%E6%89%8B%E5%86%99dubbo%209-SPI%E5%AE%9E%E7%8E%B0/">手写dubbo 9-SPI实现</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'s8pJruGkXvi5Skd0e6EaMQ5X-gzGzoHsz',
  appKey:'K3NjnXxqhPNwUw5pmqOzoO4i',
  placeholder:'说出你的故事...',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar-toc"><div class="stoc-article" id="sidebar-stoc"><strong class="stoc-title"><i class="fa fa-blind"> Contents </i></strong><div class="toc-nav" id="stoc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理分析"><span class="toc-number">1.</span> <span class="toc-text">原理分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#项目结构介绍"><span class="toc-number">2.</span> <span class="toc-text">项目结构介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化netty"><span class="toc-number">3.</span> <span class="toc-text">初始化netty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务端"><span class="toc-number">4.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消费端"><span class="toc-number">5.</span> <span class="toc-text">消费端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用SPI整合"><span class="toc-number">6.</span> <span class="toc-text">使用SPI整合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试"><span class="toc-number">7.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dubbo源码"><span class="toc-number">8.</span> <span class="toc-text">dubbo源码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#消费端-1"><span class="toc-number">8.1.</span> <span class="toc-text">消费端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#提供端"><span class="toc-number">8.2.</span> <span class="toc-text">提供端</span></a></li></ol></li></ol></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">并发笔记 - ofcoder.com | </a><a href="https://beian.miit.gov.cn/" rel="nofollow" target="_blank">粤ICP备18053760号</a><div>本站访客 <span id="busuanzi_value_site_uv"></span>人次 | 总访问 <span id="busuanzi_value_site_pv"></span>次<img src="https://s04.flagcounter.com/count/MnzJ/bg_FFFFFF/txt_000000/border_726EE0/columns_2/maxflags_10/viewers_0/labels_1/pageviews_1/flags_0/percent_0/" style="display: none;"/></div></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html><script type="text/javascript" src="/js/toc.js?v=0.0.0" async></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>